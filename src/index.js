function _mergeNamespaces(o, i) {
    for (var s = 0; s < i.length; s++) {
        const a = i[s];
        if (typeof a != "string" && !Array.isArray(a)) {
            for (const _ in a)
                if (_ !== "default" && !(_ in o)) {
                    const $ = Object.getOwnPropertyDescriptor(a, _);
                    $ && Object.defineProperty(o, _, $.get ? $ : {
                        enumerable: !0,
                        get: () => a[_]
                    })
                }
        }
    }
    return Object.freeze(Object.defineProperty(o, Symbol.toStringTag, {
        value: "Module"
    }))
}
(function() {
    const i = document.createElement("link").relList;
    if (i && i.supports && i.supports("modulepreload"))
        return;
    for (const _ of document.querySelectorAll('link[rel="modulepreload"]'))
        a(_);
    new MutationObserver(_ => {
        for (const $ of _)
            if ($.type === "childList")
                for (const _e of $.addedNodes)
                    _e.tagName === "LINK" && _e.rel === "modulepreload" && a(_e)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function s(_) {
        const $ = {};
        return _.integrity && ($.integrity = _.integrity),
        _.referrerPolicy && ($.referrerPolicy = _.referrerPolicy),
        _.crossOrigin === "use-credentials" ? $.credentials = "include" : _.crossOrigin === "anonymous" ? $.credentials = "omit" : $.credentials = "same-origin",
        $
    }
    function a(_) {
        if (_.ep)
            return;
        _.ep = !0;
        const $ = s(_);
        fetch(_.href, $)
    }
}
)();
function getDefaultExportFromCjs(o) {
    return o && o.__esModule && Object.prototype.hasOwnProperty.call(o, "default") ? o.default : o
}
var jsxRuntime = {
    exports: {}
}
  , reactJsxRuntime_production_min = {}
  , react = {
    exports: {}
}
  , react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$2 = Symbol.for("react.element")
  , n$2 = Symbol.for("react.portal")
  , p$3 = Symbol.for("react.fragment")
  , q$2 = Symbol.for("react.strict_mode")
  , r$1 = Symbol.for("react.profiler")
  , t$1 = Symbol.for("react.provider")
  , u = Symbol.for("react.context")
  , v$2 = Symbol.for("react.forward_ref")
  , w$1 = Symbol.for("react.suspense")
  , x$1 = Symbol.for("react.memo")
  , y$1 = Symbol.for("react.lazy")
  , z$2 = Symbol.iterator;
function A$2(o) {
    return o === null || typeof o != "object" ? null : (o = z$2 && o[z$2] || o["@@iterator"],
    typeof o == "function" ? o : null)
}
var B$1 = {
    isMounted: function() {
        return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}
  , C$1 = Object.assign
  , D$1 = {};
function E$1(o, i, s) {
    this.props = o,
    this.context = i,
    this.refs = D$1,
    this.updater = s || B$1
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function(o, i) {
    if (typeof o != "object" && typeof o != "function" && o != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, o, i, "setState")
}
;
E$1.prototype.forceUpdate = function(o) {
    this.updater.enqueueForceUpdate(this, o, "forceUpdate")
}
;
function F() {}
F.prototype = E$1.prototype;
function G$1(o, i, s) {
    this.props = o,
    this.context = i,
    this.refs = D$1,
    this.updater = s || B$1
}
var H$1 = G$1.prototype = new F;
H$1.constructor = G$1;
C$1(H$1, E$1.prototype);
H$1.isPureReactComponent = !0;
var I$1 = Array.isArray
  , J = Object.prototype.hasOwnProperty
  , K$1 = {
    current: null
}
  , L$1 = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function M$1(o, i, s) {
    var a, _ = {}, $ = null, _e = null;
    if (i != null)
        for (a in i.ref !== void 0 && (_e = i.ref),
        i.key !== void 0 && ($ = "" + i.key),
        i)
            J.call(i, a) && !L$1.hasOwnProperty(a) && (_[a] = i[a]);
    var tt = arguments.length - 2;
    if (tt === 1)
        _.children = s;
    else if (1 < tt) {
        for (var nt = Array(tt), rt = 0; rt < tt; rt++)
            nt[rt] = arguments[rt + 2];
        _.children = nt
    }
    if (o && o.defaultProps)
        for (a in tt = o.defaultProps,
        tt)
            _[a] === void 0 && (_[a] = tt[a]);
    return {
        $$typeof: l$2,
        type: o,
        key: $,
        ref: _e,
        props: _,
        _owner: K$1.current
    }
}
function N$1(o, i) {
    return {
        $$typeof: l$2,
        type: o.type,
        key: i,
        ref: o.ref,
        props: o.props,
        _owner: o._owner
    }
}
function O$1(o) {
    return typeof o == "object" && o !== null && o.$$typeof === l$2
}
function escape(o) {
    var i = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + o.replace(/[=:]/g, function(s) {
        return i[s]
    })
}
var P$1 = /\/+/g;
function Q$1(o, i) {
    return typeof o == "object" && o !== null && o.key != null ? escape("" + o.key) : i.toString(36)
}
function R$1(o, i, s, a, _) {
    var $ = typeof o;
    ($ === "undefined" || $ === "boolean") && (o = null);
    var _e = !1;
    if (o === null)
        _e = !0;
    else
        switch ($) {
        case "string":
        case "number":
            _e = !0;
            break;
        case "object":
            switch (o.$$typeof) {
            case l$2:
            case n$2:
                _e = !0
            }
        }
    if (_e)
        return _e = o,
        _ = _(_e),
        o = a === "" ? "." + Q$1(_e, 0) : a,
        I$1(_) ? (s = "",
        o != null && (s = o.replace(P$1, "$&/") + "/"),
        R$1(_, i, s, "", function(rt) {
            return rt
        })) : _ != null && (O$1(_) && (_ = N$1(_, s + (!_.key || _e && _e.key === _.key ? "" : ("" + _.key).replace(P$1, "$&/") + "/") + o)),
        i.push(_)),
        1;
    if (_e = 0,
    a = a === "" ? "." : a + ":",
    I$1(o))
        for (var tt = 0; tt < o.length; tt++) {
            $ = o[tt];
            var nt = a + Q$1($, tt);
            _e += R$1($, i, s, nt, _)
        }
    else if (nt = A$2(o),
    typeof nt == "function")
        for (o = nt.call(o),
        tt = 0; !($ = o.next()).done; )
            $ = $.value,
            nt = a + Q$1($, tt++),
            _e += R$1($, i, s, nt, _);
    else if ($ === "object")
        throw i = String(o),
        Error("Objects are not valid as a React child (found: " + (i === "[object Object]" ? "object with keys {" + Object.keys(o).join(", ") + "}" : i) + "). If you meant to render a collection of children, use an array instead.");
    return _e
}
function S$1(o, i, s) {
    if (o == null)
        return o;
    var a = []
      , _ = 0;
    return R$1(o, a, "", "", function($) {
        return i.call(s, $, _++)
    }),
    a
}
function T$1(o) {
    if (o._status === -1) {
        var i = o._result;
        i = i(),
        i.then(function(s) {
            (o._status === 0 || o._status === -1) && (o._status = 1,
            o._result = s)
        }, function(s) {
            (o._status === 0 || o._status === -1) && (o._status = 2,
            o._result = s)
        }),
        o._status === -1 && (o._status = 0,
        o._result = i)
    }
    if (o._status === 1)
        return o._result.default;
    throw o._result
}
var U$1 = {
    current: null
}
  , V$1 = {
    transition: null
}
  , W$1 = {
    ReactCurrentDispatcher: U$1,
    ReactCurrentBatchConfig: V$1,
    ReactCurrentOwner: K$1
};
react_production_min.Children = {
    map: S$1,
    forEach: function(o, i, s) {
        S$1(o, function() {
            i.apply(this, arguments)
        }, s)
    },
    count: function(o) {
        var i = 0;
        return S$1(o, function() {
            i++
        }),
        i
    },
    toArray: function(o) {
        return S$1(o, function(i) {
            return i
        }) || []
    },
    only: function(o) {
        if (!O$1(o))
            throw Error("React.Children.only expected to receive a single React element child.");
        return o
    }
};
react_production_min.Component = E$1;
react_production_min.Fragment = p$3;
react_production_min.Profiler = r$1;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$2;
react_production_min.Suspense = w$1;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.cloneElement = function(o, i, s) {
    if (o == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + o + ".");
    var a = C$1({}, o.props)
      , _ = o.key
      , $ = o.ref
      , _e = o._owner;
    if (i != null) {
        if (i.ref !== void 0 && ($ = i.ref,
        _e = K$1.current),
        i.key !== void 0 && (_ = "" + i.key),
        o.type && o.type.defaultProps)
            var tt = o.type.defaultProps;
        for (nt in i)
            J.call(i, nt) && !L$1.hasOwnProperty(nt) && (a[nt] = i[nt] === void 0 && tt !== void 0 ? tt[nt] : i[nt])
    }
    var nt = arguments.length - 2;
    if (nt === 1)
        a.children = s;
    else if (1 < nt) {
        tt = Array(nt);
        for (var rt = 0; rt < nt; rt++)
            tt[rt] = arguments[rt + 2];
        a.children = tt
    }
    return {
        $$typeof: l$2,
        type: o.type,
        key: _,
        ref: $,
        props: a,
        _owner: _e
    }
}
;
react_production_min.createContext = function(o) {
    return o = {
        $$typeof: u,
        _currentValue: o,
        _currentValue2: o,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    },
    o.Provider = {
        $$typeof: t$1,
        _context: o
    },
    o.Consumer = o
}
;
react_production_min.createElement = M$1;
react_production_min.createFactory = function(o) {
    var i = M$1.bind(null, o);
    return i.type = o,
    i
}
;
react_production_min.createRef = function() {
    return {
        current: null
    }
}
;
react_production_min.forwardRef = function(o) {
    return {
        $$typeof: v$2,
        render: o
    }
}
;
react_production_min.isValidElement = O$1;
react_production_min.lazy = function(o) {
    return {
        $$typeof: y$1,
        _payload: {
            _status: -1,
            _result: o
        },
        _init: T$1
    }
}
;
react_production_min.memo = function(o, i) {
    return {
        $$typeof: x$1,
        type: o,
        compare: i === void 0 ? null : i
    }
}
;
react_production_min.startTransition = function(o) {
    var i = V$1.transition;
    V$1.transition = {};
    try {
        o()
    } finally {
        V$1.transition = i
    }
}
;
react_production_min.unstable_act = function() {
    throw Error("act(...) is not supported in production builds of React.")
}
;
react_production_min.useCallback = function(o, i) {
    return U$1.current.useCallback(o, i)
}
;
react_production_min.useContext = function(o) {
    return U$1.current.useContext(o)
}
;
react_production_min.useDebugValue = function() {}
;
react_production_min.useDeferredValue = function(o) {
    return U$1.current.useDeferredValue(o)
}
;
react_production_min.useEffect = function(o, i) {
    return U$1.current.useEffect(o, i)
}
;
react_production_min.useId = function() {
    return U$1.current.useId()
}
;
react_production_min.useImperativeHandle = function(o, i, s) {
    return U$1.current.useImperativeHandle(o, i, s)
}
;
react_production_min.useInsertionEffect = function(o, i) {
    return U$1.current.useInsertionEffect(o, i)
}
;
react_production_min.useLayoutEffect = function(o, i) {
    return U$1.current.useLayoutEffect(o, i)
}
;
react_production_min.useMemo = function(o, i) {
    return U$1.current.useMemo(o, i)
}
;
react_production_min.useReducer = function(o, i, s) {
    return U$1.current.useReducer(o, i, s)
}
;
react_production_min.useRef = function(o) {
    return U$1.current.useRef(o)
}
;
react_production_min.useState = function(o) {
    return U$1.current.useState(o)
}
;
react_production_min.useSyncExternalStore = function(o, i, s) {
    return U$1.current.useSyncExternalStore(o, i, s)
}
;
react_production_min.useTransition = function() {
    return U$1.current.useTransition()
}
;
react_production_min.version = "18.2.0";
react.exports = react_production_min;
var reactExports = react.exports;
const React = getDefaultExportFromCjs(reactExports)
  , React$1 = _mergeNamespaces({
    __proto__: null,
    default: React
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$1 = reactExports
  , k$1 = Symbol.for("react.element")
  , l$1 = Symbol.for("react.fragment")
  , m$2 = Object.prototype.hasOwnProperty
  , n$1 = f$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
  , p$2 = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function q$1(o, i, s) {
    var a, _ = {}, $ = null, _e = null;
    s !== void 0 && ($ = "" + s),
    i.key !== void 0 && ($ = "" + i.key),
    i.ref !== void 0 && (_e = i.ref);
    for (a in i)
        m$2.call(i, a) && !p$2.hasOwnProperty(a) && (_[a] = i[a]);
    if (o && o.defaultProps)
        for (a in i = o.defaultProps,
        i)
            _[a] === void 0 && (_[a] = i[a]);
    return {
        $$typeof: k$1,
        type: o,
        key: $,
        ref: _e,
        props: _,
        _owner: n$1.current
    }
}
reactJsxRuntime_production_min.Fragment = l$1;
reactJsxRuntime_production_min.jsx = q$1;
reactJsxRuntime_production_min.jsxs = q$1;
jsxRuntime.exports = reactJsxRuntime_production_min;
var jsxRuntimeExports = jsxRuntime.exports
  , client = {}
  , reactDom = {
    exports: {}
}
  , reactDom_production_min = {}
  , scheduler = {
    exports: {}
}
  , scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(o) {
    function i(Rt, At) {
        var Mt = Rt.length;
        Rt.push(At);
        e: for (; 0 < Mt; ) {
            var Ut = Mt - 1 >>> 1
              , Lt = Rt[Ut];
            if (0 < _(Lt, At))
                Rt[Ut] = At,
                Rt[Mt] = Lt,
                Mt = Ut;
            else
                break e
        }
    }
    function s(Rt) {
        return Rt.length === 0 ? null : Rt[0]
    }
    function a(Rt) {
        if (Rt.length === 0)
            return null;
        var At = Rt[0]
          , Mt = Rt.pop();
        if (Mt !== At) {
            Rt[0] = Mt;
            e: for (var Ut = 0, Lt = Rt.length, tn = Lt >>> 1; Ut < tn; ) {
                var Vt = 2 * (Ut + 1) - 1
                  , Nt = Rt[Vt]
                  , Yt = Vt + 1
                  , Xt = Rt[Yt];
                if (0 > _(Nt, Mt))
                    Yt < Lt && 0 > _(Xt, Nt) ? (Rt[Ut] = Xt,
                    Rt[Yt] = Mt,
                    Ut = Yt) : (Rt[Ut] = Nt,
                    Rt[Vt] = Mt,
                    Ut = Vt);
                else if (Yt < Lt && 0 > _(Xt, Mt))
                    Rt[Ut] = Xt,
                    Rt[Yt] = Mt,
                    Ut = Yt;
                else
                    break e
            }
        }
        return At
    }
    function _(Rt, At) {
        var Mt = Rt.sortIndex - At.sortIndex;
        return Mt !== 0 ? Mt : Rt.id - At.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var $ = performance;
        o.unstable_now = function() {
            return $.now()
        }
    } else {
        var _e = Date
          , tt = _e.now();
        o.unstable_now = function() {
            return _e.now() - tt
        }
    }
    var nt = []
      , rt = []
      , ot = 1
      , et = null
      , j = 3
      , it = !1
      , st = !1
      , at = !1
      , lt = typeof setTimeout == "function" ? setTimeout : null
      , ct = typeof clearTimeout == "function" ? clearTimeout : null
      , ut = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function dt(Rt) {
        for (var At = s(rt); At !== null; ) {
            if (At.callback === null)
                a(rt);
            else if (At.startTime <= Rt)
                a(rt),
                At.sortIndex = At.expirationTime,
                i(nt, At);
            else
                break;
            At = s(rt)
        }
    }
    function ft(Rt) {
        if (at = !1,
        dt(Rt),
        !st)
            if (s(nt) !== null)
                st = !0,
                Et(ht);
            else {
                var At = s(rt);
                At !== null && Pt(ft, At.startTime - Rt)
            }
    }
    function ht(Rt, At) {
        st = !1,
        at && (at = !1,
        ct(_t),
        _t = -1),
        it = !0;
        var Mt = j;
        try {
            for (dt(At),
            et = s(nt); et !== null && (!(et.expirationTime > At) || Rt && !bt()); ) {
                var Ut = et.callback;
                if (typeof Ut == "function") {
                    et.callback = null,
                    j = et.priorityLevel;
                    var Lt = Ut(et.expirationTime <= At);
                    At = o.unstable_now(),
                    typeof Lt == "function" ? et.callback = Lt : et === s(nt) && a(nt),
                    dt(At)
                } else
                    a(nt);
                et = s(nt)
            }
            if (et !== null)
                var tn = !0;
            else {
                var Vt = s(rt);
                Vt !== null && Pt(ft, Vt.startTime - At),
                tn = !1
            }
            return tn
        } finally {
            et = null,
            j = Mt,
            it = !1
        }
    }
    var pt = !1
      , gt = null
      , _t = -1
      , mt = 5
      , yt = -1;
    function bt() {
        return !(o.unstable_now() - yt < mt)
    }
    function vt() {
        if (gt !== null) {
            var Rt = o.unstable_now();
            yt = Rt;
            var At = !0;
            try {
                At = gt(!0, Rt)
            } finally {
                At ? wt() : (pt = !1,
                gt = null)
            }
        } else
            pt = !1
    }
    var wt;
    if (typeof ut == "function")
        wt = function() {
            ut(vt)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var Tt = new MessageChannel
          , $t = Tt.port2;
        Tt.port1.onmessage = vt,
        wt = function() {
            $t.postMessage(null)
        }
    } else
        wt = function() {
            lt(vt, 0)
        }
        ;
    function Et(Rt) {
        gt = Rt,
        pt || (pt = !0,
        wt())
    }
    function Pt(Rt, At) {
        _t = lt(function() {
            Rt(o.unstable_now())
        }, At)
    }
    o.unstable_IdlePriority = 5,
    o.unstable_ImmediatePriority = 1,
    o.unstable_LowPriority = 4,
    o.unstable_NormalPriority = 3,
    o.unstable_Profiling = null,
    o.unstable_UserBlockingPriority = 2,
    o.unstable_cancelCallback = function(Rt) {
        Rt.callback = null
    }
    ,
    o.unstable_continueExecution = function() {
        st || it || (st = !0,
        Et(ht))
    }
    ,
    o.unstable_forceFrameRate = function(Rt) {
        0 > Rt || 125 < Rt ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : mt = 0 < Rt ? Math.floor(1e3 / Rt) : 5
    }
    ,
    o.unstable_getCurrentPriorityLevel = function() {
        return j
    }
    ,
    o.unstable_getFirstCallbackNode = function() {
        return s(nt)
    }
    ,
    o.unstable_next = function(Rt) {
        switch (j) {
        case 1:
        case 2:
        case 3:
            var At = 3;
            break;
        default:
            At = j
        }
        var Mt = j;
        j = At;
        try {
            return Rt()
        } finally {
            j = Mt
        }
    }
    ,
    o.unstable_pauseExecution = function() {}
    ,
    o.unstable_requestPaint = function() {}
    ,
    o.unstable_runWithPriority = function(Rt, At) {
        switch (Rt) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            Rt = 3
        }
        var Mt = j;
        j = Rt;
        try {
            return At()
        } finally {
            j = Mt
        }
    }
    ,
    o.unstable_scheduleCallback = function(Rt, At, Mt) {
        var Ut = o.unstable_now();
        switch (typeof Mt == "object" && Mt !== null ? (Mt = Mt.delay,
        Mt = typeof Mt == "number" && 0 < Mt ? Ut + Mt : Ut) : Mt = Ut,
        Rt) {
        case 1:
            var Lt = -1;
            break;
        case 2:
            Lt = 250;
            break;
        case 5:
            Lt = 1073741823;
            break;
        case 4:
            Lt = 1e4;
            break;
        default:
            Lt = 5e3
        }
        return Lt = Mt + Lt,
        Rt = {
            id: ot++,
            callback: At,
            priorityLevel: Rt,
            startTime: Mt,
            expirationTime: Lt,
            sortIndex: -1
        },
        Mt > Ut ? (Rt.sortIndex = Mt,
        i(rt, Rt),
        s(nt) === null && Rt === s(rt) && (at ? (ct(_t),
        _t = -1) : at = !0,
        Pt(ft, Mt - Ut))) : (Rt.sortIndex = Lt,
        i(nt, Rt),
        st || it || (st = !0,
        Et(ht))),
        Rt
    }
    ,
    o.unstable_shouldYield = bt,
    o.unstable_wrapCallback = function(Rt) {
        var At = j;
        return function() {
            var Mt = j;
            j = At;
            try {
                return Rt.apply(this, arguments)
            } finally {
                j = Mt
            }
        }
    }
}
)(scheduler_production_min);
scheduler.exports = scheduler_production_min;
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports
  , ca = schedulerExports;
function p$1(o) {
    for (var i = "https://reactjs.org/docs/error-decoder.html?invariant=" + o, s = 1; s < arguments.length; s++)
        i += "&args[]=" + encodeURIComponent(arguments[s]);
    return "Minified React error #" + o + "; visit " + i + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var da = new Set
  , ea = {};
function fa(o, i) {
    ha(o, i),
    ha(o + "Capture", i)
}
function ha(o, i) {
    for (ea[o] = i,
    o = 0; o < i.length; o++)
        da.add(i[o])
}
var ia = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
  , ja = Object.prototype.hasOwnProperty
  , ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
  , la = {}
  , ma = {};
function oa(o) {
    return ja.call(ma, o) ? !0 : ja.call(la, o) ? !1 : ka.test(o) ? ma[o] = !0 : (la[o] = !0,
    !1)
}
function pa(o, i, s, a) {
    if (s !== null && s.type === 0)
        return !1;
    switch (typeof i) {
    case "function":
    case "symbol":
        return !0;
    case "boolean":
        return a ? !1 : s !== null ? !s.acceptsBooleans : (o = o.toLowerCase().slice(0, 5),
        o !== "data-" && o !== "aria-");
    default:
        return !1
    }
}
function qa(o, i, s, a) {
    if (i === null || typeof i > "u" || pa(o, i, s, a))
        return !0;
    if (a)
        return !1;
    if (s !== null)
        switch (s.type) {
        case 3:
            return !i;
        case 4:
            return i === !1;
        case 5:
            return isNaN(i);
        case 6:
            return isNaN(i) || 1 > i
        }
    return !1
}
function v$1(o, i, s, a, _, $, _e) {
    this.acceptsBooleans = i === 2 || i === 3 || i === 4,
    this.attributeName = a,
    this.attributeNamespace = _,
    this.mustUseProperty = s,
    this.propertyName = o,
    this.type = i,
    this.sanitizeURL = $,
    this.removeEmptyString = _e
}
var z$1 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(o) {
    z$1[o] = new v$1(o,0,!1,o,null,!1,!1)
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(o) {
    var i = o[0];
    z$1[i] = new v$1(i,1,!1,o[1],null,!1,!1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(o) {
    z$1[o] = new v$1(o,2,!1,o.toLowerCase(),null,!1,!1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(o) {
    z$1[o] = new v$1(o,2,!1,o,null,!1,!1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(o) {
    z$1[o] = new v$1(o,3,!1,o.toLowerCase(),null,!1,!1)
});
["checked", "multiple", "muted", "selected"].forEach(function(o) {
    z$1[o] = new v$1(o,3,!0,o,null,!1,!1)
});
["capture", "download"].forEach(function(o) {
    z$1[o] = new v$1(o,4,!1,o,null,!1,!1)
});
["cols", "rows", "size", "span"].forEach(function(o) {
    z$1[o] = new v$1(o,6,!1,o,null,!1,!1)
});
["rowSpan", "start"].forEach(function(o) {
    z$1[o] = new v$1(o,5,!1,o.toLowerCase(),null,!1,!1)
});
var ra = /[\-:]([a-z])/g;
function sa(o) {
    return o[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(o) {
    var i = o.replace(ra, sa);
    z$1[i] = new v$1(i,1,!1,o,null,!1,!1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(o) {
    var i = o.replace(ra, sa);
    z$1[i] = new v$1(i,1,!1,o,"http://www.w3.org/1999/xlink",!1,!1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(o) {
    var i = o.replace(ra, sa);
    z$1[i] = new v$1(i,1,!1,o,"http://www.w3.org/XML/1998/namespace",!1,!1)
});
["tabIndex", "crossOrigin"].forEach(function(o) {
    z$1[o] = new v$1(o,1,!1,o.toLowerCase(),null,!1,!1)
});
z$1.xlinkHref = new v$1("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);
["src", "href", "action", "formAction"].forEach(function(o) {
    z$1[o] = new v$1(o,1,!1,o.toLowerCase(),null,!0,!0)
});
function ta(o, i, s, a) {
    var _ = z$1.hasOwnProperty(i) ? z$1[i] : null;
    (_ !== null ? _.type !== 0 : a || !(2 < i.length) || i[0] !== "o" && i[0] !== "O" || i[1] !== "n" && i[1] !== "N") && (qa(i, s, _, a) && (s = null),
    a || _ === null ? oa(i) && (s === null ? o.removeAttribute(i) : o.setAttribute(i, "" + s)) : _.mustUseProperty ? o[_.propertyName] = s === null ? _.type === 3 ? !1 : "" : s : (i = _.attributeName,
    a = _.attributeNamespace,
    s === null ? o.removeAttribute(i) : (_ = _.type,
    s = _ === 3 || _ === 4 && s === !0 ? "" : "" + s,
    a ? o.setAttributeNS(a, i, s) : o.setAttribute(i, s))))
}
var ua$1 = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  , va = Symbol.for("react.element")
  , wa = Symbol.for("react.portal")
  , ya = Symbol.for("react.fragment")
  , za = Symbol.for("react.strict_mode")
  , Aa = Symbol.for("react.profiler")
  , Ba = Symbol.for("react.provider")
  , Ca = Symbol.for("react.context")
  , Da = Symbol.for("react.forward_ref")
  , Ea = Symbol.for("react.suspense")
  , Fa = Symbol.for("react.suspense_list")
  , Ga = Symbol.for("react.memo")
  , Ha = Symbol.for("react.lazy")
  , Ia = Symbol.for("react.offscreen")
  , Ja = Symbol.iterator;
function Ka(o) {
    return o === null || typeof o != "object" ? null : (o = Ja && o[Ja] || o["@@iterator"],
    typeof o == "function" ? o : null)
}
var A$1 = Object.assign, La;
function Ma(o) {
    if (La === void 0)
        try {
            throw Error()
        } catch (s) {
            var i = s.stack.trim().match(/\n( *(at )?)/);
            La = i && i[1] || ""
        }
    return `
` + La + o
}
var Na = !1;
function Oa(o, i) {
    if (!o || Na)
        return "";
    Na = !0;
    var s = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (i)
            if (i = function() {
                throw Error()
            }
            ,
            Object.defineProperty(i.prototype, "props", {
                set: function() {
                    throw Error()
                }
            }),
            typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(i, [])
                } catch (rt) {
                    var a = rt
                }
                Reflect.construct(o, [], i)
            } else {
                try {
                    i.call()
                } catch (rt) {
                    a = rt
                }
                o.call(i.prototype)
            }
        else {
            try {
                throw Error()
            } catch (rt) {
                a = rt
            }
            o()
        }
    } catch (rt) {
        if (rt && a && typeof rt.stack == "string") {
            for (var _ = rt.stack.split(`
`), $ = a.stack.split(`
`), _e = _.length - 1, tt = $.length - 1; 1 <= _e && 0 <= tt && _[_e] !== $[tt]; )
                tt--;
            for (; 1 <= _e && 0 <= tt; _e--,
            tt--)
                if (_[_e] !== $[tt]) {
                    if (_e !== 1 || tt !== 1)
                        do
                            if (_e--,
                            tt--,
                            0 > tt || _[_e] !== $[tt]) {
                                var nt = `
` + _[_e].replace(" at new ", " at ");
                                return o.displayName && nt.includes("<anonymous>") && (nt = nt.replace("<anonymous>", o.displayName)),
                                nt
                            }
                        while (1 <= _e && 0 <= tt);
                    break
                }
        }
    } finally {
        Na = !1,
        Error.prepareStackTrace = s
    }
    return (o = o ? o.displayName || o.name : "") ? Ma(o) : ""
}
function Pa(o) {
    switch (o.tag) {
    case 5:
        return Ma(o.type);
    case 16:
        return Ma("Lazy");
    case 13:
        return Ma("Suspense");
    case 19:
        return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
        return o = Oa(o.type, !1),
        o;
    case 11:
        return o = Oa(o.type.render, !1),
        o;
    case 1:
        return o = Oa(o.type, !0),
        o;
    default:
        return ""
    }
}
function Qa(o) {
    if (o == null)
        return null;
    if (typeof o == "function")
        return o.displayName || o.name || null;
    if (typeof o == "string")
        return o;
    switch (o) {
    case ya:
        return "Fragment";
    case wa:
        return "Portal";
    case Aa:
        return "Profiler";
    case za:
        return "StrictMode";
    case Ea:
        return "Suspense";
    case Fa:
        return "SuspenseList"
    }
    if (typeof o == "object")
        switch (o.$$typeof) {
        case Ca:
            return (o.displayName || "Context") + ".Consumer";
        case Ba:
            return (o._context.displayName || "Context") + ".Provider";
        case Da:
            var i = o.render;
            return o = o.displayName,
            o || (o = i.displayName || i.name || "",
            o = o !== "" ? "ForwardRef(" + o + ")" : "ForwardRef"),
            o;
        case Ga:
            return i = o.displayName || null,
            i !== null ? i : Qa(o.type) || "Memo";
        case Ha:
            i = o._payload,
            o = o._init;
            try {
                return Qa(o(i))
            } catch {}
        }
    return null
}
function Ra(o) {
    var i = o.type;
    switch (o.tag) {
    case 24:
        return "Cache";
    case 9:
        return (i.displayName || "Context") + ".Consumer";
    case 10:
        return (i._context.displayName || "Context") + ".Provider";
    case 18:
        return "DehydratedFragment";
    case 11:
        return o = i.render,
        o = o.displayName || o.name || "",
        i.displayName || (o !== "" ? "ForwardRef(" + o + ")" : "ForwardRef");
    case 7:
        return "Fragment";
    case 5:
        return i;
    case 4:
        return "Portal";
    case 3:
        return "Root";
    case 6:
        return "Text";
    case 16:
        return Qa(i);
    case 8:
        return i === za ? "StrictMode" : "Mode";
    case 22:
        return "Offscreen";
    case 12:
        return "Profiler";
    case 21:
        return "Scope";
    case 13:
        return "Suspense";
    case 19:
        return "SuspenseList";
    case 25:
        return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
        if (typeof i == "function")
            return i.displayName || i.name || null;
        if (typeof i == "string")
            return i
    }
    return null
}
function Sa(o) {
    switch (typeof o) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
        return o;
    case "object":
        return o;
    default:
        return ""
    }
}
function Ta(o) {
    var i = o.type;
    return (o = o.nodeName) && o.toLowerCase() === "input" && (i === "checkbox" || i === "radio")
}
function Ua(o) {
    var i = Ta(o) ? "checked" : "value"
      , s = Object.getOwnPropertyDescriptor(o.constructor.prototype, i)
      , a = "" + o[i];
    if (!o.hasOwnProperty(i) && typeof s < "u" && typeof s.get == "function" && typeof s.set == "function") {
        var _ = s.get
          , $ = s.set;
        return Object.defineProperty(o, i, {
            configurable: !0,
            get: function() {
                return _.call(this)
            },
            set: function(_e) {
                a = "" + _e,
                $.call(this, _e)
            }
        }),
        Object.defineProperty(o, i, {
            enumerable: s.enumerable
        }),
        {
            getValue: function() {
                return a
            },
            setValue: function(_e) {
                a = "" + _e
            },
            stopTracking: function() {
                o._valueTracker = null,
                delete o[i]
            }
        }
    }
}
function Va(o) {
    o._valueTracker || (o._valueTracker = Ua(o))
}
function Wa(o) {
    if (!o)
        return !1;
    var i = o._valueTracker;
    if (!i)
        return !0;
    var s = i.getValue()
      , a = "";
    return o && (a = Ta(o) ? o.checked ? "true" : "false" : o.value),
    o = a,
    o !== s ? (i.setValue(o),
    !0) : !1
}
function Xa(o) {
    if (o = o || (typeof document < "u" ? document : void 0),
    typeof o > "u")
        return null;
    try {
        return o.activeElement || o.body
    } catch {
        return o.body
    }
}
function Ya(o, i) {
    var s = i.checked;
    return A$1({}, i, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: s ?? o._wrapperState.initialChecked
    })
}
function Za(o, i) {
    var s = i.defaultValue == null ? "" : i.defaultValue
      , a = i.checked != null ? i.checked : i.defaultChecked;
    s = Sa(i.value != null ? i.value : s),
    o._wrapperState = {
        initialChecked: a,
        initialValue: s,
        controlled: i.type === "checkbox" || i.type === "radio" ? i.checked != null : i.value != null
    }
}
function ab(o, i) {
    i = i.checked,
    i != null && ta(o, "checked", i, !1)
}
function bb(o, i) {
    ab(o, i);
    var s = Sa(i.value)
      , a = i.type;
    if (s != null)
        a === "number" ? (s === 0 && o.value === "" || o.value != s) && (o.value = "" + s) : o.value !== "" + s && (o.value = "" + s);
    else if (a === "submit" || a === "reset") {
        o.removeAttribute("value");
        return
    }
    i.hasOwnProperty("value") ? cb(o, i.type, s) : i.hasOwnProperty("defaultValue") && cb(o, i.type, Sa(i.defaultValue)),
    i.checked == null && i.defaultChecked != null && (o.defaultChecked = !!i.defaultChecked)
}
function db(o, i, s) {
    if (i.hasOwnProperty("value") || i.hasOwnProperty("defaultValue")) {
        var a = i.type;
        if (!(a !== "submit" && a !== "reset" || i.value !== void 0 && i.value !== null))
            return;
        i = "" + o._wrapperState.initialValue,
        s || i === o.value || (o.value = i),
        o.defaultValue = i
    }
    s = o.name,
    s !== "" && (o.name = ""),
    o.defaultChecked = !!o._wrapperState.initialChecked,
    s !== "" && (o.name = s)
}
function cb(o, i, s) {
    (i !== "number" || Xa(o.ownerDocument) !== o) && (s == null ? o.defaultValue = "" + o._wrapperState.initialValue : o.defaultValue !== "" + s && (o.defaultValue = "" + s))
}
var eb = Array.isArray;
function fb(o, i, s, a) {
    if (o = o.options,
    i) {
        i = {};
        for (var _ = 0; _ < s.length; _++)
            i["$" + s[_]] = !0;
        for (s = 0; s < o.length; s++)
            _ = i.hasOwnProperty("$" + o[s].value),
            o[s].selected !== _ && (o[s].selected = _),
            _ && a && (o[s].defaultSelected = !0)
    } else {
        for (s = "" + Sa(s),
        i = null,
        _ = 0; _ < o.length; _++) {
            if (o[_].value === s) {
                o[_].selected = !0,
                a && (o[_].defaultSelected = !0);
                return
            }
            i !== null || o[_].disabled || (i = o[_])
        }
        i !== null && (i.selected = !0)
    }
}
function gb(o, i) {
    if (i.dangerouslySetInnerHTML != null)
        throw Error(p$1(91));
    return A$1({}, i, {
        value: void 0,
        defaultValue: void 0,
        children: "" + o._wrapperState.initialValue
    })
}
function hb(o, i) {
    var s = i.value;
    if (s == null) {
        if (s = i.children,
        i = i.defaultValue,
        s != null) {
            if (i != null)
                throw Error(p$1(92));
            if (eb(s)) {
                if (1 < s.length)
                    throw Error(p$1(93));
                s = s[0]
            }
            i = s
        }
        i == null && (i = ""),
        s = i
    }
    o._wrapperState = {
        initialValue: Sa(s)
    }
}
function ib(o, i) {
    var s = Sa(i.value)
      , a = Sa(i.defaultValue);
    s != null && (s = "" + s,
    s !== o.value && (o.value = s),
    i.defaultValue == null && o.defaultValue !== s && (o.defaultValue = s)),
    a != null && (o.defaultValue = "" + a)
}
function jb(o) {
    var i = o.textContent;
    i === o._wrapperState.initialValue && i !== "" && i !== null && (o.value = i)
}
function kb(o) {
    switch (o) {
    case "svg":
        return "http://www.w3.org/2000/svg";
    case "math":
        return "http://www.w3.org/1998/Math/MathML";
    default:
        return "http://www.w3.org/1999/xhtml"
    }
}
function lb(o, i) {
    return o == null || o === "http://www.w3.org/1999/xhtml" ? kb(i) : o === "http://www.w3.org/2000/svg" && i === "foreignObject" ? "http://www.w3.org/1999/xhtml" : o
}
var mb, nb = function(o) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(i, s, a, _) {
        MSApp.execUnsafeLocalFunction(function() {
            return o(i, s, a, _)
        })
    }
    : o
}(function(o, i) {
    if (o.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in o)
        o.innerHTML = i;
    else {
        for (mb = mb || document.createElement("div"),
        mb.innerHTML = "<svg>" + i.valueOf().toString() + "</svg>",
        i = mb.firstChild; o.firstChild; )
            o.removeChild(o.firstChild);
        for (; i.firstChild; )
            o.appendChild(i.firstChild)
    }
});
function ob(o, i) {
    if (i) {
        var s = o.firstChild;
        if (s && s === o.lastChild && s.nodeType === 3) {
            s.nodeValue = i;
            return
        }
    }
    o.textContent = i
}
var pb = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
}
  , qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(o) {
    qb.forEach(function(i) {
        i = i + o.charAt(0).toUpperCase() + o.substring(1),
        pb[i] = pb[o]
    })
});
function rb(o, i, s) {
    return i == null || typeof i == "boolean" || i === "" ? "" : s || typeof i != "number" || i === 0 || pb.hasOwnProperty(o) && pb[o] ? ("" + i).trim() : i + "px"
}
function sb(o, i) {
    o = o.style;
    for (var s in i)
        if (i.hasOwnProperty(s)) {
            var a = s.indexOf("--") === 0
              , _ = rb(s, i[s], a);
            s === "float" && (s = "cssFloat"),
            a ? o.setProperty(s, _) : o[s] = _
        }
}
var tb = A$1({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});
function ub(o, i) {
    if (i) {
        if (tb[o] && (i.children != null || i.dangerouslySetInnerHTML != null))
            throw Error(p$1(137, o));
        if (i.dangerouslySetInnerHTML != null) {
            if (i.children != null)
                throw Error(p$1(60));
            if (typeof i.dangerouslySetInnerHTML != "object" || !("__html"in i.dangerouslySetInnerHTML))
                throw Error(p$1(61))
        }
        if (i.style != null && typeof i.style != "object")
            throw Error(p$1(62))
    }
}
function vb(o, i) {
    if (o.indexOf("-") === -1)
        return typeof i.is == "string";
    switch (o) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
        return !1;
    default:
        return !0
    }
}
var wb = null;
function xb(o) {
    return o = o.target || o.srcElement || window,
    o.correspondingUseElement && (o = o.correspondingUseElement),
    o.nodeType === 3 ? o.parentNode : o
}
var yb = null
  , zb = null
  , Ab = null;
function Bb(o) {
    if (o = Cb(o)) {
        if (typeof yb != "function")
            throw Error(p$1(280));
        var i = o.stateNode;
        i && (i = Db(i),
        yb(o.stateNode, o.type, i))
    }
}
function Eb(o) {
    zb ? Ab ? Ab.push(o) : Ab = [o] : zb = o
}
function Fb() {
    if (zb) {
        var o = zb
          , i = Ab;
        if (Ab = zb = null,
        Bb(o),
        i)
            for (o = 0; o < i.length; o++)
                Bb(i[o])
    }
}
function Gb(o, i) {
    return o(i)
}
function Hb() {}
var Ib = !1;
function Jb(o, i, s) {
    if (Ib)
        return o(i, s);
    Ib = !0;
    try {
        return Gb(o, i, s)
    } finally {
        Ib = !1,
        (zb !== null || Ab !== null) && (Hb(),
        Fb())
    }
}
function Kb(o, i) {
    var s = o.stateNode;
    if (s === null)
        return null;
    var a = Db(s);
    if (a === null)
        return null;
    s = a[i];
    e: switch (i) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
        (a = !a.disabled) || (o = o.type,
        a = !(o === "button" || o === "input" || o === "select" || o === "textarea")),
        o = !a;
        break e;
    default:
        o = !1
    }
    if (o)
        return null;
    if (s && typeof s != "function")
        throw Error(p$1(231, i, typeof s));
    return s
}
var Lb = !1;
if (ia)
    try {
        var Mb = {};
        Object.defineProperty(Mb, "passive", {
            get: function() {
                Lb = !0
            }
        }),
        window.addEventListener("test", Mb, Mb),
        window.removeEventListener("test", Mb, Mb)
    } catch {
        Lb = !1
    }
function Nb(o, i, s, a, _, $, _e, tt, nt) {
    var rt = Array.prototype.slice.call(arguments, 3);
    try {
        i.apply(s, rt)
    } catch (ot) {
        this.onError(ot)
    }
}
var Ob = !1
  , Pb = null
  , Qb = !1
  , Rb = null
  , Sb = {
    onError: function(o) {
        Ob = !0,
        Pb = o
    }
};
function Tb(o, i, s, a, _, $, _e, tt, nt) {
    Ob = !1,
    Pb = null,
    Nb.apply(Sb, arguments)
}
function Ub(o, i, s, a, _, $, _e, tt, nt) {
    if (Tb.apply(this, arguments),
    Ob) {
        if (Ob) {
            var rt = Pb;
            Ob = !1,
            Pb = null
        } else
            throw Error(p$1(198));
        Qb || (Qb = !0,
        Rb = rt)
    }
}
function Vb(o) {
    var i = o
      , s = o;
    if (o.alternate)
        for (; i.return; )
            i = i.return;
    else {
        o = i;
        do
            i = o,
            i.flags & 4098 && (s = i.return),
            o = i.return;
        while (o)
    }
    return i.tag === 3 ? s : null
}
function Wb(o) {
    if (o.tag === 13) {
        var i = o.memoizedState;
        if (i === null && (o = o.alternate,
        o !== null && (i = o.memoizedState)),
        i !== null)
            return i.dehydrated
    }
    return null
}
function Xb(o) {
    if (Vb(o) !== o)
        throw Error(p$1(188))
}
function Yb(o) {
    var i = o.alternate;
    if (!i) {
        if (i = Vb(o),
        i === null)
            throw Error(p$1(188));
        return i !== o ? null : o
    }
    for (var s = o, a = i; ; ) {
        var _ = s.return;
        if (_ === null)
            break;
        var $ = _.alternate;
        if ($ === null) {
            if (a = _.return,
            a !== null) {
                s = a;
                continue
            }
            break
        }
        if (_.child === $.child) {
            for ($ = _.child; $; ) {
                if ($ === s)
                    return Xb(_),
                    o;
                if ($ === a)
                    return Xb(_),
                    i;
                $ = $.sibling
            }
            throw Error(p$1(188))
        }
        if (s.return !== a.return)
            s = _,
            a = $;
        else {
            for (var _e = !1, tt = _.child; tt; ) {
                if (tt === s) {
                    _e = !0,
                    s = _,
                    a = $;
                    break
                }
                if (tt === a) {
                    _e = !0,
                    a = _,
                    s = $;
                    break
                }
                tt = tt.sibling
            }
            if (!_e) {
                for (tt = $.child; tt; ) {
                    if (tt === s) {
                        _e = !0,
                        s = $,
                        a = _;
                        break
                    }
                    if (tt === a) {
                        _e = !0,
                        a = $,
                        s = _;
                        break
                    }
                    tt = tt.sibling
                }
                if (!_e)
                    throw Error(p$1(189))
            }
        }
        if (s.alternate !== a)
            throw Error(p$1(190))
    }
    if (s.tag !== 3)
        throw Error(p$1(188));
    return s.stateNode.current === s ? o : i
}
function Zb(o) {
    return o = Yb(o),
    o !== null ? $b(o) : null
}
function $b(o) {
    if (o.tag === 5 || o.tag === 6)
        return o;
    for (o = o.child; o !== null; ) {
        var i = $b(o);
        if (i !== null)
            return i;
        o = o.sibling
    }
    return null
}
var ac = ca.unstable_scheduleCallback
  , bc = ca.unstable_cancelCallback
  , cc = ca.unstable_shouldYield
  , dc = ca.unstable_requestPaint
  , B = ca.unstable_now
  , ec = ca.unstable_getCurrentPriorityLevel
  , fc = ca.unstable_ImmediatePriority
  , gc = ca.unstable_UserBlockingPriority
  , hc = ca.unstable_NormalPriority
  , ic = ca.unstable_LowPriority
  , jc = ca.unstable_IdlePriority
  , kc = null
  , lc = null;
function mc(o) {
    if (lc && typeof lc.onCommitFiberRoot == "function")
        try {
            lc.onCommitFiberRoot(kc, o, void 0, (o.current.flags & 128) === 128)
        } catch {}
}
var oc = Math.clz32 ? Math.clz32 : nc
  , pc = Math.log
  , qc = Math.LN2;
function nc(o) {
    return o >>>= 0,
    o === 0 ? 32 : 31 - (pc(o) / qc | 0) | 0
}
var rc = 64
  , sc = 4194304;
function tc(o) {
    switch (o & -o) {
    case 1:
        return 1;
    case 2:
        return 2;
    case 4:
        return 4;
    case 8:
        return 8;
    case 16:
        return 16;
    case 32:
        return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return o & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return o & 130023424;
    case 134217728:
        return 134217728;
    case 268435456:
        return 268435456;
    case 536870912:
        return 536870912;
    case 1073741824:
        return 1073741824;
    default:
        return o
    }
}
function uc(o, i) {
    var s = o.pendingLanes;
    if (s === 0)
        return 0;
    var a = 0
      , _ = o.suspendedLanes
      , $ = o.pingedLanes
      , _e = s & 268435455;
    if (_e !== 0) {
        var tt = _e & ~_;
        tt !== 0 ? a = tc(tt) : ($ &= _e,
        $ !== 0 && (a = tc($)))
    } else
        _e = s & ~_,
        _e !== 0 ? a = tc(_e) : $ !== 0 && (a = tc($));
    if (a === 0)
        return 0;
    if (i !== 0 && i !== a && !(i & _) && (_ = a & -a,
    $ = i & -i,
    _ >= $ || _ === 16 && ($ & 4194240) !== 0))
        return i;
    if (a & 4 && (a |= s & 16),
    i = o.entangledLanes,
    i !== 0)
        for (o = o.entanglements,
        i &= a; 0 < i; )
            s = 31 - oc(i),
            _ = 1 << s,
            a |= o[s],
            i &= ~_;
    return a
}
function vc(o, i) {
    switch (o) {
    case 1:
    case 2:
    case 4:
        return i + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return i + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
        return -1;
    default:
        return -1
    }
}
function wc(o, i) {
    for (var s = o.suspendedLanes, a = o.pingedLanes, _ = o.expirationTimes, $ = o.pendingLanes; 0 < $; ) {
        var _e = 31 - oc($)
          , tt = 1 << _e
          , nt = _[_e];
        nt === -1 ? (!(tt & s) || tt & a) && (_[_e] = vc(tt, i)) : nt <= i && (o.expiredLanes |= tt),
        $ &= ~tt
    }
}
function xc(o) {
    return o = o.pendingLanes & -1073741825,
    o !== 0 ? o : o & 1073741824 ? 1073741824 : 0
}
function yc() {
    var o = rc;
    return rc <<= 1,
    !(rc & 4194240) && (rc = 64),
    o
}
function zc(o) {
    for (var i = [], s = 0; 31 > s; s++)
        i.push(o);
    return i
}
function Ac(o, i, s) {
    o.pendingLanes |= i,
    i !== 536870912 && (o.suspendedLanes = 0,
    o.pingedLanes = 0),
    o = o.eventTimes,
    i = 31 - oc(i),
    o[i] = s
}
function Bc(o, i) {
    var s = o.pendingLanes & ~i;
    o.pendingLanes = i,
    o.suspendedLanes = 0,
    o.pingedLanes = 0,
    o.expiredLanes &= i,
    o.mutableReadLanes &= i,
    o.entangledLanes &= i,
    i = o.entanglements;
    var a = o.eventTimes;
    for (o = o.expirationTimes; 0 < s; ) {
        var _ = 31 - oc(s)
          , $ = 1 << _;
        i[_] = 0,
        a[_] = -1,
        o[_] = -1,
        s &= ~$
    }
}
function Cc(o, i) {
    var s = o.entangledLanes |= i;
    for (o = o.entanglements; s; ) {
        var a = 31 - oc(s)
          , _ = 1 << a;
        _ & i | o[a] & i && (o[a] |= i),
        s &= ~_
    }
}
var C = 0;
function Dc(o) {
    return o &= -o,
    1 < o ? 4 < o ? o & 268435455 ? 16 : 536870912 : 4 : 1
}
var Ec, Fc, Gc, Hc, Ic, Jc = !1, Kc = [], Lc = null, Mc = null, Nc = null, Oc = new Map, Pc = new Map, Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(o, i) {
    switch (o) {
    case "focusin":
    case "focusout":
        Lc = null;
        break;
    case "dragenter":
    case "dragleave":
        Mc = null;
        break;
    case "mouseover":
    case "mouseout":
        Nc = null;
        break;
    case "pointerover":
    case "pointerout":
        Oc.delete(i.pointerId);
        break;
    case "gotpointercapture":
    case "lostpointercapture":
        Pc.delete(i.pointerId)
    }
}
function Tc(o, i, s, a, _, $) {
    return o === null || o.nativeEvent !== $ ? (o = {
        blockedOn: i,
        domEventName: s,
        eventSystemFlags: a,
        nativeEvent: $,
        targetContainers: [_]
    },
    i !== null && (i = Cb(i),
    i !== null && Fc(i)),
    o) : (o.eventSystemFlags |= a,
    i = o.targetContainers,
    _ !== null && i.indexOf(_) === -1 && i.push(_),
    o)
}
function Uc(o, i, s, a, _) {
    switch (i) {
    case "focusin":
        return Lc = Tc(Lc, o, i, s, a, _),
        !0;
    case "dragenter":
        return Mc = Tc(Mc, o, i, s, a, _),
        !0;
    case "mouseover":
        return Nc = Tc(Nc, o, i, s, a, _),
        !0;
    case "pointerover":
        var $ = _.pointerId;
        return Oc.set($, Tc(Oc.get($) || null, o, i, s, a, _)),
        !0;
    case "gotpointercapture":
        return $ = _.pointerId,
        Pc.set($, Tc(Pc.get($) || null, o, i, s, a, _)),
        !0
    }
    return !1
}
function Vc(o) {
    var i = Wc(o.target);
    if (i !== null) {
        var s = Vb(i);
        if (s !== null) {
            if (i = s.tag,
            i === 13) {
                if (i = Wb(s),
                i !== null) {
                    o.blockedOn = i,
                    Ic(o.priority, function() {
                        Gc(s)
                    });
                    return
                }
            } else if (i === 3 && s.stateNode.current.memoizedState.isDehydrated) {
                o.blockedOn = s.tag === 3 ? s.stateNode.containerInfo : null;
                return
            }
        }
    }
    o.blockedOn = null
}
function Xc(o) {
    if (o.blockedOn !== null)
        return !1;
    for (var i = o.targetContainers; 0 < i.length; ) {
        var s = Yc(o.domEventName, o.eventSystemFlags, i[0], o.nativeEvent);
        if (s === null) {
            s = o.nativeEvent;
            var a = new s.constructor(s.type,s);
            wb = a,
            s.target.dispatchEvent(a),
            wb = null
        } else
            return i = Cb(s),
            i !== null && Fc(i),
            o.blockedOn = s,
            !1;
        i.shift()
    }
    return !0
}
function Zc(o, i, s) {
    Xc(o) && s.delete(i)
}
function $c() {
    Jc = !1,
    Lc !== null && Xc(Lc) && (Lc = null),
    Mc !== null && Xc(Mc) && (Mc = null),
    Nc !== null && Xc(Nc) && (Nc = null),
    Oc.forEach(Zc),
    Pc.forEach(Zc)
}
function ad(o, i) {
    o.blockedOn === i && (o.blockedOn = null,
    Jc || (Jc = !0,
    ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)))
}
function bd(o) {
    function i(_) {
        return ad(_, o)
    }
    if (0 < Kc.length) {
        ad(Kc[0], o);
        for (var s = 1; s < Kc.length; s++) {
            var a = Kc[s];
            a.blockedOn === o && (a.blockedOn = null)
        }
    }
    for (Lc !== null && ad(Lc, o),
    Mc !== null && ad(Mc, o),
    Nc !== null && ad(Nc, o),
    Oc.forEach(i),
    Pc.forEach(i),
    s = 0; s < Qc.length; s++)
        a = Qc[s],
        a.blockedOn === o && (a.blockedOn = null);
    for (; 0 < Qc.length && (s = Qc[0],
    s.blockedOn === null); )
        Vc(s),
        s.blockedOn === null && Qc.shift()
}
var cd = ua$1.ReactCurrentBatchConfig
  , dd = !0;
function ed(o, i, s, a) {
    var _ = C
      , $ = cd.transition;
    cd.transition = null;
    try {
        C = 1,
        fd(o, i, s, a)
    } finally {
        C = _,
        cd.transition = $
    }
}
function gd(o, i, s, a) {
    var _ = C
      , $ = cd.transition;
    cd.transition = null;
    try {
        C = 4,
        fd(o, i, s, a)
    } finally {
        C = _,
        cd.transition = $
    }
}
function fd(o, i, s, a) {
    if (dd) {
        var _ = Yc(o, i, s, a);
        if (_ === null)
            hd(o, i, a, id, s),
            Sc(o, a);
        else if (Uc(_, o, i, s, a))
            a.stopPropagation();
        else if (Sc(o, a),
        i & 4 && -1 < Rc.indexOf(o)) {
            for (; _ !== null; ) {
                var $ = Cb(_);
                if ($ !== null && Ec($),
                $ = Yc(o, i, s, a),
                $ === null && hd(o, i, a, id, s),
                $ === _)
                    break;
                _ = $
            }
            _ !== null && a.stopPropagation()
        } else
            hd(o, i, a, null, s)
    }
}
var id = null;
function Yc(o, i, s, a) {
    if (id = null,
    o = xb(a),
    o = Wc(o),
    o !== null)
        if (i = Vb(o),
        i === null)
            o = null;
        else if (s = i.tag,
        s === 13) {
            if (o = Wb(i),
            o !== null)
                return o;
            o = null
        } else if (s === 3) {
            if (i.stateNode.current.memoizedState.isDehydrated)
                return i.tag === 3 ? i.stateNode.containerInfo : null;
            o = null
        } else
            i !== o && (o = null);
    return id = o,
    null
}
function jd(o) {
    switch (o) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
        return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
        return 4;
    case "message":
        switch (ec()) {
        case fc:
            return 1;
        case gc:
            return 4;
        case hc:
        case ic:
            return 16;
        case jc:
            return 536870912;
        default:
            return 16
        }
    default:
        return 16
    }
}
var kd = null
  , ld = null
  , md = null;
function nd() {
    if (md)
        return md;
    var o, i = ld, s = i.length, a, _ = "value"in kd ? kd.value : kd.textContent, $ = _.length;
    for (o = 0; o < s && i[o] === _[o]; o++)
        ;
    var _e = s - o;
    for (a = 1; a <= _e && i[s - a] === _[$ - a]; a++)
        ;
    return md = _.slice(o, 1 < a ? 1 - a : void 0)
}
function od(o) {
    var i = o.keyCode;
    return "charCode"in o ? (o = o.charCode,
    o === 0 && i === 13 && (o = 13)) : o = i,
    o === 10 && (o = 13),
    32 <= o || o === 13 ? o : 0
}
function pd() {
    return !0
}
function qd() {
    return !1
}
function rd(o) {
    function i(s, a, _, $, _e) {
        this._reactName = s,
        this._targetInst = _,
        this.type = a,
        this.nativeEvent = $,
        this.target = _e,
        this.currentTarget = null;
        for (var tt in o)
            o.hasOwnProperty(tt) && (s = o[tt],
            this[tt] = s ? s($) : $[tt]);
        return this.isDefaultPrevented = ($.defaultPrevented != null ? $.defaultPrevented : $.returnValue === !1) ? pd : qd,
        this.isPropagationStopped = qd,
        this
    }
    return A$1(i.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var s = this.nativeEvent;
            s && (s.preventDefault ? s.preventDefault() : typeof s.returnValue != "unknown" && (s.returnValue = !1),
            this.isDefaultPrevented = pd)
        },
        stopPropagation: function() {
            var s = this.nativeEvent;
            s && (s.stopPropagation ? s.stopPropagation() : typeof s.cancelBubble != "unknown" && (s.cancelBubble = !0),
            this.isPropagationStopped = pd)
        },
        persist: function() {},
        isPersistent: pd
    }),
    i
}
var sd = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(o) {
        return o.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
}, td = rd(sd), ud = A$1({}, sd, {
    view: 0,
    detail: 0
}), vd = rd(ud), wd, xd, yd, Ad = A$1({}, ud, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: zd,
    button: 0,
    buttons: 0,
    relatedTarget: function(o) {
        return o.relatedTarget === void 0 ? o.fromElement === o.srcElement ? o.toElement : o.fromElement : o.relatedTarget
    },
    movementX: function(o) {
        return "movementX"in o ? o.movementX : (o !== yd && (yd && o.type === "mousemove" ? (wd = o.screenX - yd.screenX,
        xd = o.screenY - yd.screenY) : xd = wd = 0,
        yd = o),
        wd)
    },
    movementY: function(o) {
        return "movementY"in o ? o.movementY : xd
    }
}), Bd = rd(Ad), Cd = A$1({}, Ad, {
    dataTransfer: 0
}), Dd = rd(Cd), Ed = A$1({}, ud, {
    relatedTarget: 0
}), Fd = rd(Ed), Gd = A$1({}, sd, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
}), Hd = rd(Gd), Id = A$1({}, sd, {
    clipboardData: function(o) {
        return "clipboardData"in o ? o.clipboardData : window.clipboardData
    }
}), Jd = rd(Id), Kd = A$1({}, sd, {
    data: 0
}), Ld = rd(Kd), Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
}, Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
}, Od = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
};
function Pd(o) {
    var i = this.nativeEvent;
    return i.getModifierState ? i.getModifierState(o) : (o = Od[o]) ? !!i[o] : !1
}
function zd() {
    return Pd
}
var Qd = A$1({}, ud, {
    key: function(o) {
        if (o.key) {
            var i = Md[o.key] || o.key;
            if (i !== "Unidentified")
                return i
        }
        return o.type === "keypress" ? (o = od(o),
        o === 13 ? "Enter" : String.fromCharCode(o)) : o.type === "keydown" || o.type === "keyup" ? Nd[o.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: zd,
    charCode: function(o) {
        return o.type === "keypress" ? od(o) : 0
    },
    keyCode: function(o) {
        return o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0
    },
    which: function(o) {
        return o.type === "keypress" ? od(o) : o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0
    }
})
  , Rd = rd(Qd)
  , Sd = A$1({}, Ad, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
})
  , Td = rd(Sd)
  , Ud = A$1({}, ud, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: zd
})
  , Vd = rd(Ud)
  , Wd = A$1({}, sd, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
})
  , Xd = rd(Wd)
  , Yd = A$1({}, Ad, {
    deltaX: function(o) {
        return "deltaX"in o ? o.deltaX : "wheelDeltaX"in o ? -o.wheelDeltaX : 0
    },
    deltaY: function(o) {
        return "deltaY"in o ? o.deltaY : "wheelDeltaY"in o ? -o.wheelDeltaY : "wheelDelta"in o ? -o.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
})
  , Zd = rd(Yd)
  , $d = [9, 13, 27, 32]
  , ae = ia && "CompositionEvent"in window
  , be = null;
ia && "documentMode"in document && (be = document.documentMode);
var ce = ia && "TextEvent"in window && !be
  , de = ia && (!ae || be && 8 < be && 11 >= be)
  , ee = String.fromCharCode(32)
  , fe = !1;
function ge(o, i) {
    switch (o) {
    case "keyup":
        return $d.indexOf(i.keyCode) !== -1;
    case "keydown":
        return i.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
        return !0;
    default:
        return !1
    }
}
function he(o) {
    return o = o.detail,
    typeof o == "object" && "data"in o ? o.data : null
}
var ie = !1;
function je(o, i) {
    switch (o) {
    case "compositionend":
        return he(i);
    case "keypress":
        return i.which !== 32 ? null : (fe = !0,
        ee);
    case "textInput":
        return o = i.data,
        o === ee && fe ? null : o;
    default:
        return null
    }
}
function ke(o, i) {
    if (ie)
        return o === "compositionend" || !ae && ge(o, i) ? (o = nd(),
        md = ld = kd = null,
        ie = !1,
        o) : null;
    switch (o) {
    case "paste":
        return null;
    case "keypress":
        if (!(i.ctrlKey || i.altKey || i.metaKey) || i.ctrlKey && i.altKey) {
            if (i.char && 1 < i.char.length)
                return i.char;
            if (i.which)
                return String.fromCharCode(i.which)
        }
        return null;
    case "compositionend":
        return de && i.locale !== "ko" ? null : i.data;
    default:
        return null
    }
}
var le = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};
function me(o) {
    var i = o && o.nodeName && o.nodeName.toLowerCase();
    return i === "input" ? !!le[o.type] : i === "textarea"
}
function ne(o, i, s, a) {
    Eb(a),
    i = oe(i, "onChange"),
    0 < i.length && (s = new td("onChange","change",null,s,a),
    o.push({
        event: s,
        listeners: i
    }))
}
var pe = null
  , qe = null;
function re(o) {
    se(o, 0)
}
function te(o) {
    var i = ue(o);
    if (Wa(i))
        return o
}
function ve(o, i) {
    if (o === "change")
        return i
}
var we = !1;
if (ia) {
    var xe;
    if (ia) {
        var ye = "oninput"in document;
        if (!ye) {
            var ze = document.createElement("div");
            ze.setAttribute("oninput", "return;"),
            ye = typeof ze.oninput == "function"
        }
        xe = ye
    } else
        xe = !1;
    we = xe && (!document.documentMode || 9 < document.documentMode)
}
function Ae() {
    pe && (pe.detachEvent("onpropertychange", Be),
    qe = pe = null)
}
function Be(o) {
    if (o.propertyName === "value" && te(qe)) {
        var i = [];
        ne(i, qe, o, xb(o)),
        Jb(re, i)
    }
}
function Ce(o, i, s) {
    o === "focusin" ? (Ae(),
    pe = i,
    qe = s,
    pe.attachEvent("onpropertychange", Be)) : o === "focusout" && Ae()
}
function De(o) {
    if (o === "selectionchange" || o === "keyup" || o === "keydown")
        return te(qe)
}
function Ee(o, i) {
    if (o === "click")
        return te(i)
}
function Fe(o, i) {
    if (o === "input" || o === "change")
        return te(i)
}
function Ge(o, i) {
    return o === i && (o !== 0 || 1 / o === 1 / i) || o !== o && i !== i
}
var He = typeof Object.is == "function" ? Object.is : Ge;
function Ie(o, i) {
    if (He(o, i))
        return !0;
    if (typeof o != "object" || o === null || typeof i != "object" || i === null)
        return !1;
    var s = Object.keys(o)
      , a = Object.keys(i);
    if (s.length !== a.length)
        return !1;
    for (a = 0; a < s.length; a++) {
        var _ = s[a];
        if (!ja.call(i, _) || !He(o[_], i[_]))
            return !1
    }
    return !0
}
function Je(o) {
    for (; o && o.firstChild; )
        o = o.firstChild;
    return o
}
function Ke(o, i) {
    var s = Je(o);
    o = 0;
    for (var a; s; ) {
        if (s.nodeType === 3) {
            if (a = o + s.textContent.length,
            o <= i && a >= i)
                return {
                    node: s,
                    offset: i - o
                };
            o = a
        }
        e: {
            for (; s; ) {
                if (s.nextSibling) {
                    s = s.nextSibling;
                    break e
                }
                s = s.parentNode
            }
            s = void 0
        }
        s = Je(s)
    }
}
function Le(o, i) {
    return o && i ? o === i ? !0 : o && o.nodeType === 3 ? !1 : i && i.nodeType === 3 ? Le(o, i.parentNode) : "contains"in o ? o.contains(i) : o.compareDocumentPosition ? !!(o.compareDocumentPosition(i) & 16) : !1 : !1
}
function Me() {
    for (var o = window, i = Xa(); i instanceof o.HTMLIFrameElement; ) {
        try {
            var s = typeof i.contentWindow.location.href == "string"
        } catch {
            s = !1
        }
        if (s)
            o = i.contentWindow;
        else
            break;
        i = Xa(o.document)
    }
    return i
}
function Ne(o) {
    var i = o && o.nodeName && o.nodeName.toLowerCase();
    return i && (i === "input" && (o.type === "text" || o.type === "search" || o.type === "tel" || o.type === "url" || o.type === "password") || i === "textarea" || o.contentEditable === "true")
}
function Oe(o) {
    var i = Me()
      , s = o.focusedElem
      , a = o.selectionRange;
    if (i !== s && s && s.ownerDocument && Le(s.ownerDocument.documentElement, s)) {
        if (a !== null && Ne(s)) {
            if (i = a.start,
            o = a.end,
            o === void 0 && (o = i),
            "selectionStart"in s)
                s.selectionStart = i,
                s.selectionEnd = Math.min(o, s.value.length);
            else if (o = (i = s.ownerDocument || document) && i.defaultView || window,
            o.getSelection) {
                o = o.getSelection();
                var _ = s.textContent.length
                  , $ = Math.min(a.start, _);
                a = a.end === void 0 ? $ : Math.min(a.end, _),
                !o.extend && $ > a && (_ = a,
                a = $,
                $ = _),
                _ = Ke(s, $);
                var _e = Ke(s, a);
                _ && _e && (o.rangeCount !== 1 || o.anchorNode !== _.node || o.anchorOffset !== _.offset || o.focusNode !== _e.node || o.focusOffset !== _e.offset) && (i = i.createRange(),
                i.setStart(_.node, _.offset),
                o.removeAllRanges(),
                $ > a ? (o.addRange(i),
                o.extend(_e.node, _e.offset)) : (i.setEnd(_e.node, _e.offset),
                o.addRange(i)))
            }
        }
        for (i = [],
        o = s; o = o.parentNode; )
            o.nodeType === 1 && i.push({
                element: o,
                left: o.scrollLeft,
                top: o.scrollTop
            });
        for (typeof s.focus == "function" && s.focus(),
        s = 0; s < i.length; s++)
            o = i[s],
            o.element.scrollLeft = o.left,
            o.element.scrollTop = o.top
    }
}
var Pe = ia && "documentMode"in document && 11 >= document.documentMode
  , Qe = null
  , Re = null
  , Se = null
  , Te = !1;
function Ue(o, i, s) {
    var a = s.window === s ? s.document : s.nodeType === 9 ? s : s.ownerDocument;
    Te || Qe == null || Qe !== Xa(a) || (a = Qe,
    "selectionStart"in a && Ne(a) ? a = {
        start: a.selectionStart,
        end: a.selectionEnd
    } : (a = (a.ownerDocument && a.ownerDocument.defaultView || window).getSelection(),
    a = {
        anchorNode: a.anchorNode,
        anchorOffset: a.anchorOffset,
        focusNode: a.focusNode,
        focusOffset: a.focusOffset
    }),
    Se && Ie(Se, a) || (Se = a,
    a = oe(Re, "onSelect"),
    0 < a.length && (i = new td("onSelect","select",null,i,s),
    o.push({
        event: i,
        listeners: a
    }),
    i.target = Qe)))
}
function Ve(o, i) {
    var s = {};
    return s[o.toLowerCase()] = i.toLowerCase(),
    s["Webkit" + o] = "webkit" + i,
    s["Moz" + o] = "moz" + i,
    s
}
var We = {
    animationend: Ve("Animation", "AnimationEnd"),
    animationiteration: Ve("Animation", "AnimationIteration"),
    animationstart: Ve("Animation", "AnimationStart"),
    transitionend: Ve("Transition", "TransitionEnd")
}
  , Xe = {}
  , Ye = {};
ia && (Ye = document.createElement("div").style,
"AnimationEvent"in window || (delete We.animationend.animation,
delete We.animationiteration.animation,
delete We.animationstart.animation),
"TransitionEvent"in window || delete We.transitionend.transition);
function Ze(o) {
    if (Xe[o])
        return Xe[o];
    if (!We[o])
        return o;
    var i = We[o], s;
    for (s in i)
        if (i.hasOwnProperty(s) && s in Ye)
            return Xe[o] = i[s];
    return o
}
var $e = Ze("animationend")
  , af = Ze("animationiteration")
  , bf = Ze("animationstart")
  , cf = Ze("transitionend")
  , df = new Map
  , ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(o, i) {
    df.set(o, i),
    fa(i, [o])
}
for (var gf = 0; gf < ef.length; gf++) {
    var hf = ef[gf]
      , jf = hf.toLowerCase()
      , kf = hf[0].toUpperCase() + hf.slice(1);
    ff(jf, "on" + kf)
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
  , mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(o, i, s) {
    var a = o.type || "unknown-event";
    o.currentTarget = s,
    Ub(a, i, void 0, o),
    o.currentTarget = null
}
function se(o, i) {
    i = (i & 4) !== 0;
    for (var s = 0; s < o.length; s++) {
        var a = o[s]
          , _ = a.event;
        a = a.listeners;
        e: {
            var $ = void 0;
            if (i)
                for (var _e = a.length - 1; 0 <= _e; _e--) {
                    var tt = a[_e]
                      , nt = tt.instance
                      , rt = tt.currentTarget;
                    if (tt = tt.listener,
                    nt !== $ && _.isPropagationStopped())
                        break e;
                    nf(_, tt, rt),
                    $ = nt
                }
            else
                for (_e = 0; _e < a.length; _e++) {
                    if (tt = a[_e],
                    nt = tt.instance,
                    rt = tt.currentTarget,
                    tt = tt.listener,
                    nt !== $ && _.isPropagationStopped())
                        break e;
                    nf(_, tt, rt),
                    $ = nt
                }
        }
    }
    if (Qb)
        throw o = Rb,
        Qb = !1,
        Rb = null,
        o
}
function D(o, i) {
    var s = i[of];
    s === void 0 && (s = i[of] = new Set);
    var a = o + "__bubble";
    s.has(a) || (pf(i, o, 2, !1),
    s.add(a))
}
function qf(o, i, s) {
    var a = 0;
    i && (a |= 4),
    pf(s, o, a, i)
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(o) {
    if (!o[rf]) {
        o[rf] = !0,
        da.forEach(function(s) {
            s !== "selectionchange" && (mf.has(s) || qf(s, !1, o),
            qf(s, !0, o))
        });
        var i = o.nodeType === 9 ? o : o.ownerDocument;
        i === null || i[rf] || (i[rf] = !0,
        qf("selectionchange", !1, i))
    }
}
function pf(o, i, s, a) {
    switch (jd(i)) {
    case 1:
        var _ = ed;
        break;
    case 4:
        _ = gd;
        break;
    default:
        _ = fd
    }
    s = _.bind(null, i, s, o),
    _ = void 0,
    !Lb || i !== "touchstart" && i !== "touchmove" && i !== "wheel" || (_ = !0),
    a ? _ !== void 0 ? o.addEventListener(i, s, {
        capture: !0,
        passive: _
    }) : o.addEventListener(i, s, !0) : _ !== void 0 ? o.addEventListener(i, s, {
        passive: _
    }) : o.addEventListener(i, s, !1)
}
function hd(o, i, s, a, _) {
    var $ = a;
    if (!(i & 1) && !(i & 2) && a !== null)
        e: for (; ; ) {
            if (a === null)
                return;
            var _e = a.tag;
            if (_e === 3 || _e === 4) {
                var tt = a.stateNode.containerInfo;
                if (tt === _ || tt.nodeType === 8 && tt.parentNode === _)
                    break;
                if (_e === 4)
                    for (_e = a.return; _e !== null; ) {
                        var nt = _e.tag;
                        if ((nt === 3 || nt === 4) && (nt = _e.stateNode.containerInfo,
                        nt === _ || nt.nodeType === 8 && nt.parentNode === _))
                            return;
                        _e = _e.return
                    }
                for (; tt !== null; ) {
                    if (_e = Wc(tt),
                    _e === null)
                        return;
                    if (nt = _e.tag,
                    nt === 5 || nt === 6) {
                        a = $ = _e;
                        continue e
                    }
                    tt = tt.parentNode
                }
            }
            a = a.return
        }
    Jb(function() {
        var rt = $
          , ot = xb(s)
          , et = [];
        e: {
            var j = df.get(o);
            if (j !== void 0) {
                var it = td
                  , st = o;
                switch (o) {
                case "keypress":
                    if (od(s) === 0)
                        break e;
                case "keydown":
                case "keyup":
                    it = Rd;
                    break;
                case "focusin":
                    st = "focus",
                    it = Fd;
                    break;
                case "focusout":
                    st = "blur",
                    it = Fd;
                    break;
                case "beforeblur":
                case "afterblur":
                    it = Fd;
                    break;
                case "click":
                    if (s.button === 2)
                        break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                    it = Bd;
                    break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                    it = Dd;
                    break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                    it = Vd;
                    break;
                case $e:
                case af:
                case bf:
                    it = Hd;
                    break;
                case cf:
                    it = Xd;
                    break;
                case "scroll":
                    it = vd;
                    break;
                case "wheel":
                    it = Zd;
                    break;
                case "copy":
                case "cut":
                case "paste":
                    it = Jd;
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                    it = Td
                }
                var at = (i & 4) !== 0
                  , lt = !at && o === "scroll"
                  , ct = at ? j !== null ? j + "Capture" : null : j;
                at = [];
                for (var ut = rt, dt; ut !== null; ) {
                    dt = ut;
                    var ft = dt.stateNode;
                    if (dt.tag === 5 && ft !== null && (dt = ft,
                    ct !== null && (ft = Kb(ut, ct),
                    ft != null && at.push(tf(ut, ft, dt)))),
                    lt)
                        break;
                    ut = ut.return
                }
                0 < at.length && (j = new it(j,st,null,s,ot),
                et.push({
                    event: j,
                    listeners: at
                }))
            }
        }
        if (!(i & 7)) {
            e: {
                if (j = o === "mouseover" || o === "pointerover",
                it = o === "mouseout" || o === "pointerout",
                j && s !== wb && (st = s.relatedTarget || s.fromElement) && (Wc(st) || st[uf]))
                    break e;
                if ((it || j) && (j = ot.window === ot ? ot : (j = ot.ownerDocument) ? j.defaultView || j.parentWindow : window,
                it ? (st = s.relatedTarget || s.toElement,
                it = rt,
                st = st ? Wc(st) : null,
                st !== null && (lt = Vb(st),
                st !== lt || st.tag !== 5 && st.tag !== 6) && (st = null)) : (it = null,
                st = rt),
                it !== st)) {
                    if (at = Bd,
                    ft = "onMouseLeave",
                    ct = "onMouseEnter",
                    ut = "mouse",
                    (o === "pointerout" || o === "pointerover") && (at = Td,
                    ft = "onPointerLeave",
                    ct = "onPointerEnter",
                    ut = "pointer"),
                    lt = it == null ? j : ue(it),
                    dt = st == null ? j : ue(st),
                    j = new at(ft,ut + "leave",it,s,ot),
                    j.target = lt,
                    j.relatedTarget = dt,
                    ft = null,
                    Wc(ot) === rt && (at = new at(ct,ut + "enter",st,s,ot),
                    at.target = dt,
                    at.relatedTarget = lt,
                    ft = at),
                    lt = ft,
                    it && st)
                        t: {
                            for (at = it,
                            ct = st,
                            ut = 0,
                            dt = at; dt; dt = vf(dt))
                                ut++;
                            for (dt = 0,
                            ft = ct; ft; ft = vf(ft))
                                dt++;
                            for (; 0 < ut - dt; )
                                at = vf(at),
                                ut--;
                            for (; 0 < dt - ut; )
                                ct = vf(ct),
                                dt--;
                            for (; ut--; ) {
                                if (at === ct || ct !== null && at === ct.alternate)
                                    break t;
                                at = vf(at),
                                ct = vf(ct)
                            }
                            at = null
                        }
                    else
                        at = null;
                    it !== null && wf(et, j, it, at, !1),
                    st !== null && lt !== null && wf(et, lt, st, at, !0)
                }
            }
            e: {
                if (j = rt ? ue(rt) : window,
                it = j.nodeName && j.nodeName.toLowerCase(),
                it === "select" || it === "input" && j.type === "file")
                    var ht = ve;
                else if (me(j))
                    if (we)
                        ht = Fe;
                    else {
                        ht = De;
                        var pt = Ce
                    }
                else
                    (it = j.nodeName) && it.toLowerCase() === "input" && (j.type === "checkbox" || j.type === "radio") && (ht = Ee);
                if (ht && (ht = ht(o, rt))) {
                    ne(et, ht, s, ot);
                    break e
                }
                pt && pt(o, j, rt),
                o === "focusout" && (pt = j._wrapperState) && pt.controlled && j.type === "number" && cb(j, "number", j.value)
            }
            switch (pt = rt ? ue(rt) : window,
            o) {
            case "focusin":
                (me(pt) || pt.contentEditable === "true") && (Qe = pt,
                Re = rt,
                Se = null);
                break;
            case "focusout":
                Se = Re = Qe = null;
                break;
            case "mousedown":
                Te = !0;
                break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
                Te = !1,
                Ue(et, s, ot);
                break;
            case "selectionchange":
                if (Pe)
                    break;
            case "keydown":
            case "keyup":
                Ue(et, s, ot)
            }
            var gt;
            if (ae)
                e: {
                    switch (o) {
                    case "compositionstart":
                        var _t = "onCompositionStart";
                        break e;
                    case "compositionend":
                        _t = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        _t = "onCompositionUpdate";
                        break e
                    }
                    _t = void 0
                }
            else
                ie ? ge(o, s) && (_t = "onCompositionEnd") : o === "keydown" && s.keyCode === 229 && (_t = "onCompositionStart");
            _t && (de && s.locale !== "ko" && (ie || _t !== "onCompositionStart" ? _t === "onCompositionEnd" && ie && (gt = nd()) : (kd = ot,
            ld = "value"in kd ? kd.value : kd.textContent,
            ie = !0)),
            pt = oe(rt, _t),
            0 < pt.length && (_t = new Ld(_t,o,null,s,ot),
            et.push({
                event: _t,
                listeners: pt
            }),
            gt ? _t.data = gt : (gt = he(s),
            gt !== null && (_t.data = gt)))),
            (gt = ce ? je(o, s) : ke(o, s)) && (rt = oe(rt, "onBeforeInput"),
            0 < rt.length && (ot = new Ld("onBeforeInput","beforeinput",null,s,ot),
            et.push({
                event: ot,
                listeners: rt
            }),
            ot.data = gt))
        }
        se(et, i)
    })
}
function tf(o, i, s) {
    return {
        instance: o,
        listener: i,
        currentTarget: s
    }
}
function oe(o, i) {
    for (var s = i + "Capture", a = []; o !== null; ) {
        var _ = o
          , $ = _.stateNode;
        _.tag === 5 && $ !== null && (_ = $,
        $ = Kb(o, s),
        $ != null && a.unshift(tf(o, $, _)),
        $ = Kb(o, i),
        $ != null && a.push(tf(o, $, _))),
        o = o.return
    }
    return a
}
function vf(o) {
    if (o === null)
        return null;
    do
        o = o.return;
    while (o && o.tag !== 5);
    return o || null
}
function wf(o, i, s, a, _) {
    for (var $ = i._reactName, _e = []; s !== null && s !== a; ) {
        var tt = s
          , nt = tt.alternate
          , rt = tt.stateNode;
        if (nt !== null && nt === a)
            break;
        tt.tag === 5 && rt !== null && (tt = rt,
        _ ? (nt = Kb(s, $),
        nt != null && _e.unshift(tf(s, nt, tt))) : _ || (nt = Kb(s, $),
        nt != null && _e.push(tf(s, nt, tt)))),
        s = s.return
    }
    _e.length !== 0 && o.push({
        event: i,
        listeners: _e
    })
}
var xf = /\r\n?/g
  , yf = /\u0000|\uFFFD/g;
function zf(o) {
    return (typeof o == "string" ? o : "" + o).replace(xf, `
`).replace(yf, "")
}
function Af(o, i, s) {
    if (i = zf(i),
    zf(o) !== i && s)
        throw Error(p$1(425))
}
function Bf() {}
var Cf = null
  , Df = null;
function Ef(o, i) {
    return o === "textarea" || o === "noscript" || typeof i.children == "string" || typeof i.children == "number" || typeof i.dangerouslySetInnerHTML == "object" && i.dangerouslySetInnerHTML !== null && i.dangerouslySetInnerHTML.__html != null
}
var Ff = typeof setTimeout == "function" ? setTimeout : void 0
  , Gf = typeof clearTimeout == "function" ? clearTimeout : void 0
  , Hf = typeof Promise == "function" ? Promise : void 0
  , Jf = typeof queueMicrotask == "function" ? queueMicrotask : typeof Hf < "u" ? function(o) {
    return Hf.resolve(null).then(o).catch(If)
}
: Ff;
function If(o) {
    setTimeout(function() {
        throw o
    })
}
function Kf(o, i) {
    var s = i
      , a = 0;
    do {
        var _ = s.nextSibling;
        if (o.removeChild(s),
        _ && _.nodeType === 8)
            if (s = _.data,
            s === "/$") {
                if (a === 0) {
                    o.removeChild(_),
                    bd(i);
                    return
                }
                a--
            } else
                s !== "$" && s !== "$?" && s !== "$!" || a++;
        s = _
    } while (s);
    bd(i)
}
function Lf(o) {
    for (; o != null; o = o.nextSibling) {
        var i = o.nodeType;
        if (i === 1 || i === 3)
            break;
        if (i === 8) {
            if (i = o.data,
            i === "$" || i === "$!" || i === "$?")
                break;
            if (i === "/$")
                return null
        }
    }
    return o
}
function Mf(o) {
    o = o.previousSibling;
    for (var i = 0; o; ) {
        if (o.nodeType === 8) {
            var s = o.data;
            if (s === "$" || s === "$!" || s === "$?") {
                if (i === 0)
                    return o;
                i--
            } else
                s === "/$" && i++
        }
        o = o.previousSibling
    }
    return null
}
var Nf = Math.random().toString(36).slice(2)
  , Of = "__reactFiber$" + Nf
  , Pf = "__reactProps$" + Nf
  , uf = "__reactContainer$" + Nf
  , of = "__reactEvents$" + Nf
  , Qf = "__reactListeners$" + Nf
  , Rf = "__reactHandles$" + Nf;
function Wc(o) {
    var i = o[Of];
    if (i)
        return i;
    for (var s = o.parentNode; s; ) {
        if (i = s[uf] || s[Of]) {
            if (s = i.alternate,
            i.child !== null || s !== null && s.child !== null)
                for (o = Mf(o); o !== null; ) {
                    if (s = o[Of])
                        return s;
                    o = Mf(o)
                }
            return i
        }
        o = s,
        s = o.parentNode
    }
    return null
}
function Cb(o) {
    return o = o[Of] || o[uf],
    !o || o.tag !== 5 && o.tag !== 6 && o.tag !== 13 && o.tag !== 3 ? null : o
}
function ue(o) {
    if (o.tag === 5 || o.tag === 6)
        return o.stateNode;
    throw Error(p$1(33))
}
function Db(o) {
    return o[Pf] || null
}
var Sf = []
  , Tf = -1;
function Uf(o) {
    return {
        current: o
    }
}
function E(o) {
    0 > Tf || (o.current = Sf[Tf],
    Sf[Tf] = null,
    Tf--)
}
function G(o, i) {
    Tf++,
    Sf[Tf] = o.current,
    o.current = i
}
var Vf = {}
  , H = Uf(Vf)
  , Wf = Uf(!1)
  , Xf = Vf;
function Yf(o, i) {
    var s = o.type.contextTypes;
    if (!s)
        return Vf;
    var a = o.stateNode;
    if (a && a.__reactInternalMemoizedUnmaskedChildContext === i)
        return a.__reactInternalMemoizedMaskedChildContext;
    var _ = {}, $;
    for ($ in s)
        _[$] = i[$];
    return a && (o = o.stateNode,
    o.__reactInternalMemoizedUnmaskedChildContext = i,
    o.__reactInternalMemoizedMaskedChildContext = _),
    _
}
function Zf(o) {
    return o = o.childContextTypes,
    o != null
}
function $f() {
    E(Wf),
    E(H)
}
function ag(o, i, s) {
    if (H.current !== Vf)
        throw Error(p$1(168));
    G(H, i),
    G(Wf, s)
}
function bg(o, i, s) {
    var a = o.stateNode;
    if (i = i.childContextTypes,
    typeof a.getChildContext != "function")
        return s;
    a = a.getChildContext();
    for (var _ in a)
        if (!(_ in i))
            throw Error(p$1(108, Ra(o) || "Unknown", _));
    return A$1({}, s, a)
}
function cg(o) {
    return o = (o = o.stateNode) && o.__reactInternalMemoizedMergedChildContext || Vf,
    Xf = H.current,
    G(H, o),
    G(Wf, Wf.current),
    !0
}
function dg(o, i, s) {
    var a = o.stateNode;
    if (!a)
        throw Error(p$1(169));
    s ? (o = bg(o, i, Xf),
    a.__reactInternalMemoizedMergedChildContext = o,
    E(Wf),
    E(H),
    G(H, o)) : E(Wf),
    G(Wf, s)
}
var eg = null
  , fg = !1
  , gg = !1;
function hg(o) {
    eg === null ? eg = [o] : eg.push(o)
}
function ig(o) {
    fg = !0,
    hg(o)
}
function jg() {
    if (!gg && eg !== null) {
        gg = !0;
        var o = 0
          , i = C;
        try {
            var s = eg;
            for (C = 1; o < s.length; o++) {
                var a = s[o];
                do
                    a = a(!0);
                while (a !== null)
            }
            eg = null,
            fg = !1
        } catch (_) {
            throw eg !== null && (eg = eg.slice(o + 1)),
            ac(fc, jg),
            _
        } finally {
            C = i,
            gg = !1
        }
    }
    return null
}
var kg = []
  , lg = 0
  , mg = null
  , ng = 0
  , og = []
  , pg = 0
  , qg = null
  , rg = 1
  , sg = "";
function tg(o, i) {
    kg[lg++] = ng,
    kg[lg++] = mg,
    mg = o,
    ng = i
}
function ug(o, i, s) {
    og[pg++] = rg,
    og[pg++] = sg,
    og[pg++] = qg,
    qg = o;
    var a = rg;
    o = sg;
    var _ = 32 - oc(a) - 1;
    a &= ~(1 << _),
    s += 1;
    var $ = 32 - oc(i) + _;
    if (30 < $) {
        var _e = _ - _ % 5;
        $ = (a & (1 << _e) - 1).toString(32),
        a >>= _e,
        _ -= _e,
        rg = 1 << 32 - oc(i) + _ | s << _ | a,
        sg = $ + o
    } else
        rg = 1 << $ | s << _ | a,
        sg = o
}
function vg(o) {
    o.return !== null && (tg(o, 1),
    ug(o, 1, 0))
}
function wg(o) {
    for (; o === mg; )
        mg = kg[--lg],
        kg[lg] = null,
        ng = kg[--lg],
        kg[lg] = null;
    for (; o === qg; )
        qg = og[--pg],
        og[pg] = null,
        sg = og[--pg],
        og[pg] = null,
        rg = og[--pg],
        og[pg] = null
}
var xg = null
  , yg = null
  , I = !1
  , zg = null;
function Ag(o, i) {
    var s = Bg(5, null, null, 0);
    s.elementType = "DELETED",
    s.stateNode = i,
    s.return = o,
    i = o.deletions,
    i === null ? (o.deletions = [s],
    o.flags |= 16) : i.push(s)
}
function Cg(o, i) {
    switch (o.tag) {
    case 5:
        var s = o.type;
        return i = i.nodeType !== 1 || s.toLowerCase() !== i.nodeName.toLowerCase() ? null : i,
        i !== null ? (o.stateNode = i,
        xg = o,
        yg = Lf(i.firstChild),
        !0) : !1;
    case 6:
        return i = o.pendingProps === "" || i.nodeType !== 3 ? null : i,
        i !== null ? (o.stateNode = i,
        xg = o,
        yg = null,
        !0) : !1;
    case 13:
        return i = i.nodeType !== 8 ? null : i,
        i !== null ? (s = qg !== null ? {
            id: rg,
            overflow: sg
        } : null,
        o.memoizedState = {
            dehydrated: i,
            treeContext: s,
            retryLane: 1073741824
        },
        s = Bg(18, null, null, 0),
        s.stateNode = i,
        s.return = o,
        o.child = s,
        xg = o,
        yg = null,
        !0) : !1;
    default:
        return !1
    }
}
function Dg(o) {
    return (o.mode & 1) !== 0 && (o.flags & 128) === 0
}
function Eg(o) {
    if (I) {
        var i = yg;
        if (i) {
            var s = i;
            if (!Cg(o, i)) {
                if (Dg(o))
                    throw Error(p$1(418));
                i = Lf(s.nextSibling);
                var a = xg;
                i && Cg(o, i) ? Ag(a, s) : (o.flags = o.flags & -4097 | 2,
                I = !1,
                xg = o)
            }
        } else {
            if (Dg(o))
                throw Error(p$1(418));
            o.flags = o.flags & -4097 | 2,
            I = !1,
            xg = o
        }
    }
}
function Fg(o) {
    for (o = o.return; o !== null && o.tag !== 5 && o.tag !== 3 && o.tag !== 13; )
        o = o.return;
    xg = o
}
function Gg(o) {
    if (o !== xg)
        return !1;
    if (!I)
        return Fg(o),
        I = !0,
        !1;
    var i;
    if ((i = o.tag !== 3) && !(i = o.tag !== 5) && (i = o.type,
    i = i !== "head" && i !== "body" && !Ef(o.type, o.memoizedProps)),
    i && (i = yg)) {
        if (Dg(o))
            throw Hg(),
            Error(p$1(418));
        for (; i; )
            Ag(o, i),
            i = Lf(i.nextSibling)
    }
    if (Fg(o),
    o.tag === 13) {
        if (o = o.memoizedState,
        o = o !== null ? o.dehydrated : null,
        !o)
            throw Error(p$1(317));
        e: {
            for (o = o.nextSibling,
            i = 0; o; ) {
                if (o.nodeType === 8) {
                    var s = o.data;
                    if (s === "/$") {
                        if (i === 0) {
                            yg = Lf(o.nextSibling);
                            break e
                        }
                        i--
                    } else
                        s !== "$" && s !== "$!" && s !== "$?" || i++
                }
                o = o.nextSibling
            }
            yg = null
        }
    } else
        yg = xg ? Lf(o.stateNode.nextSibling) : null;
    return !0
}
function Hg() {
    for (var o = yg; o; )
        o = Lf(o.nextSibling)
}
function Ig() {
    yg = xg = null,
    I = !1
}
function Jg(o) {
    zg === null ? zg = [o] : zg.push(o)
}
var Kg = ua$1.ReactCurrentBatchConfig;
function Lg(o, i) {
    if (o && o.defaultProps) {
        i = A$1({}, i),
        o = o.defaultProps;
        for (var s in o)
            i[s] === void 0 && (i[s] = o[s]);
        return i
    }
    return i
}
var Mg = Uf(null)
  , Ng = null
  , Og = null
  , Pg = null;
function Qg() {
    Pg = Og = Ng = null
}
function Rg(o) {
    var i = Mg.current;
    E(Mg),
    o._currentValue = i
}
function Sg(o, i, s) {
    for (; o !== null; ) {
        var a = o.alternate;
        if ((o.childLanes & i) !== i ? (o.childLanes |= i,
        a !== null && (a.childLanes |= i)) : a !== null && (a.childLanes & i) !== i && (a.childLanes |= i),
        o === s)
            break;
        o = o.return
    }
}
function Tg(o, i) {
    Ng = o,
    Pg = Og = null,
    o = o.dependencies,
    o !== null && o.firstContext !== null && (o.lanes & i && (Ug = !0),
    o.firstContext = null)
}
function Vg(o) {
    var i = o._currentValue;
    if (Pg !== o)
        if (o = {
            context: o,
            memoizedValue: i,
            next: null
        },
        Og === null) {
            if (Ng === null)
                throw Error(p$1(308));
            Og = o,
            Ng.dependencies = {
                lanes: 0,
                firstContext: o
            }
        } else
            Og = Og.next = o;
    return i
}
var Wg = null;
function Xg(o) {
    Wg === null ? Wg = [o] : Wg.push(o)
}
function Yg(o, i, s, a) {
    var _ = i.interleaved;
    return _ === null ? (s.next = s,
    Xg(i)) : (s.next = _.next,
    _.next = s),
    i.interleaved = s,
    Zg(o, a)
}
function Zg(o, i) {
    o.lanes |= i;
    var s = o.alternate;
    for (s !== null && (s.lanes |= i),
    s = o,
    o = o.return; o !== null; )
        o.childLanes |= i,
        s = o.alternate,
        s !== null && (s.childLanes |= i),
        s = o,
        o = o.return;
    return s.tag === 3 ? s.stateNode : null
}
var $g = !1;
function ah(o) {
    o.updateQueue = {
        baseState: o.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}
function bh(o, i) {
    o = o.updateQueue,
    i.updateQueue === o && (i.updateQueue = {
        baseState: o.baseState,
        firstBaseUpdate: o.firstBaseUpdate,
        lastBaseUpdate: o.lastBaseUpdate,
        shared: o.shared,
        effects: o.effects
    })
}
function ch(o, i) {
    return {
        eventTime: o,
        lane: i,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}
function dh(o, i, s) {
    var a = o.updateQueue;
    if (a === null)
        return null;
    if (a = a.shared,
    K & 2) {
        var _ = a.pending;
        return _ === null ? i.next = i : (i.next = _.next,
        _.next = i),
        a.pending = i,
        Zg(o, s)
    }
    return _ = a.interleaved,
    _ === null ? (i.next = i,
    Xg(a)) : (i.next = _.next,
    _.next = i),
    a.interleaved = i,
    Zg(o, s)
}
function eh(o, i, s) {
    if (i = i.updateQueue,
    i !== null && (i = i.shared,
    (s & 4194240) !== 0)) {
        var a = i.lanes;
        a &= o.pendingLanes,
        s |= a,
        i.lanes = s,
        Cc(o, s)
    }
}
function fh(o, i) {
    var s = o.updateQueue
      , a = o.alternate;
    if (a !== null && (a = a.updateQueue,
    s === a)) {
        var _ = null
          , $ = null;
        if (s = s.firstBaseUpdate,
        s !== null) {
            do {
                var _e = {
                    eventTime: s.eventTime,
                    lane: s.lane,
                    tag: s.tag,
                    payload: s.payload,
                    callback: s.callback,
                    next: null
                };
                $ === null ? _ = $ = _e : $ = $.next = _e,
                s = s.next
            } while (s !== null);
            $ === null ? _ = $ = i : $ = $.next = i
        } else
            _ = $ = i;
        s = {
            baseState: a.baseState,
            firstBaseUpdate: _,
            lastBaseUpdate: $,
            shared: a.shared,
            effects: a.effects
        },
        o.updateQueue = s;
        return
    }
    o = s.lastBaseUpdate,
    o === null ? s.firstBaseUpdate = i : o.next = i,
    s.lastBaseUpdate = i
}
function gh(o, i, s, a) {
    var _ = o.updateQueue;
    $g = !1;
    var $ = _.firstBaseUpdate
      , _e = _.lastBaseUpdate
      , tt = _.shared.pending;
    if (tt !== null) {
        _.shared.pending = null;
        var nt = tt
          , rt = nt.next;
        nt.next = null,
        _e === null ? $ = rt : _e.next = rt,
        _e = nt;
        var ot = o.alternate;
        ot !== null && (ot = ot.updateQueue,
        tt = ot.lastBaseUpdate,
        tt !== _e && (tt === null ? ot.firstBaseUpdate = rt : tt.next = rt,
        ot.lastBaseUpdate = nt))
    }
    if ($ !== null) {
        var et = _.baseState;
        _e = 0,
        ot = rt = nt = null,
        tt = $;
        do {
            var j = tt.lane
              , it = tt.eventTime;
            if ((a & j) === j) {
                ot !== null && (ot = ot.next = {
                    eventTime: it,
                    lane: 0,
                    tag: tt.tag,
                    payload: tt.payload,
                    callback: tt.callback,
                    next: null
                });
                e: {
                    var st = o
                      , at = tt;
                    switch (j = i,
                    it = s,
                    at.tag) {
                    case 1:
                        if (st = at.payload,
                        typeof st == "function") {
                            et = st.call(it, et, j);
                            break e
                        }
                        et = st;
                        break e;
                    case 3:
                        st.flags = st.flags & -65537 | 128;
                    case 0:
                        if (st = at.payload,
                        j = typeof st == "function" ? st.call(it, et, j) : st,
                        j == null)
                            break e;
                        et = A$1({}, et, j);
                        break e;
                    case 2:
                        $g = !0
                    }
                }
                tt.callback !== null && tt.lane !== 0 && (o.flags |= 64,
                j = _.effects,
                j === null ? _.effects = [tt] : j.push(tt))
            } else
                it = {
                    eventTime: it,
                    lane: j,
                    tag: tt.tag,
                    payload: tt.payload,
                    callback: tt.callback,
                    next: null
                },
                ot === null ? (rt = ot = it,
                nt = et) : ot = ot.next = it,
                _e |= j;
            if (tt = tt.next,
            tt === null) {
                if (tt = _.shared.pending,
                tt === null)
                    break;
                j = tt,
                tt = j.next,
                j.next = null,
                _.lastBaseUpdate = j,
                _.shared.pending = null
            }
        } while (1);
        if (ot === null && (nt = et),
        _.baseState = nt,
        _.firstBaseUpdate = rt,
        _.lastBaseUpdate = ot,
        i = _.shared.interleaved,
        i !== null) {
            _ = i;
            do
                _e |= _.lane,
                _ = _.next;
            while (_ !== i)
        } else
            $ === null && (_.shared.lanes = 0);
        hh |= _e,
        o.lanes = _e,
        o.memoizedState = et
    }
}
function ih(o, i, s) {
    if (o = i.effects,
    i.effects = null,
    o !== null)
        for (i = 0; i < o.length; i++) {
            var a = o[i]
              , _ = a.callback;
            if (_ !== null) {
                if (a.callback = null,
                a = s,
                typeof _ != "function")
                    throw Error(p$1(191, _));
                _.call(a)
            }
        }
}
var jh = new aa.Component().refs;
function kh(o, i, s, a) {
    i = o.memoizedState,
    s = s(a, i),
    s = s == null ? i : A$1({}, i, s),
    o.memoizedState = s,
    o.lanes === 0 && (o.updateQueue.baseState = s)
}
var nh = {
    isMounted: function(o) {
        return (o = o._reactInternals) ? Vb(o) === o : !1
    },
    enqueueSetState: function(o, i, s) {
        o = o._reactInternals;
        var a = L()
          , _ = lh(o)
          , $ = ch(a, _);
        $.payload = i,
        s != null && ($.callback = s),
        i = dh(o, $, _),
        i !== null && (mh(i, o, _, a),
        eh(i, o, _))
    },
    enqueueReplaceState: function(o, i, s) {
        o = o._reactInternals;
        var a = L()
          , _ = lh(o)
          , $ = ch(a, _);
        $.tag = 1,
        $.payload = i,
        s != null && ($.callback = s),
        i = dh(o, $, _),
        i !== null && (mh(i, o, _, a),
        eh(i, o, _))
    },
    enqueueForceUpdate: function(o, i) {
        o = o._reactInternals;
        var s = L()
          , a = lh(o)
          , _ = ch(s, a);
        _.tag = 2,
        i != null && (_.callback = i),
        i = dh(o, _, a),
        i !== null && (mh(i, o, a, s),
        eh(i, o, a))
    }
};
function oh(o, i, s, a, _, $, _e) {
    return o = o.stateNode,
    typeof o.shouldComponentUpdate == "function" ? o.shouldComponentUpdate(a, $, _e) : i.prototype && i.prototype.isPureReactComponent ? !Ie(s, a) || !Ie(_, $) : !0
}
function ph(o, i, s) {
    var a = !1
      , _ = Vf
      , $ = i.contextType;
    return typeof $ == "object" && $ !== null ? $ = Vg($) : (_ = Zf(i) ? Xf : H.current,
    a = i.contextTypes,
    $ = (a = a != null) ? Yf(o, _) : Vf),
    i = new i(s,$),
    o.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null,
    i.updater = nh,
    o.stateNode = i,
    i._reactInternals = o,
    a && (o = o.stateNode,
    o.__reactInternalMemoizedUnmaskedChildContext = _,
    o.__reactInternalMemoizedMaskedChildContext = $),
    i
}
function qh(o, i, s, a) {
    o = i.state,
    typeof i.componentWillReceiveProps == "function" && i.componentWillReceiveProps(s, a),
    typeof i.UNSAFE_componentWillReceiveProps == "function" && i.UNSAFE_componentWillReceiveProps(s, a),
    i.state !== o && nh.enqueueReplaceState(i, i.state, null)
}
function rh(o, i, s, a) {
    var _ = o.stateNode;
    _.props = s,
    _.state = o.memoizedState,
    _.refs = jh,
    ah(o);
    var $ = i.contextType;
    typeof $ == "object" && $ !== null ? _.context = Vg($) : ($ = Zf(i) ? Xf : H.current,
    _.context = Yf(o, $)),
    _.state = o.memoizedState,
    $ = i.getDerivedStateFromProps,
    typeof $ == "function" && (kh(o, i, $, s),
    _.state = o.memoizedState),
    typeof i.getDerivedStateFromProps == "function" || typeof _.getSnapshotBeforeUpdate == "function" || typeof _.UNSAFE_componentWillMount != "function" && typeof _.componentWillMount != "function" || (i = _.state,
    typeof _.componentWillMount == "function" && _.componentWillMount(),
    typeof _.UNSAFE_componentWillMount == "function" && _.UNSAFE_componentWillMount(),
    i !== _.state && nh.enqueueReplaceState(_, _.state, null),
    gh(o, s, _, a),
    _.state = o.memoizedState),
    typeof _.componentDidMount == "function" && (o.flags |= 4194308)
}
function sh(o, i, s) {
    if (o = s.ref,
    o !== null && typeof o != "function" && typeof o != "object") {
        if (s._owner) {
            if (s = s._owner,
            s) {
                if (s.tag !== 1)
                    throw Error(p$1(309));
                var a = s.stateNode
            }
            if (!a)
                throw Error(p$1(147, o));
            var _ = a
              , $ = "" + o;
            return i !== null && i.ref !== null && typeof i.ref == "function" && i.ref._stringRef === $ ? i.ref : (i = function(_e) {
                var tt = _.refs;
                tt === jh && (tt = _.refs = {}),
                _e === null ? delete tt[$] : tt[$] = _e
            }
            ,
            i._stringRef = $,
            i)
        }
        if (typeof o != "string")
            throw Error(p$1(284));
        if (!s._owner)
            throw Error(p$1(290, o))
    }
    return o
}
function th(o, i) {
    throw o = Object.prototype.toString.call(i),
    Error(p$1(31, o === "[object Object]" ? "object with keys {" + Object.keys(i).join(", ") + "}" : o))
}
function uh(o) {
    var i = o._init;
    return i(o._payload)
}
function vh(o) {
    function i(ct, ut) {
        if (o) {
            var dt = ct.deletions;
            dt === null ? (ct.deletions = [ut],
            ct.flags |= 16) : dt.push(ut)
        }
    }
    function s(ct, ut) {
        if (!o)
            return null;
        for (; ut !== null; )
            i(ct, ut),
            ut = ut.sibling;
        return null
    }
    function a(ct, ut) {
        for (ct = new Map; ut !== null; )
            ut.key !== null ? ct.set(ut.key, ut) : ct.set(ut.index, ut),
            ut = ut.sibling;
        return ct
    }
    function _(ct, ut) {
        return ct = wh(ct, ut),
        ct.index = 0,
        ct.sibling = null,
        ct
    }
    function $(ct, ut, dt) {
        return ct.index = dt,
        o ? (dt = ct.alternate,
        dt !== null ? (dt = dt.index,
        dt < ut ? (ct.flags |= 2,
        ut) : dt) : (ct.flags |= 2,
        ut)) : (ct.flags |= 1048576,
        ut)
    }
    function _e(ct) {
        return o && ct.alternate === null && (ct.flags |= 2),
        ct
    }
    function tt(ct, ut, dt, ft) {
        return ut === null || ut.tag !== 6 ? (ut = xh(dt, ct.mode, ft),
        ut.return = ct,
        ut) : (ut = _(ut, dt),
        ut.return = ct,
        ut)
    }
    function nt(ct, ut, dt, ft) {
        var ht = dt.type;
        return ht === ya ? ot(ct, ut, dt.props.children, ft, dt.key) : ut !== null && (ut.elementType === ht || typeof ht == "object" && ht !== null && ht.$$typeof === Ha && uh(ht) === ut.type) ? (ft = _(ut, dt.props),
        ft.ref = sh(ct, ut, dt),
        ft.return = ct,
        ft) : (ft = yh(dt.type, dt.key, dt.props, null, ct.mode, ft),
        ft.ref = sh(ct, ut, dt),
        ft.return = ct,
        ft)
    }
    function rt(ct, ut, dt, ft) {
        return ut === null || ut.tag !== 4 || ut.stateNode.containerInfo !== dt.containerInfo || ut.stateNode.implementation !== dt.implementation ? (ut = zh(dt, ct.mode, ft),
        ut.return = ct,
        ut) : (ut = _(ut, dt.children || []),
        ut.return = ct,
        ut)
    }
    function ot(ct, ut, dt, ft, ht) {
        return ut === null || ut.tag !== 7 ? (ut = Ah(dt, ct.mode, ft, ht),
        ut.return = ct,
        ut) : (ut = _(ut, dt),
        ut.return = ct,
        ut)
    }
    function et(ct, ut, dt) {
        if (typeof ut == "string" && ut !== "" || typeof ut == "number")
            return ut = xh("" + ut, ct.mode, dt),
            ut.return = ct,
            ut;
        if (typeof ut == "object" && ut !== null) {
            switch (ut.$$typeof) {
            case va:
                return dt = yh(ut.type, ut.key, ut.props, null, ct.mode, dt),
                dt.ref = sh(ct, null, ut),
                dt.return = ct,
                dt;
            case wa:
                return ut = zh(ut, ct.mode, dt),
                ut.return = ct,
                ut;
            case Ha:
                var ft = ut._init;
                return et(ct, ft(ut._payload), dt)
            }
            if (eb(ut) || Ka(ut))
                return ut = Ah(ut, ct.mode, dt, null),
                ut.return = ct,
                ut;
            th(ct, ut)
        }
        return null
    }
    function j(ct, ut, dt, ft) {
        var ht = ut !== null ? ut.key : null;
        if (typeof dt == "string" && dt !== "" || typeof dt == "number")
            return ht !== null ? null : tt(ct, ut, "" + dt, ft);
        if (typeof dt == "object" && dt !== null) {
            switch (dt.$$typeof) {
            case va:
                return dt.key === ht ? nt(ct, ut, dt, ft) : null;
            case wa:
                return dt.key === ht ? rt(ct, ut, dt, ft) : null;
            case Ha:
                return ht = dt._init,
                j(ct, ut, ht(dt._payload), ft)
            }
            if (eb(dt) || Ka(dt))
                return ht !== null ? null : ot(ct, ut, dt, ft, null);
            th(ct, dt)
        }
        return null
    }
    function it(ct, ut, dt, ft, ht) {
        if (typeof ft == "string" && ft !== "" || typeof ft == "number")
            return ct = ct.get(dt) || null,
            tt(ut, ct, "" + ft, ht);
        if (typeof ft == "object" && ft !== null) {
            switch (ft.$$typeof) {
            case va:
                return ct = ct.get(ft.key === null ? dt : ft.key) || null,
                nt(ut, ct, ft, ht);
            case wa:
                return ct = ct.get(ft.key === null ? dt : ft.key) || null,
                rt(ut, ct, ft, ht);
            case Ha:
                var pt = ft._init;
                return it(ct, ut, dt, pt(ft._payload), ht)
            }
            if (eb(ft) || Ka(ft))
                return ct = ct.get(dt) || null,
                ot(ut, ct, ft, ht, null);
            th(ut, ft)
        }
        return null
    }
    function st(ct, ut, dt, ft) {
        for (var ht = null, pt = null, gt = ut, _t = ut = 0, mt = null; gt !== null && _t < dt.length; _t++) {
            gt.index > _t ? (mt = gt,
            gt = null) : mt = gt.sibling;
            var yt = j(ct, gt, dt[_t], ft);
            if (yt === null) {
                gt === null && (gt = mt);
                break
            }
            o && gt && yt.alternate === null && i(ct, gt),
            ut = $(yt, ut, _t),
            pt === null ? ht = yt : pt.sibling = yt,
            pt = yt,
            gt = mt
        }
        if (_t === dt.length)
            return s(ct, gt),
            I && tg(ct, _t),
            ht;
        if (gt === null) {
            for (; _t < dt.length; _t++)
                gt = et(ct, dt[_t], ft),
                gt !== null && (ut = $(gt, ut, _t),
                pt === null ? ht = gt : pt.sibling = gt,
                pt = gt);
            return I && tg(ct, _t),
            ht
        }
        for (gt = a(ct, gt); _t < dt.length; _t++)
            mt = it(gt, ct, _t, dt[_t], ft),
            mt !== null && (o && mt.alternate !== null && gt.delete(mt.key === null ? _t : mt.key),
            ut = $(mt, ut, _t),
            pt === null ? ht = mt : pt.sibling = mt,
            pt = mt);
        return o && gt.forEach(function(bt) {
            return i(ct, bt)
        }),
        I && tg(ct, _t),
        ht
    }
    function at(ct, ut, dt, ft) {
        var ht = Ka(dt);
        if (typeof ht != "function")
            throw Error(p$1(150));
        if (dt = ht.call(dt),
        dt == null)
            throw Error(p$1(151));
        for (var pt = ht = null, gt = ut, _t = ut = 0, mt = null, yt = dt.next(); gt !== null && !yt.done; _t++,
        yt = dt.next()) {
            gt.index > _t ? (mt = gt,
            gt = null) : mt = gt.sibling;
            var bt = j(ct, gt, yt.value, ft);
            if (bt === null) {
                gt === null && (gt = mt);
                break
            }
            o && gt && bt.alternate === null && i(ct, gt),
            ut = $(bt, ut, _t),
            pt === null ? ht = bt : pt.sibling = bt,
            pt = bt,
            gt = mt
        }
        if (yt.done)
            return s(ct, gt),
            I && tg(ct, _t),
            ht;
        if (gt === null) {
            for (; !yt.done; _t++,
            yt = dt.next())
                yt = et(ct, yt.value, ft),
                yt !== null && (ut = $(yt, ut, _t),
                pt === null ? ht = yt : pt.sibling = yt,
                pt = yt);
            return I && tg(ct, _t),
            ht
        }
        for (gt = a(ct, gt); !yt.done; _t++,
        yt = dt.next())
            yt = it(gt, ct, _t, yt.value, ft),
            yt !== null && (o && yt.alternate !== null && gt.delete(yt.key === null ? _t : yt.key),
            ut = $(yt, ut, _t),
            pt === null ? ht = yt : pt.sibling = yt,
            pt = yt);
        return o && gt.forEach(function(vt) {
            return i(ct, vt)
        }),
        I && tg(ct, _t),
        ht
    }
    function lt(ct, ut, dt, ft) {
        if (typeof dt == "object" && dt !== null && dt.type === ya && dt.key === null && (dt = dt.props.children),
        typeof dt == "object" && dt !== null) {
            switch (dt.$$typeof) {
            case va:
                e: {
                    for (var ht = dt.key, pt = ut; pt !== null; ) {
                        if (pt.key === ht) {
                            if (ht = dt.type,
                            ht === ya) {
                                if (pt.tag === 7) {
                                    s(ct, pt.sibling),
                                    ut = _(pt, dt.props.children),
                                    ut.return = ct,
                                    ct = ut;
                                    break e
                                }
                            } else if (pt.elementType === ht || typeof ht == "object" && ht !== null && ht.$$typeof === Ha && uh(ht) === pt.type) {
                                s(ct, pt.sibling),
                                ut = _(pt, dt.props),
                                ut.ref = sh(ct, pt, dt),
                                ut.return = ct,
                                ct = ut;
                                break e
                            }
                            s(ct, pt);
                            break
                        } else
                            i(ct, pt);
                        pt = pt.sibling
                    }
                    dt.type === ya ? (ut = Ah(dt.props.children, ct.mode, ft, dt.key),
                    ut.return = ct,
                    ct = ut) : (ft = yh(dt.type, dt.key, dt.props, null, ct.mode, ft),
                    ft.ref = sh(ct, ut, dt),
                    ft.return = ct,
                    ct = ft)
                }
                return _e(ct);
            case wa:
                e: {
                    for (pt = dt.key; ut !== null; ) {
                        if (ut.key === pt)
                            if (ut.tag === 4 && ut.stateNode.containerInfo === dt.containerInfo && ut.stateNode.implementation === dt.implementation) {
                                s(ct, ut.sibling),
                                ut = _(ut, dt.children || []),
                                ut.return = ct,
                                ct = ut;
                                break e
                            } else {
                                s(ct, ut);
                                break
                            }
                        else
                            i(ct, ut);
                        ut = ut.sibling
                    }
                    ut = zh(dt, ct.mode, ft),
                    ut.return = ct,
                    ct = ut
                }
                return _e(ct);
            case Ha:
                return pt = dt._init,
                lt(ct, ut, pt(dt._payload), ft)
            }
            if (eb(dt))
                return st(ct, ut, dt, ft);
            if (Ka(dt))
                return at(ct, ut, dt, ft);
            th(ct, dt)
        }
        return typeof dt == "string" && dt !== "" || typeof dt == "number" ? (dt = "" + dt,
        ut !== null && ut.tag === 6 ? (s(ct, ut.sibling),
        ut = _(ut, dt),
        ut.return = ct,
        ct = ut) : (s(ct, ut),
        ut = xh(dt, ct.mode, ft),
        ut.return = ct,
        ct = ut),
        _e(ct)) : s(ct, ut)
    }
    return lt
}
var Bh = vh(!0)
  , Ch = vh(!1)
  , Dh = {}
  , Eh = Uf(Dh)
  , Fh = Uf(Dh)
  , Gh = Uf(Dh);
function Hh(o) {
    if (o === Dh)
        throw Error(p$1(174));
    return o
}
function Ih(o, i) {
    switch (G(Gh, i),
    G(Fh, o),
    G(Eh, Dh),
    o = i.nodeType,
    o) {
    case 9:
    case 11:
        i = (i = i.documentElement) ? i.namespaceURI : lb(null, "");
        break;
    default:
        o = o === 8 ? i.parentNode : i,
        i = o.namespaceURI || null,
        o = o.tagName,
        i = lb(i, o)
    }
    E(Eh),
    G(Eh, i)
}
function Jh() {
    E(Eh),
    E(Fh),
    E(Gh)
}
function Kh(o) {
    Hh(Gh.current);
    var i = Hh(Eh.current)
      , s = lb(i, o.type);
    i !== s && (G(Fh, o),
    G(Eh, s))
}
function Lh(o) {
    Fh.current === o && (E(Eh),
    E(Fh))
}
var M = Uf(0);
function Mh(o) {
    for (var i = o; i !== null; ) {
        if (i.tag === 13) {
            var s = i.memoizedState;
            if (s !== null && (s = s.dehydrated,
            s === null || s.data === "$?" || s.data === "$!"))
                return i
        } else if (i.tag === 19 && i.memoizedProps.revealOrder !== void 0) {
            if (i.flags & 128)
                return i
        } else if (i.child !== null) {
            i.child.return = i,
            i = i.child;
            continue
        }
        if (i === o)
            break;
        for (; i.sibling === null; ) {
            if (i.return === null || i.return === o)
                return null;
            i = i.return
        }
        i.sibling.return = i.return,
        i = i.sibling
    }
    return null
}
var Nh = [];
function Oh() {
    for (var o = 0; o < Nh.length; o++)
        Nh[o]._workInProgressVersionPrimary = null;
    Nh.length = 0
}
var Ph = ua$1.ReactCurrentDispatcher
  , Qh = ua$1.ReactCurrentBatchConfig
  , Rh = 0
  , N = null
  , O = null
  , P = null
  , Sh = !1
  , Th = !1
  , Uh = 0
  , Vh = 0;
function Q() {
    throw Error(p$1(321))
}
function Wh(o, i) {
    if (i === null)
        return !1;
    for (var s = 0; s < i.length && s < o.length; s++)
        if (!He(o[s], i[s]))
            return !1;
    return !0
}
function Xh(o, i, s, a, _, $) {
    if (Rh = $,
    N = i,
    i.memoizedState = null,
    i.updateQueue = null,
    i.lanes = 0,
    Ph.current = o === null || o.memoizedState === null ? Yh : Zh,
    o = s(a, _),
    Th) {
        $ = 0;
        do {
            if (Th = !1,
            Uh = 0,
            25 <= $)
                throw Error(p$1(301));
            $ += 1,
            P = O = null,
            i.updateQueue = null,
            Ph.current = $h,
            o = s(a, _)
        } while (Th)
    }
    if (Ph.current = ai,
    i = O !== null && O.next !== null,
    Rh = 0,
    P = O = N = null,
    Sh = !1,
    i)
        throw Error(p$1(300));
    return o
}
function bi() {
    var o = Uh !== 0;
    return Uh = 0,
    o
}
function ci() {
    var o = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return P === null ? N.memoizedState = P = o : P = P.next = o,
    P
}
function di() {
    if (O === null) {
        var o = N.alternate;
        o = o !== null ? o.memoizedState : null
    } else
        o = O.next;
    var i = P === null ? N.memoizedState : P.next;
    if (i !== null)
        P = i,
        O = o;
    else {
        if (o === null)
            throw Error(p$1(310));
        O = o,
        o = {
            memoizedState: O.memoizedState,
            baseState: O.baseState,
            baseQueue: O.baseQueue,
            queue: O.queue,
            next: null
        },
        P === null ? N.memoizedState = P = o : P = P.next = o
    }
    return P
}
function ei(o, i) {
    return typeof i == "function" ? i(o) : i
}
function fi(o) {
    var i = di()
      , s = i.queue;
    if (s === null)
        throw Error(p$1(311));
    s.lastRenderedReducer = o;
    var a = O
      , _ = a.baseQueue
      , $ = s.pending;
    if ($ !== null) {
        if (_ !== null) {
            var _e = _.next;
            _.next = $.next,
            $.next = _e
        }
        a.baseQueue = _ = $,
        s.pending = null
    }
    if (_ !== null) {
        $ = _.next,
        a = a.baseState;
        var tt = _e = null
          , nt = null
          , rt = $;
        do {
            var ot = rt.lane;
            if ((Rh & ot) === ot)
                nt !== null && (nt = nt.next = {
                    lane: 0,
                    action: rt.action,
                    hasEagerState: rt.hasEagerState,
                    eagerState: rt.eagerState,
                    next: null
                }),
                a = rt.hasEagerState ? rt.eagerState : o(a, rt.action);
            else {
                var et = {
                    lane: ot,
                    action: rt.action,
                    hasEagerState: rt.hasEagerState,
                    eagerState: rt.eagerState,
                    next: null
                };
                nt === null ? (tt = nt = et,
                _e = a) : nt = nt.next = et,
                N.lanes |= ot,
                hh |= ot
            }
            rt = rt.next
        } while (rt !== null && rt !== $);
        nt === null ? _e = a : nt.next = tt,
        He(a, i.memoizedState) || (Ug = !0),
        i.memoizedState = a,
        i.baseState = _e,
        i.baseQueue = nt,
        s.lastRenderedState = a
    }
    if (o = s.interleaved,
    o !== null) {
        _ = o;
        do
            $ = _.lane,
            N.lanes |= $,
            hh |= $,
            _ = _.next;
        while (_ !== o)
    } else
        _ === null && (s.lanes = 0);
    return [i.memoizedState, s.dispatch]
}
function gi(o) {
    var i = di()
      , s = i.queue;
    if (s === null)
        throw Error(p$1(311));
    s.lastRenderedReducer = o;
    var a = s.dispatch
      , _ = s.pending
      , $ = i.memoizedState;
    if (_ !== null) {
        s.pending = null;
        var _e = _ = _.next;
        do
            $ = o($, _e.action),
            _e = _e.next;
        while (_e !== _);
        He($, i.memoizedState) || (Ug = !0),
        i.memoizedState = $,
        i.baseQueue === null && (i.baseState = $),
        s.lastRenderedState = $
    }
    return [$, a]
}
function hi() {}
function ii(o, i) {
    var s = N
      , a = di()
      , _ = i()
      , $ = !He(a.memoizedState, _);
    if ($ && (a.memoizedState = _,
    Ug = !0),
    a = a.queue,
    ji(ki.bind(null, s, a, o), [o]),
    a.getSnapshot !== i || $ || P !== null && P.memoizedState.tag & 1) {
        if (s.flags |= 2048,
        li(9, mi.bind(null, s, a, _, i), void 0, null),
        R === null)
            throw Error(p$1(349));
        Rh & 30 || ni(s, i, _)
    }
    return _
}
function ni(o, i, s) {
    o.flags |= 16384,
    o = {
        getSnapshot: i,
        value: s
    },
    i = N.updateQueue,
    i === null ? (i = {
        lastEffect: null,
        stores: null
    },
    N.updateQueue = i,
    i.stores = [o]) : (s = i.stores,
    s === null ? i.stores = [o] : s.push(o))
}
function mi(o, i, s, a) {
    i.value = s,
    i.getSnapshot = a,
    oi(i) && pi(o)
}
function ki(o, i, s) {
    return s(function() {
        oi(i) && pi(o)
    })
}
function oi(o) {
    var i = o.getSnapshot;
    o = o.value;
    try {
        var s = i();
        return !He(o, s)
    } catch {
        return !0
    }
}
function pi(o) {
    var i = Zg(o, 1);
    i !== null && mh(i, o, 1, -1)
}
function qi(o) {
    var i = ci();
    return typeof o == "function" && (o = o()),
    i.memoizedState = i.baseState = o,
    o = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: ei,
        lastRenderedState: o
    },
    i.queue = o,
    o = o.dispatch = ri.bind(null, N, o),
    [i.memoizedState, o]
}
function li(o, i, s, a) {
    return o = {
        tag: o,
        create: i,
        destroy: s,
        deps: a,
        next: null
    },
    i = N.updateQueue,
    i === null ? (i = {
        lastEffect: null,
        stores: null
    },
    N.updateQueue = i,
    i.lastEffect = o.next = o) : (s = i.lastEffect,
    s === null ? i.lastEffect = o.next = o : (a = s.next,
    s.next = o,
    o.next = a,
    i.lastEffect = o)),
    o
}
function si() {
    return di().memoizedState
}
function ti(o, i, s, a) {
    var _ = ci();
    N.flags |= o,
    _.memoizedState = li(1 | i, s, void 0, a === void 0 ? null : a)
}
function ui(o, i, s, a) {
    var _ = di();
    a = a === void 0 ? null : a;
    var $ = void 0;
    if (O !== null) {
        var _e = O.memoizedState;
        if ($ = _e.destroy,
        a !== null && Wh(a, _e.deps)) {
            _.memoizedState = li(i, s, $, a);
            return
        }
    }
    N.flags |= o,
    _.memoizedState = li(1 | i, s, $, a)
}
function vi(o, i) {
    return ti(8390656, 8, o, i)
}
function ji(o, i) {
    return ui(2048, 8, o, i)
}
function wi(o, i) {
    return ui(4, 2, o, i)
}
function xi(o, i) {
    return ui(4, 4, o, i)
}
function yi(o, i) {
    if (typeof i == "function")
        return o = o(),
        i(o),
        function() {
            i(null)
        }
        ;
    if (i != null)
        return o = o(),
        i.current = o,
        function() {
            i.current = null
        }
}
function zi(o, i, s) {
    return s = s != null ? s.concat([o]) : null,
    ui(4, 4, yi.bind(null, i, o), s)
}
function Ai() {}
function Bi(o, i) {
    var s = di();
    i = i === void 0 ? null : i;
    var a = s.memoizedState;
    return a !== null && i !== null && Wh(i, a[1]) ? a[0] : (s.memoizedState = [o, i],
    o)
}
function Ci(o, i) {
    var s = di();
    i = i === void 0 ? null : i;
    var a = s.memoizedState;
    return a !== null && i !== null && Wh(i, a[1]) ? a[0] : (o = o(),
    s.memoizedState = [o, i],
    o)
}
function Di(o, i, s) {
    return Rh & 21 ? (He(s, i) || (s = yc(),
    N.lanes |= s,
    hh |= s,
    o.baseState = !0),
    i) : (o.baseState && (o.baseState = !1,
    Ug = !0),
    o.memoizedState = s)
}
function Ei(o, i) {
    var s = C;
    C = s !== 0 && 4 > s ? s : 4,
    o(!0);
    var a = Qh.transition;
    Qh.transition = {};
    try {
        o(!1),
        i()
    } finally {
        C = s,
        Qh.transition = a
    }
}
function Fi() {
    return di().memoizedState
}
function Gi(o, i, s) {
    var a = lh(o);
    if (s = {
        lane: a,
        action: s,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    Hi(o))
        Ii(i, s);
    else if (s = Yg(o, i, s, a),
    s !== null) {
        var _ = L();
        mh(s, o, a, _),
        Ji(s, i, a)
    }
}
function ri(o, i, s) {
    var a = lh(o)
      , _ = {
        lane: a,
        action: s,
        hasEagerState: !1,
        eagerState: null,
        next: null
    };
    if (Hi(o))
        Ii(i, _);
    else {
        var $ = o.alternate;
        if (o.lanes === 0 && ($ === null || $.lanes === 0) && ($ = i.lastRenderedReducer,
        $ !== null))
            try {
                var _e = i.lastRenderedState
                  , tt = $(_e, s);
                if (_.hasEagerState = !0,
                _.eagerState = tt,
                He(tt, _e)) {
                    var nt = i.interleaved;
                    nt === null ? (_.next = _,
                    Xg(i)) : (_.next = nt.next,
                    nt.next = _),
                    i.interleaved = _;
                    return
                }
            } catch {} finally {}
        s = Yg(o, i, _, a),
        s !== null && (_ = L(),
        mh(s, o, a, _),
        Ji(s, i, a))
    }
}
function Hi(o) {
    var i = o.alternate;
    return o === N || i !== null && i === N
}
function Ii(o, i) {
    Th = Sh = !0;
    var s = o.pending;
    s === null ? i.next = i : (i.next = s.next,
    s.next = i),
    o.pending = i
}
function Ji(o, i, s) {
    if (s & 4194240) {
        var a = i.lanes;
        a &= o.pendingLanes,
        s |= a,
        i.lanes = s,
        Cc(o, s)
    }
}
var ai = {
    readContext: Vg,
    useCallback: Q,
    useContext: Q,
    useEffect: Q,
    useImperativeHandle: Q,
    useInsertionEffect: Q,
    useLayoutEffect: Q,
    useMemo: Q,
    useReducer: Q,
    useRef: Q,
    useState: Q,
    useDebugValue: Q,
    useDeferredValue: Q,
    useTransition: Q,
    useMutableSource: Q,
    useSyncExternalStore: Q,
    useId: Q,
    unstable_isNewReconciler: !1
}
  , Yh = {
    readContext: Vg,
    useCallback: function(o, i) {
        return ci().memoizedState = [o, i === void 0 ? null : i],
        o
    },
    useContext: Vg,
    useEffect: vi,
    useImperativeHandle: function(o, i, s) {
        return s = s != null ? s.concat([o]) : null,
        ti(4194308, 4, yi.bind(null, i, o), s)
    },
    useLayoutEffect: function(o, i) {
        return ti(4194308, 4, o, i)
    },
    useInsertionEffect: function(o, i) {
        return ti(4, 2, o, i)
    },
    useMemo: function(o, i) {
        var s = ci();
        return i = i === void 0 ? null : i,
        o = o(),
        s.memoizedState = [o, i],
        o
    },
    useReducer: function(o, i, s) {
        var a = ci();
        return i = s !== void 0 ? s(i) : i,
        a.memoizedState = a.baseState = i,
        o = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: o,
            lastRenderedState: i
        },
        a.queue = o,
        o = o.dispatch = Gi.bind(null, N, o),
        [a.memoizedState, o]
    },
    useRef: function(o) {
        var i = ci();
        return o = {
            current: o
        },
        i.memoizedState = o
    },
    useState: qi,
    useDebugValue: Ai,
    useDeferredValue: function(o) {
        return ci().memoizedState = o
    },
    useTransition: function() {
        var o = qi(!1)
          , i = o[0];
        return o = Ei.bind(null, o[1]),
        ci().memoizedState = o,
        [i, o]
    },
    useMutableSource: function() {},
    useSyncExternalStore: function(o, i, s) {
        var a = N
          , _ = ci();
        if (I) {
            if (s === void 0)
                throw Error(p$1(407));
            s = s()
        } else {
            if (s = i(),
            R === null)
                throw Error(p$1(349));
            Rh & 30 || ni(a, i, s)
        }
        _.memoizedState = s;
        var $ = {
            value: s,
            getSnapshot: i
        };
        return _.queue = $,
        vi(ki.bind(null, a, $, o), [o]),
        a.flags |= 2048,
        li(9, mi.bind(null, a, $, s, i), void 0, null),
        s
    },
    useId: function() {
        var o = ci()
          , i = R.identifierPrefix;
        if (I) {
            var s = sg
              , a = rg;
            s = (a & ~(1 << 32 - oc(a) - 1)).toString(32) + s,
            i = ":" + i + "R" + s,
            s = Uh++,
            0 < s && (i += "H" + s.toString(32)),
            i += ":"
        } else
            s = Vh++,
            i = ":" + i + "r" + s.toString(32) + ":";
        return o.memoizedState = i
    },
    unstable_isNewReconciler: !1
}
  , Zh = {
    readContext: Vg,
    useCallback: Bi,
    useContext: Vg,
    useEffect: ji,
    useImperativeHandle: zi,
    useInsertionEffect: wi,
    useLayoutEffect: xi,
    useMemo: Ci,
    useReducer: fi,
    useRef: si,
    useState: function() {
        return fi(ei)
    },
    useDebugValue: Ai,
    useDeferredValue: function(o) {
        var i = di();
        return Di(i, O.memoizedState, o)
    },
    useTransition: function() {
        var o = fi(ei)[0]
          , i = di().memoizedState;
        return [o, i]
    },
    useMutableSource: hi,
    useSyncExternalStore: ii,
    useId: Fi,
    unstable_isNewReconciler: !1
}
  , $h = {
    readContext: Vg,
    useCallback: Bi,
    useContext: Vg,
    useEffect: ji,
    useImperativeHandle: zi,
    useInsertionEffect: wi,
    useLayoutEffect: xi,
    useMemo: Ci,
    useReducer: gi,
    useRef: si,
    useState: function() {
        return gi(ei)
    },
    useDebugValue: Ai,
    useDeferredValue: function(o) {
        var i = di();
        return O === null ? i.memoizedState = o : Di(i, O.memoizedState, o)
    },
    useTransition: function() {
        var o = gi(ei)[0]
          , i = di().memoizedState;
        return [o, i]
    },
    useMutableSource: hi,
    useSyncExternalStore: ii,
    useId: Fi,
    unstable_isNewReconciler: !1
};
function Ki(o, i) {
    try {
        var s = ""
          , a = i;
        do
            s += Pa(a),
            a = a.return;
        while (a);
        var _ = s
    } catch ($) {
        _ = `
Error generating stack: ` + $.message + `
` + $.stack
    }
    return {
        value: o,
        source: i,
        stack: _,
        digest: null
    }
}
function Li(o, i, s) {
    return {
        value: o,
        source: null,
        stack: s ?? null,
        digest: i ?? null
    }
}
function Mi(o, i) {
    try {
        console.error(i.value)
    } catch (s) {
        setTimeout(function() {
            throw s
        })
    }
}
var Ni = typeof WeakMap == "function" ? WeakMap : Map;
function Oi(o, i, s) {
    s = ch(-1, s),
    s.tag = 3,
    s.payload = {
        element: null
    };
    var a = i.value;
    return s.callback = function() {
        Pi || (Pi = !0,
        Qi = a),
        Mi(o, i)
    }
    ,
    s
}
function Ri(o, i, s) {
    s = ch(-1, s),
    s.tag = 3;
    var a = o.type.getDerivedStateFromError;
    if (typeof a == "function") {
        var _ = i.value;
        s.payload = function() {
            return a(_)
        }
        ,
        s.callback = function() {
            Mi(o, i)
        }
    }
    var $ = o.stateNode;
    return $ !== null && typeof $.componentDidCatch == "function" && (s.callback = function() {
        Mi(o, i),
        typeof a != "function" && (Si === null ? Si = new Set([this]) : Si.add(this));
        var _e = i.stack;
        this.componentDidCatch(i.value, {
            componentStack: _e !== null ? _e : ""
        })
    }
    ),
    s
}
function Ti(o, i, s) {
    var a = o.pingCache;
    if (a === null) {
        a = o.pingCache = new Ni;
        var _ = new Set;
        a.set(i, _)
    } else
        _ = a.get(i),
        _ === void 0 && (_ = new Set,
        a.set(i, _));
    _.has(s) || (_.add(s),
    o = Ui.bind(null, o, i, s),
    i.then(o, o))
}
function Vi(o) {
    do {
        var i;
        if ((i = o.tag === 13) && (i = o.memoizedState,
        i = i !== null ? i.dehydrated !== null : !0),
        i)
            return o;
        o = o.return
    } while (o !== null);
    return null
}
function Wi(o, i, s, a, _) {
    return o.mode & 1 ? (o.flags |= 65536,
    o.lanes = _,
    o) : (o === i ? o.flags |= 65536 : (o.flags |= 128,
    s.flags |= 131072,
    s.flags &= -52805,
    s.tag === 1 && (s.alternate === null ? s.tag = 17 : (i = ch(-1, 1),
    i.tag = 2,
    dh(s, i, 1))),
    s.lanes |= 1),
    o)
}
var Xi = ua$1.ReactCurrentOwner
  , Ug = !1;
function Yi(o, i, s, a) {
    i.child = o === null ? Ch(i, null, s, a) : Bh(i, o.child, s, a)
}
function Zi(o, i, s, a, _) {
    s = s.render;
    var $ = i.ref;
    return Tg(i, _),
    a = Xh(o, i, s, a, $, _),
    s = bi(),
    o !== null && !Ug ? (i.updateQueue = o.updateQueue,
    i.flags &= -2053,
    o.lanes &= ~_,
    $i(o, i, _)) : (I && s && vg(i),
    i.flags |= 1,
    Yi(o, i, a, _),
    i.child)
}
function aj(o, i, s, a, _) {
    if (o === null) {
        var $ = s.type;
        return typeof $ == "function" && !bj($) && $.defaultProps === void 0 && s.compare === null && s.defaultProps === void 0 ? (i.tag = 15,
        i.type = $,
        cj(o, i, $, a, _)) : (o = yh(s.type, null, a, i, i.mode, _),
        o.ref = i.ref,
        o.return = i,
        i.child = o)
    }
    if ($ = o.child,
    !(o.lanes & _)) {
        var _e = $.memoizedProps;
        if (s = s.compare,
        s = s !== null ? s : Ie,
        s(_e, a) && o.ref === i.ref)
            return $i(o, i, _)
    }
    return i.flags |= 1,
    o = wh($, a),
    o.ref = i.ref,
    o.return = i,
    i.child = o
}
function cj(o, i, s, a, _) {
    if (o !== null) {
        var $ = o.memoizedProps;
        if (Ie($, a) && o.ref === i.ref)
            if (Ug = !1,
            i.pendingProps = a = $,
            (o.lanes & _) !== 0)
                o.flags & 131072 && (Ug = !0);
            else
                return i.lanes = o.lanes,
                $i(o, i, _)
    }
    return dj(o, i, s, a, _)
}
function ej(o, i, s) {
    var a = i.pendingProps
      , _ = a.children
      , $ = o !== null ? o.memoizedState : null;
    if (a.mode === "hidden")
        if (!(i.mode & 1))
            i.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            G(fj, gj),
            gj |= s;
        else {
            if (!(s & 1073741824))
                return o = $ !== null ? $.baseLanes | s : s,
                i.lanes = i.childLanes = 1073741824,
                i.memoizedState = {
                    baseLanes: o,
                    cachePool: null,
                    transitions: null
                },
                i.updateQueue = null,
                G(fj, gj),
                gj |= o,
                null;
            i.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            a = $ !== null ? $.baseLanes : s,
            G(fj, gj),
            gj |= a
        }
    else
        $ !== null ? (a = $.baseLanes | s,
        i.memoizedState = null) : a = s,
        G(fj, gj),
        gj |= a;
    return Yi(o, i, _, s),
    i.child
}
function hj(o, i) {
    var s = i.ref;
    (o === null && s !== null || o !== null && o.ref !== s) && (i.flags |= 512,
    i.flags |= 2097152)
}
function dj(o, i, s, a, _) {
    var $ = Zf(s) ? Xf : H.current;
    return $ = Yf(i, $),
    Tg(i, _),
    s = Xh(o, i, s, a, $, _),
    a = bi(),
    o !== null && !Ug ? (i.updateQueue = o.updateQueue,
    i.flags &= -2053,
    o.lanes &= ~_,
    $i(o, i, _)) : (I && a && vg(i),
    i.flags |= 1,
    Yi(o, i, s, _),
    i.child)
}
function ij(o, i, s, a, _) {
    if (Zf(s)) {
        var $ = !0;
        cg(i)
    } else
        $ = !1;
    if (Tg(i, _),
    i.stateNode === null)
        jj(o, i),
        ph(i, s, a),
        rh(i, s, a, _),
        a = !0;
    else if (o === null) {
        var _e = i.stateNode
          , tt = i.memoizedProps;
        _e.props = tt;
        var nt = _e.context
          , rt = s.contextType;
        typeof rt == "object" && rt !== null ? rt = Vg(rt) : (rt = Zf(s) ? Xf : H.current,
        rt = Yf(i, rt));
        var ot = s.getDerivedStateFromProps
          , et = typeof ot == "function" || typeof _e.getSnapshotBeforeUpdate == "function";
        et || typeof _e.UNSAFE_componentWillReceiveProps != "function" && typeof _e.componentWillReceiveProps != "function" || (tt !== a || nt !== rt) && qh(i, _e, a, rt),
        $g = !1;
        var j = i.memoizedState;
        _e.state = j,
        gh(i, a, _e, _),
        nt = i.memoizedState,
        tt !== a || j !== nt || Wf.current || $g ? (typeof ot == "function" && (kh(i, s, ot, a),
        nt = i.memoizedState),
        (tt = $g || oh(i, s, tt, a, j, nt, rt)) ? (et || typeof _e.UNSAFE_componentWillMount != "function" && typeof _e.componentWillMount != "function" || (typeof _e.componentWillMount == "function" && _e.componentWillMount(),
        typeof _e.UNSAFE_componentWillMount == "function" && _e.UNSAFE_componentWillMount()),
        typeof _e.componentDidMount == "function" && (i.flags |= 4194308)) : (typeof _e.componentDidMount == "function" && (i.flags |= 4194308),
        i.memoizedProps = a,
        i.memoizedState = nt),
        _e.props = a,
        _e.state = nt,
        _e.context = rt,
        a = tt) : (typeof _e.componentDidMount == "function" && (i.flags |= 4194308),
        a = !1)
    } else {
        _e = i.stateNode,
        bh(o, i),
        tt = i.memoizedProps,
        rt = i.type === i.elementType ? tt : Lg(i.type, tt),
        _e.props = rt,
        et = i.pendingProps,
        j = _e.context,
        nt = s.contextType,
        typeof nt == "object" && nt !== null ? nt = Vg(nt) : (nt = Zf(s) ? Xf : H.current,
        nt = Yf(i, nt));
        var it = s.getDerivedStateFromProps;
        (ot = typeof it == "function" || typeof _e.getSnapshotBeforeUpdate == "function") || typeof _e.UNSAFE_componentWillReceiveProps != "function" && typeof _e.componentWillReceiveProps != "function" || (tt !== et || j !== nt) && qh(i, _e, a, nt),
        $g = !1,
        j = i.memoizedState,
        _e.state = j,
        gh(i, a, _e, _);
        var st = i.memoizedState;
        tt !== et || j !== st || Wf.current || $g ? (typeof it == "function" && (kh(i, s, it, a),
        st = i.memoizedState),
        (rt = $g || oh(i, s, rt, a, j, st, nt) || !1) ? (ot || typeof _e.UNSAFE_componentWillUpdate != "function" && typeof _e.componentWillUpdate != "function" || (typeof _e.componentWillUpdate == "function" && _e.componentWillUpdate(a, st, nt),
        typeof _e.UNSAFE_componentWillUpdate == "function" && _e.UNSAFE_componentWillUpdate(a, st, nt)),
        typeof _e.componentDidUpdate == "function" && (i.flags |= 4),
        typeof _e.getSnapshotBeforeUpdate == "function" && (i.flags |= 1024)) : (typeof _e.componentDidUpdate != "function" || tt === o.memoizedProps && j === o.memoizedState || (i.flags |= 4),
        typeof _e.getSnapshotBeforeUpdate != "function" || tt === o.memoizedProps && j === o.memoizedState || (i.flags |= 1024),
        i.memoizedProps = a,
        i.memoizedState = st),
        _e.props = a,
        _e.state = st,
        _e.context = nt,
        a = rt) : (typeof _e.componentDidUpdate != "function" || tt === o.memoizedProps && j === o.memoizedState || (i.flags |= 4),
        typeof _e.getSnapshotBeforeUpdate != "function" || tt === o.memoizedProps && j === o.memoizedState || (i.flags |= 1024),
        a = !1)
    }
    return kj(o, i, s, a, $, _)
}
function kj(o, i, s, a, _, $) {
    hj(o, i);
    var _e = (i.flags & 128) !== 0;
    if (!a && !_e)
        return _ && dg(i, s, !1),
        $i(o, i, $);
    a = i.stateNode,
    Xi.current = i;
    var tt = _e && typeof s.getDerivedStateFromError != "function" ? null : a.render();
    return i.flags |= 1,
    o !== null && _e ? (i.child = Bh(i, o.child, null, $),
    i.child = Bh(i, null, tt, $)) : Yi(o, i, tt, $),
    i.memoizedState = a.state,
    _ && dg(i, s, !0),
    i.child
}
function lj(o) {
    var i = o.stateNode;
    i.pendingContext ? ag(o, i.pendingContext, i.pendingContext !== i.context) : i.context && ag(o, i.context, !1),
    Ih(o, i.containerInfo)
}
function mj(o, i, s, a, _) {
    return Ig(),
    Jg(_),
    i.flags |= 256,
    Yi(o, i, s, a),
    i.child
}
var nj = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};
function oj(o) {
    return {
        baseLanes: o,
        cachePool: null,
        transitions: null
    }
}
function pj(o, i, s) {
    var a = i.pendingProps, _ = M.current, $ = !1, _e = (i.flags & 128) !== 0, tt;
    if ((tt = _e) || (tt = o !== null && o.memoizedState === null ? !1 : (_ & 2) !== 0),
    tt ? ($ = !0,
    i.flags &= -129) : (o === null || o.memoizedState !== null) && (_ |= 1),
    G(M, _ & 1),
    o === null)
        return Eg(i),
        o = i.memoizedState,
        o !== null && (o = o.dehydrated,
        o !== null) ? (i.mode & 1 ? o.data === "$!" ? i.lanes = 8 : i.lanes = 1073741824 : i.lanes = 1,
        null) : (_e = a.children,
        o = a.fallback,
        $ ? (a = i.mode,
        $ = i.child,
        _e = {
            mode: "hidden",
            children: _e
        },
        !(a & 1) && $ !== null ? ($.childLanes = 0,
        $.pendingProps = _e) : $ = qj(_e, a, 0, null),
        o = Ah(o, a, s, null),
        $.return = i,
        o.return = i,
        $.sibling = o,
        i.child = $,
        i.child.memoizedState = oj(s),
        i.memoizedState = nj,
        o) : rj(i, _e));
    if (_ = o.memoizedState,
    _ !== null && (tt = _.dehydrated,
    tt !== null))
        return sj(o, i, _e, a, tt, _, s);
    if ($) {
        $ = a.fallback,
        _e = i.mode,
        _ = o.child,
        tt = _.sibling;
        var nt = {
            mode: "hidden",
            children: a.children
        };
        return !(_e & 1) && i.child !== _ ? (a = i.child,
        a.childLanes = 0,
        a.pendingProps = nt,
        i.deletions = null) : (a = wh(_, nt),
        a.subtreeFlags = _.subtreeFlags & 14680064),
        tt !== null ? $ = wh(tt, $) : ($ = Ah($, _e, s, null),
        $.flags |= 2),
        $.return = i,
        a.return = i,
        a.sibling = $,
        i.child = a,
        a = $,
        $ = i.child,
        _e = o.child.memoizedState,
        _e = _e === null ? oj(s) : {
            baseLanes: _e.baseLanes | s,
            cachePool: null,
            transitions: _e.transitions
        },
        $.memoizedState = _e,
        $.childLanes = o.childLanes & ~s,
        i.memoizedState = nj,
        a
    }
    return $ = o.child,
    o = $.sibling,
    a = wh($, {
        mode: "visible",
        children: a.children
    }),
    !(i.mode & 1) && (a.lanes = s),
    a.return = i,
    a.sibling = null,
    o !== null && (s = i.deletions,
    s === null ? (i.deletions = [o],
    i.flags |= 16) : s.push(o)),
    i.child = a,
    i.memoizedState = null,
    a
}
function rj(o, i) {
    return i = qj({
        mode: "visible",
        children: i
    }, o.mode, 0, null),
    i.return = o,
    o.child = i
}
function tj(o, i, s, a) {
    return a !== null && Jg(a),
    Bh(i, o.child, null, s),
    o = rj(i, i.pendingProps.children),
    o.flags |= 2,
    i.memoizedState = null,
    o
}
function sj(o, i, s, a, _, $, _e) {
    if (s)
        return i.flags & 256 ? (i.flags &= -257,
        a = Li(Error(p$1(422))),
        tj(o, i, _e, a)) : i.memoizedState !== null ? (i.child = o.child,
        i.flags |= 128,
        null) : ($ = a.fallback,
        _ = i.mode,
        a = qj({
            mode: "visible",
            children: a.children
        }, _, 0, null),
        $ = Ah($, _, _e, null),
        $.flags |= 2,
        a.return = i,
        $.return = i,
        a.sibling = $,
        i.child = a,
        i.mode & 1 && Bh(i, o.child, null, _e),
        i.child.memoizedState = oj(_e),
        i.memoizedState = nj,
        $);
    if (!(i.mode & 1))
        return tj(o, i, _e, null);
    if (_.data === "$!") {
        if (a = _.nextSibling && _.nextSibling.dataset,
        a)
            var tt = a.dgst;
        return a = tt,
        $ = Error(p$1(419)),
        a = Li($, a, void 0),
        tj(o, i, _e, a)
    }
    if (tt = (_e & o.childLanes) !== 0,
    Ug || tt) {
        if (a = R,
        a !== null) {
            switch (_e & -_e) {
            case 4:
                _ = 2;
                break;
            case 16:
                _ = 8;
                break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                _ = 32;
                break;
            case 536870912:
                _ = 268435456;
                break;
            default:
                _ = 0
            }
            _ = _ & (a.suspendedLanes | _e) ? 0 : _,
            _ !== 0 && _ !== $.retryLane && ($.retryLane = _,
            Zg(o, _),
            mh(a, o, _, -1))
        }
        return uj(),
        a = Li(Error(p$1(421))),
        tj(o, i, _e, a)
    }
    return _.data === "$?" ? (i.flags |= 128,
    i.child = o.child,
    i = vj.bind(null, o),
    _._reactRetry = i,
    null) : (o = $.treeContext,
    yg = Lf(_.nextSibling),
    xg = i,
    I = !0,
    zg = null,
    o !== null && (og[pg++] = rg,
    og[pg++] = sg,
    og[pg++] = qg,
    rg = o.id,
    sg = o.overflow,
    qg = i),
    i = rj(i, a.children),
    i.flags |= 4096,
    i)
}
function wj(o, i, s) {
    o.lanes |= i;
    var a = o.alternate;
    a !== null && (a.lanes |= i),
    Sg(o.return, i, s)
}
function xj(o, i, s, a, _) {
    var $ = o.memoizedState;
    $ === null ? o.memoizedState = {
        isBackwards: i,
        rendering: null,
        renderingStartTime: 0,
        last: a,
        tail: s,
        tailMode: _
    } : ($.isBackwards = i,
    $.rendering = null,
    $.renderingStartTime = 0,
    $.last = a,
    $.tail = s,
    $.tailMode = _)
}
function yj(o, i, s) {
    var a = i.pendingProps
      , _ = a.revealOrder
      , $ = a.tail;
    if (Yi(o, i, a.children, s),
    a = M.current,
    a & 2)
        a = a & 1 | 2,
        i.flags |= 128;
    else {
        if (o !== null && o.flags & 128)
            e: for (o = i.child; o !== null; ) {
                if (o.tag === 13)
                    o.memoizedState !== null && wj(o, s, i);
                else if (o.tag === 19)
                    wj(o, s, i);
                else if (o.child !== null) {
                    o.child.return = o,
                    o = o.child;
                    continue
                }
                if (o === i)
                    break e;
                for (; o.sibling === null; ) {
                    if (o.return === null || o.return === i)
                        break e;
                    o = o.return
                }
                o.sibling.return = o.return,
                o = o.sibling
            }
        a &= 1
    }
    if (G(M, a),
    !(i.mode & 1))
        i.memoizedState = null;
    else
        switch (_) {
        case "forwards":
            for (s = i.child,
            _ = null; s !== null; )
                o = s.alternate,
                o !== null && Mh(o) === null && (_ = s),
                s = s.sibling;
            s = _,
            s === null ? (_ = i.child,
            i.child = null) : (_ = s.sibling,
            s.sibling = null),
            xj(i, !1, _, s, $);
            break;
        case "backwards":
            for (s = null,
            _ = i.child,
            i.child = null; _ !== null; ) {
                if (o = _.alternate,
                o !== null && Mh(o) === null) {
                    i.child = _;
                    break
                }
                o = _.sibling,
                _.sibling = s,
                s = _,
                _ = o
            }
            xj(i, !0, s, null, $);
            break;
        case "together":
            xj(i, !1, null, null, void 0);
            break;
        default:
            i.memoizedState = null
        }
    return i.child
}
function jj(o, i) {
    !(i.mode & 1) && o !== null && (o.alternate = null,
    i.alternate = null,
    i.flags |= 2)
}
function $i(o, i, s) {
    if (o !== null && (i.dependencies = o.dependencies),
    hh |= i.lanes,
    !(s & i.childLanes))
        return null;
    if (o !== null && i.child !== o.child)
        throw Error(p$1(153));
    if (i.child !== null) {
        for (o = i.child,
        s = wh(o, o.pendingProps),
        i.child = s,
        s.return = i; o.sibling !== null; )
            o = o.sibling,
            s = s.sibling = wh(o, o.pendingProps),
            s.return = i;
        s.sibling = null
    }
    return i.child
}
function zj(o, i, s) {
    switch (i.tag) {
    case 3:
        lj(i),
        Ig();
        break;
    case 5:
        Kh(i);
        break;
    case 1:
        Zf(i.type) && cg(i);
        break;
    case 4:
        Ih(i, i.stateNode.containerInfo);
        break;
    case 10:
        var a = i.type._context
          , _ = i.memoizedProps.value;
        G(Mg, a._currentValue),
        a._currentValue = _;
        break;
    case 13:
        if (a = i.memoizedState,
        a !== null)
            return a.dehydrated !== null ? (G(M, M.current & 1),
            i.flags |= 128,
            null) : s & i.child.childLanes ? pj(o, i, s) : (G(M, M.current & 1),
            o = $i(o, i, s),
            o !== null ? o.sibling : null);
        G(M, M.current & 1);
        break;
    case 19:
        if (a = (s & i.childLanes) !== 0,
        o.flags & 128) {
            if (a)
                return yj(o, i, s);
            i.flags |= 128
        }
        if (_ = i.memoizedState,
        _ !== null && (_.rendering = null,
        _.tail = null,
        _.lastEffect = null),
        G(M, M.current),
        a)
            break;
        return null;
    case 22:
    case 23:
        return i.lanes = 0,
        ej(o, i, s)
    }
    return $i(o, i, s)
}
var Aj, Bj, Cj, Dj;
Aj = function(o, i) {
    for (var s = i.child; s !== null; ) {
        if (s.tag === 5 || s.tag === 6)
            o.appendChild(s.stateNode);
        else if (s.tag !== 4 && s.child !== null) {
            s.child.return = s,
            s = s.child;
            continue
        }
        if (s === i)
            break;
        for (; s.sibling === null; ) {
            if (s.return === null || s.return === i)
                return;
            s = s.return
        }
        s.sibling.return = s.return,
        s = s.sibling
    }
}
;
Bj = function() {}
;
Cj = function(o, i, s, a) {
    var _ = o.memoizedProps;
    if (_ !== a) {
        o = i.stateNode,
        Hh(Eh.current);
        var $ = null;
        switch (s) {
        case "input":
            _ = Ya(o, _),
            a = Ya(o, a),
            $ = [];
            break;
        case "select":
            _ = A$1({}, _, {
                value: void 0
            }),
            a = A$1({}, a, {
                value: void 0
            }),
            $ = [];
            break;
        case "textarea":
            _ = gb(o, _),
            a = gb(o, a),
            $ = [];
            break;
        default:
            typeof _.onClick != "function" && typeof a.onClick == "function" && (o.onclick = Bf)
        }
        ub(s, a);
        var _e;
        s = null;
        for (rt in _)
            if (!a.hasOwnProperty(rt) && _.hasOwnProperty(rt) && _[rt] != null)
                if (rt === "style") {
                    var tt = _[rt];
                    for (_e in tt)
                        tt.hasOwnProperty(_e) && (s || (s = {}),
                        s[_e] = "")
                } else
                    rt !== "dangerouslySetInnerHTML" && rt !== "children" && rt !== "suppressContentEditableWarning" && rt !== "suppressHydrationWarning" && rt !== "autoFocus" && (ea.hasOwnProperty(rt) ? $ || ($ = []) : ($ = $ || []).push(rt, null));
        for (rt in a) {
            var nt = a[rt];
            if (tt = _ != null ? _[rt] : void 0,
            a.hasOwnProperty(rt) && nt !== tt && (nt != null || tt != null))
                if (rt === "style")
                    if (tt) {
                        for (_e in tt)
                            !tt.hasOwnProperty(_e) || nt && nt.hasOwnProperty(_e) || (s || (s = {}),
                            s[_e] = "");
                        for (_e in nt)
                            nt.hasOwnProperty(_e) && tt[_e] !== nt[_e] && (s || (s = {}),
                            s[_e] = nt[_e])
                    } else
                        s || ($ || ($ = []),
                        $.push(rt, s)),
                        s = nt;
                else
                    rt === "dangerouslySetInnerHTML" ? (nt = nt ? nt.__html : void 0,
                    tt = tt ? tt.__html : void 0,
                    nt != null && tt !== nt && ($ = $ || []).push(rt, nt)) : rt === "children" ? typeof nt != "string" && typeof nt != "number" || ($ = $ || []).push(rt, "" + nt) : rt !== "suppressContentEditableWarning" && rt !== "suppressHydrationWarning" && (ea.hasOwnProperty(rt) ? (nt != null && rt === "onScroll" && D("scroll", o),
                    $ || tt === nt || ($ = [])) : ($ = $ || []).push(rt, nt))
        }
        s && ($ = $ || []).push("style", s);
        var rt = $;
        (i.updateQueue = rt) && (i.flags |= 4)
    }
}
;
Dj = function(o, i, s, a) {
    s !== a && (i.flags |= 4)
}
;
function Ej(o, i) {
    if (!I)
        switch (o.tailMode) {
        case "hidden":
            i = o.tail;
            for (var s = null; i !== null; )
                i.alternate !== null && (s = i),
                i = i.sibling;
            s === null ? o.tail = null : s.sibling = null;
            break;
        case "collapsed":
            s = o.tail;
            for (var a = null; s !== null; )
                s.alternate !== null && (a = s),
                s = s.sibling;
            a === null ? i || o.tail === null ? o.tail = null : o.tail.sibling = null : a.sibling = null
        }
}
function S(o) {
    var i = o.alternate !== null && o.alternate.child === o.child
      , s = 0
      , a = 0;
    if (i)
        for (var _ = o.child; _ !== null; )
            s |= _.lanes | _.childLanes,
            a |= _.subtreeFlags & 14680064,
            a |= _.flags & 14680064,
            _.return = o,
            _ = _.sibling;
    else
        for (_ = o.child; _ !== null; )
            s |= _.lanes | _.childLanes,
            a |= _.subtreeFlags,
            a |= _.flags,
            _.return = o,
            _ = _.sibling;
    return o.subtreeFlags |= a,
    o.childLanes = s,
    i
}
function Fj(o, i, s) {
    var a = i.pendingProps;
    switch (wg(i),
    i.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
        return S(i),
        null;
    case 1:
        return Zf(i.type) && $f(),
        S(i),
        null;
    case 3:
        return a = i.stateNode,
        Jh(),
        E(Wf),
        E(H),
        Oh(),
        a.pendingContext && (a.context = a.pendingContext,
        a.pendingContext = null),
        (o === null || o.child === null) && (Gg(i) ? i.flags |= 4 : o === null || o.memoizedState.isDehydrated && !(i.flags & 256) || (i.flags |= 1024,
        zg !== null && (Gj(zg),
        zg = null))),
        Bj(o, i),
        S(i),
        null;
    case 5:
        Lh(i);
        var _ = Hh(Gh.current);
        if (s = i.type,
        o !== null && i.stateNode != null)
            Cj(o, i, s, a, _),
            o.ref !== i.ref && (i.flags |= 512,
            i.flags |= 2097152);
        else {
            if (!a) {
                if (i.stateNode === null)
                    throw Error(p$1(166));
                return S(i),
                null
            }
            if (o = Hh(Eh.current),
            Gg(i)) {
                a = i.stateNode,
                s = i.type;
                var $ = i.memoizedProps;
                switch (a[Of] = i,
                a[Pf] = $,
                o = (i.mode & 1) !== 0,
                s) {
                case "dialog":
                    D("cancel", a),
                    D("close", a);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    D("load", a);
                    break;
                case "video":
                case "audio":
                    for (_ = 0; _ < lf.length; _++)
                        D(lf[_], a);
                    break;
                case "source":
                    D("error", a);
                    break;
                case "img":
                case "image":
                case "link":
                    D("error", a),
                    D("load", a);
                    break;
                case "details":
                    D("toggle", a);
                    break;
                case "input":
                    Za(a, $),
                    D("invalid", a);
                    break;
                case "select":
                    a._wrapperState = {
                        wasMultiple: !!$.multiple
                    },
                    D("invalid", a);
                    break;
                case "textarea":
                    hb(a, $),
                    D("invalid", a)
                }
                ub(s, $),
                _ = null;
                for (var _e in $)
                    if ($.hasOwnProperty(_e)) {
                        var tt = $[_e];
                        _e === "children" ? typeof tt == "string" ? a.textContent !== tt && ($.suppressHydrationWarning !== !0 && Af(a.textContent, tt, o),
                        _ = ["children", tt]) : typeof tt == "number" && a.textContent !== "" + tt && ($.suppressHydrationWarning !== !0 && Af(a.textContent, tt, o),
                        _ = ["children", "" + tt]) : ea.hasOwnProperty(_e) && tt != null && _e === "onScroll" && D("scroll", a)
                    }
                switch (s) {
                case "input":
                    Va(a),
                    db(a, $, !0);
                    break;
                case "textarea":
                    Va(a),
                    jb(a);
                    break;
                case "select":
                case "option":
                    break;
                default:
                    typeof $.onClick == "function" && (a.onclick = Bf)
                }
                a = _,
                i.updateQueue = a,
                a !== null && (i.flags |= 4)
            } else {
                _e = _.nodeType === 9 ? _ : _.ownerDocument,
                o === "http://www.w3.org/1999/xhtml" && (o = kb(s)),
                o === "http://www.w3.org/1999/xhtml" ? s === "script" ? (o = _e.createElement("div"),
                o.innerHTML = "<script><\/script>",
                o = o.removeChild(o.firstChild)) : typeof a.is == "string" ? o = _e.createElement(s, {
                    is: a.is
                }) : (o = _e.createElement(s),
                s === "select" && (_e = o,
                a.multiple ? _e.multiple = !0 : a.size && (_e.size = a.size))) : o = _e.createElementNS(o, s),
                o[Of] = i,
                o[Pf] = a,
                Aj(o, i, !1, !1),
                i.stateNode = o;
                e: {
                    switch (_e = vb(s, a),
                    s) {
                    case "dialog":
                        D("cancel", o),
                        D("close", o),
                        _ = a;
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        D("load", o),
                        _ = a;
                        break;
                    case "video":
                    case "audio":
                        for (_ = 0; _ < lf.length; _++)
                            D(lf[_], o);
                        _ = a;
                        break;
                    case "source":
                        D("error", o),
                        _ = a;
                        break;
                    case "img":
                    case "image":
                    case "link":
                        D("error", o),
                        D("load", o),
                        _ = a;
                        break;
                    case "details":
                        D("toggle", o),
                        _ = a;
                        break;
                    case "input":
                        Za(o, a),
                        _ = Ya(o, a),
                        D("invalid", o);
                        break;
                    case "option":
                        _ = a;
                        break;
                    case "select":
                        o._wrapperState = {
                            wasMultiple: !!a.multiple
                        },
                        _ = A$1({}, a, {
                            value: void 0
                        }),
                        D("invalid", o);
                        break;
                    case "textarea":
                        hb(o, a),
                        _ = gb(o, a),
                        D("invalid", o);
                        break;
                    default:
                        _ = a
                    }
                    ub(s, _),
                    tt = _;
                    for ($ in tt)
                        if (tt.hasOwnProperty($)) {
                            var nt = tt[$];
                            $ === "style" ? sb(o, nt) : $ === "dangerouslySetInnerHTML" ? (nt = nt ? nt.__html : void 0,
                            nt != null && nb(o, nt)) : $ === "children" ? typeof nt == "string" ? (s !== "textarea" || nt !== "") && ob(o, nt) : typeof nt == "number" && ob(o, "" + nt) : $ !== "suppressContentEditableWarning" && $ !== "suppressHydrationWarning" && $ !== "autoFocus" && (ea.hasOwnProperty($) ? nt != null && $ === "onScroll" && D("scroll", o) : nt != null && ta(o, $, nt, _e))
                        }
                    switch (s) {
                    case "input":
                        Va(o),
                        db(o, a, !1);
                        break;
                    case "textarea":
                        Va(o),
                        jb(o);
                        break;
                    case "option":
                        a.value != null && o.setAttribute("value", "" + Sa(a.value));
                        break;
                    case "select":
                        o.multiple = !!a.multiple,
                        $ = a.value,
                        $ != null ? fb(o, !!a.multiple, $, !1) : a.defaultValue != null && fb(o, !!a.multiple, a.defaultValue, !0);
                        break;
                    default:
                        typeof _.onClick == "function" && (o.onclick = Bf)
                    }
                    switch (s) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        a = !!a.autoFocus;
                        break e;
                    case "img":
                        a = !0;
                        break e;
                    default:
                        a = !1
                    }
                }
                a && (i.flags |= 4)
            }
            i.ref !== null && (i.flags |= 512,
            i.flags |= 2097152)
        }
        return S(i),
        null;
    case 6:
        if (o && i.stateNode != null)
            Dj(o, i, o.memoizedProps, a);
        else {
            if (typeof a != "string" && i.stateNode === null)
                throw Error(p$1(166));
            if (s = Hh(Gh.current),
            Hh(Eh.current),
            Gg(i)) {
                if (a = i.stateNode,
                s = i.memoizedProps,
                a[Of] = i,
                ($ = a.nodeValue !== s) && (o = xg,
                o !== null))
                    switch (o.tag) {
                    case 3:
                        Af(a.nodeValue, s, (o.mode & 1) !== 0);
                        break;
                    case 5:
                        o.memoizedProps.suppressHydrationWarning !== !0 && Af(a.nodeValue, s, (o.mode & 1) !== 0)
                    }
                $ && (i.flags |= 4)
            } else
                a = (s.nodeType === 9 ? s : s.ownerDocument).createTextNode(a),
                a[Of] = i,
                i.stateNode = a
        }
        return S(i),
        null;
    case 13:
        if (E(M),
        a = i.memoizedState,
        o === null || o.memoizedState !== null && o.memoizedState.dehydrated !== null) {
            if (I && yg !== null && i.mode & 1 && !(i.flags & 128))
                Hg(),
                Ig(),
                i.flags |= 98560,
                $ = !1;
            else if ($ = Gg(i),
            a !== null && a.dehydrated !== null) {
                if (o === null) {
                    if (!$)
                        throw Error(p$1(318));
                    if ($ = i.memoizedState,
                    $ = $ !== null ? $.dehydrated : null,
                    !$)
                        throw Error(p$1(317));
                    $[Of] = i
                } else
                    Ig(),
                    !(i.flags & 128) && (i.memoizedState = null),
                    i.flags |= 4;
                S(i),
                $ = !1
            } else
                zg !== null && (Gj(zg),
                zg = null),
                $ = !0;
            if (!$)
                return i.flags & 65536 ? i : null
        }
        return i.flags & 128 ? (i.lanes = s,
        i) : (a = a !== null,
        a !== (o !== null && o.memoizedState !== null) && a && (i.child.flags |= 8192,
        i.mode & 1 && (o === null || M.current & 1 ? T === 0 && (T = 3) : uj())),
        i.updateQueue !== null && (i.flags |= 4),
        S(i),
        null);
    case 4:
        return Jh(),
        Bj(o, i),
        o === null && sf(i.stateNode.containerInfo),
        S(i),
        null;
    case 10:
        return Rg(i.type._context),
        S(i),
        null;
    case 17:
        return Zf(i.type) && $f(),
        S(i),
        null;
    case 19:
        if (E(M),
        $ = i.memoizedState,
        $ === null)
            return S(i),
            null;
        if (a = (i.flags & 128) !== 0,
        _e = $.rendering,
        _e === null)
            if (a)
                Ej($, !1);
            else {
                if (T !== 0 || o !== null && o.flags & 128)
                    for (o = i.child; o !== null; ) {
                        if (_e = Mh(o),
                        _e !== null) {
                            for (i.flags |= 128,
                            Ej($, !1),
                            a = _e.updateQueue,
                            a !== null && (i.updateQueue = a,
                            i.flags |= 4),
                            i.subtreeFlags = 0,
                            a = s,
                            s = i.child; s !== null; )
                                $ = s,
                                o = a,
                                $.flags &= 14680066,
                                _e = $.alternate,
                                _e === null ? ($.childLanes = 0,
                                $.lanes = o,
                                $.child = null,
                                $.subtreeFlags = 0,
                                $.memoizedProps = null,
                                $.memoizedState = null,
                                $.updateQueue = null,
                                $.dependencies = null,
                                $.stateNode = null) : ($.childLanes = _e.childLanes,
                                $.lanes = _e.lanes,
                                $.child = _e.child,
                                $.subtreeFlags = 0,
                                $.deletions = null,
                                $.memoizedProps = _e.memoizedProps,
                                $.memoizedState = _e.memoizedState,
                                $.updateQueue = _e.updateQueue,
                                $.type = _e.type,
                                o = _e.dependencies,
                                $.dependencies = o === null ? null : {
                                    lanes: o.lanes,
                                    firstContext: o.firstContext
                                }),
                                s = s.sibling;
                            return G(M, M.current & 1 | 2),
                            i.child
                        }
                        o = o.sibling
                    }
                $.tail !== null && B() > Hj && (i.flags |= 128,
                a = !0,
                Ej($, !1),
                i.lanes = 4194304)
            }
        else {
            if (!a)
                if (o = Mh(_e),
                o !== null) {
                    if (i.flags |= 128,
                    a = !0,
                    s = o.updateQueue,
                    s !== null && (i.updateQueue = s,
                    i.flags |= 4),
                    Ej($, !0),
                    $.tail === null && $.tailMode === "hidden" && !_e.alternate && !I)
                        return S(i),
                        null
                } else
                    2 * B() - $.renderingStartTime > Hj && s !== 1073741824 && (i.flags |= 128,
                    a = !0,
                    Ej($, !1),
                    i.lanes = 4194304);
            $.isBackwards ? (_e.sibling = i.child,
            i.child = _e) : (s = $.last,
            s !== null ? s.sibling = _e : i.child = _e,
            $.last = _e)
        }
        return $.tail !== null ? (i = $.tail,
        $.rendering = i,
        $.tail = i.sibling,
        $.renderingStartTime = B(),
        i.sibling = null,
        s = M.current,
        G(M, a ? s & 1 | 2 : s & 1),
        i) : (S(i),
        null);
    case 22:
    case 23:
        return Ij(),
        a = i.memoizedState !== null,
        o !== null && o.memoizedState !== null !== a && (i.flags |= 8192),
        a && i.mode & 1 ? gj & 1073741824 && (S(i),
        i.subtreeFlags & 6 && (i.flags |= 8192)) : S(i),
        null;
    case 24:
        return null;
    case 25:
        return null
    }
    throw Error(p$1(156, i.tag))
}
function Jj(o, i) {
    switch (wg(i),
    i.tag) {
    case 1:
        return Zf(i.type) && $f(),
        o = i.flags,
        o & 65536 ? (i.flags = o & -65537 | 128,
        i) : null;
    case 3:
        return Jh(),
        E(Wf),
        E(H),
        Oh(),
        o = i.flags,
        o & 65536 && !(o & 128) ? (i.flags = o & -65537 | 128,
        i) : null;
    case 5:
        return Lh(i),
        null;
    case 13:
        if (E(M),
        o = i.memoizedState,
        o !== null && o.dehydrated !== null) {
            if (i.alternate === null)
                throw Error(p$1(340));
            Ig()
        }
        return o = i.flags,
        o & 65536 ? (i.flags = o & -65537 | 128,
        i) : null;
    case 19:
        return E(M),
        null;
    case 4:
        return Jh(),
        null;
    case 10:
        return Rg(i.type._context),
        null;
    case 22:
    case 23:
        return Ij(),
        null;
    case 24:
        return null;
    default:
        return null
    }
}
var Kj = !1
  , U = !1
  , Lj = typeof WeakSet == "function" ? WeakSet : Set
  , V = null;
function Mj(o, i) {
    var s = o.ref;
    if (s !== null)
        if (typeof s == "function")
            try {
                s(null)
            } catch (a) {
                W(o, i, a)
            }
        else
            s.current = null
}
function Nj(o, i, s) {
    try {
        s()
    } catch (a) {
        W(o, i, a)
    }
}
var Oj = !1;
function Pj(o, i) {
    if (Cf = dd,
    o = Me(),
    Ne(o)) {
        if ("selectionStart"in o)
            var s = {
                start: o.selectionStart,
                end: o.selectionEnd
            };
        else
            e: {
                s = (s = o.ownerDocument) && s.defaultView || window;
                var a = s.getSelection && s.getSelection();
                if (a && a.rangeCount !== 0) {
                    s = a.anchorNode;
                    var _ = a.anchorOffset
                      , $ = a.focusNode;
                    a = a.focusOffset;
                    try {
                        s.nodeType,
                        $.nodeType
                    } catch {
                        s = null;
                        break e
                    }
                    var _e = 0
                      , tt = -1
                      , nt = -1
                      , rt = 0
                      , ot = 0
                      , et = o
                      , j = null;
                    t: for (; ; ) {
                        for (var it; et !== s || _ !== 0 && et.nodeType !== 3 || (tt = _e + _),
                        et !== $ || a !== 0 && et.nodeType !== 3 || (nt = _e + a),
                        et.nodeType === 3 && (_e += et.nodeValue.length),
                        (it = et.firstChild) !== null; )
                            j = et,
                            et = it;
                        for (; ; ) {
                            if (et === o)
                                break t;
                            if (j === s && ++rt === _ && (tt = _e),
                            j === $ && ++ot === a && (nt = _e),
                            (it = et.nextSibling) !== null)
                                break;
                            et = j,
                            j = et.parentNode
                        }
                        et = it
                    }
                    s = tt === -1 || nt === -1 ? null : {
                        start: tt,
                        end: nt
                    }
                } else
                    s = null
            }
        s = s || {
            start: 0,
            end: 0
        }
    } else
        s = null;
    for (Df = {
        focusedElem: o,
        selectionRange: s
    },
    dd = !1,
    V = i; V !== null; )
        if (i = V,
        o = i.child,
        (i.subtreeFlags & 1028) !== 0 && o !== null)
            o.return = i,
            V = o;
        else
            for (; V !== null; ) {
                i = V;
                try {
                    var st = i.alternate;
                    if (i.flags & 1024)
                        switch (i.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (st !== null) {
                                var at = st.memoizedProps
                                  , lt = st.memoizedState
                                  , ct = i.stateNode
                                  , ut = ct.getSnapshotBeforeUpdate(i.elementType === i.type ? at : Lg(i.type, at), lt);
                                ct.__reactInternalSnapshotBeforeUpdate = ut
                            }
                            break;
                        case 3:
                            var dt = i.stateNode.containerInfo;
                            dt.nodeType === 1 ? dt.textContent = "" : dt.nodeType === 9 && dt.documentElement && dt.removeChild(dt.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(p$1(163))
                        }
                } catch (ft) {
                    W(i, i.return, ft)
                }
                if (o = i.sibling,
                o !== null) {
                    o.return = i.return,
                    V = o;
                    break
                }
                V = i.return
            }
    return st = Oj,
    Oj = !1,
    st
}
function Qj(o, i, s) {
    var a = i.updateQueue;
    if (a = a !== null ? a.lastEffect : null,
    a !== null) {
        var _ = a = a.next;
        do {
            if ((_.tag & o) === o) {
                var $ = _.destroy;
                _.destroy = void 0,
                $ !== void 0 && Nj(i, s, $)
            }
            _ = _.next
        } while (_ !== a)
    }
}
function Rj(o, i) {
    if (i = i.updateQueue,
    i = i !== null ? i.lastEffect : null,
    i !== null) {
        var s = i = i.next;
        do {
            if ((s.tag & o) === o) {
                var a = s.create;
                s.destroy = a()
            }
            s = s.next
        } while (s !== i)
    }
}
function Sj(o) {
    var i = o.ref;
    if (i !== null) {
        var s = o.stateNode;
        switch (o.tag) {
        case 5:
            o = s;
            break;
        default:
            o = s
        }
        typeof i == "function" ? i(o) : i.current = o
    }
}
function Tj(o) {
    var i = o.alternate;
    i !== null && (o.alternate = null,
    Tj(i)),
    o.child = null,
    o.deletions = null,
    o.sibling = null,
    o.tag === 5 && (i = o.stateNode,
    i !== null && (delete i[Of],
    delete i[Pf],
    delete i[of],
    delete i[Qf],
    delete i[Rf])),
    o.stateNode = null,
    o.return = null,
    o.dependencies = null,
    o.memoizedProps = null,
    o.memoizedState = null,
    o.pendingProps = null,
    o.stateNode = null,
    o.updateQueue = null
}
function Uj(o) {
    return o.tag === 5 || o.tag === 3 || o.tag === 4
}
function Vj(o) {
    e: for (; ; ) {
        for (; o.sibling === null; ) {
            if (o.return === null || Uj(o.return))
                return null;
            o = o.return
        }
        for (o.sibling.return = o.return,
        o = o.sibling; o.tag !== 5 && o.tag !== 6 && o.tag !== 18; ) {
            if (o.flags & 2 || o.child === null || o.tag === 4)
                continue e;
            o.child.return = o,
            o = o.child
        }
        if (!(o.flags & 2))
            return o.stateNode
    }
}
function Wj(o, i, s) {
    var a = o.tag;
    if (a === 5 || a === 6)
        o = o.stateNode,
        i ? s.nodeType === 8 ? s.parentNode.insertBefore(o, i) : s.insertBefore(o, i) : (s.nodeType === 8 ? (i = s.parentNode,
        i.insertBefore(o, s)) : (i = s,
        i.appendChild(o)),
        s = s._reactRootContainer,
        s != null || i.onclick !== null || (i.onclick = Bf));
    else if (a !== 4 && (o = o.child,
    o !== null))
        for (Wj(o, i, s),
        o = o.sibling; o !== null; )
            Wj(o, i, s),
            o = o.sibling
}
function Xj(o, i, s) {
    var a = o.tag;
    if (a === 5 || a === 6)
        o = o.stateNode,
        i ? s.insertBefore(o, i) : s.appendChild(o);
    else if (a !== 4 && (o = o.child,
    o !== null))
        for (Xj(o, i, s),
        o = o.sibling; o !== null; )
            Xj(o, i, s),
            o = o.sibling
}
var X = null
  , Yj = !1;
function Zj(o, i, s) {
    for (s = s.child; s !== null; )
        ak(o, i, s),
        s = s.sibling
}
function ak(o, i, s) {
    if (lc && typeof lc.onCommitFiberUnmount == "function")
        try {
            lc.onCommitFiberUnmount(kc, s)
        } catch {}
    switch (s.tag) {
    case 5:
        U || Mj(s, i);
    case 6:
        var a = X
          , _ = Yj;
        X = null,
        Zj(o, i, s),
        X = a,
        Yj = _,
        X !== null && (Yj ? (o = X,
        s = s.stateNode,
        o.nodeType === 8 ? o.parentNode.removeChild(s) : o.removeChild(s)) : X.removeChild(s.stateNode));
        break;
    case 18:
        X !== null && (Yj ? (o = X,
        s = s.stateNode,
        o.nodeType === 8 ? Kf(o.parentNode, s) : o.nodeType === 1 && Kf(o, s),
        bd(o)) : Kf(X, s.stateNode));
        break;
    case 4:
        a = X,
        _ = Yj,
        X = s.stateNode.containerInfo,
        Yj = !0,
        Zj(o, i, s),
        X = a,
        Yj = _;
        break;
    case 0:
    case 11:
    case 14:
    case 15:
        if (!U && (a = s.updateQueue,
        a !== null && (a = a.lastEffect,
        a !== null))) {
            _ = a = a.next;
            do {
                var $ = _
                  , _e = $.destroy;
                $ = $.tag,
                _e !== void 0 && ($ & 2 || $ & 4) && Nj(s, i, _e),
                _ = _.next
            } while (_ !== a)
        }
        Zj(o, i, s);
        break;
    case 1:
        if (!U && (Mj(s, i),
        a = s.stateNode,
        typeof a.componentWillUnmount == "function"))
            try {
                a.props = s.memoizedProps,
                a.state = s.memoizedState,
                a.componentWillUnmount()
            } catch (tt) {
                W(s, i, tt)
            }
        Zj(o, i, s);
        break;
    case 21:
        Zj(o, i, s);
        break;
    case 22:
        s.mode & 1 ? (U = (a = U) || s.memoizedState !== null,
        Zj(o, i, s),
        U = a) : Zj(o, i, s);
        break;
    default:
        Zj(o, i, s)
    }
}
function bk(o) {
    var i = o.updateQueue;
    if (i !== null) {
        o.updateQueue = null;
        var s = o.stateNode;
        s === null && (s = o.stateNode = new Lj),
        i.forEach(function(a) {
            var _ = ck.bind(null, o, a);
            s.has(a) || (s.add(a),
            a.then(_, _))
        })
    }
}
function dk(o, i) {
    var s = i.deletions;
    if (s !== null)
        for (var a = 0; a < s.length; a++) {
            var _ = s[a];
            try {
                var $ = o
                  , _e = i
                  , tt = _e;
                e: for (; tt !== null; ) {
                    switch (tt.tag) {
                    case 5:
                        X = tt.stateNode,
                        Yj = !1;
                        break e;
                    case 3:
                        X = tt.stateNode.containerInfo,
                        Yj = !0;
                        break e;
                    case 4:
                        X = tt.stateNode.containerInfo,
                        Yj = !0;
                        break e
                    }
                    tt = tt.return
                }
                if (X === null)
                    throw Error(p$1(160));
                ak($, _e, _),
                X = null,
                Yj = !1;
                var nt = _.alternate;
                nt !== null && (nt.return = null),
                _.return = null
            } catch (rt) {
                W(_, i, rt)
            }
        }
    if (i.subtreeFlags & 12854)
        for (i = i.child; i !== null; )
            ek(i, o),
            i = i.sibling
}
function ek(o, i) {
    var s = o.alternate
      , a = o.flags;
    switch (o.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
        if (dk(i, o),
        fk(o),
        a & 4) {
            try {
                Qj(3, o, o.return),
                Rj(3, o)
            } catch (at) {
                W(o, o.return, at)
            }
            try {
                Qj(5, o, o.return)
            } catch (at) {
                W(o, o.return, at)
            }
        }
        break;
    case 1:
        dk(i, o),
        fk(o),
        a & 512 && s !== null && Mj(s, s.return);
        break;
    case 5:
        if (dk(i, o),
        fk(o),
        a & 512 && s !== null && Mj(s, s.return),
        o.flags & 32) {
            var _ = o.stateNode;
            try {
                ob(_, "")
            } catch (at) {
                W(o, o.return, at)
            }
        }
        if (a & 4 && (_ = o.stateNode,
        _ != null)) {
            var $ = o.memoizedProps
              , _e = s !== null ? s.memoizedProps : $
              , tt = o.type
              , nt = o.updateQueue;
            if (o.updateQueue = null,
            nt !== null)
                try {
                    tt === "input" && $.type === "radio" && $.name != null && ab(_, $),
                    vb(tt, _e);
                    var rt = vb(tt, $);
                    for (_e = 0; _e < nt.length; _e += 2) {
                        var ot = nt[_e]
                          , et = nt[_e + 1];
                        ot === "style" ? sb(_, et) : ot === "dangerouslySetInnerHTML" ? nb(_, et) : ot === "children" ? ob(_, et) : ta(_, ot, et, rt)
                    }
                    switch (tt) {
                    case "input":
                        bb(_, $);
                        break;
                    case "textarea":
                        ib(_, $);
                        break;
                    case "select":
                        var j = _._wrapperState.wasMultiple;
                        _._wrapperState.wasMultiple = !!$.multiple;
                        var it = $.value;
                        it != null ? fb(_, !!$.multiple, it, !1) : j !== !!$.multiple && ($.defaultValue != null ? fb(_, !!$.multiple, $.defaultValue, !0) : fb(_, !!$.multiple, $.multiple ? [] : "", !1))
                    }
                    _[Pf] = $
                } catch (at) {
                    W(o, o.return, at)
                }
        }
        break;
    case 6:
        if (dk(i, o),
        fk(o),
        a & 4) {
            if (o.stateNode === null)
                throw Error(p$1(162));
            _ = o.stateNode,
            $ = o.memoizedProps;
            try {
                _.nodeValue = $
            } catch (at) {
                W(o, o.return, at)
            }
        }
        break;
    case 3:
        if (dk(i, o),
        fk(o),
        a & 4 && s !== null && s.memoizedState.isDehydrated)
            try {
                bd(i.containerInfo)
            } catch (at) {
                W(o, o.return, at)
            }
        break;
    case 4:
        dk(i, o),
        fk(o);
        break;
    case 13:
        dk(i, o),
        fk(o),
        _ = o.child,
        _.flags & 8192 && ($ = _.memoizedState !== null,
        _.stateNode.isHidden = $,
        !$ || _.alternate !== null && _.alternate.memoizedState !== null || (gk = B())),
        a & 4 && bk(o);
        break;
    case 22:
        if (ot = s !== null && s.memoizedState !== null,
        o.mode & 1 ? (U = (rt = U) || ot,
        dk(i, o),
        U = rt) : dk(i, o),
        fk(o),
        a & 8192) {
            if (rt = o.memoizedState !== null,
            (o.stateNode.isHidden = rt) && !ot && o.mode & 1)
                for (V = o,
                ot = o.child; ot !== null; ) {
                    for (et = V = ot; V !== null; ) {
                        switch (j = V,
                        it = j.child,
                        j.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            Qj(4, j, j.return);
                            break;
                        case 1:
                            Mj(j, j.return);
                            var st = j.stateNode;
                            if (typeof st.componentWillUnmount == "function") {
                                a = j,
                                s = j.return;
                                try {
                                    i = a,
                                    st.props = i.memoizedProps,
                                    st.state = i.memoizedState,
                                    st.componentWillUnmount()
                                } catch (at) {
                                    W(a, s, at)
                                }
                            }
                            break;
                        case 5:
                            Mj(j, j.return);
                            break;
                        case 22:
                            if (j.memoizedState !== null) {
                                hk(et);
                                continue
                            }
                        }
                        it !== null ? (it.return = j,
                        V = it) : hk(et)
                    }
                    ot = ot.sibling
                }
            e: for (ot = null,
            et = o; ; ) {
                if (et.tag === 5) {
                    if (ot === null) {
                        ot = et;
                        try {
                            _ = et.stateNode,
                            rt ? ($ = _.style,
                            typeof $.setProperty == "function" ? $.setProperty("display", "none", "important") : $.display = "none") : (tt = et.stateNode,
                            nt = et.memoizedProps.style,
                            _e = nt != null && nt.hasOwnProperty("display") ? nt.display : null,
                            tt.style.display = rb("display", _e))
                        } catch (at) {
                            W(o, o.return, at)
                        }
                    }
                } else if (et.tag === 6) {
                    if (ot === null)
                        try {
                            et.stateNode.nodeValue = rt ? "" : et.memoizedProps
                        } catch (at) {
                            W(o, o.return, at)
                        }
                } else if ((et.tag !== 22 && et.tag !== 23 || et.memoizedState === null || et === o) && et.child !== null) {
                    et.child.return = et,
                    et = et.child;
                    continue
                }
                if (et === o)
                    break e;
                for (; et.sibling === null; ) {
                    if (et.return === null || et.return === o)
                        break e;
                    ot === et && (ot = null),
                    et = et.return
                }
                ot === et && (ot = null),
                et.sibling.return = et.return,
                et = et.sibling
            }
        }
        break;
    case 19:
        dk(i, o),
        fk(o),
        a & 4 && bk(o);
        break;
    case 21:
        break;
    default:
        dk(i, o),
        fk(o)
    }
}
function fk(o) {
    var i = o.flags;
    if (i & 2) {
        try {
            e: {
                for (var s = o.return; s !== null; ) {
                    if (Uj(s)) {
                        var a = s;
                        break e
                    }
                    s = s.return
                }
                throw Error(p$1(160))
            }
            switch (a.tag) {
            case 5:
                var _ = a.stateNode;
                a.flags & 32 && (ob(_, ""),
                a.flags &= -33);
                var $ = Vj(o);
                Xj(o, $, _);
                break;
            case 3:
            case 4:
                var _e = a.stateNode.containerInfo
                  , tt = Vj(o);
                Wj(o, tt, _e);
                break;
            default:
                throw Error(p$1(161))
            }
        } catch (nt) {
            W(o, o.return, nt)
        }
        o.flags &= -3
    }
    i & 4096 && (o.flags &= -4097)
}
function ik(o, i, s) {
    V = o,
    jk(o)
}
function jk(o, i, s) {
    for (var a = (o.mode & 1) !== 0; V !== null; ) {
        var _ = V
          , $ = _.child;
        if (_.tag === 22 && a) {
            var _e = _.memoizedState !== null || Kj;
            if (!_e) {
                var tt = _.alternate
                  , nt = tt !== null && tt.memoizedState !== null || U;
                tt = Kj;
                var rt = U;
                if (Kj = _e,
                (U = nt) && !rt)
                    for (V = _; V !== null; )
                        _e = V,
                        nt = _e.child,
                        _e.tag === 22 && _e.memoizedState !== null ? kk(_) : nt !== null ? (nt.return = _e,
                        V = nt) : kk(_);
                for (; $ !== null; )
                    V = $,
                    jk($),
                    $ = $.sibling;
                V = _,
                Kj = tt,
                U = rt
            }
            lk(o)
        } else
            _.subtreeFlags & 8772 && $ !== null ? ($.return = _,
            V = $) : lk(o)
    }
}
function lk(o) {
    for (; V !== null; ) {
        var i = V;
        if (i.flags & 8772) {
            var s = i.alternate;
            try {
                if (i.flags & 8772)
                    switch (i.tag) {
                    case 0:
                    case 11:
                    case 15:
                        U || Rj(5, i);
                        break;
                    case 1:
                        var a = i.stateNode;
                        if (i.flags & 4 && !U)
                            if (s === null)
                                a.componentDidMount();
                            else {
                                var _ = i.elementType === i.type ? s.memoizedProps : Lg(i.type, s.memoizedProps);
                                a.componentDidUpdate(_, s.memoizedState, a.__reactInternalSnapshotBeforeUpdate)
                            }
                        var $ = i.updateQueue;
                        $ !== null && ih(i, $, a);
                        break;
                    case 3:
                        var _e = i.updateQueue;
                        if (_e !== null) {
                            if (s = null,
                            i.child !== null)
                                switch (i.child.tag) {
                                case 5:
                                    s = i.child.stateNode;
                                    break;
                                case 1:
                                    s = i.child.stateNode
                                }
                            ih(i, _e, s)
                        }
                        break;
                    case 5:
                        var tt = i.stateNode;
                        if (s === null && i.flags & 4) {
                            s = tt;
                            var nt = i.memoizedProps;
                            switch (i.type) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                nt.autoFocus && s.focus();
                                break;
                            case "img":
                                nt.src && (s.src = nt.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (i.memoizedState === null) {
                            var rt = i.alternate;
                            if (rt !== null) {
                                var ot = rt.memoizedState;
                                if (ot !== null) {
                                    var et = ot.dehydrated;
                                    et !== null && bd(et)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(p$1(163))
                    }
                U || i.flags & 512 && Sj(i)
            } catch (j) {
                W(i, i.return, j)
            }
        }
        if (i === o) {
            V = null;
            break
        }
        if (s = i.sibling,
        s !== null) {
            s.return = i.return,
            V = s;
            break
        }
        V = i.return
    }
}
function hk(o) {
    for (; V !== null; ) {
        var i = V;
        if (i === o) {
            V = null;
            break
        }
        var s = i.sibling;
        if (s !== null) {
            s.return = i.return,
            V = s;
            break
        }
        V = i.return
    }
}
function kk(o) {
    for (; V !== null; ) {
        var i = V;
        try {
            switch (i.tag) {
            case 0:
            case 11:
            case 15:
                var s = i.return;
                try {
                    Rj(4, i)
                } catch (nt) {
                    W(i, s, nt)
                }
                break;
            case 1:
                var a = i.stateNode;
                if (typeof a.componentDidMount == "function") {
                    var _ = i.return;
                    try {
                        a.componentDidMount()
                    } catch (nt) {
                        W(i, _, nt)
                    }
                }
                var $ = i.return;
                try {
                    Sj(i)
                } catch (nt) {
                    W(i, $, nt)
                }
                break;
            case 5:
                var _e = i.return;
                try {
                    Sj(i)
                } catch (nt) {
                    W(i, _e, nt)
                }
            }
        } catch (nt) {
            W(i, i.return, nt)
        }
        if (i === o) {
            V = null;
            break
        }
        var tt = i.sibling;
        if (tt !== null) {
            tt.return = i.return,
            V = tt;
            break
        }
        V = i.return
    }
}
var mk = Math.ceil
  , nk = ua$1.ReactCurrentDispatcher
  , ok = ua$1.ReactCurrentOwner
  , pk = ua$1.ReactCurrentBatchConfig
  , K = 0
  , R = null
  , Y = null
  , Z = 0
  , gj = 0
  , fj = Uf(0)
  , T = 0
  , qk = null
  , hh = 0
  , rk = 0
  , sk = 0
  , tk = null
  , uk = null
  , gk = 0
  , Hj = 1 / 0
  , vk = null
  , Pi = !1
  , Qi = null
  , Si = null
  , wk = !1
  , xk = null
  , yk = 0
  , zk = 0
  , Ak = null
  , Bk = -1
  , Ck = 0;
function L() {
    return K & 6 ? B() : Bk !== -1 ? Bk : Bk = B()
}
function lh(o) {
    return o.mode & 1 ? K & 2 && Z !== 0 ? Z & -Z : Kg.transition !== null ? (Ck === 0 && (Ck = yc()),
    Ck) : (o = C,
    o !== 0 || (o = window.event,
    o = o === void 0 ? 16 : jd(o.type)),
    o) : 1
}
function mh(o, i, s, a) {
    if (50 < zk)
        throw zk = 0,
        Ak = null,
        Error(p$1(185));
    Ac(o, s, a),
    (!(K & 2) || o !== R) && (o === R && (!(K & 2) && (rk |= s),
    T === 4 && Dk(o, Z)),
    Ek(o, a),
    s === 1 && K === 0 && !(i.mode & 1) && (Hj = B() + 500,
    fg && jg()))
}
function Ek(o, i) {
    var s = o.callbackNode;
    wc(o, i);
    var a = uc(o, o === R ? Z : 0);
    if (a === 0)
        s !== null && bc(s),
        o.callbackNode = null,
        o.callbackPriority = 0;
    else if (i = a & -a,
    o.callbackPriority !== i) {
        if (s != null && bc(s),
        i === 1)
            o.tag === 0 ? ig(Fk.bind(null, o)) : hg(Fk.bind(null, o)),
            Jf(function() {
                !(K & 6) && jg()
            }),
            s = null;
        else {
            switch (Dc(a)) {
            case 1:
                s = fc;
                break;
            case 4:
                s = gc;
                break;
            case 16:
                s = hc;
                break;
            case 536870912:
                s = jc;
                break;
            default:
                s = hc
            }
            s = Gk(s, Hk.bind(null, o))
        }
        o.callbackPriority = i,
        o.callbackNode = s
    }
}
function Hk(o, i) {
    if (Bk = -1,
    Ck = 0,
    K & 6)
        throw Error(p$1(327));
    var s = o.callbackNode;
    if (Ik() && o.callbackNode !== s)
        return null;
    var a = uc(o, o === R ? Z : 0);
    if (a === 0)
        return null;
    if (a & 30 || a & o.expiredLanes || i)
        i = Jk(o, a);
    else {
        i = a;
        var _ = K;
        K |= 2;
        var $ = Kk();
        (R !== o || Z !== i) && (vk = null,
        Hj = B() + 500,
        Lk(o, i));
        do
            try {
                Mk();
                break
            } catch (tt) {
                Nk(o, tt)
            }
        while (1);
        Qg(),
        nk.current = $,
        K = _,
        Y !== null ? i = 0 : (R = null,
        Z = 0,
        i = T)
    }
    if (i !== 0) {
        if (i === 2 && (_ = xc(o),
        _ !== 0 && (a = _,
        i = Ok(o, _))),
        i === 1)
            throw s = qk,
            Lk(o, 0),
            Dk(o, a),
            Ek(o, B()),
            s;
        if (i === 6)
            Dk(o, a);
        else {
            if (_ = o.current.alternate,
            !(a & 30) && !Pk(_) && (i = Jk(o, a),
            i === 2 && ($ = xc(o),
            $ !== 0 && (a = $,
            i = Ok(o, $))),
            i === 1))
                throw s = qk,
                Lk(o, 0),
                Dk(o, a),
                Ek(o, B()),
                s;
            switch (o.finishedWork = _,
            o.finishedLanes = a,
            i) {
            case 0:
            case 1:
                throw Error(p$1(345));
            case 2:
                Qk(o, uk, vk);
                break;
            case 3:
                if (Dk(o, a),
                (a & 130023424) === a && (i = gk + 500 - B(),
                10 < i)) {
                    if (uc(o, 0) !== 0)
                        break;
                    if (_ = o.suspendedLanes,
                    (_ & a) !== a) {
                        L(),
                        o.pingedLanes |= o.suspendedLanes & _;
                        break
                    }
                    o.timeoutHandle = Ff(Qk.bind(null, o, uk, vk), i);
                    break
                }
                Qk(o, uk, vk);
                break;
            case 4:
                if (Dk(o, a),
                (a & 4194240) === a)
                    break;
                for (i = o.eventTimes,
                _ = -1; 0 < a; ) {
                    var _e = 31 - oc(a);
                    $ = 1 << _e,
                    _e = i[_e],
                    _e > _ && (_ = _e),
                    a &= ~$
                }
                if (a = _,
                a = B() - a,
                a = (120 > a ? 120 : 480 > a ? 480 : 1080 > a ? 1080 : 1920 > a ? 1920 : 3e3 > a ? 3e3 : 4320 > a ? 4320 : 1960 * mk(a / 1960)) - a,
                10 < a) {
                    o.timeoutHandle = Ff(Qk.bind(null, o, uk, vk), a);
                    break
                }
                Qk(o, uk, vk);
                break;
            case 5:
                Qk(o, uk, vk);
                break;
            default:
                throw Error(p$1(329))
            }
        }
    }
    return Ek(o, B()),
    o.callbackNode === s ? Hk.bind(null, o) : null
}
function Ok(o, i) {
    var s = tk;
    return o.current.memoizedState.isDehydrated && (Lk(o, i).flags |= 256),
    o = Jk(o, i),
    o !== 2 && (i = uk,
    uk = s,
    i !== null && Gj(i)),
    o
}
function Gj(o) {
    uk === null ? uk = o : uk.push.apply(uk, o)
}
function Pk(o) {
    for (var i = o; ; ) {
        if (i.flags & 16384) {
            var s = i.updateQueue;
            if (s !== null && (s = s.stores,
            s !== null))
                for (var a = 0; a < s.length; a++) {
                    var _ = s[a]
                      , $ = _.getSnapshot;
                    _ = _.value;
                    try {
                        if (!He($(), _))
                            return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (s = i.child,
        i.subtreeFlags & 16384 && s !== null)
            s.return = i,
            i = s;
        else {
            if (i === o)
                break;
            for (; i.sibling === null; ) {
                if (i.return === null || i.return === o)
                    return !0;
                i = i.return
            }
            i.sibling.return = i.return,
            i = i.sibling
        }
    }
    return !0
}
function Dk(o, i) {
    for (i &= ~sk,
    i &= ~rk,
    o.suspendedLanes |= i,
    o.pingedLanes &= ~i,
    o = o.expirationTimes; 0 < i; ) {
        var s = 31 - oc(i)
          , a = 1 << s;
        o[s] = -1,
        i &= ~a
    }
}
function Fk(o) {
    if (K & 6)
        throw Error(p$1(327));
    Ik();
    var i = uc(o, 0);
    if (!(i & 1))
        return Ek(o, B()),
        null;
    var s = Jk(o, i);
    if (o.tag !== 0 && s === 2) {
        var a = xc(o);
        a !== 0 && (i = a,
        s = Ok(o, a))
    }
    if (s === 1)
        throw s = qk,
        Lk(o, 0),
        Dk(o, i),
        Ek(o, B()),
        s;
    if (s === 6)
        throw Error(p$1(345));
    return o.finishedWork = o.current.alternate,
    o.finishedLanes = i,
    Qk(o, uk, vk),
    Ek(o, B()),
    null
}
function Rk(o, i) {
    var s = K;
    K |= 1;
    try {
        return o(i)
    } finally {
        K = s,
        K === 0 && (Hj = B() + 500,
        fg && jg())
    }
}
function Sk(o) {
    xk !== null && xk.tag === 0 && !(K & 6) && Ik();
    var i = K;
    K |= 1;
    var s = pk.transition
      , a = C;
    try {
        if (pk.transition = null,
        C = 1,
        o)
            return o()
    } finally {
        C = a,
        pk.transition = s,
        K = i,
        !(K & 6) && jg()
    }
}
function Ij() {
    gj = fj.current,
    E(fj)
}
function Lk(o, i) {
    o.finishedWork = null,
    o.finishedLanes = 0;
    var s = o.timeoutHandle;
    if (s !== -1 && (o.timeoutHandle = -1,
    Gf(s)),
    Y !== null)
        for (s = Y.return; s !== null; ) {
            var a = s;
            switch (wg(a),
            a.tag) {
            case 1:
                a = a.type.childContextTypes,
                a != null && $f();
                break;
            case 3:
                Jh(),
                E(Wf),
                E(H),
                Oh();
                break;
            case 5:
                Lh(a);
                break;
            case 4:
                Jh();
                break;
            case 13:
                E(M);
                break;
            case 19:
                E(M);
                break;
            case 10:
                Rg(a.type._context);
                break;
            case 22:
            case 23:
                Ij()
            }
            s = s.return
        }
    if (R = o,
    Y = o = wh(o.current, null),
    Z = gj = i,
    T = 0,
    qk = null,
    sk = rk = hh = 0,
    uk = tk = null,
    Wg !== null) {
        for (i = 0; i < Wg.length; i++)
            if (s = Wg[i],
            a = s.interleaved,
            a !== null) {
                s.interleaved = null;
                var _ = a.next
                  , $ = s.pending;
                if ($ !== null) {
                    var _e = $.next;
                    $.next = _,
                    a.next = _e
                }
                s.pending = a
            }
        Wg = null
    }
    return o
}
function Nk(o, i) {
    do {
        var s = Y;
        try {
            if (Qg(),
            Ph.current = ai,
            Sh) {
                for (var a = N.memoizedState; a !== null; ) {
                    var _ = a.queue;
                    _ !== null && (_.pending = null),
                    a = a.next
                }
                Sh = !1
            }
            if (Rh = 0,
            P = O = N = null,
            Th = !1,
            Uh = 0,
            ok.current = null,
            s === null || s.return === null) {
                T = 1,
                qk = i,
                Y = null;
                break
            }
            e: {
                var $ = o
                  , _e = s.return
                  , tt = s
                  , nt = i;
                if (i = Z,
                tt.flags |= 32768,
                nt !== null && typeof nt == "object" && typeof nt.then == "function") {
                    var rt = nt
                      , ot = tt
                      , et = ot.tag;
                    if (!(ot.mode & 1) && (et === 0 || et === 11 || et === 15)) {
                        var j = ot.alternate;
                        j ? (ot.updateQueue = j.updateQueue,
                        ot.memoizedState = j.memoizedState,
                        ot.lanes = j.lanes) : (ot.updateQueue = null,
                        ot.memoizedState = null)
                    }
                    var it = Vi(_e);
                    if (it !== null) {
                        it.flags &= -257,
                        Wi(it, _e, tt, $, i),
                        it.mode & 1 && Ti($, rt, i),
                        i = it,
                        nt = rt;
                        var st = i.updateQueue;
                        if (st === null) {
                            var at = new Set;
                            at.add(nt),
                            i.updateQueue = at
                        } else
                            st.add(nt);
                        break e
                    } else {
                        if (!(i & 1)) {
                            Ti($, rt, i),
                            uj();
                            break e
                        }
                        nt = Error(p$1(426))
                    }
                } else if (I && tt.mode & 1) {
                    var lt = Vi(_e);
                    if (lt !== null) {
                        !(lt.flags & 65536) && (lt.flags |= 256),
                        Wi(lt, _e, tt, $, i),
                        Jg(Ki(nt, tt));
                        break e
                    }
                }
                $ = nt = Ki(nt, tt),
                T !== 4 && (T = 2),
                tk === null ? tk = [$] : tk.push($),
                $ = _e;
                do {
                    switch ($.tag) {
                    case 3:
                        $.flags |= 65536,
                        i &= -i,
                        $.lanes |= i;
                        var ct = Oi($, nt, i);
                        fh($, ct);
                        break e;
                    case 1:
                        tt = nt;
                        var ut = $.type
                          , dt = $.stateNode;
                        if (!($.flags & 128) && (typeof ut.getDerivedStateFromError == "function" || dt !== null && typeof dt.componentDidCatch == "function" && (Si === null || !Si.has(dt)))) {
                            $.flags |= 65536,
                            i &= -i,
                            $.lanes |= i;
                            var ft = Ri($, tt, i);
                            fh($, ft);
                            break e
                        }
                    }
                    $ = $.return
                } while ($ !== null)
            }
            Tk(s)
        } catch (ht) {
            i = ht,
            Y === s && s !== null && (Y = s = s.return);
            continue
        }
        break
    } while (1)
}
function Kk() {
    var o = nk.current;
    return nk.current = ai,
    o === null ? ai : o
}
function uj() {
    (T === 0 || T === 3 || T === 2) && (T = 4),
    R === null || !(hh & 268435455) && !(rk & 268435455) || Dk(R, Z)
}
function Jk(o, i) {
    var s = K;
    K |= 2;
    var a = Kk();
    (R !== o || Z !== i) && (vk = null,
    Lk(o, i));
    do
        try {
            Uk();
            break
        } catch (_) {
            Nk(o, _)
        }
    while (1);
    if (Qg(),
    K = s,
    nk.current = a,
    Y !== null)
        throw Error(p$1(261));
    return R = null,
    Z = 0,
    T
}
function Uk() {
    for (; Y !== null; )
        Vk(Y)
}
function Mk() {
    for (; Y !== null && !cc(); )
        Vk(Y)
}
function Vk(o) {
    var i = Wk(o.alternate, o, gj);
    o.memoizedProps = o.pendingProps,
    i === null ? Tk(o) : Y = i,
    ok.current = null
}
function Tk(o) {
    var i = o;
    do {
        var s = i.alternate;
        if (o = i.return,
        i.flags & 32768) {
            if (s = Jj(s, i),
            s !== null) {
                s.flags &= 32767,
                Y = s;
                return
            }
            if (o !== null)
                o.flags |= 32768,
                o.subtreeFlags = 0,
                o.deletions = null;
            else {
                T = 6,
                Y = null;
                return
            }
        } else if (s = Fj(s, i, gj),
        s !== null) {
            Y = s;
            return
        }
        if (i = i.sibling,
        i !== null) {
            Y = i;
            return
        }
        Y = i = o
    } while (i !== null);
    T === 0 && (T = 5)
}
function Qk(o, i, s) {
    var a = C
      , _ = pk.transition;
    try {
        pk.transition = null,
        C = 1,
        Xk(o, i, s, a)
    } finally {
        pk.transition = _,
        C = a
    }
    return null
}
function Xk(o, i, s, a) {
    do
        Ik();
    while (xk !== null);
    if (K & 6)
        throw Error(p$1(327));
    s = o.finishedWork;
    var _ = o.finishedLanes;
    if (s === null)
        return null;
    if (o.finishedWork = null,
    o.finishedLanes = 0,
    s === o.current)
        throw Error(p$1(177));
    o.callbackNode = null,
    o.callbackPriority = 0;
    var $ = s.lanes | s.childLanes;
    if (Bc(o, $),
    o === R && (Y = R = null,
    Z = 0),
    !(s.subtreeFlags & 2064) && !(s.flags & 2064) || wk || (wk = !0,
    Gk(hc, function() {
        return Ik(),
        null
    })),
    $ = (s.flags & 15990) !== 0,
    s.subtreeFlags & 15990 || $) {
        $ = pk.transition,
        pk.transition = null;
        var _e = C;
        C = 1;
        var tt = K;
        K |= 4,
        ok.current = null,
        Pj(o, s),
        ek(s, o),
        Oe(Df),
        dd = !!Cf,
        Df = Cf = null,
        o.current = s,
        ik(s),
        dc(),
        K = tt,
        C = _e,
        pk.transition = $
    } else
        o.current = s;
    if (wk && (wk = !1,
    xk = o,
    yk = _),
    $ = o.pendingLanes,
    $ === 0 && (Si = null),
    mc(s.stateNode),
    Ek(o, B()),
    i !== null)
        for (a = o.onRecoverableError,
        s = 0; s < i.length; s++)
            _ = i[s],
            a(_.value, {
                componentStack: _.stack,
                digest: _.digest
            });
    if (Pi)
        throw Pi = !1,
        o = Qi,
        Qi = null,
        o;
    return yk & 1 && o.tag !== 0 && Ik(),
    $ = o.pendingLanes,
    $ & 1 ? o === Ak ? zk++ : (zk = 0,
    Ak = o) : zk = 0,
    jg(),
    null
}
function Ik() {
    if (xk !== null) {
        var o = Dc(yk)
          , i = pk.transition
          , s = C;
        try {
            if (pk.transition = null,
            C = 16 > o ? 16 : o,
            xk === null)
                var a = !1;
            else {
                if (o = xk,
                xk = null,
                yk = 0,
                K & 6)
                    throw Error(p$1(331));
                var _ = K;
                for (K |= 4,
                V = o.current; V !== null; ) {
                    var $ = V
                      , _e = $.child;
                    if (V.flags & 16) {
                        var tt = $.deletions;
                        if (tt !== null) {
                            for (var nt = 0; nt < tt.length; nt++) {
                                var rt = tt[nt];
                                for (V = rt; V !== null; ) {
                                    var ot = V;
                                    switch (ot.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Qj(8, ot, $)
                                    }
                                    var et = ot.child;
                                    if (et !== null)
                                        et.return = ot,
                                        V = et;
                                    else
                                        for (; V !== null; ) {
                                            ot = V;
                                            var j = ot.sibling
                                              , it = ot.return;
                                            if (Tj(ot),
                                            ot === rt) {
                                                V = null;
                                                break
                                            }
                                            if (j !== null) {
                                                j.return = it,
                                                V = j;
                                                break
                                            }
                                            V = it
                                        }
                                }
                            }
                            var st = $.alternate;
                            if (st !== null) {
                                var at = st.child;
                                if (at !== null) {
                                    st.child = null;
                                    do {
                                        var lt = at.sibling;
                                        at.sibling = null,
                                        at = lt
                                    } while (at !== null)
                                }
                            }
                            V = $
                        }
                    }
                    if ($.subtreeFlags & 2064 && _e !== null)
                        _e.return = $,
                        V = _e;
                    else
                        e: for (; V !== null; ) {
                            if ($ = V,
                            $.flags & 2048)
                                switch ($.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Qj(9, $, $.return)
                                }
                            var ct = $.sibling;
                            if (ct !== null) {
                                ct.return = $.return,
                                V = ct;
                                break e
                            }
                            V = $.return
                        }
                }
                var ut = o.current;
                for (V = ut; V !== null; ) {
                    _e = V;
                    var dt = _e.child;
                    if (_e.subtreeFlags & 2064 && dt !== null)
                        dt.return = _e,
                        V = dt;
                    else
                        e: for (_e = ut; V !== null; ) {
                            if (tt = V,
                            tt.flags & 2048)
                                try {
                                    switch (tt.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Rj(9, tt)
                                    }
                                } catch (ht) {
                                    W(tt, tt.return, ht)
                                }
                            if (tt === _e) {
                                V = null;
                                break e
                            }
                            var ft = tt.sibling;
                            if (ft !== null) {
                                ft.return = tt.return,
                                V = ft;
                                break e
                            }
                            V = tt.return
                        }
                }
                if (K = _,
                jg(),
                lc && typeof lc.onPostCommitFiberRoot == "function")
                    try {
                        lc.onPostCommitFiberRoot(kc, o)
                    } catch {}
                a = !0
            }
            return a
        } finally {
            C = s,
            pk.transition = i
        }
    }
    return !1
}
function Yk(o, i, s) {
    i = Ki(s, i),
    i = Oi(o, i, 1),
    o = dh(o, i, 1),
    i = L(),
    o !== null && (Ac(o, 1, i),
    Ek(o, i))
}
function W(o, i, s) {
    if (o.tag === 3)
        Yk(o, o, s);
    else
        for (; i !== null; ) {
            if (i.tag === 3) {
                Yk(i, o, s);
                break
            } else if (i.tag === 1) {
                var a = i.stateNode;
                if (typeof i.type.getDerivedStateFromError == "function" || typeof a.componentDidCatch == "function" && (Si === null || !Si.has(a))) {
                    o = Ki(s, o),
                    o = Ri(i, o, 1),
                    i = dh(i, o, 1),
                    o = L(),
                    i !== null && (Ac(i, 1, o),
                    Ek(i, o));
                    break
                }
            }
            i = i.return
        }
}
function Ui(o, i, s) {
    var a = o.pingCache;
    a !== null && a.delete(i),
    i = L(),
    o.pingedLanes |= o.suspendedLanes & s,
    R === o && (Z & s) === s && (T === 4 || T === 3 && (Z & 130023424) === Z && 500 > B() - gk ? Lk(o, 0) : sk |= s),
    Ek(o, i)
}
function Zk(o, i) {
    i === 0 && (o.mode & 1 ? (i = sc,
    sc <<= 1,
    !(sc & 130023424) && (sc = 4194304)) : i = 1);
    var s = L();
    o = Zg(o, i),
    o !== null && (Ac(o, i, s),
    Ek(o, s))
}
function vj(o) {
    var i = o.memoizedState
      , s = 0;
    i !== null && (s = i.retryLane),
    Zk(o, s)
}
function ck(o, i) {
    var s = 0;
    switch (o.tag) {
    case 13:
        var a = o.stateNode
          , _ = o.memoizedState;
        _ !== null && (s = _.retryLane);
        break;
    case 19:
        a = o.stateNode;
        break;
    default:
        throw Error(p$1(314))
    }
    a !== null && a.delete(i),
    Zk(o, s)
}
var Wk;
Wk = function(o, i, s) {
    if (o !== null)
        if (o.memoizedProps !== i.pendingProps || Wf.current)
            Ug = !0;
        else {
            if (!(o.lanes & s) && !(i.flags & 128))
                return Ug = !1,
                zj(o, i, s);
            Ug = !!(o.flags & 131072)
        }
    else
        Ug = !1,
        I && i.flags & 1048576 && ug(i, ng, i.index);
    switch (i.lanes = 0,
    i.tag) {
    case 2:
        var a = i.type;
        jj(o, i),
        o = i.pendingProps;
        var _ = Yf(i, H.current);
        Tg(i, s),
        _ = Xh(null, i, a, o, _, s);
        var $ = bi();
        return i.flags |= 1,
        typeof _ == "object" && _ !== null && typeof _.render == "function" && _.$$typeof === void 0 ? (i.tag = 1,
        i.memoizedState = null,
        i.updateQueue = null,
        Zf(a) ? ($ = !0,
        cg(i)) : $ = !1,
        i.memoizedState = _.state !== null && _.state !== void 0 ? _.state : null,
        ah(i),
        _.updater = nh,
        i.stateNode = _,
        _._reactInternals = i,
        rh(i, a, o, s),
        i = kj(null, i, a, !0, $, s)) : (i.tag = 0,
        I && $ && vg(i),
        Yi(null, i, _, s),
        i = i.child),
        i;
    case 16:
        a = i.elementType;
        e: {
            switch (jj(o, i),
            o = i.pendingProps,
            _ = a._init,
            a = _(a._payload),
            i.type = a,
            _ = i.tag = $k(a),
            o = Lg(a, o),
            _) {
            case 0:
                i = dj(null, i, a, o, s);
                break e;
            case 1:
                i = ij(null, i, a, o, s);
                break e;
            case 11:
                i = Zi(null, i, a, o, s);
                break e;
            case 14:
                i = aj(null, i, a, Lg(a.type, o), s);
                break e
            }
            throw Error(p$1(306, a, ""))
        }
        return i;
    case 0:
        return a = i.type,
        _ = i.pendingProps,
        _ = i.elementType === a ? _ : Lg(a, _),
        dj(o, i, a, _, s);
    case 1:
        return a = i.type,
        _ = i.pendingProps,
        _ = i.elementType === a ? _ : Lg(a, _),
        ij(o, i, a, _, s);
    case 3:
        e: {
            if (lj(i),
            o === null)
                throw Error(p$1(387));
            a = i.pendingProps,
            $ = i.memoizedState,
            _ = $.element,
            bh(o, i),
            gh(i, a, null, s);
            var _e = i.memoizedState;
            if (a = _e.element,
            $.isDehydrated)
                if ($ = {
                    element: a,
                    isDehydrated: !1,
                    cache: _e.cache,
                    pendingSuspenseBoundaries: _e.pendingSuspenseBoundaries,
                    transitions: _e.transitions
                },
                i.updateQueue.baseState = $,
                i.memoizedState = $,
                i.flags & 256) {
                    _ = Ki(Error(p$1(423)), i),
                    i = mj(o, i, a, s, _);
                    break e
                } else if (a !== _) {
                    _ = Ki(Error(p$1(424)), i),
                    i = mj(o, i, a, s, _);
                    break e
                } else
                    for (yg = Lf(i.stateNode.containerInfo.firstChild),
                    xg = i,
                    I = !0,
                    zg = null,
                    s = Ch(i, null, a, s),
                    i.child = s; s; )
                        s.flags = s.flags & -3 | 4096,
                        s = s.sibling;
            else {
                if (Ig(),
                a === _) {
                    i = $i(o, i, s);
                    break e
                }
                Yi(o, i, a, s)
            }
            i = i.child
        }
        return i;
    case 5:
        return Kh(i),
        o === null && Eg(i),
        a = i.type,
        _ = i.pendingProps,
        $ = o !== null ? o.memoizedProps : null,
        _e = _.children,
        Ef(a, _) ? _e = null : $ !== null && Ef(a, $) && (i.flags |= 32),
        hj(o, i),
        Yi(o, i, _e, s),
        i.child;
    case 6:
        return o === null && Eg(i),
        null;
    case 13:
        return pj(o, i, s);
    case 4:
        return Ih(i, i.stateNode.containerInfo),
        a = i.pendingProps,
        o === null ? i.child = Bh(i, null, a, s) : Yi(o, i, a, s),
        i.child;
    case 11:
        return a = i.type,
        _ = i.pendingProps,
        _ = i.elementType === a ? _ : Lg(a, _),
        Zi(o, i, a, _, s);
    case 7:
        return Yi(o, i, i.pendingProps, s),
        i.child;
    case 8:
        return Yi(o, i, i.pendingProps.children, s),
        i.child;
    case 12:
        return Yi(o, i, i.pendingProps.children, s),
        i.child;
    case 10:
        e: {
            if (a = i.type._context,
            _ = i.pendingProps,
            $ = i.memoizedProps,
            _e = _.value,
            G(Mg, a._currentValue),
            a._currentValue = _e,
            $ !== null)
                if (He($.value, _e)) {
                    if ($.children === _.children && !Wf.current) {
                        i = $i(o, i, s);
                        break e
                    }
                } else
                    for ($ = i.child,
                    $ !== null && ($.return = i); $ !== null; ) {
                        var tt = $.dependencies;
                        if (tt !== null) {
                            _e = $.child;
                            for (var nt = tt.firstContext; nt !== null; ) {
                                if (nt.context === a) {
                                    if ($.tag === 1) {
                                        nt = ch(-1, s & -s),
                                        nt.tag = 2;
                                        var rt = $.updateQueue;
                                        if (rt !== null) {
                                            rt = rt.shared;
                                            var ot = rt.pending;
                                            ot === null ? nt.next = nt : (nt.next = ot.next,
                                            ot.next = nt),
                                            rt.pending = nt
                                        }
                                    }
                                    $.lanes |= s,
                                    nt = $.alternate,
                                    nt !== null && (nt.lanes |= s),
                                    Sg($.return, s, i),
                                    tt.lanes |= s;
                                    break
                                }
                                nt = nt.next
                            }
                        } else if ($.tag === 10)
                            _e = $.type === i.type ? null : $.child;
                        else if ($.tag === 18) {
                            if (_e = $.return,
                            _e === null)
                                throw Error(p$1(341));
                            _e.lanes |= s,
                            tt = _e.alternate,
                            tt !== null && (tt.lanes |= s),
                            Sg(_e, s, i),
                            _e = $.sibling
                        } else
                            _e = $.child;
                        if (_e !== null)
                            _e.return = $;
                        else
                            for (_e = $; _e !== null; ) {
                                if (_e === i) {
                                    _e = null;
                                    break
                                }
                                if ($ = _e.sibling,
                                $ !== null) {
                                    $.return = _e.return,
                                    _e = $;
                                    break
                                }
                                _e = _e.return
                            }
                        $ = _e
                    }
            Yi(o, i, _.children, s),
            i = i.child
        }
        return i;
    case 9:
        return _ = i.type,
        a = i.pendingProps.children,
        Tg(i, s),
        _ = Vg(_),
        a = a(_),
        i.flags |= 1,
        Yi(o, i, a, s),
        i.child;
    case 14:
        return a = i.type,
        _ = Lg(a, i.pendingProps),
        _ = Lg(a.type, _),
        aj(o, i, a, _, s);
    case 15:
        return cj(o, i, i.type, i.pendingProps, s);
    case 17:
        return a = i.type,
        _ = i.pendingProps,
        _ = i.elementType === a ? _ : Lg(a, _),
        jj(o, i),
        i.tag = 1,
        Zf(a) ? (o = !0,
        cg(i)) : o = !1,
        Tg(i, s),
        ph(i, a, _),
        rh(i, a, _, s),
        kj(null, i, a, !0, o, s);
    case 19:
        return yj(o, i, s);
    case 22:
        return ej(o, i, s)
    }
    throw Error(p$1(156, i.tag))
}
;
function Gk(o, i) {
    return ac(o, i)
}
function al(o, i, s, a) {
    this.tag = o,
    this.key = s,
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
    this.index = 0,
    this.ref = null,
    this.pendingProps = i,
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
    this.mode = a,
    this.subtreeFlags = this.flags = 0,
    this.deletions = null,
    this.childLanes = this.lanes = 0,
    this.alternate = null
}
function Bg(o, i, s, a) {
    return new al(o,i,s,a)
}
function bj(o) {
    return o = o.prototype,
    !(!o || !o.isReactComponent)
}
function $k(o) {
    if (typeof o == "function")
        return bj(o) ? 1 : 0;
    if (o != null) {
        if (o = o.$$typeof,
        o === Da)
            return 11;
        if (o === Ga)
            return 14
    }
    return 2
}
function wh(o, i) {
    var s = o.alternate;
    return s === null ? (s = Bg(o.tag, i, o.key, o.mode),
    s.elementType = o.elementType,
    s.type = o.type,
    s.stateNode = o.stateNode,
    s.alternate = o,
    o.alternate = s) : (s.pendingProps = i,
    s.type = o.type,
    s.flags = 0,
    s.subtreeFlags = 0,
    s.deletions = null),
    s.flags = o.flags & 14680064,
    s.childLanes = o.childLanes,
    s.lanes = o.lanes,
    s.child = o.child,
    s.memoizedProps = o.memoizedProps,
    s.memoizedState = o.memoizedState,
    s.updateQueue = o.updateQueue,
    i = o.dependencies,
    s.dependencies = i === null ? null : {
        lanes: i.lanes,
        firstContext: i.firstContext
    },
    s.sibling = o.sibling,
    s.index = o.index,
    s.ref = o.ref,
    s
}
function yh(o, i, s, a, _, $) {
    var _e = 2;
    if (a = o,
    typeof o == "function")
        bj(o) && (_e = 1);
    else if (typeof o == "string")
        _e = 5;
    else
        e: switch (o) {
        case ya:
            return Ah(s.children, _, $, i);
        case za:
            _e = 8,
            _ |= 8;
            break;
        case Aa:
            return o = Bg(12, s, i, _ | 2),
            o.elementType = Aa,
            o.lanes = $,
            o;
        case Ea:
            return o = Bg(13, s, i, _),
            o.elementType = Ea,
            o.lanes = $,
            o;
        case Fa:
            return o = Bg(19, s, i, _),
            o.elementType = Fa,
            o.lanes = $,
            o;
        case Ia:
            return qj(s, _, $, i);
        default:
            if (typeof o == "object" && o !== null)
                switch (o.$$typeof) {
                case Ba:
                    _e = 10;
                    break e;
                case Ca:
                    _e = 9;
                    break e;
                case Da:
                    _e = 11;
                    break e;
                case Ga:
                    _e = 14;
                    break e;
                case Ha:
                    _e = 16,
                    a = null;
                    break e
                }
            throw Error(p$1(130, o == null ? o : typeof o, ""))
        }
    return i = Bg(_e, s, i, _),
    i.elementType = o,
    i.type = a,
    i.lanes = $,
    i
}
function Ah(o, i, s, a) {
    return o = Bg(7, o, a, i),
    o.lanes = s,
    o
}
function qj(o, i, s, a) {
    return o = Bg(22, o, a, i),
    o.elementType = Ia,
    o.lanes = s,
    o.stateNode = {
        isHidden: !1
    },
    o
}
function xh(o, i, s) {
    return o = Bg(6, o, null, i),
    o.lanes = s,
    o
}
function zh(o, i, s) {
    return i = Bg(4, o.children !== null ? o.children : [], o.key, i),
    i.lanes = s,
    i.stateNode = {
        containerInfo: o.containerInfo,
        pendingChildren: null,
        implementation: o.implementation
    },
    i
}
function bl(o, i, s, a, _) {
    this.tag = i,
    this.containerInfo = o,
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
    this.timeoutHandle = -1,
    this.callbackNode = this.pendingContext = this.context = null,
    this.callbackPriority = 0,
    this.eventTimes = zc(0),
    this.expirationTimes = zc(-1),
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
    this.entanglements = zc(0),
    this.identifierPrefix = a,
    this.onRecoverableError = _,
    this.mutableSourceEagerHydrationData = null
}
function cl(o, i, s, a, _, $, _e, tt, nt) {
    return o = new bl(o,i,s,tt,nt),
    i === 1 ? (i = 1,
    $ === !0 && (i |= 8)) : i = 0,
    $ = Bg(3, null, null, i),
    o.current = $,
    $.stateNode = o,
    $.memoizedState = {
        element: a,
        isDehydrated: s,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    },
    ah($),
    o
}
function dl(o, i, s) {
    var a = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: wa,
        key: a == null ? null : "" + a,
        children: o,
        containerInfo: i,
        implementation: s
    }
}
function el(o) {
    if (!o)
        return Vf;
    o = o._reactInternals;
    e: {
        if (Vb(o) !== o || o.tag !== 1)
            throw Error(p$1(170));
        var i = o;
        do {
            switch (i.tag) {
            case 3:
                i = i.stateNode.context;
                break e;
            case 1:
                if (Zf(i.type)) {
                    i = i.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e
                }
            }
            i = i.return
        } while (i !== null);
        throw Error(p$1(171))
    }
    if (o.tag === 1) {
        var s = o.type;
        if (Zf(s))
            return bg(o, s, i)
    }
    return i
}
function fl(o, i, s, a, _, $, _e, tt, nt) {
    return o = cl(s, a, !0, o, _, $, _e, tt, nt),
    o.context = el(null),
    s = o.current,
    a = L(),
    _ = lh(s),
    $ = ch(a, _),
    $.callback = i ?? null,
    dh(s, $, _),
    o.current.lanes = _,
    Ac(o, _, a),
    Ek(o, a),
    o
}
function gl(o, i, s, a) {
    var _ = i.current
      , $ = L()
      , _e = lh(_);
    return s = el(s),
    i.context === null ? i.context = s : i.pendingContext = s,
    i = ch($, _e),
    i.payload = {
        element: o
    },
    a = a === void 0 ? null : a,
    a !== null && (i.callback = a),
    o = dh(_, i, _e),
    o !== null && (mh(o, _, _e, $),
    eh(o, _, _e)),
    _e
}
function hl(o) {
    if (o = o.current,
    !o.child)
        return null;
    switch (o.child.tag) {
    case 5:
        return o.child.stateNode;
    default:
        return o.child.stateNode
    }
}
function il(o, i) {
    if (o = o.memoizedState,
    o !== null && o.dehydrated !== null) {
        var s = o.retryLane;
        o.retryLane = s !== 0 && s < i ? s : i
    }
}
function jl(o, i) {
    il(o, i),
    (o = o.alternate) && il(o, i)
}
function kl() {
    return null
}
var ll = typeof reportError == "function" ? reportError : function(o) {
    console.error(o)
}
;
function ml(o) {
    this._internalRoot = o
}
nl.prototype.render = ml.prototype.render = function(o) {
    var i = this._internalRoot;
    if (i === null)
        throw Error(p$1(409));
    gl(o, i, null, null)
}
;
nl.prototype.unmount = ml.prototype.unmount = function() {
    var o = this._internalRoot;
    if (o !== null) {
        this._internalRoot = null;
        var i = o.containerInfo;
        Sk(function() {
            gl(null, o, null, null)
        }),
        i[uf] = null
    }
}
;
function nl(o) {
    this._internalRoot = o
}
nl.prototype.unstable_scheduleHydration = function(o) {
    if (o) {
        var i = Hc();
        o = {
            blockedOn: null,
            target: o,
            priority: i
        };
        for (var s = 0; s < Qc.length && i !== 0 && i < Qc[s].priority; s++)
            ;
        Qc.splice(s, 0, o),
        s === 0 && Vc(o)
    }
}
;
function ol$1(o) {
    return !(!o || o.nodeType !== 1 && o.nodeType !== 9 && o.nodeType !== 11)
}
function pl(o) {
    return !(!o || o.nodeType !== 1 && o.nodeType !== 9 && o.nodeType !== 11 && (o.nodeType !== 8 || o.nodeValue !== " react-mount-point-unstable "))
}
function ql() {}
function rl(o, i, s, a, _) {
    if (_) {
        if (typeof a == "function") {
            var $ = a;
            a = function() {
                var rt = hl(_e);
                $.call(rt)
            }
        }
        var _e = fl(i, a, o, 0, null, !1, !1, "", ql);
        return o._reactRootContainer = _e,
        o[uf] = _e.current,
        sf(o.nodeType === 8 ? o.parentNode : o),
        Sk(),
        _e
    }
    for (; _ = o.lastChild; )
        o.removeChild(_);
    if (typeof a == "function") {
        var tt = a;
        a = function() {
            var rt = hl(nt);
            tt.call(rt)
        }
    }
    var nt = cl(o, 0, !1, null, null, !1, !1, "", ql);
    return o._reactRootContainer = nt,
    o[uf] = nt.current,
    sf(o.nodeType === 8 ? o.parentNode : o),
    Sk(function() {
        gl(i, nt, s, a)
    }),
    nt
}
function sl(o, i, s, a, _) {
    var $ = s._reactRootContainer;
    if ($) {
        var _e = $;
        if (typeof _ == "function") {
            var tt = _;
            _ = function() {
                var nt = hl(_e);
                tt.call(nt)
            }
        }
        gl(i, _e, o, _)
    } else
        _e = rl(s, i, o, _, a);
    return hl(_e)
}
Ec = function(o) {
    switch (o.tag) {
    case 3:
        var i = o.stateNode;
        if (i.current.memoizedState.isDehydrated) {
            var s = tc(i.pendingLanes);
            s !== 0 && (Cc(i, s | 1),
            Ek(i, B()),
            !(K & 6) && (Hj = B() + 500,
            jg()))
        }
        break;
    case 13:
        Sk(function() {
            var a = Zg(o, 1);
            if (a !== null) {
                var _ = L();
                mh(a, o, 1, _)
            }
        }),
        jl(o, 1)
    }
}
;
Fc = function(o) {
    if (o.tag === 13) {
        var i = Zg(o, 134217728);
        if (i !== null) {
            var s = L();
            mh(i, o, 134217728, s)
        }
        jl(o, 134217728)
    }
}
;
Gc = function(o) {
    if (o.tag === 13) {
        var i = lh(o)
          , s = Zg(o, i);
        if (s !== null) {
            var a = L();
            mh(s, o, i, a)
        }
        jl(o, i)
    }
}
;
Hc = function() {
    return C
}
;
Ic = function(o, i) {
    var s = C;
    try {
        return C = o,
        i()
    } finally {
        C = s
    }
}
;
yb = function(o, i, s) {
    switch (i) {
    case "input":
        if (bb(o, s),
        i = s.name,
        s.type === "radio" && i != null) {
            for (s = o; s.parentNode; )
                s = s.parentNode;
            for (s = s.querySelectorAll("input[name=" + JSON.stringify("" + i) + '][type="radio"]'),
            i = 0; i < s.length; i++) {
                var a = s[i];
                if (a !== o && a.form === o.form) {
                    var _ = Db(a);
                    if (!_)
                        throw Error(p$1(90));
                    Wa(a),
                    bb(a, _)
                }
            }
        }
        break;
    case "textarea":
        ib(o, s);
        break;
    case "select":
        i = s.value,
        i != null && fb(o, !!s.multiple, i, !1)
    }
}
;
Gb = Rk;
Hb = Sk;
var tl = {
    usingClientEntryPoint: !1,
    Events: [Cb, ue, Db, Eb, Fb, Rk]
}
  , ul = {
    findFiberByHostInstance: Wc,
    bundleType: 0,
    version: "18.2.0",
    rendererPackageName: "react-dom"
}
  , vl = {
    bundleType: ul.bundleType,
    version: ul.version,
    rendererPackageName: ul.rendererPackageName,
    rendererConfig: ul.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: ua$1.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(o) {
        return o = Zb(o),
        o === null ? null : o.stateNode
    },
    findFiberByHostInstance: ul.findFiberByHostInstance || kl,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.2.0-next-9e3b772b8-20220608"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!wl.isDisabled && wl.supportsFiber)
        try {
            kc = wl.inject(vl),
            lc = wl
        } catch {}
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = tl;
reactDom_production_min.createPortal = function(o, i) {
    var s = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!ol$1(i))
        throw Error(p$1(200));
    return dl(o, i, null, s)
}
;
reactDom_production_min.createRoot = function(o, i) {
    if (!ol$1(o))
        throw Error(p$1(299));
    var s = !1
      , a = ""
      , _ = ll;
    return i != null && (i.unstable_strictMode === !0 && (s = !0),
    i.identifierPrefix !== void 0 && (a = i.identifierPrefix),
    i.onRecoverableError !== void 0 && (_ = i.onRecoverableError)),
    i = cl(o, 1, !1, null, null, s, !1, a, _),
    o[uf] = i.current,
    sf(o.nodeType === 8 ? o.parentNode : o),
    new ml(i)
}
;
reactDom_production_min.findDOMNode = function(o) {
    if (o == null)
        return null;
    if (o.nodeType === 1)
        return o;
    var i = o._reactInternals;
    if (i === void 0)
        throw typeof o.render == "function" ? Error(p$1(188)) : (o = Object.keys(o).join(","),
        Error(p$1(268, o)));
    return o = Zb(i),
    o = o === null ? null : o.stateNode,
    o
}
;
reactDom_production_min.flushSync = function(o) {
    return Sk(o)
}
;
reactDom_production_min.hydrate = function(o, i, s) {
    if (!pl(i))
        throw Error(p$1(200));
    return sl(null, o, i, !0, s)
}
;
reactDom_production_min.hydrateRoot = function(o, i, s) {
    if (!ol$1(o))
        throw Error(p$1(405));
    var a = s != null && s.hydratedSources || null
      , _ = !1
      , $ = ""
      , _e = ll;
    if (s != null && (s.unstable_strictMode === !0 && (_ = !0),
    s.identifierPrefix !== void 0 && ($ = s.identifierPrefix),
    s.onRecoverableError !== void 0 && (_e = s.onRecoverableError)),
    i = fl(i, null, o, 1, s ?? null, _, !1, $, _e),
    o[uf] = i.current,
    sf(o),
    a)
        for (o = 0; o < a.length; o++)
            s = a[o],
            _ = s._getVersion,
            _ = _(s._source),
            i.mutableSourceEagerHydrationData == null ? i.mutableSourceEagerHydrationData = [s, _] : i.mutableSourceEagerHydrationData.push(s, _);
    return new nl(i)
}
;
reactDom_production_min.render = function(o, i, s) {
    if (!pl(i))
        throw Error(p$1(200));
    return sl(null, o, i, !1, s)
}
;
reactDom_production_min.unmountComponentAtNode = function(o) {
    if (!pl(o))
        throw Error(p$1(40));
    return o._reactRootContainer ? (Sk(function() {
        sl(null, null, o, !1, function() {
            o._reactRootContainer = null,
            o[uf] = null
        })
    }),
    !0) : !1
}
;
reactDom_production_min.unstable_batchedUpdates = Rk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(o, i, s, a) {
    if (!pl(s))
        throw Error(p$1(200));
    if (o == null || o._reactInternals === void 0)
        throw Error(p$1(38));
    return sl(o, i, s, !1, a)
}
;
reactDom_production_min.version = "18.2.0-next-9e3b772b8-20220608";
function checkDCE() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE)
        } catch (o) {
            console.error(o)
        }
}
checkDCE(),
reactDom.exports = reactDom_production_min;
var reactDomExports = reactDom.exports;
const ReactDOM = getDefaultExportFromCjs(reactDomExports);
var m$1 = reactDomExports;
client.createRoot = m$1.createRoot,
client.hydrateRoot = m$1.hydrateRoot;
const index$2 = "";
/**
 * @remix-run/router v1.8.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$3() {
    return _extends$3 = Object.assign ? Object.assign.bind() : function(o) {
        for (var i = 1; i < arguments.length; i++) {
            var s = arguments[i];
            for (var a in s)
                Object.prototype.hasOwnProperty.call(s, a) && (o[a] = s[a])
        }
        return o
    }
    ,
    _extends$3.apply(this, arguments)
}
var Action;
(function(o) {
    o.Pop = "POP",
    o.Push = "PUSH",
    o.Replace = "REPLACE"
}
)(Action || (Action = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(o) {
    o === void 0 && (o = {});
    function i(a, _) {
        let {pathname: $, search: _e, hash: tt} = a.location;
        return createLocation("", {
            pathname: $,
            search: _e,
            hash: tt
        }, _.state && _.state.usr || null, _.state && _.state.key || "default")
    }
    function s(a, _) {
        return typeof _ == "string" ? _ : createPath(_)
    }
    return getUrlBasedHistory(i, s, null, o)
}
function invariant(o, i) {
    if (o === !1 || o === null || typeof o > "u")
        throw new Error(i)
}
function warning(o, i) {
    if (!o) {
        typeof console < "u" && console.warn(i);
        try {
            throw new Error(i)
        } catch {}
    }
}
function createKey() {
    return Math.random().toString(36).substr(2, 8)
}
function getHistoryState(o, i) {
    return {
        usr: o.state,
        key: o.key,
        idx: i
    }
}
function createLocation(o, i, s, a) {
    return s === void 0 && (s = null),
    _extends$3({
        pathname: typeof o == "string" ? o : o.pathname,
        search: "",
        hash: ""
    }, typeof i == "string" ? parsePath(i) : i, {
        state: s,
        key: i && i.key || a || createKey()
    })
}
function createPath(o) {
    let {pathname: i="/", search: s="", hash: a=""} = o;
    return s && s !== "?" && (i += s.charAt(0) === "?" ? s : "?" + s),
    a && a !== "#" && (i += a.charAt(0) === "#" ? a : "#" + a),
    i
}
function parsePath(o) {
    let i = {};
    if (o) {
        let s = o.indexOf("#");
        s >= 0 && (i.hash = o.substr(s),
        o = o.substr(0, s));
        let a = o.indexOf("?");
        a >= 0 && (i.search = o.substr(a),
        o = o.substr(0, a)),
        o && (i.pathname = o)
    }
    return i
}
function getUrlBasedHistory(o, i, s, a) {
    a === void 0 && (a = {});
    let {window: _=document.defaultView, v5Compat: $=!1} = a
      , _e = _.history
      , tt = Action.Pop
      , nt = null
      , rt = ot();
    rt == null && (rt = 0,
    _e.replaceState(_extends$3({}, _e.state, {
        idx: rt
    }), ""));
    function ot() {
        return (_e.state || {
            idx: null
        }).idx
    }
    function et() {
        tt = Action.Pop;
        let lt = ot()
          , ct = lt == null ? null : lt - rt;
        rt = lt,
        nt && nt({
            action: tt,
            location: at.location,
            delta: ct
        })
    }
    function j(lt, ct) {
        tt = Action.Push;
        let ut = createLocation(at.location, lt, ct);
        s && s(ut, lt),
        rt = ot() + 1;
        let dt = getHistoryState(ut, rt)
          , ft = at.createHref(ut);
        try {
            _e.pushState(dt, "", ft)
        } catch (ht) {
            if (ht instanceof DOMException && ht.name === "DataCloneError")
                throw ht;
            _.location.assign(ft)
        }
        $ && nt && nt({
            action: tt,
            location: at.location,
            delta: 1
        })
    }
    function it(lt, ct) {
        tt = Action.Replace;
        let ut = createLocation(at.location, lt, ct);
        s && s(ut, lt),
        rt = ot();
        let dt = getHistoryState(ut, rt)
          , ft = at.createHref(ut);
        _e.replaceState(dt, "", ft),
        $ && nt && nt({
            action: tt,
            location: at.location,
            delta: 0
        })
    }
    function st(lt) {
        let ct = _.location.origin !== "null" ? _.location.origin : _.location.href
          , ut = typeof lt == "string" ? lt : createPath(lt);
        return invariant(ct, "No window.location.(origin|href) available to create URL for href: " + ut),
        new URL(ut,ct)
    }
    let at = {
        get action() {
            return tt
        },
        get location() {
            return o(_, _e)
        },
        listen(lt) {
            if (nt)
                throw new Error("A history only accepts one active listener");
            return _.addEventListener(PopStateEventType, et),
            nt = lt,
            () => {
                _.removeEventListener(PopStateEventType, et),
                nt = null
            }
        },
        createHref(lt) {
            return i(_, lt)
        },
        createURL: st,
        encodeLocation(lt) {
            let ct = st(lt);
            return {
                pathname: ct.pathname,
                search: ct.search,
                hash: ct.hash
            }
        },
        push: j,
        replace: it,
        go(lt) {
            return _e.go(lt)
        }
    };
    return at
}
var ResultType;
(function(o) {
    o.data = "data",
    o.deferred = "deferred",
    o.redirect = "redirect",
    o.error = "error"
}
)(ResultType || (ResultType = {}));
const immutableRouteKeys = new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
function isIndexRoute(o) {
    return o.index === !0
}
function convertRoutesToDataRoutes(o, i, s, a) {
    return s === void 0 && (s = []),
    a === void 0 && (a = {}),
    o.map( (_, $) => {
        let _e = [...s, $]
          , tt = typeof _.id == "string" ? _.id : _e.join("-");
        if (invariant(_.index !== !0 || !_.children, "Cannot specify children on an index route"),
        invariant(!a[tt], 'Found a route id collision on id "' + tt + `".  Route id's must be globally unique within Data Router usages`),
        isIndexRoute(_)) {
            let nt = _extends$3({}, _, i(_), {
                id: tt
            });
            return a[tt] = nt,
            nt
        } else {
            let nt = _extends$3({}, _, i(_), {
                id: tt,
                children: void 0
            });
            return a[tt] = nt,
            _.children && (nt.children = convertRoutesToDataRoutes(_.children, i, _e, a)),
            nt
        }
    }
    )
}
function matchRoutes(o, i, s) {
    s === void 0 && (s = "/");
    let a = typeof i == "string" ? parsePath(i) : i
      , _ = stripBasename(a.pathname || "/", s);
    if (_ == null)
        return null;
    let $ = flattenRoutes(o);
    rankRouteBranches($);
    let _e = null;
    for (let tt = 0; _e == null && tt < $.length; ++tt)
        _e = matchRouteBranch($[tt], safelyDecodeURI(_));
    return _e
}
function flattenRoutes(o, i, s, a) {
    i === void 0 && (i = []),
    s === void 0 && (s = []),
    a === void 0 && (a = "");
    let _ = ($, _e, tt) => {
        let nt = {
            relativePath: tt === void 0 ? $.path || "" : tt,
            caseSensitive: $.caseSensitive === !0,
            childrenIndex: _e,
            route: $
        };
        nt.relativePath.startsWith("/") && (invariant(nt.relativePath.startsWith(a), 'Absolute route path "' + nt.relativePath + '" nested under path ' + ('"' + a + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."),
        nt.relativePath = nt.relativePath.slice(a.length));
        let rt = joinPaths([a, nt.relativePath])
          , ot = s.concat(nt);
        $.children && $.children.length > 0 && (invariant($.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + rt + '".')),
        flattenRoutes($.children, i, ot, rt)),
        !($.path == null && !$.index) && i.push({
            path: rt,
            score: computeScore(rt, $.index),
            routesMeta: ot
        })
    }
    ;
    return o.forEach( ($, _e) => {
        var tt;
        if ($.path === "" || !((tt = $.path) != null && tt.includes("?")))
            _($, _e);
        else
            for (let nt of explodeOptionalSegments($.path))
                _($, _e, nt)
    }
    ),
    i
}
function explodeOptionalSegments(o) {
    let i = o.split("/");
    if (i.length === 0)
        return [];
    let[s,...a] = i
      , _ = s.endsWith("?")
      , $ = s.replace(/\?$/, "");
    if (a.length === 0)
        return _ ? [$, ""] : [$];
    let _e = explodeOptionalSegments(a.join("/"))
      , tt = [];
    return tt.push(..._e.map(nt => nt === "" ? $ : [$, nt].join("/"))),
    _ && tt.push(..._e),
    tt.map(nt => o.startsWith("/") && nt === "" ? "/" : nt)
}
function rankRouteBranches(o) {
    o.sort( (i, s) => i.score !== s.score ? s.score - i.score : compareIndexes(i.routesMeta.map(a => a.childrenIndex), s.routesMeta.map(a => a.childrenIndex)))
}
const paramRe = /^:\w+$/
  , dynamicSegmentValue = 3
  , indexRouteValue = 2
  , emptySegmentValue = 1
  , staticSegmentValue = 10
  , splatPenalty = -2
  , isSplat = o => o === "*";
function computeScore(o, i) {
    let s = o.split("/")
      , a = s.length;
    return s.some(isSplat) && (a += splatPenalty),
    i && (a += indexRouteValue),
    s.filter(_ => !isSplat(_)).reduce( (_, $) => _ + (paramRe.test($) ? dynamicSegmentValue : $ === "" ? emptySegmentValue : staticSegmentValue), a)
}
function compareIndexes(o, i) {
    return o.length === i.length && o.slice(0, -1).every( (a, _) => a === i[_]) ? o[o.length - 1] - i[i.length - 1] : 0
}
function matchRouteBranch(o, i) {
    let {routesMeta: s} = o
      , a = {}
      , _ = "/"
      , $ = [];
    for (let _e = 0; _e < s.length; ++_e) {
        let tt = s[_e]
          , nt = _e === s.length - 1
          , rt = _ === "/" ? i : i.slice(_.length) || "/"
          , ot = matchPath({
            path: tt.relativePath,
            caseSensitive: tt.caseSensitive,
            end: nt
        }, rt);
        if (!ot)
            return null;
        Object.assign(a, ot.params);
        let et = tt.route;
        $.push({
            params: a,
            pathname: joinPaths([_, ot.pathname]),
            pathnameBase: normalizePathname(joinPaths([_, ot.pathnameBase])),
            route: et
        }),
        ot.pathnameBase !== "/" && (_ = joinPaths([_, ot.pathnameBase]))
    }
    return $
}
function matchPath(o, i) {
    typeof o == "string" && (o = {
        path: o,
        caseSensitive: !1,
        end: !0
    });
    let[s,a] = compilePath(o.path, o.caseSensitive, o.end)
      , _ = i.match(s);
    if (!_)
        return null;
    let $ = _[0]
      , _e = $.replace(/(.)\/+$/, "$1")
      , tt = _.slice(1);
    return {
        params: a.reduce( (rt, ot, et) => {
            if (ot === "*") {
                let j = tt[et] || "";
                _e = $.slice(0, $.length - j.length).replace(/(.)\/+$/, "$1")
            }
            return rt[ot] = safelyDecodeURIComponent(tt[et] || "", ot),
            rt
        }
        , {}),
        pathname: $,
        pathnameBase: _e,
        pattern: o
    }
}
function compilePath(o, i, s) {
    i === void 0 && (i = !1),
    s === void 0 && (s = !0),
    warning(o === "*" || !o.endsWith("*") || o.endsWith("/*"), 'Route path "' + o + '" will be treated as if it were ' + ('"' + o.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + o.replace(/\*$/, "/*") + '".'));
    let a = []
      , _ = "^" + o.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/\/:(\w+)/g, (_e, tt) => (a.push(tt),
    "/([^\\/]+)"));
    return o.endsWith("*") ? (a.push("*"),
    _ += o === "*" || o === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : s ? _ += "\\/*$" : o !== "" && o !== "/" && (_ += "(?:(?=\\/|$))"),
    [new RegExp(_,i ? void 0 : "i"), a]
}
function safelyDecodeURI(o) {
    try {
        return decodeURI(o)
    } catch (i) {
        return warning(!1, 'The URL path "' + o + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + i + ").")),
        o
    }
}
function safelyDecodeURIComponent(o, i) {
    try {
        return decodeURIComponent(o)
    } catch (s) {
        return warning(!1, 'The value for the URL param "' + i + '" will not be decoded because' + (' the string "' + o + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + s + ").")),
        o
    }
}
function stripBasename(o, i) {
    if (i === "/")
        return o;
    if (!o.toLowerCase().startsWith(i.toLowerCase()))
        return null;
    let s = i.endsWith("/") ? i.length - 1 : i.length
      , a = o.charAt(s);
    return a && a !== "/" ? null : o.slice(s) || "/"
}
function resolvePath(o, i) {
    i === void 0 && (i = "/");
    let {pathname: s, search: a="", hash: _=""} = typeof o == "string" ? parsePath(o) : o;
    return {
        pathname: s ? s.startsWith("/") ? s : resolvePathname(s, i) : i,
        search: normalizeSearch(a),
        hash: normalizeHash(_)
    }
}
function resolvePathname(o, i) {
    let s = i.replace(/\/+$/, "").split("/");
    return o.split("/").forEach(_ => {
        _ === ".." ? s.length > 1 && s.pop() : _ !== "." && s.push(_)
    }
    ),
    s.length > 1 ? s.join("/") : "/"
}
function getInvalidPathError(o, i, s, a) {
    return "Cannot include a '" + o + "' character in a manually specified " + ("`to." + i + "` field [" + JSON.stringify(a) + "].  Please separate it out to the ") + ("`to." + s + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.'
}
function getPathContributingMatches(o) {
    return o.filter( (i, s) => s === 0 || i.route.path && i.route.path.length > 0)
}
function resolveTo(o, i, s, a) {
    a === void 0 && (a = !1);
    let _;
    typeof o == "string" ? _ = parsePath(o) : (_ = _extends$3({}, o),
    invariant(!_.pathname || !_.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", _)),
    invariant(!_.pathname || !_.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", _)),
    invariant(!_.search || !_.search.includes("#"), getInvalidPathError("#", "search", "hash", _)));
    let $ = o === "" || _.pathname === "", _e = $ ? "/" : _.pathname, tt;
    if (a || _e == null)
        tt = s;
    else {
        let et = i.length - 1;
        if (_e.startsWith("..")) {
            let j = _e.split("/");
            for (; j[0] === ".."; )
                j.shift(),
                et -= 1;
            _.pathname = j.join("/")
        }
        tt = et >= 0 ? i[et] : "/"
    }
    let nt = resolvePath(_, tt)
      , rt = _e && _e !== "/" && _e.endsWith("/")
      , ot = ($ || _e === ".") && s.endsWith("/");
    return !nt.pathname.endsWith("/") && (rt || ot) && (nt.pathname += "/"),
    nt
}
const joinPaths = o => o.join("/").replace(/\/\/+/g, "/")
  , normalizePathname = o => o.replace(/\/+$/, "").replace(/^\/*/, "/")
  , normalizeSearch = o => !o || o === "?" ? "" : o.startsWith("?") ? o : "?" + o
  , normalizeHash = o => !o || o === "#" ? "" : o.startsWith("#") ? o : "#" + o;
class ErrorResponse {
    constructor(i, s, a, _) {
        _ === void 0 && (_ = !1),
        this.status = i,
        this.statusText = s || "",
        this.internal = _,
        a instanceof Error ? (this.data = a.toString(),
        this.error = a) : this.data = a
    }
}
function isRouteErrorResponse(o) {
    return o != null && typeof o.status == "number" && typeof o.statusText == "string" && typeof o.internal == "boolean" && "data"in o
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"]
  , validMutationMethods = new Set(validMutationMethodsArr)
  , validRequestMethodsArr = ["get", ...validMutationMethodsArr]
  , validRequestMethods = new Set(validRequestMethodsArr)
  , redirectStatusCodes = new Set([301, 302, 303, 307, 308])
  , redirectPreserveMethodStatusCodes = new Set([307, 308])
  , IDLE_NAVIGATION = {
    state: "idle",
    location: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
}
  , IDLE_FETCHER = {
    state: "idle",
    data: void 0,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
}
  , IDLE_BLOCKER = {
    state: "unblocked",
    proceed: void 0,
    reset: void 0,
    location: void 0
}
  , ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i
  , defaultMapRouteProperties = o => ({
    hasErrorBoundary: !!o.hasErrorBoundary
});
function createRouter(o) {
    const i = o.window ? o.window : typeof window < "u" ? window : void 0
      , s = typeof i < "u" && typeof i.document < "u" && typeof i.document.createElement < "u"
      , a = !s;
    invariant(o.routes.length > 0, "You must provide a non-empty routes array to createRouter");
    let _;
    if (o.mapRouteProperties)
        _ = o.mapRouteProperties;
    else if (o.detectErrorBoundary) {
        let xt = o.detectErrorBoundary;
        _ = Ot => ({
            hasErrorBoundary: xt(Ot)
        })
    } else
        _ = defaultMapRouteProperties;
    let $ = {}, _e = convertRoutesToDataRoutes(o.routes, _, void 0, $), tt, nt = o.basename || "/", rt = _extends$3({
        v7_normalizeFormMethod: !1,
        v7_prependBasename: !1
    }, o.future), ot = null, et = new Set, j = null, it = null, st = null, at = o.hydrationData != null, lt = matchRoutes(_e, o.history.location, nt), ct = null;
    if (lt == null) {
        let xt = getInternalRouterError(404, {
            pathname: o.history.location.pathname
        })
          , {matches: Ot, route: Dt} = getShortCircuitMatches(_e);
        lt = Ot,
        ct = {
            [Dt.id]: xt
        }
    }
    let ut = !lt.some(xt => xt.route.lazy) && (!lt.some(xt => xt.route.loader) || o.hydrationData != null), dt, ft = {
        historyAction: o.history.action,
        location: o.history.location,
        matches: lt,
        initialized: ut,
        navigation: IDLE_NAVIGATION,
        restoreScrollPosition: o.hydrationData != null ? !1 : null,
        preventScrollReset: !1,
        revalidation: "idle",
        loaderData: o.hydrationData && o.hydrationData.loaderData || {},
        actionData: o.hydrationData && o.hydrationData.actionData || null,
        errors: o.hydrationData && o.hydrationData.errors || ct,
        fetchers: new Map,
        blockers: new Map
    }, ht = Action.Pop, pt = !1, gt, _t = !1, mt = !1, yt = [], bt = [], vt = new Map, wt = 0, Tt = -1, $t = new Map, Et = new Set, Pt = new Map, Rt = new Map, At = new Map, Mt = !1;
    function Ut() {
        return ot = o.history.listen(xt => {
            let {action: Ot, location: Dt, delta: Bt} = xt;
            if (Mt) {
                Mt = !1;
                return
            }
            warning(At.size === 0 || Bt != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
            let Wt = Fn({
                currentLocation: ft.location,
                nextLocation: Dt,
                historyAction: Ot
            });
            if (Wt && Bt != null) {
                Mt = !0,
                o.history.go(Bt * -1),
                An(Wt, {
                    state: "blocked",
                    location: Dt,
                    proceed() {
                        An(Wt, {
                            state: "proceeding",
                            proceed: void 0,
                            reset: void 0,
                            location: Dt
                        }),
                        o.history.go(Bt)
                    },
                    reset() {
                        let Zt = new Map(ft.blockers);
                        Zt.set(Wt, IDLE_BLOCKER),
                        Vt({
                            blockers: Zt
                        })
                    }
                });
                return
            }
            return jt(Ot, Dt)
        }
        ),
        ft.initialized || jt(Action.Pop, ft.location),
        dt
    }
    function Lt() {
        ot && ot(),
        et.clear(),
        gt && gt.abort(),
        ft.fetchers.forEach( (xt, Ot) => Nn(Ot)),
        ft.blockers.forEach( (xt, Ot) => kn(Ot))
    }
    function tn(xt) {
        return et.add(xt),
        () => et.delete(xt)
    }
    function Vt(xt) {
        ft = _extends$3({}, ft, xt),
        et.forEach(Ot => Ot(ft))
    }
    function Nt(xt, Ot) {
        var Dt, Bt;
        let Wt = ft.actionData != null && ft.navigation.formMethod != null && isMutationMethod(ft.navigation.formMethod) && ft.navigation.state === "loading" && ((Dt = xt.state) == null ? void 0 : Dt._isRedirect) !== !0, Zt;
        Ot.actionData ? Object.keys(Ot.actionData).length > 0 ? Zt = Ot.actionData : Zt = null : Wt ? Zt = ft.actionData : Zt = null;
        let an = Ot.loaderData ? mergeLoaderData(ft.loaderData, Ot.loaderData, Ot.matches || [], Ot.errors) : ft.loaderData
          , en = ft.blockers;
        en.size > 0 && (en = new Map(en),
        en.forEach( (pn, vn) => en.set(vn, IDLE_BLOCKER)));
        let Jt = pt === !0 || ft.navigation.formMethod != null && isMutationMethod(ft.navigation.formMethod) && ((Bt = xt.state) == null ? void 0 : Bt._isRedirect) !== !0;
        tt && (_e = tt,
        tt = void 0),
        _t || ht === Action.Pop || (ht === Action.Push ? o.history.push(xt, xt.state) : ht === Action.Replace && o.history.replace(xt, xt.state)),
        Vt(_extends$3({}, Ot, {
            actionData: Zt,
            loaderData: an,
            historyAction: ht,
            location: xt,
            initialized: !0,
            navigation: IDLE_NAVIGATION,
            revalidation: "idle",
            restoreScrollPosition: fn(xt, Ot.matches || ft.matches),
            preventScrollReset: Jt,
            blockers: en
        })),
        ht = Action.Pop,
        pt = !1,
        _t = !1,
        mt = !1,
        yt = [],
        bt = []
    }
    async function Yt(xt, Ot) {
        if (typeof xt == "number") {
            o.history.go(xt);
            return
        }
        let Dt = normalizeTo(ft.location, ft.matches, nt, rt.v7_prependBasename, xt, Ot == null ? void 0 : Ot.fromRouteId, Ot == null ? void 0 : Ot.relative)
          , {path: Bt, submission: Wt, error: Zt} = normalizeNavigateOptions(rt.v7_normalizeFormMethod, !1, Dt, Ot)
          , an = ft.location
          , en = createLocation(ft.location, Bt, Ot && Ot.state);
        en = _extends$3({}, en, o.history.encodeLocation(en));
        let Jt = Ot && Ot.replace != null ? Ot.replace : void 0
          , pn = Action.Push;
        Jt === !0 ? pn = Action.Replace : Jt === !1 || Wt != null && isMutationMethod(Wt.formMethod) && Wt.formAction === ft.location.pathname + ft.location.search && (pn = Action.Replace);
        let vn = Ot && "preventScrollReset"in Ot ? Ot.preventScrollReset === !0 : void 0
          , hn = Fn({
            currentLocation: an,
            nextLocation: en,
            historyAction: pn
        });
        if (hn) {
            An(hn, {
                state: "blocked",
                location: en,
                proceed() {
                    An(hn, {
                        state: "proceeding",
                        proceed: void 0,
                        reset: void 0,
                        location: en
                    }),
                    Yt(xt, Ot)
                },
                reset() {
                    let Ft = new Map(ft.blockers);
                    Ft.set(hn, IDLE_BLOCKER),
                    Vt({
                        blockers: Ft
                    })
                }
            });
            return
        }
        return await jt(pn, en, {
            submission: Wt,
            pendingError: Zt,
            preventScrollReset: vn,
            replace: Ot && Ot.replace
        })
    }
    function Xt() {
        if (bn(),
        Vt({
            revalidation: "loading"
        }),
        ft.navigation.state !== "submitting") {
            if (ft.navigation.state === "idle") {
                jt(ft.historyAction, ft.location, {
                    startUninterruptedRevalidation: !0
                });
                return
            }
            jt(ht || ft.historyAction, ft.navigation.location, {
                overrideNavigation: ft.navigation
            })
        }
    }
    async function jt(xt, Ot, Dt) {
        gt && gt.abort(),
        gt = null,
        ht = xt,
        _t = (Dt && Dt.startUninterruptedRevalidation) === !0,
        Mn(ft.location, ft.matches),
        pt = (Dt && Dt.preventScrollReset) === !0;
        let Bt = tt || _e
          , Wt = Dt && Dt.overrideNavigation
          , Zt = matchRoutes(Bt, Ot, nt);
        if (!Zt) {
            let Ft = getInternalRouterError(404, {
                pathname: Ot.pathname
            })
              , {matches: Qt, route: yn} = getShortCircuitMatches(Bt);
            On(),
            Nt(Ot, {
                matches: Qt,
                loaderData: {},
                errors: {
                    [yn.id]: Ft
                }
            });
            return
        }
        if (ft.initialized && !mt && isHashChangeOnly(ft.location, Ot) && !(Dt && Dt.submission && isMutationMethod(Dt.submission.formMethod))) {
            Nt(Ot, {
                matches: Zt
            });
            return
        }
        gt = new AbortController;
        let an = createClientSideRequest(o.history, Ot, gt.signal, Dt && Dt.submission), en, Jt;
        if (Dt && Dt.pendingError)
            Jt = {
                [findNearestBoundary(Zt).route.id]: Dt.pendingError
            };
        else if (Dt && Dt.submission && isMutationMethod(Dt.submission.formMethod)) {
            let Ft = await Gt(an, Ot, Dt.submission, Zt, {
                replace: Dt.replace
            });
            if (Ft.shortCircuited)
                return;
            en = Ft.pendingActionData,
            Jt = Ft.pendingActionError,
            Wt = getLoadingNavigation(Ot, Dt.submission),
            an = new Request(an.url,{
                signal: an.signal
            })
        }
        let {shortCircuited: pn, loaderData: vn, errors: hn} = await Kt(an, Ot, Zt, Wt, Dt && Dt.submission, Dt && Dt.fetcherSubmission, Dt && Dt.replace, en, Jt);
        pn || (gt = null,
        Nt(Ot, _extends$3({
            matches: Zt
        }, en ? {
            actionData: en
        } : {}, {
            loaderData: vn,
            errors: hn
        })))
    }
    async function Gt(xt, Ot, Dt, Bt, Wt) {
        Wt === void 0 && (Wt = {}),
        bn();
        let Zt = getSubmittingNavigation(Ot, Dt);
        Vt({
            navigation: Zt
        });
        let an, en = getTargetMatch(Bt, Ot);
        if (!en.route.action && !en.route.lazy)
            an = {
                type: ResultType.error,
                error: getInternalRouterError(405, {
                    method: xt.method,
                    pathname: Ot.pathname,
                    routeId: en.route.id
                })
            };
        else if (an = await callLoaderOrAction("action", xt, en, Bt, $, _, nt),
        xt.signal.aborted)
            return {
                shortCircuited: !0
            };
        if (isRedirectResult(an)) {
            let Jt;
            return Wt && Wt.replace != null ? Jt = Wt.replace : Jt = an.location === ft.location.pathname + ft.location.search,
            await mn(ft, an, {
                submission: Dt,
                replace: Jt
            }),
            {
                shortCircuited: !0
            }
        }
        if (isErrorResult(an)) {
            let Jt = findNearestBoundary(Bt, en.route.id);
            return (Wt && Wt.replace) !== !0 && (ht = Action.Push),
            {
                pendingActionData: {},
                pendingActionError: {
                    [Jt.route.id]: an.error
                }
            }
        }
        if (isDeferredResult(an))
            throw getInternalRouterError(400, {
                type: "defer-action"
            });
        return {
            pendingActionData: {
                [en.route.id]: an.data
            }
        }
    }
    async function Kt(xt, Ot, Dt, Bt, Wt, Zt, an, en, Jt) {
        let pn = Bt || getLoadingNavigation(Ot, Wt)
          , vn = Wt || Zt || getSubmissionFromNavigation(pn)
          , hn = tt || _e
          , [Ft,Qt] = getMatchesToLoad(o.history, ft, Dt, vn, Ot, mt, yt, bt, Pt, Et, hn, nt, en, Jt);
        if (On(Tn => !(Dt && Dt.some(sn => sn.route.id === Tn)) || Ft && Ft.some(sn => sn.route.id === Tn)),
        Tt = ++wt,
        Ft.length === 0 && Qt.length === 0) {
            let Tn = gn();
            return Nt(Ot, _extends$3({
                matches: Dt,
                loaderData: {},
                errors: Jt || null
            }, en ? {
                actionData: en
            } : {}, Tn ? {
                fetchers: new Map(ft.fetchers)
            } : {})),
            {
                shortCircuited: !0
            }
        }
        if (!_t) {
            Qt.forEach(sn => {
                let un = ft.fetchers.get(sn.key)
                  , Bn = getLoadingFetcher(void 0, un ? un.data : void 0);
                ft.fetchers.set(sn.key, Bn)
            }
            );
            let Tn = en || ft.actionData;
            Vt(_extends$3({
                navigation: pn
            }, Tn ? Object.keys(Tn).length === 0 ? {
                actionData: null
            } : {
                actionData: Tn
            } : {}, Qt.length > 0 ? {
                fetchers: new Map(ft.fetchers)
            } : {}))
        }
        Qt.forEach(Tn => {
            vt.has(Tn.key) && cn(Tn.key),
            Tn.controller && vt.set(Tn.key, Tn.controller)
        }
        );
        let yn = () => Qt.forEach(Tn => cn(Tn.key));
        gt && gt.signal.addEventListener("abort", yn);
        let {results: wn, loaderResults: Ln, fetcherResults: Hn} = await Sn(ft.matches, Dt, Ft, Qt, xt);
        if (xt.signal.aborted)
            return {
                shortCircuited: !0
            };
        gt && gt.signal.removeEventListener("abort", yn),
        Qt.forEach(Tn => vt.delete(Tn.key));
        let Rn = findRedirect(wn);
        if (Rn) {
            if (Rn.idx >= Ft.length) {
                let Tn = Qt[Rn.idx - Ft.length].key;
                Et.add(Tn)
            }
            return await mn(ft, Rn.result, {
                replace: an
            }),
            {
                shortCircuited: !0
            }
        }
        let {loaderData: Cn, errors: zn} = processLoaderData(ft, Dt, Ft, Ln, Jt, Qt, Hn, Rt);
        Rt.forEach( (Tn, sn) => {
            Tn.subscribe(un => {
                (un || Tn.done) && Rt.delete(sn)
            }
            )
        }
        );
        let qn = gn()
          , Qn = dn(Tt)
          , er = qn || Qn || Qt.length > 0;
        return _extends$3({
            loaderData: Cn,
            errors: zn
        }, er ? {
            fetchers: new Map(ft.fetchers)
        } : {})
    }
    function qt(xt) {
        return ft.fetchers.get(xt) || IDLE_FETCHER
    }
    function rn(xt, Ot, Dt, Bt) {
        if (a)
            throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
        vt.has(xt) && cn(xt);
        let Wt = tt || _e
          , Zt = normalizeTo(ft.location, ft.matches, nt, rt.v7_prependBasename, Dt, Ot, Bt == null ? void 0 : Bt.relative)
          , an = matchRoutes(Wt, Zt, nt);
        if (!an) {
            In(xt, Ot, getInternalRouterError(404, {
                pathname: Zt
            }));
            return
        }
        let {path: en, submission: Jt, error: pn} = normalizeNavigateOptions(rt.v7_normalizeFormMethod, !0, Zt, Bt);
        if (pn) {
            In(xt, Ot, pn);
            return
        }
        let vn = getTargetMatch(an, en);
        if (pt = (Bt && Bt.preventScrollReset) === !0,
        Jt && isMutationMethod(Jt.formMethod)) {
            on(xt, Ot, en, vn, an, Jt);
            return
        }
        Pt.set(xt, {
            routeId: Ot,
            path: en
        }),
        _n(xt, Ot, en, vn, an, Jt)
    }
    async function on(xt, Ot, Dt, Bt, Wt, Zt) {
        if (bn(),
        Pt.delete(xt),
        !Bt.route.action && !Bt.route.lazy) {
            let En = getInternalRouterError(405, {
                method: Zt.formMethod,
                pathname: Dt,
                routeId: Ot
            });
            In(xt, Ot, En);
            return
        }
        let an = ft.fetchers.get(xt)
          , en = getSubmittingFetcher(Zt, an);
        ft.fetchers.set(xt, en),
        Vt({
            fetchers: new Map(ft.fetchers)
        });
        let Jt = new AbortController
          , pn = createClientSideRequest(o.history, Dt, Jt.signal, Zt);
        vt.set(xt, Jt);
        let vn = wt
          , hn = await callLoaderOrAction("action", pn, Bt, Wt, $, _, nt);
        if (pn.signal.aborted) {
            vt.get(xt) === Jt && vt.delete(xt);
            return
        }
        if (isRedirectResult(hn))
            if (vt.delete(xt),
            Tt > vn) {
                let En = getDoneFetcher(void 0);
                ft.fetchers.set(xt, En),
                Vt({
                    fetchers: new Map(ft.fetchers)
                });
                return
            } else {
                Et.add(xt);
                let En = getLoadingFetcher(Zt);
                return ft.fetchers.set(xt, En),
                Vt({
                    fetchers: new Map(ft.fetchers)
                }),
                mn(ft, hn, {
                    submission: Zt,
                    isFetchActionRedirect: !0
                })
            }
        if (isErrorResult(hn)) {
            In(xt, Ot, hn.error);
            return
        }
        if (isDeferredResult(hn))
            throw getInternalRouterError(400, {
                type: "defer-action"
            });
        let Ft = ft.navigation.location || ft.location
          , Qt = createClientSideRequest(o.history, Ft, Jt.signal)
          , yn = tt || _e
          , wn = ft.navigation.state !== "idle" ? matchRoutes(yn, ft.navigation.location, nt) : ft.matches;
        invariant(wn, "Didn't find any matches after fetcher action");
        let Ln = ++wt;
        $t.set(xt, Ln);
        let Hn = getLoadingFetcher(Zt, hn.data);
        ft.fetchers.set(xt, Hn);
        let[Rn,Cn] = getMatchesToLoad(o.history, ft, wn, Zt, Ft, mt, yt, bt, Pt, Et, yn, nt, {
            [Bt.route.id]: hn.data
        }, void 0);
        Cn.filter(En => En.key !== xt).forEach(En => {
            let Jn = En.key
              , rr = ft.fetchers.get(Jn)
              , ir = getLoadingFetcher(void 0, rr ? rr.data : void 0);
            ft.fetchers.set(Jn, ir),
            vt.has(Jn) && cn(Jn),
            En.controller && vt.set(Jn, En.controller)
        }
        ),
        Vt({
            fetchers: new Map(ft.fetchers)
        });
        let zn = () => Cn.forEach(En => cn(En.key));
        Jt.signal.addEventListener("abort", zn);
        let {results: qn, loaderResults: Qn, fetcherResults: er} = await Sn(ft.matches, wn, Rn, Cn, Qt);
        if (Jt.signal.aborted)
            return;
        Jt.signal.removeEventListener("abort", zn),
        $t.delete(xt),
        vt.delete(xt),
        Cn.forEach(En => vt.delete(En.key));
        let Tn = findRedirect(qn);
        if (Tn) {
            if (Tn.idx >= Rn.length) {
                let En = Cn[Tn.idx - Rn.length].key;
                Et.add(En)
            }
            return mn(ft, Tn.result)
        }
        let {loaderData: sn, errors: un} = processLoaderData(ft, ft.matches, Rn, Qn, void 0, Cn, er, Rt);
        if (ft.fetchers.has(xt)) {
            let En = getDoneFetcher(hn.data);
            ft.fetchers.set(xt, En)
        }
        let Bn = dn(Ln);
        ft.navigation.state === "loading" && Ln > Tt ? (invariant(ht, "Expected pending action"),
        gt && gt.abort(),
        Nt(ft.navigation.location, {
            matches: wn,
            loaderData: sn,
            errors: un,
            fetchers: new Map(ft.fetchers)
        })) : (Vt(_extends$3({
            errors: un,
            loaderData: mergeLoaderData(ft.loaderData, sn, wn, un)
        }, Bn || Cn.length > 0 ? {
            fetchers: new Map(ft.fetchers)
        } : {})),
        mt = !1)
    }
    async function _n(xt, Ot, Dt, Bt, Wt, Zt) {
        let an = ft.fetchers.get(xt)
          , en = getLoadingFetcher(Zt, an ? an.data : void 0);
        ft.fetchers.set(xt, en),
        Vt({
            fetchers: new Map(ft.fetchers)
        });
        let Jt = new AbortController
          , pn = createClientSideRequest(o.history, Dt, Jt.signal);
        vt.set(xt, Jt);
        let vn = wt
          , hn = await callLoaderOrAction("loader", pn, Bt, Wt, $, _, nt);
        if (isDeferredResult(hn) && (hn = await resolveDeferredData(hn, pn.signal, !0) || hn),
        vt.get(xt) === Jt && vt.delete(xt),
        pn.signal.aborted)
            return;
        if (isRedirectResult(hn))
            if (Tt > vn) {
                let Qt = getDoneFetcher(void 0);
                ft.fetchers.set(xt, Qt),
                Vt({
                    fetchers: new Map(ft.fetchers)
                });
                return
            } else {
                Et.add(xt),
                await mn(ft, hn);
                return
            }
        if (isErrorResult(hn)) {
            let Qt = findNearestBoundary(ft.matches, Ot);
            ft.fetchers.delete(xt),
            Vt({
                fetchers: new Map(ft.fetchers),
                errors: {
                    [Qt.route.id]: hn.error
                }
            });
            return
        }
        invariant(!isDeferredResult(hn), "Unhandled fetcher deferred data");
        let Ft = getDoneFetcher(hn.data);
        ft.fetchers.set(xt, Ft),
        Vt({
            fetchers: new Map(ft.fetchers)
        })
    }
    async function mn(xt, Ot, Dt) {
        let {submission: Bt, replace: Wt, isFetchActionRedirect: Zt} = Dt === void 0 ? {} : Dt;
        Ot.revalidate && (mt = !0);
        let an = createLocation(xt.location, Ot.location, _extends$3({
            _isRedirect: !0
        }, Zt ? {
            _isFetchActionRedirect: !0
        } : {}));
        if (invariant(an, "Expected a location on the redirect navigation"),
        s) {
            let pn = !1;
            if (Ot.reloadDocument)
                pn = !0;
            else if (ABSOLUTE_URL_REGEX.test(Ot.location)) {
                const vn = o.history.createURL(Ot.location);
                pn = vn.origin !== i.location.origin || stripBasename(vn.pathname, nt) == null
            }
            if (pn) {
                Wt ? i.location.replace(Ot.location) : i.location.assign(Ot.location);
                return
            }
        }
        gt = null;
        let en = Wt === !0 ? Action.Replace : Action.Push
          , Jt = Bt || getSubmissionFromNavigation(xt.navigation);
        if (redirectPreserveMethodStatusCodes.has(Ot.status) && Jt && isMutationMethod(Jt.formMethod))
            await jt(en, an, {
                submission: _extends$3({}, Jt, {
                    formAction: Ot.location
                }),
                preventScrollReset: pt
            });
        else if (Zt)
            await jt(en, an, {
                overrideNavigation: getLoadingNavigation(an),
                fetcherSubmission: Jt,
                preventScrollReset: pt
            });
        else {
            let pn = getLoadingNavigation(an, Jt);
            await jt(en, an, {
                overrideNavigation: pn,
                preventScrollReset: pt
            })
        }
    }
    async function Sn(xt, Ot, Dt, Bt, Wt) {
        let Zt = await Promise.all([...Dt.map(Jt => callLoaderOrAction("loader", Wt, Jt, Ot, $, _, nt)), ...Bt.map(Jt => Jt.matches && Jt.match && Jt.controller ? callLoaderOrAction("loader", createClientSideRequest(o.history, Jt.path, Jt.controller.signal), Jt.match, Jt.matches, $, _, nt) : {
            type: ResultType.error,
            error: getInternalRouterError(404, {
                pathname: Jt.path
            })
        })])
          , an = Zt.slice(0, Dt.length)
          , en = Zt.slice(Dt.length);
        return await Promise.all([resolveDeferredResults(xt, Dt, an, an.map( () => Wt.signal), !1, ft.loaderData), resolveDeferredResults(xt, Bt.map(Jt => Jt.match), en, Bt.map(Jt => Jt.controller ? Jt.controller.signal : null), !0)]),
        {
            results: Zt,
            loaderResults: an,
            fetcherResults: en
        }
    }
    function bn() {
        mt = !0,
        yt.push(...On()),
        Pt.forEach( (xt, Ot) => {
            vt.has(Ot) && (bt.push(Ot),
            cn(Ot))
        }
        )
    }
    function In(xt, Ot, Dt) {
        let Bt = findNearestBoundary(ft.matches, Ot);
        Nn(xt),
        Vt({
            errors: {
                [Bt.route.id]: Dt
            },
            fetchers: new Map(ft.fetchers)
        })
    }
    function Nn(xt) {
        let Ot = ft.fetchers.get(xt);
        vt.has(xt) && !(Ot && Ot.state === "loading" && $t.has(xt)) && cn(xt),
        Pt.delete(xt),
        $t.delete(xt),
        Et.delete(xt),
        ft.fetchers.delete(xt)
    }
    function cn(xt) {
        let Ot = vt.get(xt);
        invariant(Ot, "Expected fetch controller: " + xt),
        Ot.abort(),
        vt.delete(xt)
    }
    function $n(xt) {
        for (let Ot of xt) {
            let Dt = qt(Ot)
              , Bt = getDoneFetcher(Dt.data);
            ft.fetchers.set(Ot, Bt)
        }
    }
    function gn() {
        let xt = []
          , Ot = !1;
        for (let Dt of Et) {
            let Bt = ft.fetchers.get(Dt);
            invariant(Bt, "Expected fetcher: " + Dt),
            Bt.state === "loading" && (Et.delete(Dt),
            xt.push(Dt),
            Ot = !0)
        }
        return $n(xt),
        Ot
    }
    function dn(xt) {
        let Ot = [];
        for (let[Dt,Bt] of $t)
            if (Bt < xt) {
                let Wt = ft.fetchers.get(Dt);
                invariant(Wt, "Expected fetcher: " + Dt),
                Wt.state === "loading" && (cn(Dt),
                $t.delete(Dt),
                Ot.push(Dt))
            }
        return $n(Ot),
        Ot.length > 0
    }
    function Dn(xt, Ot) {
        let Dt = ft.blockers.get(xt) || IDLE_BLOCKER;
        return At.get(xt) !== Ot && At.set(xt, Ot),
        Dt
    }
    function kn(xt) {
        ft.blockers.delete(xt),
        At.delete(xt)
    }
    function An(xt, Ot) {
        let Dt = ft.blockers.get(xt) || IDLE_BLOCKER;
        invariant(Dt.state === "unblocked" && Ot.state === "blocked" || Dt.state === "blocked" && Ot.state === "blocked" || Dt.state === "blocked" && Ot.state === "proceeding" || Dt.state === "blocked" && Ot.state === "unblocked" || Dt.state === "proceeding" && Ot.state === "unblocked", "Invalid blocker state transition: " + Dt.state + " -> " + Ot.state);
        let Bt = new Map(ft.blockers);
        Bt.set(xt, Ot),
        Vt({
            blockers: Bt
        })
    }
    function Fn(xt) {
        let {currentLocation: Ot, nextLocation: Dt, historyAction: Bt} = xt;
        if (At.size === 0)
            return;
        At.size > 1 && warning(!1, "A router only supports one blocker at a time");
        let Wt = Array.from(At.entries())
          , [Zt,an] = Wt[Wt.length - 1]
          , en = ft.blockers.get(Zt);
        if (!(en && en.state === "proceeding") && an({
            currentLocation: Ot,
            nextLocation: Dt,
            historyAction: Bt
        }))
            return Zt
    }
    function On(xt) {
        let Ot = [];
        return Rt.forEach( (Dt, Bt) => {
            (!xt || xt(Bt)) && (Dt.cancel(),
            Ot.push(Bt),
            Rt.delete(Bt))
        }
        ),
        Ot
    }
    function jn(xt, Ot, Dt) {
        if (j = xt,
        st = Ot,
        it = Dt || null,
        !at && ft.navigation === IDLE_NAVIGATION) {
            at = !0;
            let Bt = fn(ft.location, ft.matches);
            Bt != null && Vt({
                restoreScrollPosition: Bt
            })
        }
        return () => {
            j = null,
            st = null,
            it = null
        }
    }
    function Vn(xt, Ot) {
        return it && it(xt, Ot.map(Bt => createUseMatchesMatch(Bt, ft.loaderData))) || xt.key
    }
    function Mn(xt, Ot) {
        if (j && st) {
            let Dt = Vn(xt, Ot);
            j[Dt] = st()
        }
    }
    function fn(xt, Ot) {
        if (j) {
            let Dt = Vn(xt, Ot)
              , Bt = j[Dt];
            if (typeof Bt == "number")
                return Bt
        }
        return null
    }
    function It(xt) {
        $ = {},
        tt = convertRoutesToDataRoutes(xt, _, void 0, $)
    }
    return dt = {
        get basename() {
            return nt
        },
        get state() {
            return ft
        },
        get routes() {
            return _e
        },
        initialize: Ut,
        subscribe: tn,
        enableScrollRestoration: jn,
        navigate: Yt,
        fetch: rn,
        revalidate: Xt,
        createHref: xt => o.history.createHref(xt),
        encodeLocation: xt => o.history.encodeLocation(xt),
        getFetcher: qt,
        deleteFetcher: Nn,
        dispose: Lt,
        getBlocker: Dn,
        deleteBlocker: kn,
        _internalFetchControllers: vt,
        _internalActiveDeferreds: Rt,
        _internalSetRoutes: It
    },
    dt
}
function isSubmissionNavigation(o) {
    return o != null && ("formData"in o && o.formData != null || "body"in o && o.body !== void 0)
}
function normalizeTo(o, i, s, a, _, $, _e) {
    let tt, nt;
    if ($ != null && _e !== "path") {
        tt = [];
        for (let ot of i)
            if (tt.push(ot),
            ot.route.id === $) {
                nt = ot;
                break
            }
    } else
        tt = i,
        nt = i[i.length - 1];
    let rt = resolveTo(_ || ".", getPathContributingMatches(tt).map(ot => ot.pathnameBase), stripBasename(o.pathname, s) || o.pathname, _e === "path");
    return _ == null && (rt.search = o.search,
    rt.hash = o.hash),
    (_ == null || _ === "" || _ === ".") && nt && nt.route.index && !hasNakedIndexQuery(rt.search) && (rt.search = rt.search ? rt.search.replace(/^\?/, "?index&") : "?index"),
    a && s !== "/" && (rt.pathname = rt.pathname === "/" ? s : joinPaths([s, rt.pathname])),
    createPath(rt)
}
function normalizeNavigateOptions(o, i, s, a) {
    if (!a || !isSubmissionNavigation(a))
        return {
            path: s
        };
    if (a.formMethod && !isValidMethod(a.formMethod))
        return {
            path: s,
            error: getInternalRouterError(405, {
                method: a.formMethod
            })
        };
    let _ = () => ({
        path: s,
        error: getInternalRouterError(400, {
            type: "invalid-body"
        })
    })
      , $ = a.formMethod || "get"
      , _e = o ? $.toUpperCase() : $.toLowerCase()
      , tt = stripHashFromPath(s);
    if (a.body !== void 0) {
        if (a.formEncType === "text/plain") {
            if (!isMutationMethod(_e))
                return _();
            let j = typeof a.body == "string" ? a.body : a.body instanceof FormData || a.body instanceof URLSearchParams ? Array.from(a.body.entries()).reduce( (it, st) => {
                let[at,lt] = st;
                return "" + it + at + "=" + lt + `
`
            }
            , "") : String(a.body);
            return {
                path: s,
                submission: {
                    formMethod: _e,
                    formAction: tt,
                    formEncType: a.formEncType,
                    formData: void 0,
                    json: void 0,
                    text: j
                }
            }
        } else if (a.formEncType === "application/json") {
            if (!isMutationMethod(_e))
                return _();
            try {
                let j = typeof a.body == "string" ? JSON.parse(a.body) : a.body;
                return {
                    path: s,
                    submission: {
                        formMethod: _e,
                        formAction: tt,
                        formEncType: a.formEncType,
                        formData: void 0,
                        json: j,
                        text: void 0
                    }
                }
            } catch {
                return _()
            }
        }
    }
    invariant(typeof FormData == "function", "FormData is not available in this environment");
    let nt, rt;
    if (a.formData)
        nt = convertFormDataToSearchParams(a.formData),
        rt = a.formData;
    else if (a.body instanceof FormData)
        nt = convertFormDataToSearchParams(a.body),
        rt = a.body;
    else if (a.body instanceof URLSearchParams)
        nt = a.body,
        rt = convertSearchParamsToFormData(nt);
    else if (a.body == null)
        nt = new URLSearchParams,
        rt = new FormData;
    else
        try {
            nt = new URLSearchParams(a.body),
            rt = convertSearchParamsToFormData(nt)
        } catch {
            return _()
        }
    let ot = {
        formMethod: _e,
        formAction: tt,
        formEncType: a && a.formEncType || "application/x-www-form-urlencoded",
        formData: rt,
        json: void 0,
        text: void 0
    };
    if (isMutationMethod(ot.formMethod))
        return {
            path: s,
            submission: ot
        };
    let et = parsePath(s);
    return i && et.search && hasNakedIndexQuery(et.search) && nt.append("index", ""),
    et.search = "?" + nt,
    {
        path: createPath(et),
        submission: ot
    }
}
function getLoaderMatchesUntilBoundary(o, i) {
    let s = o;
    if (i) {
        let a = o.findIndex(_ => _.route.id === i);
        a >= 0 && (s = o.slice(0, a))
    }
    return s
}
function getMatchesToLoad(o, i, s, a, _, $, _e, tt, nt, rt, ot, et, j, it) {
    let st = it ? Object.values(it)[0] : j ? Object.values(j)[0] : void 0
      , at = o.createURL(i.location)
      , lt = o.createURL(_)
      , ct = it ? Object.keys(it)[0] : void 0
      , dt = getLoaderMatchesUntilBoundary(s, ct).filter( (ht, pt) => {
        if (ht.route.lazy)
            return !0;
        if (ht.route.loader == null)
            return !1;
        if (isNewLoader(i.loaderData, i.matches[pt], ht) || _e.some(mt => mt === ht.route.id))
            return !0;
        let gt = i.matches[pt]
          , _t = ht;
        return shouldRevalidateLoader(ht, _extends$3({
            currentUrl: at,
            currentParams: gt.params,
            nextUrl: lt,
            nextParams: _t.params
        }, a, {
            actionResult: st,
            defaultShouldRevalidate: $ || at.pathname + at.search === lt.pathname + lt.search || at.search !== lt.search || isNewRouteInstance(gt, _t)
        }))
    }
    )
      , ft = [];
    return nt.forEach( (ht, pt) => {
        if (!s.some(bt => bt.route.id === ht.routeId))
            return;
        let gt = matchRoutes(ot, ht.path, et);
        if (!gt) {
            ft.push({
                key: pt,
                routeId: ht.routeId,
                path: ht.path,
                matches: null,
                match: null,
                controller: null
            });
            return
        }
        let _t = i.fetchers.get(pt)
          , mt = getTargetMatch(gt, ht.path)
          , yt = !1;
        rt.has(pt) ? yt = !1 : tt.includes(pt) ? yt = !0 : _t && _t.state !== "idle" && _t.data === void 0 ? yt = $ : yt = shouldRevalidateLoader(mt, _extends$3({
            currentUrl: at,
            currentParams: i.matches[i.matches.length - 1].params,
            nextUrl: lt,
            nextParams: s[s.length - 1].params
        }, a, {
            actionResult: st,
            defaultShouldRevalidate: $
        })),
        yt && ft.push({
            key: pt,
            routeId: ht.routeId,
            path: ht.path,
            matches: gt,
            match: mt,
            controller: new AbortController
        })
    }
    ),
    [dt, ft]
}
function isNewLoader(o, i, s) {
    let a = !i || s.route.id !== i.route.id
      , _ = o[s.route.id] === void 0;
    return a || _
}
function isNewRouteInstance(o, i) {
    let s = o.route.path;
    return o.pathname !== i.pathname || s != null && s.endsWith("*") && o.params["*"] !== i.params["*"]
}
function shouldRevalidateLoader(o, i) {
    if (o.route.shouldRevalidate) {
        let s = o.route.shouldRevalidate(i);
        if (typeof s == "boolean")
            return s
    }
    return i.defaultShouldRevalidate
}
async function loadLazyRouteModule(o, i, s) {
    if (!o.lazy)
        return;
    let a = await o.lazy();
    if (!o.lazy)
        return;
    let _ = s[o.id];
    invariant(_, "No route found in manifest");
    let $ = {};
    for (let _e in a) {
        let nt = _[_e] !== void 0 && _e !== "hasErrorBoundary";
        warning(!nt, 'Route "' + _.id + '" has a static property "' + _e + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + _e + '" will be ignored.')),
        !nt && !immutableRouteKeys.has(_e) && ($[_e] = a[_e])
    }
    Object.assign(_, $),
    Object.assign(_, _extends$3({}, i(_), {
        lazy: void 0
    }))
}
async function callLoaderOrAction(o, i, s, a, _, $, _e, tt) {
    tt === void 0 && (tt = {});
    let nt, rt, ot, et = st => {
        let at, lt = new Promise( (ct, ut) => at = ut);
        return ot = () => at(),
        i.signal.addEventListener("abort", ot),
        Promise.race([st({
            request: i,
            params: s.params,
            context: tt.requestContext
        }), lt])
    }
    ;
    try {
        let st = s.route[o];
        if (s.route.lazy)
            if (st)
                rt = (await Promise.all([et(st), loadLazyRouteModule(s.route, $, _)]))[0];
            else if (await loadLazyRouteModule(s.route, $, _),
            st = s.route[o],
            st)
                rt = await et(st);
            else if (o === "action") {
                let at = new URL(i.url)
                  , lt = at.pathname + at.search;
                throw getInternalRouterError(405, {
                    method: i.method,
                    pathname: lt,
                    routeId: s.route.id
                })
            } else
                return {
                    type: ResultType.data,
                    data: void 0
                };
        else if (st)
            rt = await et(st);
        else {
            let at = new URL(i.url)
              , lt = at.pathname + at.search;
            throw getInternalRouterError(404, {
                pathname: lt
            })
        }
        invariant(rt !== void 0, "You defined " + (o === "action" ? "an action" : "a loader") + " for route " + ('"' + s.route.id + "\" but didn't return anything from your `" + o + "` ") + "function. Please return a value or `null`.")
    } catch (st) {
        nt = ResultType.error,
        rt = st
    } finally {
        ot && i.signal.removeEventListener("abort", ot)
    }
    if (isResponse(rt)) {
        let st = rt.status;
        if (redirectStatusCodes.has(st)) {
            let ct = rt.headers.get("Location");
            if (invariant(ct, "Redirects returned/thrown from loaders/actions must have a Location header"),
            !ABSOLUTE_URL_REGEX.test(ct))
                ct = normalizeTo(new URL(i.url), a.slice(0, a.indexOf(s) + 1), _e, !0, ct);
            else if (!tt.isStaticRequest) {
                let ut = new URL(i.url)
                  , dt = ct.startsWith("//") ? new URL(ut.protocol + ct) : new URL(ct)
                  , ft = stripBasename(dt.pathname, _e) != null;
                dt.origin === ut.origin && ft && (ct = dt.pathname + dt.search + dt.hash)
            }
            if (tt.isStaticRequest)
                throw rt.headers.set("Location", ct),
                rt;
            return {
                type: ResultType.redirect,
                status: st,
                location: ct,
                revalidate: rt.headers.get("X-Remix-Revalidate") !== null,
                reloadDocument: rt.headers.get("X-Remix-Reload-Document") !== null
            }
        }
        if (tt.isRouteRequest)
            throw {
                type: nt === ResultType.error ? ResultType.error : ResultType.data,
                response: rt
            };
        let at, lt = rt.headers.get("Content-Type");
        return lt && /\bapplication\/json\b/.test(lt) ? at = await rt.json() : at = await rt.text(),
        nt === ResultType.error ? {
            type: nt,
            error: new ErrorResponse(st,rt.statusText,at),
            headers: rt.headers
        } : {
            type: ResultType.data,
            data: at,
            statusCode: rt.status,
            headers: rt.headers
        }
    }
    if (nt === ResultType.error)
        return {
            type: nt,
            error: rt
        };
    if (isDeferredData(rt)) {
        var j, it;
        return {
            type: ResultType.deferred,
            deferredData: rt,
            statusCode: (j = rt.init) == null ? void 0 : j.status,
            headers: ((it = rt.init) == null ? void 0 : it.headers) && new Headers(rt.init.headers)
        }
    }
    return {
        type: ResultType.data,
        data: rt
    }
}
function createClientSideRequest(o, i, s, a) {
    let _ = o.createURL(stripHashFromPath(i)).toString()
      , $ = {
        signal: s
    };
    if (a && isMutationMethod(a.formMethod)) {
        let {formMethod: _e, formEncType: tt} = a;
        $.method = _e.toUpperCase(),
        tt === "application/json" ? ($.headers = new Headers({
            "Content-Type": tt
        }),
        $.body = JSON.stringify(a.json)) : tt === "text/plain" ? $.body = a.text : tt === "application/x-www-form-urlencoded" && a.formData ? $.body = convertFormDataToSearchParams(a.formData) : $.body = a.formData
    }
    return new Request(_,$)
}
function convertFormDataToSearchParams(o) {
    let i = new URLSearchParams;
    for (let[s,a] of o.entries())
        i.append(s, typeof a == "string" ? a : a.name);
    return i
}
function convertSearchParamsToFormData(o) {
    let i = new FormData;
    for (let[s,a] of o.entries())
        i.append(s, a);
    return i
}
function processRouteLoaderData(o, i, s, a, _) {
    let $ = {}, _e = null, tt, nt = !1, rt = {};
    return s.forEach( (ot, et) => {
        let j = i[et].route.id;
        if (invariant(!isRedirectResult(ot), "Cannot handle redirect results in processLoaderData"),
        isErrorResult(ot)) {
            let it = findNearestBoundary(o, j)
              , st = ot.error;
            a && (st = Object.values(a)[0],
            a = void 0),
            _e = _e || {},
            _e[it.route.id] == null && (_e[it.route.id] = st),
            $[j] = void 0,
            nt || (nt = !0,
            tt = isRouteErrorResponse(ot.error) ? ot.error.status : 500),
            ot.headers && (rt[j] = ot.headers)
        } else
            isDeferredResult(ot) ? (_.set(j, ot.deferredData),
            $[j] = ot.deferredData.data) : $[j] = ot.data,
            ot.statusCode != null && ot.statusCode !== 200 && !nt && (tt = ot.statusCode),
            ot.headers && (rt[j] = ot.headers)
    }
    ),
    a && (_e = a,
    $[Object.keys(a)[0]] = void 0),
    {
        loaderData: $,
        errors: _e,
        statusCode: tt || 200,
        loaderHeaders: rt
    }
}
function processLoaderData(o, i, s, a, _, $, _e, tt) {
    let {loaderData: nt, errors: rt} = processRouteLoaderData(i, s, a, _, tt);
    for (let ot = 0; ot < $.length; ot++) {
        let {key: et, match: j, controller: it} = $[ot];
        invariant(_e !== void 0 && _e[ot] !== void 0, "Did not find corresponding fetcher result");
        let st = _e[ot];
        if (!(it && it.signal.aborted))
            if (isErrorResult(st)) {
                let at = findNearestBoundary(o.matches, j == null ? void 0 : j.route.id);
                rt && rt[at.route.id] || (rt = _extends$3({}, rt, {
                    [at.route.id]: st.error
                })),
                o.fetchers.delete(et)
            } else if (isRedirectResult(st))
                invariant(!1, "Unhandled fetcher revalidation redirect");
            else if (isDeferredResult(st))
                invariant(!1, "Unhandled fetcher deferred data");
            else {
                let at = getDoneFetcher(st.data);
                o.fetchers.set(et, at)
            }
    }
    return {
        loaderData: nt,
        errors: rt
    }
}
function mergeLoaderData(o, i, s, a) {
    let _ = _extends$3({}, i);
    for (let $ of s) {
        let _e = $.route.id;
        if (i.hasOwnProperty(_e) ? i[_e] !== void 0 && (_[_e] = i[_e]) : o[_e] !== void 0 && $.route.loader && (_[_e] = o[_e]),
        a && a.hasOwnProperty(_e))
            break
    }
    return _
}
function findNearestBoundary(o, i) {
    return (i ? o.slice(0, o.findIndex(a => a.route.id === i) + 1) : [...o]).reverse().find(a => a.route.hasErrorBoundary === !0) || o[0]
}
function getShortCircuitMatches(o) {
    let i = o.find(s => s.index || !s.path || s.path === "/") || {
        id: "__shim-error-route__"
    };
    return {
        matches: [{
            params: {},
            pathname: "",
            pathnameBase: "",
            route: i
        }],
        route: i
    }
}
function getInternalRouterError(o, i) {
    let {pathname: s, routeId: a, method: _, type: $} = i === void 0 ? {} : i
      , _e = "Unknown Server Error"
      , tt = "Unknown @remix-run/router error";
    return o === 400 ? (_e = "Bad Request",
    _ && s && a ? tt = "You made a " + _ + ' request to "' + s + '" but ' + ('did not provide a `loader` for route "' + a + '", ') + "so there is no way to handle the request." : $ === "defer-action" ? tt = "defer() is not supported in actions" : $ === "invalid-body" && (tt = "Unable to encode submission body")) : o === 403 ? (_e = "Forbidden",
    tt = 'Route "' + a + '" does not match URL "' + s + '"') : o === 404 ? (_e = "Not Found",
    tt = 'No route matches URL "' + s + '"') : o === 405 && (_e = "Method Not Allowed",
    _ && s && a ? tt = "You made a " + _.toUpperCase() + ' request to "' + s + '" but ' + ('did not provide an `action` for route "' + a + '", ') + "so there is no way to handle the request." : _ && (tt = 'Invalid request method "' + _.toUpperCase() + '"')),
    new ErrorResponse(o || 500,_e,new Error(tt),!0)
}
function findRedirect(o) {
    for (let i = o.length - 1; i >= 0; i--) {
        let s = o[i];
        if (isRedirectResult(s))
            return {
                result: s,
                idx: i
            }
    }
}
function stripHashFromPath(o) {
    let i = typeof o == "string" ? parsePath(o) : o;
    return createPath(_extends$3({}, i, {
        hash: ""
    }))
}
function isHashChangeOnly(o, i) {
    return o.pathname !== i.pathname || o.search !== i.search ? !1 : o.hash === "" ? i.hash !== "" : o.hash === i.hash ? !0 : i.hash !== ""
}
function isDeferredResult(o) {
    return o.type === ResultType.deferred
}
function isErrorResult(o) {
    return o.type === ResultType.error
}
function isRedirectResult(o) {
    return (o && o.type) === ResultType.redirect
}
function isDeferredData(o) {
    let i = o;
    return i && typeof i == "object" && typeof i.data == "object" && typeof i.subscribe == "function" && typeof i.cancel == "function" && typeof i.resolveData == "function"
}
function isResponse(o) {
    return o != null && typeof o.status == "number" && typeof o.statusText == "string" && typeof o.headers == "object" && typeof o.body < "u"
}
function isValidMethod(o) {
    return validRequestMethods.has(o.toLowerCase())
}
function isMutationMethod(o) {
    return validMutationMethods.has(o.toLowerCase())
}
async function resolveDeferredResults(o, i, s, a, _, $) {
    for (let _e = 0; _e < s.length; _e++) {
        let tt = s[_e]
          , nt = i[_e];
        if (!nt)
            continue;
        let rt = o.find(et => et.route.id === nt.route.id)
          , ot = rt != null && !isNewRouteInstance(rt, nt) && ($ && $[nt.route.id]) !== void 0;
        if (isDeferredResult(tt) && (_ || ot)) {
            let et = a[_e];
            invariant(et, "Expected an AbortSignal for revalidating fetcher deferred result"),
            await resolveDeferredData(tt, et, _).then(j => {
                j && (s[_e] = j || s[_e])
            }
            )
        }
    }
}
async function resolveDeferredData(o, i, s) {
    if (s === void 0 && (s = !1),
    !await o.deferredData.resolveData(i)) {
        if (s)
            try {
                return {
                    type: ResultType.data,
                    data: o.deferredData.unwrappedData
                }
            } catch (_) {
                return {
                    type: ResultType.error,
                    error: _
                }
            }
        return {
            type: ResultType.data,
            data: o.deferredData.data
        }
    }
}
function hasNakedIndexQuery(o) {
    return new URLSearchParams(o).getAll("index").some(i => i === "")
}
function createUseMatchesMatch(o, i) {
    let {route: s, pathname: a, params: _} = o;
    return {
        id: s.id,
        pathname: a,
        params: _,
        data: i[s.id],
        handle: s.handle
    }
}
function getTargetMatch(o, i) {
    let s = typeof i == "string" ? parsePath(i).search : i.search;
    if (o[o.length - 1].route.index && hasNakedIndexQuery(s || ""))
        return o[o.length - 1];
    let a = getPathContributingMatches(o);
    return a[a.length - 1]
}
function getSubmissionFromNavigation(o) {
    let {formMethod: i, formAction: s, formEncType: a, text: _, formData: $, json: _e} = o;
    if (!(!i || !s || !a)) {
        if (_ != null)
            return {
                formMethod: i,
                formAction: s,
                formEncType: a,
                formData: void 0,
                json: void 0,
                text: _
            };
        if ($ != null)
            return {
                formMethod: i,
                formAction: s,
                formEncType: a,
                formData: $,
                json: void 0,
                text: void 0
            };
        if (_e !== void 0)
            return {
                formMethod: i,
                formAction: s,
                formEncType: a,
                formData: void 0,
                json: _e,
                text: void 0
            }
    }
}
function getLoadingNavigation(o, i) {
    return i ? {
        state: "loading",
        location: o,
        formMethod: i.formMethod,
        formAction: i.formAction,
        formEncType: i.formEncType,
        formData: i.formData,
        json: i.json,
        text: i.text
    } : {
        state: "loading",
        location: o,
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0
    }
}
function getSubmittingNavigation(o, i) {
    return {
        state: "submitting",
        location: o,
        formMethod: i.formMethod,
        formAction: i.formAction,
        formEncType: i.formEncType,
        formData: i.formData,
        json: i.json,
        text: i.text
    }
}
function getLoadingFetcher(o, i) {
    return o ? {
        state: "loading",
        formMethod: o.formMethod,
        formAction: o.formAction,
        formEncType: o.formEncType,
        formData: o.formData,
        json: o.json,
        text: o.text,
        data: i,
        " _hasFetcherDoneAnything ": !0
    } : {
        state: "loading",
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
        data: i,
        " _hasFetcherDoneAnything ": !0
    }
}
function getSubmittingFetcher(o, i) {
    return {
        state: "submitting",
        formMethod: o.formMethod,
        formAction: o.formAction,
        formEncType: o.formEncType,
        formData: o.formData,
        json: o.json,
        text: o.text,
        data: i ? i.data : void 0,
        " _hasFetcherDoneAnything ": !0
    }
}
function getDoneFetcher(o) {
    return {
        state: "idle",
        formMethod: void 0,
        formAction: void 0,
        formEncType: void 0,
        formData: void 0,
        json: void 0,
        text: void 0,
        data: o,
        " _hasFetcherDoneAnything ": !0
    }
}
/**
 * React Router v6.15.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$2() {
    return _extends$2 = Object.assign ? Object.assign.bind() : function(o) {
        for (var i = 1; i < arguments.length; i++) {
            var s = arguments[i];
            for (var a in s)
                Object.prototype.hasOwnProperty.call(s, a) && (o[a] = s[a])
        }
        return o
    }
    ,
    _extends$2.apply(this, arguments)
}
const DataRouterContext = reactExports.createContext(null)
  , DataRouterStateContext = reactExports.createContext(null)
  , NavigationContext = reactExports.createContext(null)
  , LocationContext = reactExports.createContext(null)
  , RouteContext = reactExports.createContext({
    outlet: null,
    matches: [],
    isDataRoute: !1
})
  , RouteErrorContext = reactExports.createContext(null);
function useInRouterContext() {
    return reactExports.useContext(LocationContext) != null
}
function useLocation() {
    return useInRouterContext() || invariant(!1),
    reactExports.useContext(LocationContext).location
}
function useIsomorphicLayoutEffect(o) {
    reactExports.useContext(NavigationContext).static || reactExports.useLayoutEffect(o)
}
function useNavigate() {
    let {isDataRoute: o} = reactExports.useContext(RouteContext);
    return o ? useNavigateStable() : useNavigateUnstable()
}
function useNavigateUnstable() {
    useInRouterContext() || invariant(!1);
    let o = reactExports.useContext(DataRouterContext)
      , {basename: i, navigator: s} = reactExports.useContext(NavigationContext)
      , {matches: a} = reactExports.useContext(RouteContext)
      , {pathname: _} = useLocation()
      , $ = JSON.stringify(getPathContributingMatches(a).map(nt => nt.pathnameBase))
      , _e = reactExports.useRef(!1);
    return useIsomorphicLayoutEffect( () => {
        _e.current = !0
    }
    ),
    reactExports.useCallback(function(nt, rt) {
        if (rt === void 0 && (rt = {}),
        !_e.current)
            return;
        if (typeof nt == "number") {
            s.go(nt);
            return
        }
        let ot = resolveTo(nt, JSON.parse($), _, rt.relative === "path");
        o == null && i !== "/" && (ot.pathname = ot.pathname === "/" ? i : joinPaths([i, ot.pathname])),
        (rt.replace ? s.replace : s.push)(ot, rt.state, rt)
    }, [i, s, $, _, o])
}
function useRoutesImpl(o, i, s) {
    useInRouterContext() || invariant(!1);
    let {navigator: a} = reactExports.useContext(NavigationContext)
      , {matches: _} = reactExports.useContext(RouteContext)
      , $ = _[_.length - 1]
      , _e = $ ? $.params : {};
    $ && $.pathname;
    let tt = $ ? $.pathnameBase : "/";
    $ && $.route;
    let nt = useLocation(), rt;
    if (i) {
        var ot;
        let at = typeof i == "string" ? parsePath(i) : i;
        tt === "/" || (ot = at.pathname) != null && ot.startsWith(tt) || invariant(!1),
        rt = at
    } else
        rt = nt;
    let et = rt.pathname || "/"
      , j = tt === "/" ? et : et.slice(tt.length) || "/"
      , it = matchRoutes(o, {
        pathname: j
    })
      , st = _renderMatches(it && it.map(at => Object.assign({}, at, {
        params: Object.assign({}, _e, at.params),
        pathname: joinPaths([tt, a.encodeLocation ? a.encodeLocation(at.pathname).pathname : at.pathname]),
        pathnameBase: at.pathnameBase === "/" ? tt : joinPaths([tt, a.encodeLocation ? a.encodeLocation(at.pathnameBase).pathname : at.pathnameBase])
    })), _, s);
    return i && st ? reactExports.createElement(LocationContext.Provider, {
        value: {
            location: _extends$2({
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default"
            }, rt),
            navigationType: Action.Pop
        }
    }, st) : st
}
function DefaultErrorComponent() {
    let o = useRouteError()
      , i = isRouteErrorResponse(o) ? o.status + " " + o.statusText : o instanceof Error ? o.message : JSON.stringify(o)
      , s = o instanceof Error ? o.stack : null
      , _ = {
        padding: "0.5rem",
        backgroundColor: "rgba(200,200,200, 0.5)"
    }
      , $ = null;
    return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("h2", null, "Unexpected Application Error!"), reactExports.createElement("h3", {
        style: {
            fontStyle: "italic"
        }
    }, i), s ? reactExports.createElement("pre", {
        style: _
    }, s) : null, $)
}
const defaultErrorElement = reactExports.createElement(DefaultErrorComponent, null);
class RenderErrorBoundary extends reactExports.Component {
    constructor(i) {
        super(i),
        this.state = {
            location: i.location,
            revalidation: i.revalidation,
            error: i.error
        }
    }
    static getDerivedStateFromError(i) {
        return {
            error: i
        }
    }
    static getDerivedStateFromProps(i, s) {
        return s.location !== i.location || s.revalidation !== "idle" && i.revalidation === "idle" ? {
            error: i.error,
            location: i.location,
            revalidation: i.revalidation
        } : {
            error: i.error || s.error,
            location: s.location,
            revalidation: i.revalidation || s.revalidation
        }
    }
    componentDidCatch(i, s) {
        console.error("React Router caught the following error during render", i, s)
    }
    render() {
        return this.state.error ? reactExports.createElement(RouteContext.Provider, {
            value: this.props.routeContext
        }, reactExports.createElement(RouteErrorContext.Provider, {
            value: this.state.error,
            children: this.props.component
        })) : this.props.children
    }
}
function RenderedRoute(o) {
    let {routeContext: i, match: s, children: a} = o
      , _ = reactExports.useContext(DataRouterContext);
    return _ && _.static && _.staticContext && (s.route.errorElement || s.route.ErrorBoundary) && (_.staticContext._deepestRenderedBoundaryId = s.route.id),
    reactExports.createElement(RouteContext.Provider, {
        value: i
    }, a)
}
function _renderMatches(o, i, s) {
    var a;
    if (i === void 0 && (i = []),
    s === void 0 && (s = null),
    o == null) {
        var _;
        if ((_ = s) != null && _.errors)
            o = s.matches;
        else
            return null
    }
    let $ = o
      , _e = (a = s) == null ? void 0 : a.errors;
    if (_e != null) {
        let tt = $.findIndex(nt => nt.route.id && (_e == null ? void 0 : _e[nt.route.id]));
        tt >= 0 || invariant(!1),
        $ = $.slice(0, Math.min($.length, tt + 1))
    }
    return $.reduceRight( (tt, nt, rt) => {
        let ot = nt.route.id ? _e == null ? void 0 : _e[nt.route.id] : null
          , et = null;
        s && (et = nt.route.errorElement || defaultErrorElement);
        let j = i.concat($.slice(0, rt + 1))
          , it = () => {
            let st;
            return ot ? st = et : nt.route.Component ? st = reactExports.createElement(nt.route.Component, null) : nt.route.element ? st = nt.route.element : st = tt,
            reactExports.createElement(RenderedRoute, {
                match: nt,
                routeContext: {
                    outlet: tt,
                    matches: j,
                    isDataRoute: s != null
                },
                children: st
            })
        }
        ;
        return s && (nt.route.ErrorBoundary || nt.route.errorElement || rt === 0) ? reactExports.createElement(RenderErrorBoundary, {
            location: s.location,
            revalidation: s.revalidation,
            component: et,
            error: ot,
            children: it(),
            routeContext: {
                outlet: null,
                matches: j,
                isDataRoute: !0
            }
        }) : it()
    }
    , null)
}
var DataRouterHook$1 = function(o) {
    return o.UseBlocker = "useBlocker",
    o.UseRevalidator = "useRevalidator",
    o.UseNavigateStable = "useNavigate",
    o
}(DataRouterHook$1 || {})
  , DataRouterStateHook$1 = function(o) {
    return o.UseBlocker = "useBlocker",
    o.UseLoaderData = "useLoaderData",
    o.UseActionData = "useActionData",
    o.UseRouteError = "useRouteError",
    o.UseNavigation = "useNavigation",
    o.UseRouteLoaderData = "useRouteLoaderData",
    o.UseMatches = "useMatches",
    o.UseRevalidator = "useRevalidator",
    o.UseNavigateStable = "useNavigate",
    o.UseRouteId = "useRouteId",
    o
}(DataRouterStateHook$1 || {});
function useDataRouterContext(o) {
    let i = reactExports.useContext(DataRouterContext);
    return i || invariant(!1),
    i
}
function useDataRouterState(o) {
    let i = reactExports.useContext(DataRouterStateContext);
    return i || invariant(!1),
    i
}
function useRouteContext(o) {
    let i = reactExports.useContext(RouteContext);
    return i || invariant(!1),
    i
}
function useCurrentRouteId(o) {
    let i = useRouteContext()
      , s = i.matches[i.matches.length - 1];
    return s.route.id || invariant(!1),
    s.route.id
}
function useRouteError() {
    var o;
    let i = reactExports.useContext(RouteErrorContext)
      , s = useDataRouterState(DataRouterStateHook$1.UseRouteError)
      , a = useCurrentRouteId(DataRouterStateHook$1.UseRouteError);
    return i || ((o = s.errors) == null ? void 0 : o[a])
}
function useNavigateStable() {
    let {router: o} = useDataRouterContext(DataRouterHook$1.UseNavigateStable)
      , i = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable)
      , s = reactExports.useRef(!1);
    return useIsomorphicLayoutEffect( () => {
        s.current = !0
    }
    ),
    reactExports.useCallback(function(_, $) {
        $ === void 0 && ($ = {}),
        s.current && (typeof _ == "number" ? o.navigate(_) : o.navigate(_, _extends$2({
            fromRouteId: i
        }, $)))
    }, [o, i])
}
const START_TRANSITION = "startTransition"
  , startTransitionImpl = React$1[START_TRANSITION];
function RouterProvider(o) {
    let {fallbackElement: i, router: s, future: a} = o
      , [_,$] = reactExports.useState(s.state)
      , {v7_startTransition: _e} = a || {}
      , tt = reactExports.useCallback(et => {
        _e && startTransitionImpl ? startTransitionImpl( () => $(et)) : $(et)
    }
    , [$, _e]);
    reactExports.useLayoutEffect( () => s.subscribe(tt), [s, tt]);
    let nt = reactExports.useMemo( () => ({
        createHref: s.createHref,
        encodeLocation: s.encodeLocation,
        go: et => s.navigate(et),
        push: (et, j, it) => s.navigate(et, {
            state: j,
            preventScrollReset: it == null ? void 0 : it.preventScrollReset
        }),
        replace: (et, j, it) => s.navigate(et, {
            replace: !0,
            state: j,
            preventScrollReset: it == null ? void 0 : it.preventScrollReset
        })
    }), [s])
      , rt = s.basename || "/"
      , ot = reactExports.useMemo( () => ({
        router: s,
        navigator: nt,
        static: !1,
        basename: rt
    }), [s, nt, rt]);
    return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(DataRouterContext.Provider, {
        value: ot
    }, reactExports.createElement(DataRouterStateContext.Provider, {
        value: _
    }, reactExports.createElement(Router, {
        basename: rt,
        location: _.location,
        navigationType: _.historyAction,
        navigator: nt
    }, _.initialized ? reactExports.createElement(DataRoutes, {
        routes: s.routes,
        state: _
    }) : i))), null)
}
function DataRoutes(o) {
    let {routes: i, state: s} = o;
    return useRoutesImpl(i, void 0, s)
}
function Navigate(o) {
    let {to: i, replace: s, state: a, relative: _} = o;
    useInRouterContext() || invariant(!1);
    let {matches: $} = reactExports.useContext(RouteContext)
      , {pathname: _e} = useLocation()
      , tt = useNavigate()
      , nt = resolveTo(i, getPathContributingMatches($).map(ot => ot.pathnameBase), _e, _ === "path")
      , rt = JSON.stringify(nt);
    return reactExports.useEffect( () => tt(JSON.parse(rt), {
        replace: s,
        state: a,
        relative: _
    }), [tt, rt, _, s, a]),
    null
}
function Router(o) {
    let {basename: i="/", children: s=null, location: a, navigationType: _=Action.Pop, navigator: $, static: _e=!1} = o;
    useInRouterContext() && invariant(!1);
    let tt = i.replace(/^\/*/, "/")
      , nt = reactExports.useMemo( () => ({
        basename: tt,
        navigator: $,
        static: _e
    }), [tt, $, _e]);
    typeof a == "string" && (a = parsePath(a));
    let {pathname: rt="/", search: ot="", hash: et="", state: j=null, key: it="default"} = a
      , st = reactExports.useMemo( () => {
        let at = stripBasename(rt, tt);
        return at == null ? null : {
            location: {
                pathname: at,
                search: ot,
                hash: et,
                state: j,
                key: it
            },
            navigationType: _
        }
    }
    , [tt, rt, ot, et, j, it, _]);
    return st == null ? null : reactExports.createElement(NavigationContext.Provider, {
        value: nt
    }, reactExports.createElement(LocationContext.Provider, {
        children: s,
        value: st
    }))
}
new Promise( () => {}
);
function mapRouteProperties(o) {
    let i = {
        hasErrorBoundary: o.ErrorBoundary != null || o.errorElement != null
    };
    return o.Component && Object.assign(i, {
        element: reactExports.createElement(o.Component),
        Component: void 0
    }),
    o.ErrorBoundary && Object.assign(i, {
        errorElement: reactExports.createElement(o.ErrorBoundary),
        ErrorBoundary: void 0
    }),
    i
}
/**
 * React Router DOM v6.15.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$1() {
    return _extends$1 = Object.assign ? Object.assign.bind() : function(o) {
        for (var i = 1; i < arguments.length; i++) {
            var s = arguments[i];
            for (var a in s)
                Object.prototype.hasOwnProperty.call(s, a) && (o[a] = s[a])
        }
        return o
    }
    ,
    _extends$1.apply(this, arguments)
}
function createBrowserRouter(o, i) {
    return createRouter({
        basename: i == null ? void 0 : i.basename,
        future: _extends$1({}, i == null ? void 0 : i.future, {
            v7_prependBasename: !0
        }),
        history: createBrowserHistory({
            window: i == null ? void 0 : i.window
        }),
        hydrationData: (i == null ? void 0 : i.hydrationData) || parseHydrationData(),
        routes: o,
        mapRouteProperties
    }).initialize()
}
function parseHydrationData() {
    var o;
    let i = (o = window) == null ? void 0 : o.__staticRouterHydrationData;
    return i && i.errors && (i = _extends$1({}, i, {
        errors: deserializeErrors(i.errors)
    })),
    i
}
function deserializeErrors(o) {
    if (!o)
        return null;
    let i = Object.entries(o)
      , s = {};
    for (let[a,_] of i)
        if (_ && _.__type === "RouteErrorResponse")
            s[a] = new ErrorResponse(_.status,_.statusText,_.data,_.internal === !0);
        else if (_ && _.__type === "Error") {
            if (_.__subType) {
                let $ = window[_.__subType];
                if (typeof $ == "function")
                    try {
                        let _e = new $(_.message);
                        _e.stack = "",
                        s[a] = _e
                    } catch {}
            }
            if (s[a] == null) {
                let $ = new Error(_.message);
                $.stack = "",
                s[a] = $
            }
        } else
            s[a] = _;
    return s
}
var DataRouterHook;
(function(o) {
    o.UseScrollRestoration = "useScrollRestoration",
    o.UseSubmit = "useSubmit",
    o.UseSubmitFetcher = "useSubmitFetcher",
    o.UseFetcher = "useFetcher"
}
)(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(o) {
    o.UseFetchers = "useFetchers",
    o.UseScrollRestoration = "useScrollRestoration"
}
)(DataRouterStateHook || (DataRouterStateHook = {}));
var __assign = function() {
    return __assign = Object.assign || function(i) {
        for (var s, a = 1, _ = arguments.length; a < _; a++) {
            s = arguments[a];
            for (var $ in s)
                Object.prototype.hasOwnProperty.call(s, $) && (i[$] = s[$])
        }
        return i
    }
    ,
    __assign.apply(this, arguments)
};
function __rest(o, i) {
    var s = {};
    for (var a in o)
        Object.prototype.hasOwnProperty.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && typeof Object.getOwnPropertySymbols == "function")
        for (var _ = 0, a = Object.getOwnPropertySymbols(o); _ < a.length; _++)
            i.indexOf(a[_]) < 0 && Object.prototype.propertyIsEnumerable.call(o, a[_]) && (s[a[_]] = o[a[_]]);
    return s
}
function __spreadArray(o, i, s) {
    if (s || arguments.length === 2)
        for (var a = 0, _ = i.length, $; a < _; a++)
            ($ || !(a in i)) && ($ || ($ = Array.prototype.slice.call(i, 0, a)),
            $[a] = i[a]);
    return o.concat($ || Array.prototype.slice.call(i))
}
typeof SuppressedError == "function" && SuppressedError;
var zeroRightClassName = "right-scroll-bar-position"
  , fullWidthClassName = "width-before-scroll-bar"
  , noScrollbarsClassName = "with-scroll-bars-hidden"
  , removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef$1(o, i) {
    return typeof o == "function" ? o(i) : o && (o.current = i),
    o
}
function useCallbackRef(o, i) {
    var s = reactExports.useState(function() {
        return {
            value: o,
            callback: i,
            facade: {
                get current() {
                    return s.value
                },
                set current(a) {
                    var _ = s.value;
                    _ !== a && (s.value = a,
                    s.callback(a, _))
                }
            }
        }
    })[0];
    return s.callback = i,
    s.facade
}
function useMergeRefs(o, i) {
    return useCallbackRef(i || null, function(s) {
        return o.forEach(function(a) {
            return assignRef$1(a, s)
        })
    })
}
function ItoI(o) {
    return o
}
function innerCreateMedium(o, i) {
    i === void 0 && (i = ItoI);
    var s = []
      , a = !1
      , _ = {
        read: function() {
            if (a)
                throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
            return s.length ? s[s.length - 1] : o
        },
        useMedium: function($) {
            var _e = i($, a);
            return s.push(_e),
            function() {
                s = s.filter(function(tt) {
                    return tt !== _e
                })
            }
        },
        assignSyncMedium: function($) {
            for (a = !0; s.length; ) {
                var _e = s;
                s = [],
                _e.forEach($)
            }
            s = {
                push: function(tt) {
                    return $(tt)
                },
                filter: function() {
                    return s
                }
            }
        },
        assignMedium: function($) {
            a = !0;
            var _e = [];
            if (s.length) {
                var tt = s;
                s = [],
                tt.forEach($),
                _e = s
            }
            var nt = function() {
                var ot = _e;
                _e = [],
                ot.forEach($)
            }
              , rt = function() {
                return Promise.resolve().then(nt)
            };
            rt(),
            s = {
                push: function(ot) {
                    _e.push(ot),
                    rt()
                },
                filter: function(ot) {
                    return _e = _e.filter(ot),
                    s
                }
            }
        }
    };
    return _
}
function createSidecarMedium(o) {
    o === void 0 && (o = {});
    var i = innerCreateMedium(null);
    return i.options = __assign({
        async: !0,
        ssr: !1
    }, o),
    i
}
var SideCar$1 = function(o) {
    var i = o.sideCar
      , s = __rest(o, ["sideCar"]);
    if (!i)
        throw new Error("Sidecar: please provide `sideCar` property to import the right car");
    var a = i.read();
    if (!a)
        throw new Error("Sidecar medium not found");
    return reactExports.createElement(a, __assign({}, s))
};
SideCar$1.isSideCarExport = !0;
function exportSidecar(o, i) {
    return o.useMedium(i),
    SideCar$1
}
var effectCar = createSidecarMedium()
  , nothing = function() {}
  , RemoveScroll$1 = reactExports.forwardRef(function(o, i) {
    var s = reactExports.useRef(null)
      , a = reactExports.useState({
        onScrollCapture: nothing,
        onWheelCapture: nothing,
        onTouchMoveCapture: nothing
    })
      , _ = a[0]
      , $ = a[1]
      , _e = o.forwardProps
      , tt = o.children
      , nt = o.className
      , rt = o.removeScrollBar
      , ot = o.enabled
      , et = o.shards
      , j = o.sideCar
      , it = o.noIsolation
      , st = o.inert
      , at = o.allowPinchZoom
      , lt = o.as
      , ct = lt === void 0 ? "div" : lt
      , ut = o.gapMode
      , dt = __rest(o, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"])
      , ft = j
      , ht = useMergeRefs([s, i])
      , pt = __assign(__assign({}, dt), _);
    return reactExports.createElement(reactExports.Fragment, null, ot && reactExports.createElement(ft, {
        sideCar: effectCar,
        removeScrollBar: rt,
        shards: et,
        noIsolation: it,
        inert: st,
        setCallbacks: $,
        allowPinchZoom: !!at,
        lockRef: s,
        gapMode: ut
    }), _e ? reactExports.cloneElement(reactExports.Children.only(tt), __assign(__assign({}, pt), {
        ref: ht
    })) : reactExports.createElement(ct, __assign({}, pt, {
        className: nt,
        ref: ht
    }), tt))
});
RemoveScroll$1.defaultProps = {
    enabled: !0,
    removeScrollBar: !0,
    inert: !1
};
RemoveScroll$1.classNames = {
    fullWidth: fullWidthClassName,
    zeroRight: zeroRightClassName
};
var currentNonce, getNonce = function() {
    if (currentNonce)
        return currentNonce;
    if (typeof __webpack_nonce__ < "u")
        return __webpack_nonce__
};
function makeStyleTag() {
    if (!document)
        return null;
    var o = document.createElement("style");
    o.type = "text/css";
    var i = getNonce();
    return i && o.setAttribute("nonce", i),
    o
}
function injectStyles(o, i) {
    o.styleSheet ? o.styleSheet.cssText = i : o.appendChild(document.createTextNode(i))
}
function insertStyleTag(o) {
    var i = document.head || document.getElementsByTagName("head")[0];
    i.appendChild(o)
}
var stylesheetSingleton = function() {
    var o = 0
      , i = null;
    return {
        add: function(s) {
            o == 0 && (i = makeStyleTag()) && (injectStyles(i, s),
            insertStyleTag(i)),
            o++
        },
        remove: function() {
            o--,
            !o && i && (i.parentNode && i.parentNode.removeChild(i),
            i = null)
        }
    }
}
  , styleHookSingleton = function() {
    var o = stylesheetSingleton();
    return function(i, s) {
        reactExports.useEffect(function() {
            return o.add(i),
            function() {
                o.remove()
            }
        }, [i && s])
    }
}
  , styleSingleton = function() {
    var o = styleHookSingleton()
      , i = function(s) {
        var a = s.styles
          , _ = s.dynamic;
        return o(a, _),
        null
    };
    return i
}
  , zeroGap = {
    left: 0,
    top: 0,
    right: 0,
    gap: 0
}
  , parse$2 = function(o) {
    return parseInt(o || "", 10) || 0
}
  , getOffset = function(o) {
    var i = window.getComputedStyle(document.body)
      , s = i[o === "padding" ? "paddingLeft" : "marginLeft"]
      , a = i[o === "padding" ? "paddingTop" : "marginTop"]
      , _ = i[o === "padding" ? "paddingRight" : "marginRight"];
    return [parse$2(s), parse$2(a), parse$2(_)]
}
  , getGapWidth = function(o) {
    if (o === void 0 && (o = "margin"),
    typeof window > "u")
        return zeroGap;
    var i = getOffset(o)
      , s = document.documentElement.clientWidth
      , a = window.innerWidth;
    return {
        left: i[0],
        top: i[1],
        right: i[2],
        gap: Math.max(0, a - s + i[2] - i[0])
    }
}
  , Style$2 = styleSingleton()
  , getStyles$1 = function(o, i, s, a) {
    var _ = o.left
      , $ = o.top
      , _e = o.right
      , tt = o.gap;
    return s === void 0 && (s = "margin"),
    `
  .`.concat(noScrollbarsClassName, ` {
   overflow: hidden `).concat(a, `;
   padding-right: `).concat(tt, "px ").concat(a, `;
  }
  body {
    overflow: hidden `).concat(a, `;
    overscroll-behavior: contain;
    `).concat([i && "position: relative ".concat(a, ";"), s === "margin" && `
    padding-left: `.concat(_, `px;
    padding-top: `).concat($, `px;
    padding-right: `).concat(_e, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(tt, "px ").concat(a, `;
    `), s === "padding" && "padding-right: ".concat(tt, "px ").concat(a, ";")].filter(Boolean).join(""), `
  }
  
  .`).concat(zeroRightClassName, ` {
    right: `).concat(tt, "px ").concat(a, `;
  }
  
  .`).concat(fullWidthClassName, ` {
    margin-right: `).concat(tt, "px ").concat(a, `;
  }
  
  .`).concat(zeroRightClassName, " .").concat(zeroRightClassName, ` {
    right: 0 `).concat(a, `;
  }
  
  .`).concat(fullWidthClassName, " .").concat(fullWidthClassName, ` {
    margin-right: 0 `).concat(a, `;
  }
  
  body {
    `).concat(removedBarSizeVariable, ": ").concat(tt, `px;
  }
`)
}
  , RemoveScrollBar = function(o) {
    var i = o.noRelative
      , s = o.noImportant
      , a = o.gapMode
      , _ = a === void 0 ? "margin" : a
      , $ = reactExports.useMemo(function() {
        return getGapWidth(_)
    }, [_]);
    return reactExports.createElement(Style$2, {
        styles: getStyles$1($, !i, _, s ? "" : "!important")
    })
}
  , passiveSupported = !1;
if (typeof window < "u")
    try {
        var options = Object.defineProperty({}, "passive", {
            get: function() {
                return passiveSupported = !0,
                !0
            }
        });
        window.addEventListener("test", options, options),
        window.removeEventListener("test", options, options)
    } catch {
        passiveSupported = !1
    }
var nonPassive = passiveSupported ? {
    passive: !1
} : !1
  , alwaysContainsScroll = function(o) {
    return o.tagName === "TEXTAREA"
}
  , elementCanBeScrolled = function(o, i) {
    var s = window.getComputedStyle(o);
    return s[i] !== "hidden" && !(s.overflowY === s.overflowX && !alwaysContainsScroll(o) && s[i] === "visible")
}
  , elementCouldBeVScrolled = function(o) {
    return elementCanBeScrolled(o, "overflowY")
}
  , elementCouldBeHScrolled = function(o) {
    return elementCanBeScrolled(o, "overflowX")
}
  , locationCouldBeScrolled = function(o, i) {
    var s = i.ownerDocument
      , a = i;
    do {
        typeof ShadowRoot < "u" && a instanceof ShadowRoot && (a = a.host);
        var _ = elementCouldBeScrolled(o, a);
        if (_) {
            var $ = getScrollVariables(o, a)
              , _e = $[1]
              , tt = $[2];
            if (_e > tt)
                return !0
        }
        a = a.parentNode
    } while (a && a !== s.body);
    return !1
}
  , getVScrollVariables = function(o) {
    var i = o.scrollTop
      , s = o.scrollHeight
      , a = o.clientHeight;
    return [i, s, a]
}
  , getHScrollVariables = function(o) {
    var i = o.scrollLeft
      , s = o.scrollWidth
      , a = o.clientWidth;
    return [i, s, a]
}
  , elementCouldBeScrolled = function(o, i) {
    return o === "v" ? elementCouldBeVScrolled(i) : elementCouldBeHScrolled(i)
}
  , getScrollVariables = function(o, i) {
    return o === "v" ? getVScrollVariables(i) : getHScrollVariables(i)
}
  , getDirectionFactor = function(o, i) {
    return o === "h" && i === "rtl" ? -1 : 1
}
  , handleScroll = function(o, i, s, a, _) {
    var $ = getDirectionFactor(o, window.getComputedStyle(i).direction)
      , _e = $ * a
      , tt = s.target
      , nt = i.contains(tt)
      , rt = !1
      , ot = _e > 0
      , et = 0
      , j = 0;
    do {
        var it = getScrollVariables(o, tt)
          , st = it[0]
          , at = it[1]
          , lt = it[2]
          , ct = at - lt - $ * st;
        (st || ct) && elementCouldBeScrolled(o, tt) && (et += ct,
        j += st),
        tt = tt.parentNode
    } while (!nt && tt !== document.body || nt && (i.contains(tt) || i === tt));
    return (ot && (_ && et === 0 || !_ && _e > et) || !ot && (_ && j === 0 || !_ && -_e > j)) && (rt = !0),
    rt
}
  , getTouchXY = function(o) {
    return "changedTouches"in o ? [o.changedTouches[0].clientX, o.changedTouches[0].clientY] : [0, 0]
}
  , getDeltaXY = function(o) {
    return [o.deltaX, o.deltaY]
}
  , extractRef = function(o) {
    return o && "current"in o ? o.current : o
}
  , deltaCompare = function(o, i) {
    return o[0] === i[0] && o[1] === i[1]
}
  , generateStyle = function(o) {
    return `
  .block-interactivity-`.concat(o, ` {pointer-events: none;}
  .allow-interactivity-`).concat(o, ` {pointer-events: all;}
`)
}
  , idCounter = 0
  , lockStack = [];
function RemoveScrollSideCar(o) {
    var i = reactExports.useRef([])
      , s = reactExports.useRef([0, 0])
      , a = reactExports.useRef()
      , _ = reactExports.useState(idCounter++)[0]
      , $ = reactExports.useState(styleSingleton)[0]
      , _e = reactExports.useRef(o);
    reactExports.useEffect(function() {
        _e.current = o
    }, [o]),
    reactExports.useEffect(function() {
        if (o.inert) {
            document.body.classList.add("block-interactivity-".concat(_));
            var at = __spreadArray([o.lockRef.current], (o.shards || []).map(extractRef), !0).filter(Boolean);
            return at.forEach(function(lt) {
                return lt.classList.add("allow-interactivity-".concat(_))
            }),
            function() {
                document.body.classList.remove("block-interactivity-".concat(_)),
                at.forEach(function(lt) {
                    return lt.classList.remove("allow-interactivity-".concat(_))
                })
            }
        }
    }, [o.inert, o.lockRef.current, o.shards]);
    var tt = reactExports.useCallback(function(at, lt) {
        if ("touches"in at && at.touches.length === 2)
            return !_e.current.allowPinchZoom;
        var ct = getTouchXY(at), ut = s.current, dt = "deltaX"in at ? at.deltaX : ut[0] - ct[0], ft = "deltaY"in at ? at.deltaY : ut[1] - ct[1], ht, pt = at.target, gt = Math.abs(dt) > Math.abs(ft) ? "h" : "v";
        if ("touches"in at && gt === "h" && pt.type === "range")
            return !1;
        var _t = locationCouldBeScrolled(gt, pt);
        if (!_t)
            return !0;
        if (_t ? ht = gt : (ht = gt === "v" ? "h" : "v",
        _t = locationCouldBeScrolled(gt, pt)),
        !_t)
            return !1;
        if (!a.current && "changedTouches"in at && (dt || ft) && (a.current = ht),
        !ht)
            return !0;
        var mt = a.current || ht;
        return handleScroll(mt, lt, at, mt === "h" ? dt : ft, !0)
    }, [])
      , nt = reactExports.useCallback(function(at) {
        var lt = at;
        if (!(!lockStack.length || lockStack[lockStack.length - 1] !== $)) {
            var ct = "deltaY"in lt ? getDeltaXY(lt) : getTouchXY(lt)
              , ut = i.current.filter(function(ht) {
                return ht.name === lt.type && ht.target === lt.target && deltaCompare(ht.delta, ct)
            })[0];
            if (ut && ut.should) {
                lt.cancelable && lt.preventDefault();
                return
            }
            if (!ut) {
                var dt = (_e.current.shards || []).map(extractRef).filter(Boolean).filter(function(ht) {
                    return ht.contains(lt.target)
                })
                  , ft = dt.length > 0 ? tt(lt, dt[0]) : !_e.current.noIsolation;
                ft && lt.cancelable && lt.preventDefault()
            }
        }
    }, [])
      , rt = reactExports.useCallback(function(at, lt, ct, ut) {
        var dt = {
            name: at,
            delta: lt,
            target: ct,
            should: ut
        };
        i.current.push(dt),
        setTimeout(function() {
            i.current = i.current.filter(function(ft) {
                return ft !== dt
            })
        }, 1)
    }, [])
      , ot = reactExports.useCallback(function(at) {
        s.current = getTouchXY(at),
        a.current = void 0
    }, [])
      , et = reactExports.useCallback(function(at) {
        rt(at.type, getDeltaXY(at), at.target, tt(at, o.lockRef.current))
    }, [])
      , j = reactExports.useCallback(function(at) {
        rt(at.type, getTouchXY(at), at.target, tt(at, o.lockRef.current))
    }, []);
    reactExports.useEffect(function() {
        return lockStack.push($),
        o.setCallbacks({
            onScrollCapture: et,
            onWheelCapture: et,
            onTouchMoveCapture: j
        }),
        document.addEventListener("wheel", nt, nonPassive),
        document.addEventListener("touchmove", nt, nonPassive),
        document.addEventListener("touchstart", ot, nonPassive),
        function() {
            lockStack = lockStack.filter(function(at) {
                return at !== $
            }),
            document.removeEventListener("wheel", nt, nonPassive),
            document.removeEventListener("touchmove", nt, nonPassive),
            document.removeEventListener("touchstart", ot, nonPassive)
        }
    }, []);
    var it = o.removeScrollBar
      , st = o.inert;
    return reactExports.createElement(reactExports.Fragment, null, st ? reactExports.createElement($, {
        styles: generateStyle(_)
    }) : null, it ? reactExports.createElement(RemoveScrollBar, {
        gapMode: o.gapMode
    }) : null)
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = reactExports.forwardRef(function(o, i) {
    return reactExports.createElement(RemoveScroll$1, __assign({}, o, {
        ref: i,
        sideCar: SideCar
    }))
});
ReactRemoveScroll.classNames = RemoveScroll$1.classNames;
const RemoveScroll = ReactRemoveScroll;
function createPolymorphicComponent(o) {
    return o
}
function createSafeContext(o) {
    const i = reactExports.createContext(null);
    return [ ({children: _, value: $}) => React.createElement(i.Provider, {
        value: $
    }, _), () => {
        const _ = reactExports.useContext(i);
        if (_ === null)
            throw new Error(o);
        return _
    }
    ]
}
function packSx(o) {
    return Array.isArray(o) ? o : [o]
}
const noop$2 = () => {}
;
function closeOnEscape(o, i={
    active: !0
}) {
    return typeof o != "function" || !i.active ? i.onKeyDown || noop$2 : s => {
        var a;
        s.key === "Escape" && (o(s),
        (a = i.onTrigger) == null || a.call(i))
    }
}
function groupOptions({data: o}) {
    const i = []
      , s = []
      , a = o.reduce( (_, $, _e) => ($.group ? _[$.group] ? _[$.group].push(_e) : _[$.group] = [_e] : s.push(_e),
    _), {});
    return Object.keys(a).forEach(_ => {
        i.push(...a[_].map($ => o[$]))
    }
    ),
    i.push(...s.map(_ => o[_])),
    i
}
function dispatchEvent(o, i) {
    window.dispatchEvent(new CustomEvent(o,{
        detail: i
    }))
}
const useIsomorphicEffect$1 = typeof window < "u" ? reactExports.useLayoutEffect : reactExports.useEffect;
function createUseExternalEvents(o) {
    function i(a) {
        const _ = Object.keys(a).reduce( ($, _e) => ($[`${o}:${_e}`] = tt => a[_e](tt.detail),
        $), {});
        useIsomorphicEffect$1( () => (Object.keys(_).forEach($ => {
            window.removeEventListener($, _[$]),
            window.addEventListener($, _[$])
        }
        ),
        () => Object.keys(_).forEach($ => {
            window.removeEventListener($, _[$])
        }
        )), [_])
    }
    function s(a) {
        return (..._) => dispatchEvent(`${o}:${String(a)}`, _[0])
    }
    return [i, s]
}
function isElement$2(o) {
    return Array.isArray(o) || o === null ? !1 : typeof o == "object" ? o.type !== React.Fragment : !1
}
function toVal(o) {
    var i, s, a = "";
    if (typeof o == "string" || typeof o == "number")
        a += o;
    else if (typeof o == "object")
        if (Array.isArray(o))
            for (i = 0; i < o.length; i++)
                o[i] && (s = toVal(o[i])) && (a && (a += " "),
                a += s);
        else
            for (i in o)
                o[i] && (a && (a += " "),
                a += i);
    return a
}
function clsx() {
    for (var o = 0, i, s, a = ""; o < arguments.length; )
        (i = arguments[o++]) && (s = toVal(i)) && (a && (a += " "),
        a += s);
    return a
}
const DEFAULT_COLORS = {
    dark: ["#C1C2C5", "#A6A7AB", "#909296", "#5c5f66", "#373A40", "#2C2E33", "#25262b", "#1A1B1E", "#141517", "#101113"],
    gray: ["#f8f9fa", "#f1f3f5", "#e9ecef", "#dee2e6", "#ced4da", "#adb5bd", "#868e96", "#495057", "#343a40", "#212529"],
    red: ["#fff5f5", "#ffe3e3", "#ffc9c9", "#ffa8a8", "#ff8787", "#ff6b6b", "#fa5252", "#f03e3e", "#e03131", "#c92a2a"],
    pink: ["#fff0f6", "#ffdeeb", "#fcc2d7", "#faa2c1", "#f783ac", "#f06595", "#e64980", "#d6336c", "#c2255c", "#a61e4d"],
    grape: ["#f8f0fc", "#f3d9fa", "#eebefa", "#e599f7", "#da77f2", "#cc5de8", "#be4bdb", "#ae3ec9", "#9c36b5", "#862e9c"],
    violet: ["#f3f0ff", "#e5dbff", "#d0bfff", "#b197fc", "#9775fa", "#845ef7", "#7950f2", "#7048e8", "#6741d9", "#5f3dc4"],
    indigo: ["#edf2ff", "#dbe4ff", "#bac8ff", "#91a7ff", "#748ffc", "#5c7cfa", "#4c6ef5", "#4263eb", "#3b5bdb", "#364fc7"],
    blue: ["#e7f5ff", "#d0ebff", "#a5d8ff", "#74c0fc", "#4dabf7", "#339af0", "#228be6", "#1c7ed6", "#1971c2", "#1864ab"],
    cyan: ["#e3fafc", "#c5f6fa", "#99e9f2", "#66d9e8", "#3bc9db", "#22b8cf", "#15aabf", "#1098ad", "#0c8599", "#0b7285"],
    teal: ["#e6fcf5", "#c3fae8", "#96f2d7", "#63e6be", "#38d9a9", "#20c997", "#12b886", "#0ca678", "#099268", "#087f5b"],
    green: ["#ebfbee", "#d3f9d8", "#b2f2bb", "#8ce99a", "#69db7c", "#51cf66", "#40c057", "#37b24d", "#2f9e44", "#2b8a3e"],
    lime: ["#f4fce3", "#e9fac8", "#d8f5a2", "#c0eb75", "#a9e34b", "#94d82d", "#82c91e", "#74b816", "#66a80f", "#5c940d"],
    yellow: ["#fff9db", "#fff3bf", "#ffec99", "#ffe066", "#ffd43b", "#fcc419", "#fab005", "#f59f00", "#f08c00", "#e67700"],
    orange: ["#fff4e6", "#ffe8cc", "#ffd8a8", "#ffc078", "#ffa94d", "#ff922b", "#fd7e14", "#f76707", "#e8590c", "#d9480f"]
};
function fontStyles(o) {
    return () => ({
        fontFamily: o.fontFamily || "sans-serif"
    })
}
var __defProp$1E = Object.defineProperty
  , __getOwnPropSymbols$1G = Object.getOwnPropertySymbols
  , __hasOwnProp$1G = Object.prototype.hasOwnProperty
  , __propIsEnum$1G = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1E = (o, i, s) => i in o ? __defProp$1E(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1E = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1G.call(i, s) && __defNormalProp$1E(o, s, i[s]);
    if (__getOwnPropSymbols$1G)
        for (var s of __getOwnPropSymbols$1G(i))
            __propIsEnum$1G.call(i, s) && __defNormalProp$1E(o, s, i[s]);
    return o
}
;
function focusStyles(o) {
    return i => ({
        WebkitTapHighlightColor: "transparent",
        [i || "&:focus"]: __spreadValues$1E({}, o.focusRing === "always" || o.focusRing === "auto" ? o.focusRingStyles.styles(o) : o.focusRingStyles.resetStyles(o)),
        [i ? i.replace(":focus", ":focus:not(:focus-visible)") : "&:focus:not(:focus-visible)"]: __spreadValues$1E({}, o.focusRing === "auto" || o.focusRing === "never" ? o.focusRingStyles.resetStyles(o) : null)
    })
}
function primaryShade(o) {
    return i => typeof o.primaryShade == "number" ? o.primaryShade : o.primaryShade[i || o.colorScheme]
}
function themeColor(o) {
    const i = primaryShade(o);
    return (s, a, _=!0, $=!0) => {
        if (typeof s == "string" && s.includes(".")) {
            const [tt,nt] = s.split(".")
              , rt = parseInt(nt, 10);
            if (tt in o.colors && rt >= 0 && rt < 10)
                return o.colors[tt][typeof a == "number" && !$ ? a : rt]
        }
        const _e = typeof a == "number" ? a : i();
        return s in o.colors ? o.colors[s][_e] : _ ? o.colors[o.primaryColor][_e] : s
    }
}
function getGradientColorStops(o) {
    let i = "";
    for (let s = 1; s < o.length - 1; s += 1)
        i += `${o[s]} ${s / (o.length - 1) * 100}%, `;
    return `${o[0]} 0%, ${i}${o[o.length - 1]} 100%`
}
function linearGradient(o, ...i) {
    return `linear-gradient(${o}deg, ${getGradientColorStops(i)})`
}
function radialGradient(...o) {
    return `radial-gradient(circle, ${getGradientColorStops(o)})`
}
function gradient(o) {
    const i = themeColor(o)
      , s = primaryShade(o);
    return a => {
        const _ = {
            from: (a == null ? void 0 : a.from) || o.defaultGradient.from,
            to: (a == null ? void 0 : a.to) || o.defaultGradient.to,
            deg: (a == null ? void 0 : a.deg) || o.defaultGradient.deg
        };
        return `linear-gradient(${_.deg}deg, ${i(_.from, s(), !1)} 0%, ${i(_.to, s(), !1)} 100%)`
    }
}
function createConverter(o) {
    return i => {
        if (typeof i == "number")
            return `${i / 16}${o}`;
        if (typeof i == "string") {
            const s = i.replace("px", "");
            if (!Number.isNaN(Number(s)))
                return `${Number(s) / 16}${o}`
        }
        return i
    }
}
const rem = createConverter("rem")
  , em = createConverter("em");
function getSize({size: o, sizes: i, units: s}) {
    return o in i ? i[o] : typeof o == "number" ? s === "em" ? em(o) : rem(o) : o || i.md
}
function getBreakpointValue(o) {
    return typeof o == "number" ? o : typeof o == "string" && o.includes("rem") ? Number(o.replace("rem", "")) * 16 : typeof o == "string" && o.includes("em") ? Number(o.replace("em", "")) * 16 : Number(o)
}
function largerThan(o) {
    return i => `@media (min-width: ${em(getBreakpointValue(getSize({
        size: i,
        sizes: o.breakpoints
    })))})`
}
function smallerThan(o) {
    return i => `@media (max-width: ${em(getBreakpointValue(getSize({
        size: i,
        sizes: o.breakpoints
    })) - 1)})`
}
function isHexColor(o) {
    return /^#?([0-9A-F]{3}){1,2}$/i.test(o)
}
function hexToRgba(o) {
    let i = o.replace("#", "");
    if (i.length === 3) {
        const _e = i.split("");
        i = [_e[0], _e[0], _e[1], _e[1], _e[2], _e[2]].join("")
    }
    const s = parseInt(i, 16)
      , a = s >> 16 & 255
      , _ = s >> 8 & 255
      , $ = s & 255;
    return {
        r: a,
        g: _,
        b: $,
        a: 1
    }
}
function rgbStringToRgba(o) {
    const [i,s,a,_] = o.replace(/[^0-9,.]/g, "").split(",").map(Number);
    return {
        r: i,
        g: s,
        b: a,
        a: _ || 1
    }
}
function toRgba(o) {
    return isHexColor(o) ? hexToRgba(o) : o.startsWith("rgb") ? rgbStringToRgba(o) : {
        r: 0,
        g: 0,
        b: 0,
        a: 1
    }
}
function rgba(o, i) {
    if (typeof o != "string" || i > 1 || i < 0)
        return "rgba(0, 0, 0, 1)";
    if (o.startsWith("var(--"))
        return o;
    const {r: s, g: a, b: _} = toRgba(o);
    return `rgba(${s}, ${a}, ${_}, ${i})`
}
function cover(o=0) {
    return {
        position: "absolute",
        top: rem(o),
        right: rem(o),
        left: rem(o),
        bottom: rem(o)
    }
}
function darken(o, i) {
    if (typeof o == "string" && o.startsWith("var(--"))
        return o;
    const {r: s, g: a, b: _, a: $} = toRgba(o)
      , _e = 1 - i
      , tt = nt => Math.round(nt * _e);
    return `rgba(${tt(s)}, ${tt(a)}, ${tt(_)}, ${$})`
}
function lighten(o, i) {
    if (typeof o == "string" && o.startsWith("var(--"))
        return o;
    const {r: s, g: a, b: _, a: $} = toRgba(o)
      , _e = tt => Math.round(tt + (255 - tt) * i);
    return `rgba(${_e(s)}, ${_e(a)}, ${_e(_)}, ${$})`
}
function radius(o) {
    return i => {
        if (typeof i == "number")
            return rem(i);
        const s = typeof o.defaultRadius == "number" ? o.defaultRadius : o.radius[o.defaultRadius] || o.defaultRadius;
        return o.radius[i] || i || s
    }
}
function getColorIndexInfo(o, i) {
    if (typeof o == "string" && o.includes(".")) {
        const [s,a] = o.split(".")
          , _ = parseInt(a, 10);
        if (s in i.colors && _ >= 0 && _ < 10)
            return {
                isSplittedColor: !0,
                key: s,
                shade: _
            }
    }
    return {
        isSplittedColor: !1
    }
}
function variant(o) {
    const i = themeColor(o)
      , s = primaryShade(o)
      , a = gradient(o);
    return ({variant: _, color: $, gradient: _e, primaryFallback: tt}) => {
        const nt = getColorIndexInfo($, o);
        switch (_) {
        case "light":
            return {
                border: "transparent",
                background: rgba(i($, o.colorScheme === "dark" ? 8 : 0, tt, !1), o.colorScheme === "dark" ? .2 : 1),
                color: $ === "dark" ? o.colorScheme === "dark" ? o.colors.dark[0] : o.colors.dark[9] : i($, o.colorScheme === "dark" ? 2 : s("light")),
                hover: rgba(i($, o.colorScheme === "dark" ? 7 : 1, tt, !1), o.colorScheme === "dark" ? .25 : .65)
            };
        case "subtle":
            return {
                border: "transparent",
                background: "transparent",
                color: $ === "dark" ? o.colorScheme === "dark" ? o.colors.dark[0] : o.colors.dark[9] : i($, o.colorScheme === "dark" ? 2 : s("light")),
                hover: rgba(i($, o.colorScheme === "dark" ? 8 : 0, tt, !1), o.colorScheme === "dark" ? .2 : 1)
            };
        case "outline":
            return {
                border: i($, o.colorScheme === "dark" ? 5 : s("light")),
                background: "transparent",
                color: i($, o.colorScheme === "dark" ? 5 : s("light")),
                hover: o.colorScheme === "dark" ? rgba(i($, 5, tt, !1), .05) : rgba(i($, 0, tt, !1), .35)
            };
        case "default":
            return {
                border: o.colorScheme === "dark" ? o.colors.dark[4] : o.colors.gray[4],
                background: o.colorScheme === "dark" ? o.colors.dark[6] : o.white,
                color: o.colorScheme === "dark" ? o.white : o.black,
                hover: o.colorScheme === "dark" ? o.colors.dark[5] : o.colors.gray[0]
            };
        case "white":
            return {
                border: "transparent",
                background: o.white,
                color: i($, s()),
                hover: null
            };
        case "transparent":
            return {
                border: "transparent",
                color: $ === "dark" ? o.colorScheme === "dark" ? o.colors.dark[0] : o.colors.dark[9] : i($, o.colorScheme === "dark" ? 2 : s("light")),
                background: "transparent",
                hover: null
            };
        case "gradient":
            return {
                background: a(_e),
                color: o.white,
                border: "transparent",
                hover: null
            };
        default:
            {
                const rt = s()
                  , ot = nt.isSplittedColor ? nt.shade : rt
                  , et = nt.isSplittedColor ? nt.key : $;
                return {
                    border: "transparent",
                    background: i(et, ot, tt),
                    color: o.white,
                    hover: i(et, ot === 9 ? 8 : ot + 1)
                }
            }
        }
    }
}
function primaryColor(o) {
    return i => {
        const s = primaryShade(o)(i);
        return o.colors[o.primaryColor][s]
    }
}
function hover(o) {
    return {
        "@media (hover: hover)": {
            "&:hover": o
        },
        "@media (hover: none)": {
            "&:active": o
        }
    }
}
function placeholderStyles(o) {
    return () => ({
        userSelect: "none",
        color: o.colorScheme === "dark" ? o.colors.dark[3] : o.colors.gray[5]
    })
}
function dimmed(o) {
    return () => o.colorScheme === "dark" ? o.colors.dark[2] : o.colors.gray[6]
}
const fns = {
    fontStyles,
    themeColor,
    focusStyles,
    linearGradient,
    radialGradient,
    smallerThan,
    largerThan,
    rgba,
    cover,
    darken,
    lighten,
    radius,
    variant,
    primaryShade,
    hover,
    gradient,
    primaryColor,
    placeholderStyles,
    dimmed
};
var __defProp$1D = Object.defineProperty
  , __defProps$O = Object.defineProperties
  , __getOwnPropDescs$O = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$1F = Object.getOwnPropertySymbols
  , __hasOwnProp$1F = Object.prototype.hasOwnProperty
  , __propIsEnum$1F = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1D = (o, i, s) => i in o ? __defProp$1D(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1D = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1F.call(i, s) && __defNormalProp$1D(o, s, i[s]);
    if (__getOwnPropSymbols$1F)
        for (var s of __getOwnPropSymbols$1F(i))
            __propIsEnum$1F.call(i, s) && __defNormalProp$1D(o, s, i[s]);
    return o
}
  , __spreadProps$O = (o, i) => __defProps$O(o, __getOwnPropDescs$O(i));
function attachFunctions(o) {
    return __spreadProps$O(__spreadValues$1D({}, o), {
        fn: {
            fontStyles: fns.fontStyles(o),
            themeColor: fns.themeColor(o),
            focusStyles: fns.focusStyles(o),
            largerThan: fns.largerThan(o),
            smallerThan: fns.smallerThan(o),
            radialGradient: fns.radialGradient,
            linearGradient: fns.linearGradient,
            gradient: fns.gradient(o),
            rgba: fns.rgba,
            cover: fns.cover,
            lighten: fns.lighten,
            darken: fns.darken,
            primaryShade: fns.primaryShade(o),
            radius: fns.radius(o),
            variant: fns.variant(o),
            hover: fns.hover,
            primaryColor: fns.primaryColor(o),
            placeholderStyles: fns.placeholderStyles(o),
            dimmed: fns.dimmed(o)
        }
    })
}
const _DEFAULT_THEME = {
    dir: "ltr",
    primaryShade: {
        light: 6,
        dark: 8
    },
    focusRing: "auto",
    loader: "oval",
    colorScheme: "light",
    white: "#fff",
    black: "#000",
    defaultRadius: "sm",
    transitionTimingFunction: "ease",
    colors: DEFAULT_COLORS,
    lineHeight: 1.55,
    fontFamily: "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji",
    fontFamilyMonospace: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace",
    primaryColor: "blue",
    respectReducedMotion: !0,
    cursorType: "default",
    defaultGradient: {
        from: "indigo",
        to: "cyan",
        deg: 45
    },
    shadows: {
        xs: "0 0.0625rem 0.1875rem rgba(0, 0, 0, 0.05), 0 0.0625rem 0.125rem rgba(0, 0, 0, 0.1)",
        sm: "0 0.0625rem 0.1875rem rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 0.625rem 0.9375rem -0.3125rem, rgba(0, 0, 0, 0.04) 0 0.4375rem 0.4375rem -0.3125rem",
        md: "0 0.0625rem 0.1875rem rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 1.25rem 1.5625rem -0.3125rem, rgba(0, 0, 0, 0.04) 0 0.625rem 0.625rem -0.3125rem",
        lg: "0 0.0625rem 0.1875rem rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 1.75rem 1.4375rem -0.4375rem, rgba(0, 0, 0, 0.04) 0 0.75rem 0.75rem -0.4375rem",
        xl: "0 0.0625rem 0.1875rem rgba(0, 0, 0, 0.05), rgba(0, 0, 0, 0.05) 0 2.25rem 1.75rem -0.4375rem, rgba(0, 0, 0, 0.04) 0 1.0625rem 1.0625rem -0.4375rem"
    },
    fontSizes: {
        xs: "0.75rem",
        sm: "0.875rem",
        md: "1rem",
        lg: "1.125rem",
        xl: "1.25rem"
    },
    radius: {
        xs: "0.125rem",
        sm: "0.25rem",
        md: "0.5rem",
        lg: "1rem",
        xl: "2rem"
    },
    spacing: {
        xs: "0.625rem",
        sm: "0.75rem",
        md: "1rem",
        lg: "1.25rem",
        xl: "1.5rem"
    },
    breakpoints: {
        xs: "36em",
        sm: "48em",
        md: "62em",
        lg: "75em",
        xl: "88em"
    },
    headings: {
        fontFamily: "-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica, Arial, sans-serif, Apple Color Emoji, Segoe UI Emoji",
        fontWeight: 700,
        sizes: {
            h1: {
                fontSize: "2.125rem",
                lineHeight: 1.3,
                fontWeight: void 0
            },
            h2: {
                fontSize: "1.625rem",
                lineHeight: 1.35,
                fontWeight: void 0
            },
            h3: {
                fontSize: "1.375rem",
                lineHeight: 1.4,
                fontWeight: void 0
            },
            h4: {
                fontSize: "1.125rem",
                lineHeight: 1.45,
                fontWeight: void 0
            },
            h5: {
                fontSize: "1rem",
                lineHeight: 1.5,
                fontWeight: void 0
            },
            h6: {
                fontSize: "0.875rem",
                lineHeight: 1.5,
                fontWeight: void 0
            }
        }
    },
    other: {},
    components: {},
    activeStyles: {
        transform: "translateY(0.0625rem)"
    },
    datesLocale: "en",
    globalStyles: void 0,
    focusRingStyles: {
        styles: o => ({
            outlineOffset: "0.125rem",
            outline: `0.125rem solid ${o.colors[o.primaryColor][o.colorScheme === "dark" ? 7 : 5]}`
        }),
        resetStyles: () => ({
            outline: "none"
        }),
        inputStyles: o => ({
            outline: "none",
            borderColor: o.colors[o.primaryColor][typeof o.primaryShade == "object" ? o.primaryShade[o.colorScheme] : o.primaryShade]
        })
    }
}
  , DEFAULT_THEME = attachFunctions(_DEFAULT_THEME);
function sheetForTag(o) {
    if (o.sheet)
        return o.sheet;
    for (var i = 0; i < document.styleSheets.length; i++)
        if (document.styleSheets[i].ownerNode === o)
            return document.styleSheets[i]
}
function createStyleElement(o) {
    var i = document.createElement("style");
    return i.setAttribute("data-emotion", o.key),
    o.nonce !== void 0 && i.setAttribute("nonce", o.nonce),
    i.appendChild(document.createTextNode("")),
    i.setAttribute("data-s", ""),
    i
}
var StyleSheet = function() {
    function o(s) {
        var a = this;
        this._insertTag = function(_) {
            var $;
            a.tags.length === 0 ? a.insertionPoint ? $ = a.insertionPoint.nextSibling : a.prepend ? $ = a.container.firstChild : $ = a.before : $ = a.tags[a.tags.length - 1].nextSibling,
            a.container.insertBefore(_, $),
            a.tags.push(_)
        }
        ,
        this.isSpeedy = s.speedy === void 0 ? !0 : s.speedy,
        this.tags = [],
        this.ctr = 0,
        this.nonce = s.nonce,
        this.key = s.key,
        this.container = s.container,
        this.prepend = s.prepend,
        this.insertionPoint = s.insertionPoint,
        this.before = null
    }
    var i = o.prototype;
    return i.hydrate = function(a) {
        a.forEach(this._insertTag)
    }
    ,
    i.insert = function(a) {
        this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(createStyleElement(this));
        var _ = this.tags[this.tags.length - 1];
        if (this.isSpeedy) {
            var $ = sheetForTag(_);
            try {
                $.insertRule(a, $.cssRules.length)
            } catch {}
        } else
            _.appendChild(document.createTextNode(a));
        this.ctr++
    }
    ,
    i.flush = function() {
        this.tags.forEach(function(a) {
            return a.parentNode && a.parentNode.removeChild(a)
        }),
        this.tags = [],
        this.ctr = 0
    }
    ,
    o
}()
  , MS = "-ms-"
  , MOZ = "-moz-"
  , WEBKIT$1 = "-webkit-"
  , COMMENT = "comm"
  , RULESET = "rule"
  , DECLARATION = "decl"
  , IMPORT = "@import"
  , KEYFRAMES = "@keyframes"
  , LAYER = "@layer"
  , abs = Math.abs
  , from = String.fromCharCode
  , assign = Object.assign;
function hash$1(o, i) {
    return charat(o, 0) ^ 45 ? (((i << 2 ^ charat(o, 0)) << 2 ^ charat(o, 1)) << 2 ^ charat(o, 2)) << 2 ^ charat(o, 3) : 0
}
function trim(o) {
    return o.trim()
}
function match(o, i) {
    return (o = i.exec(o)) ? o[0] : o
}
function replace(o, i, s) {
    return o.replace(i, s)
}
function indexof(o, i) {
    return o.indexOf(i)
}
function charat(o, i) {
    return o.charCodeAt(i) | 0
}
function substr(o, i, s) {
    return o.slice(i, s)
}
function strlen(o) {
    return o.length
}
function sizeof(o) {
    return o.length
}
function append(o, i) {
    return i.push(o),
    o
}
function combine(o, i) {
    return o.map(i).join("")
}
var line = 1
  , column = 1
  , length = 0
  , position = 0
  , character = 0
  , characters = "";
function node(o, i, s, a, _, $, _e) {
    return {
        value: o,
        root: i,
        parent: s,
        type: a,
        props: _,
        children: $,
        line,
        column,
        length: _e,
        return: ""
    }
}
function copy(o, i) {
    return assign(node("", null, null, "", null, null, 0), o, {
        length: -o.length
    }, i)
}
function char() {
    return character
}
function prev() {
    return character = position > 0 ? charat(characters, --position) : 0,
    column--,
    character === 10 && (column = 1,
    line--),
    character
}
function next() {
    return character = position < length ? charat(characters, position++) : 0,
    column++,
    character === 10 && (column = 1,
    line++),
    character
}
function peek() {
    return charat(characters, position)
}
function caret() {
    return position
}
function slice(o, i) {
    return substr(characters, o, i)
}
function token(o) {
    switch (o) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
        return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
        return 4;
    case 58:
        return 3;
    case 34:
    case 39:
    case 40:
    case 91:
        return 2;
    case 41:
    case 93:
        return 1
    }
    return 0
}
function alloc(o) {
    return line = column = 1,
    length = strlen(characters = o),
    position = 0,
    []
}
function dealloc(o) {
    return characters = "",
    o
}
function delimit(o) {
    return trim(slice(position - 1, delimiter(o === 91 ? o + 2 : o === 40 ? o + 1 : o)))
}
function whitespace(o) {
    for (; (character = peek()) && character < 33; )
        next();
    return token(o) > 2 || token(character) > 3 ? "" : " "
}
function escaping(o, i) {
    for (; --i && next() && !(character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97); )
        ;
    return slice(o, caret() + (i < 6 && peek() == 32 && next() == 32))
}
function delimiter(o) {
    for (; next(); )
        switch (character) {
        case o:
            return position;
        case 34:
        case 39:
            o !== 34 && o !== 39 && delimiter(character);
            break;
        case 40:
            o === 41 && delimiter(o);
            break;
        case 92:
            next();
            break
        }
    return position
}
function commenter(o, i) {
    for (; next() && o + character !== 47 + 10; )
        if (o + character === 42 + 42 && peek() === 47)
            break;
    return "/*" + slice(i, position - 1) + "*" + from(o === 47 ? o : next())
}
function identifier(o) {
    for (; !token(peek()); )
        next();
    return slice(o, position)
}
function compile(o) {
    return dealloc(parse$1("", null, null, null, [""], o = alloc(o), 0, [0], o))
}
function parse$1(o, i, s, a, _, $, _e, tt, nt) {
    for (var rt = 0, ot = 0, et = _e, j = 0, it = 0, st = 0, at = 1, lt = 1, ct = 1, ut = 0, dt = "", ft = _, ht = $, pt = a, gt = dt; lt; )
        switch (st = ut,
        ut = next()) {
        case 40:
            if (st != 108 && charat(gt, et - 1) == 58) {
                indexof(gt += replace(delimit(ut), "&", "&\f"), "&\f") != -1 && (ct = -1);
                break
            }
        case 34:
        case 39:
        case 91:
            gt += delimit(ut);
            break;
        case 9:
        case 10:
        case 13:
        case 32:
            gt += whitespace(st);
            break;
        case 92:
            gt += escaping(caret() - 1, 7);
            continue;
        case 47:
            switch (peek()) {
            case 42:
            case 47:
                append(comment(commenter(next(), caret()), i, s), nt);
                break;
            default:
                gt += "/"
            }
            break;
        case 123 * at:
            tt[rt++] = strlen(gt) * ct;
        case 125 * at:
        case 59:
        case 0:
            switch (ut) {
            case 0:
            case 125:
                lt = 0;
            case 59 + ot:
                ct == -1 && (gt = replace(gt, /\f/g, "")),
                it > 0 && strlen(gt) - et && append(it > 32 ? declaration(gt + ";", a, s, et - 1) : declaration(replace(gt, " ", "") + ";", a, s, et - 2), nt);
                break;
            case 59:
                gt += ";";
            default:
                if (append(pt = ruleset(gt, i, s, rt, ot, _, tt, dt, ft = [], ht = [], et), $),
                ut === 123)
                    if (ot === 0)
                        parse$1(gt, i, pt, pt, ft, $, et, tt, ht);
                    else
                        switch (j === 99 && charat(gt, 3) === 110 ? 100 : j) {
                        case 100:
                        case 108:
                        case 109:
                        case 115:
                            parse$1(o, pt, pt, a && append(ruleset(o, pt, pt, 0, 0, _, tt, dt, _, ft = [], et), ht), _, ht, et, tt, a ? ft : ht);
                            break;
                        default:
                            parse$1(gt, pt, pt, pt, [""], ht, 0, tt, ht)
                        }
            }
            rt = ot = it = 0,
            at = ct = 1,
            dt = gt = "",
            et = _e;
            break;
        case 58:
            et = 1 + strlen(gt),
            it = st;
        default:
            if (at < 1) {
                if (ut == 123)
                    --at;
                else if (ut == 125 && at++ == 0 && prev() == 125)
                    continue
            }
            switch (gt += from(ut),
            ut * at) {
            case 38:
                ct = ot > 0 ? 1 : (gt += "\f",
                -1);
                break;
            case 44:
                tt[rt++] = (strlen(gt) - 1) * ct,
                ct = 1;
                break;
            case 64:
                peek() === 45 && (gt += delimit(next())),
                j = peek(),
                ot = et = strlen(dt = gt += identifier(caret())),
                ut++;
                break;
            case 45:
                st === 45 && strlen(gt) == 2 && (at = 0)
            }
        }
    return $
}
function ruleset(o, i, s, a, _, $, _e, tt, nt, rt, ot) {
    for (var et = _ - 1, j = _ === 0 ? $ : [""], it = sizeof(j), st = 0, at = 0, lt = 0; st < a; ++st)
        for (var ct = 0, ut = substr(o, et + 1, et = abs(at = _e[st])), dt = o; ct < it; ++ct)
            (dt = trim(at > 0 ? j[ct] + " " + ut : replace(ut, /&\f/g, j[ct]))) && (nt[lt++] = dt);
    return node(o, i, s, _ === 0 ? RULESET : tt, nt, rt, ot)
}
function comment(o, i, s) {
    return node(o, i, s, COMMENT, from(char()), substr(o, 2, -2), 0)
}
function declaration(o, i, s, a) {
    return node(o, i, s, DECLARATION, substr(o, 0, a), substr(o, a + 1, -1), a)
}
function serialize(o, i) {
    for (var s = "", a = sizeof(o), _ = 0; _ < a; _++)
        s += i(o[_], _, o, i) || "";
    return s
}
function stringify(o, i, s, a) {
    switch (o.type) {
    case LAYER:
        if (o.children.length)
            break;
    case IMPORT:
    case DECLARATION:
        return o.return = o.return || o.value;
    case COMMENT:
        return "";
    case KEYFRAMES:
        return o.return = o.value + "{" + serialize(o.children, a) + "}";
    case RULESET:
        o.value = o.props.join(",")
    }
    return strlen(s = serialize(o.children, a)) ? o.return = o.value + "{" + s + "}" : ""
}
function middleware(o) {
    var i = sizeof(o);
    return function(s, a, _, $) {
        for (var _e = "", tt = 0; tt < i; tt++)
            _e += o[tt](s, a, _, $) || "";
        return _e
    }
}
function rulesheet(o) {
    return function(i) {
        i.root || (i = i.return) && o(i)
    }
}
var weakMemoize = function(i) {
    var s = new WeakMap;
    return function(a) {
        if (s.has(a))
            return s.get(a);
        var _ = i(a);
        return s.set(a, _),
        _
    }
};
function memoize(o) {
    var i = Object.create(null);
    return function(s) {
        return i[s] === void 0 && (i[s] = o(s)),
        i[s]
    }
}
var identifierWithPointTracking = function(i, s, a) {
    for (var _ = 0, $ = 0; _ = $,
    $ = peek(),
    _ === 38 && $ === 12 && (s[a] = 1),
    !token($); )
        next();
    return slice(i, position)
}
  , toRules = function(i, s) {
    var a = -1
      , _ = 44;
    do
        switch (token(_)) {
        case 0:
            _ === 38 && peek() === 12 && (s[a] = 1),
            i[a] += identifierWithPointTracking(position - 1, s, a);
            break;
        case 2:
            i[a] += delimit(_);
            break;
        case 4:
            if (_ === 44) {
                i[++a] = peek() === 58 ? "&\f" : "",
                s[a] = i[a].length;
                break
            }
        default:
            i[a] += from(_)
        }
    while (_ = next());
    return i
}
  , getRules = function(i, s) {
    return dealloc(toRules(alloc(i), s))
}
  , fixedElements = new WeakMap
  , compat = function(i) {
    if (!(i.type !== "rule" || !i.parent || i.length < 1)) {
        for (var s = i.value, a = i.parent, _ = i.column === a.column && i.line === a.line; a.type !== "rule"; )
            if (a = a.parent,
            !a)
                return;
        if (!(i.props.length === 1 && s.charCodeAt(0) !== 58 && !fixedElements.get(a)) && !_) {
            fixedElements.set(i, !0);
            for (var $ = [], _e = getRules(s, $), tt = a.props, nt = 0, rt = 0; nt < _e.length; nt++)
                for (var ot = 0; ot < tt.length; ot++,
                rt++)
                    i.props[rt] = $[nt] ? _e[nt].replace(/&\f/g, tt[ot]) : tt[ot] + " " + _e[nt]
        }
    }
}
  , removeLabel = function(i) {
    if (i.type === "decl") {
        var s = i.value;
        s.charCodeAt(0) === 108 && s.charCodeAt(2) === 98 && (i.return = "",
        i.value = "")
    }
};
function prefix(o, i) {
    switch (hash$1(o, i)) {
    case 5103:
        return WEBKIT$1 + "print-" + o + o;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
        return WEBKIT$1 + o + o;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
        return WEBKIT$1 + o + MOZ + o + MS + o + o;
    case 6828:
    case 4268:
        return WEBKIT$1 + o + MS + o + o;
    case 6165:
        return WEBKIT$1 + o + MS + "flex-" + o + o;
    case 5187:
        return WEBKIT$1 + o + replace(o, /(\w+).+(:[^]+)/, WEBKIT$1 + "box-$1$2" + MS + "flex-$1$2") + o;
    case 5443:
        return WEBKIT$1 + o + MS + "flex-item-" + replace(o, /flex-|-self/, "") + o;
    case 4675:
        return WEBKIT$1 + o + MS + "flex-line-pack" + replace(o, /align-content|flex-|-self/, "") + o;
    case 5548:
        return WEBKIT$1 + o + MS + replace(o, "shrink", "negative") + o;
    case 5292:
        return WEBKIT$1 + o + MS + replace(o, "basis", "preferred-size") + o;
    case 6060:
        return WEBKIT$1 + "box-" + replace(o, "-grow", "") + WEBKIT$1 + o + MS + replace(o, "grow", "positive") + o;
    case 4554:
        return WEBKIT$1 + replace(o, /([^-])(transform)/g, "$1" + WEBKIT$1 + "$2") + o;
    case 6187:
        return replace(replace(replace(o, /(zoom-|grab)/, WEBKIT$1 + "$1"), /(image-set)/, WEBKIT$1 + "$1"), o, "") + o;
    case 5495:
    case 3959:
        return replace(o, /(image-set\([^]*)/, WEBKIT$1 + "$1$`$1");
    case 4968:
        return replace(replace(o, /(.+:)(flex-)?(.*)/, WEBKIT$1 + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT$1 + o + o;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
        return replace(o, /(.+)-inline(.+)/, WEBKIT$1 + "$1$2") + o;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
        if (strlen(o) - 1 - i > 6)
            switch (charat(o, i + 1)) {
            case 109:
                if (charat(o, i + 4) !== 45)
                    break;
            case 102:
                return replace(o, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT$1 + "$2-$3$1" + MOZ + (charat(o, i + 3) == 108 ? "$3" : "$2-$3")) + o;
            case 115:
                return ~indexof(o, "stretch") ? prefix(replace(o, "stretch", "fill-available"), i) + o : o
            }
        break;
    case 4949:
        if (charat(o, i + 1) !== 115)
            break;
    case 6444:
        switch (charat(o, strlen(o) - 3 - (~indexof(o, "!important") && 10))) {
        case 107:
            return replace(o, ":", ":" + WEBKIT$1) + o;
        case 101:
            return replace(o, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT$1 + (charat(o, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT$1 + "$2$3$1" + MS + "$2box$3") + o
        }
        break;
    case 5936:
        switch (charat(o, i + 11)) {
        case 114:
            return WEBKIT$1 + o + MS + replace(o, /[svh]\w+-[tblr]{2}/, "tb") + o;
        case 108:
            return WEBKIT$1 + o + MS + replace(o, /[svh]\w+-[tblr]{2}/, "tb-rl") + o;
        case 45:
            return WEBKIT$1 + o + MS + replace(o, /[svh]\w+-[tblr]{2}/, "lr") + o
        }
        return WEBKIT$1 + o + MS + o + o
    }
    return o
}
var prefixer = function(i, s, a, _) {
    if (i.length > -1 && !i.return)
        switch (i.type) {
        case DECLARATION:
            i.return = prefix(i.value, i.length);
            break;
        case KEYFRAMES:
            return serialize([copy(i, {
                value: replace(i.value, "@", "@" + WEBKIT$1)
            })], _);
        case RULESET:
            if (i.length)
                return combine(i.props, function($) {
                    switch (match($, /(::plac\w+|:read-\w+)/)) {
                    case ":read-only":
                    case ":read-write":
                        return serialize([copy(i, {
                            props: [replace($, /:(read-\w+)/, ":" + MOZ + "$1")]
                        })], _);
                    case "::placeholder":
                        return serialize([copy(i, {
                            props: [replace($, /:(plac\w+)/, ":" + WEBKIT$1 + "input-$1")]
                        }), copy(i, {
                            props: [replace($, /:(plac\w+)/, ":" + MOZ + "$1")]
                        }), copy(i, {
                            props: [replace($, /:(plac\w+)/, MS + "input-$1")]
                        })], _)
                    }
                    return ""
                })
        }
}
  , defaultStylisPlugins = [prefixer]
  , createCache = function(i) {
    var s = i.key;
    if (s === "css") {
        var a = document.querySelectorAll("style[data-emotion]:not([data-s])");
        Array.prototype.forEach.call(a, function(at) {
            var lt = at.getAttribute("data-emotion");
            lt.indexOf(" ") !== -1 && (document.head.appendChild(at),
            at.setAttribute("data-s", ""))
        })
    }
    var _ = i.stylisPlugins || defaultStylisPlugins, $ = {}, _e, tt = [];
    _e = i.container || document.head,
    Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="' + s + ' "]'), function(at) {
        for (var lt = at.getAttribute("data-emotion").split(" "), ct = 1; ct < lt.length; ct++)
            $[lt[ct]] = !0;
        tt.push(at)
    });
    var nt, rt = [compat, removeLabel];
    {
        var ot, et = [stringify, rulesheet(function(at) {
            ot.insert(at)
        })], j = middleware(rt.concat(_, et)), it = function(lt) {
            return serialize(compile(lt), j)
        };
        nt = function(lt, ct, ut, dt) {
            ot = ut,
            it(lt ? lt + "{" + ct.styles + "}" : ct.styles),
            dt && (st.inserted[ct.name] = !0)
        }
    }
    var st = {
        key: s,
        sheet: new StyleSheet({
            key: s,
            container: _e,
            nonce: i.nonce,
            speedy: i.speedy,
            prepend: i.prepend,
            insertionPoint: i.insertionPoint
        }),
        nonce: i.nonce,
        inserted: $,
        registered: {},
        insert: nt
    };
    return st.sheet.hydrate(tt),
    st
};
function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(o) {
        for (var i = 1; i < arguments.length; i++) {
            var s = arguments[i];
            for (var a in s)
                Object.prototype.hasOwnProperty.call(s, a) && (o[a] = s[a])
        }
        return o
    }
    ,
    _extends.apply(this, arguments)
}
var reactIs$1 = {
    exports: {}
}
  , reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = typeof Symbol == "function" && Symbol.for
  , c = b ? Symbol.for("react.element") : 60103
  , d = b ? Symbol.for("react.portal") : 60106
  , e = b ? Symbol.for("react.fragment") : 60107
  , f = b ? Symbol.for("react.strict_mode") : 60108
  , g = b ? Symbol.for("react.profiler") : 60114
  , h = b ? Symbol.for("react.provider") : 60109
  , k = b ? Symbol.for("react.context") : 60110
  , l = b ? Symbol.for("react.async_mode") : 60111
  , m = b ? Symbol.for("react.concurrent_mode") : 60111
  , n = b ? Symbol.for("react.forward_ref") : 60112
  , p = b ? Symbol.for("react.suspense") : 60113
  , q = b ? Symbol.for("react.suspense_list") : 60120
  , r = b ? Symbol.for("react.memo") : 60115
  , t = b ? Symbol.for("react.lazy") : 60116
  , v = b ? Symbol.for("react.block") : 60121
  , w = b ? Symbol.for("react.fundamental") : 60117
  , x = b ? Symbol.for("react.responder") : 60118
  , y = b ? Symbol.for("react.scope") : 60119;
function z(o) {
    if (typeof o == "object" && o !== null) {
        var i = o.$$typeof;
        switch (i) {
        case c:
            switch (o = o.type,
            o) {
            case l:
            case m:
            case e:
            case g:
            case f:
            case p:
                return o;
            default:
                switch (o = o && o.$$typeof,
                o) {
                case k:
                case n:
                case t:
                case r:
                case h:
                    return o;
                default:
                    return i
                }
            }
        case d:
            return i
        }
    }
}
function A(o) {
    return z(o) === m
}
reactIs_production_min.AsyncMode = l;
reactIs_production_min.ConcurrentMode = m;
reactIs_production_min.ContextConsumer = k;
reactIs_production_min.ContextProvider = h;
reactIs_production_min.Element = c;
reactIs_production_min.ForwardRef = n;
reactIs_production_min.Fragment = e;
reactIs_production_min.Lazy = t;
reactIs_production_min.Memo = r;
reactIs_production_min.Portal = d;
reactIs_production_min.Profiler = g;
reactIs_production_min.StrictMode = f;
reactIs_production_min.Suspense = p;
reactIs_production_min.isAsyncMode = function(o) {
    return A(o) || z(o) === l
}
;
reactIs_production_min.isConcurrentMode = A;
reactIs_production_min.isContextConsumer = function(o) {
    return z(o) === k
}
;
reactIs_production_min.isContextProvider = function(o) {
    return z(o) === h
}
;
reactIs_production_min.isElement = function(o) {
    return typeof o == "object" && o !== null && o.$$typeof === c
}
;
reactIs_production_min.isForwardRef = function(o) {
    return z(o) === n
}
;
reactIs_production_min.isFragment = function(o) {
    return z(o) === e
}
;
reactIs_production_min.isLazy = function(o) {
    return z(o) === t
}
;
reactIs_production_min.isMemo = function(o) {
    return z(o) === r
}
;
reactIs_production_min.isPortal = function(o) {
    return z(o) === d
}
;
reactIs_production_min.isProfiler = function(o) {
    return z(o) === g
}
;
reactIs_production_min.isStrictMode = function(o) {
    return z(o) === f
}
;
reactIs_production_min.isSuspense = function(o) {
    return z(o) === p
}
;
reactIs_production_min.isValidElementType = function(o) {
    return typeof o == "string" || typeof o == "function" || o === e || o === m || o === g || o === f || o === p || o === q || typeof o == "object" && o !== null && (o.$$typeof === t || o.$$typeof === r || o.$$typeof === h || o.$$typeof === k || o.$$typeof === n || o.$$typeof === w || o.$$typeof === x || o.$$typeof === y || o.$$typeof === v)
}
;
reactIs_production_min.typeOf = z;
reactIs$1.exports = reactIs_production_min;
var reactIsExports = reactIs$1.exports
  , reactIs = reactIsExports
  , FORWARD_REF_STATICS = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0
}
  , MEMO_STATICS = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0
}
  , TYPE_STATICS = {};
TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
var isBrowser = !0;
function getRegisteredStyles(o, i, s) {
    var a = "";
    return s.split(" ").forEach(function(_) {
        o[_] !== void 0 ? i.push(o[_] + ";") : a += _ + " "
    }),
    a
}
var registerStyles = function(i, s, a) {
    var _ = i.key + "-" + s.name;
    (a === !1 || isBrowser === !1) && i.registered[_] === void 0 && (i.registered[_] = s.styles)
}
  , insertStyles = function(i, s, a) {
    registerStyles(i, s, a);
    var _ = i.key + "-" + s.name;
    if (i.inserted[s.name] === void 0) {
        var $ = s;
        do
            i.insert(s === $ ? "." + _ : "", $, i.sheet, !0),
            $ = $.next;
        while ($ !== void 0)
    }
};
function murmur2(o) {
    for (var i = 0, s, a = 0, _ = o.length; _ >= 4; ++a,
    _ -= 4)
        s = o.charCodeAt(a) & 255 | (o.charCodeAt(++a) & 255) << 8 | (o.charCodeAt(++a) & 255) << 16 | (o.charCodeAt(++a) & 255) << 24,
        s = (s & 65535) * 1540483477 + ((s >>> 16) * 59797 << 16),
        s ^= s >>> 24,
        i = (s & 65535) * 1540483477 + ((s >>> 16) * 59797 << 16) ^ (i & 65535) * 1540483477 + ((i >>> 16) * 59797 << 16);
    switch (_) {
    case 3:
        i ^= (o.charCodeAt(a + 2) & 255) << 16;
    case 2:
        i ^= (o.charCodeAt(a + 1) & 255) << 8;
    case 1:
        i ^= o.charCodeAt(a) & 255,
        i = (i & 65535) * 1540483477 + ((i >>> 16) * 59797 << 16)
    }
    return i ^= i >>> 13,
    i = (i & 65535) * 1540483477 + ((i >>> 16) * 59797 << 16),
    ((i ^ i >>> 15) >>> 0).toString(36)
}
var unitlessKeys = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
}
  , hyphenateRegex = /[A-Z]|^ms/g
  , animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g
  , isCustomProperty = function(i) {
    return i.charCodeAt(1) === 45
}
  , isProcessableValue = function(i) {
    return i != null && typeof i != "boolean"
}
  , processStyleName = memoize(function(o) {
    return isCustomProperty(o) ? o : o.replace(hyphenateRegex, "-$&").toLowerCase()
})
  , processStyleValue = function(i, s) {
    switch (i) {
    case "animation":
    case "animationName":
        if (typeof s == "string")
            return s.replace(animationRegex, function(a, _, $) {
                return cursor = {
                    name: _,
                    styles: $,
                    next: cursor
                },
                _
            })
    }
    return unitlessKeys[i] !== 1 && !isCustomProperty(i) && typeof s == "number" && s !== 0 ? s + "px" : s
}
  , noComponentSelectorMessage = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function handleInterpolation(o, i, s) {
    if (s == null)
        return "";
    if (s.__emotion_styles !== void 0)
        return s;
    switch (typeof s) {
    case "boolean":
        return "";
    case "object":
        {
            if (s.anim === 1)
                return cursor = {
                    name: s.name,
                    styles: s.styles,
                    next: cursor
                },
                s.name;
            if (s.styles !== void 0) {
                var a = s.next;
                if (a !== void 0)
                    for (; a !== void 0; )
                        cursor = {
                            name: a.name,
                            styles: a.styles,
                            next: cursor
                        },
                        a = a.next;
                var _ = s.styles + ";";
                return _
            }
            return createStringFromObject(o, i, s)
        }
    case "function":
        {
            if (o !== void 0) {
                var $ = cursor
                  , _e = s(o);
                return cursor = $,
                handleInterpolation(o, i, _e)
            }
            break
        }
    }
    if (i == null)
        return s;
    var tt = i[s];
    return tt !== void 0 ? tt : s
}
function createStringFromObject(o, i, s) {
    var a = "";
    if (Array.isArray(s))
        for (var _ = 0; _ < s.length; _++)
            a += handleInterpolation(o, i, s[_]) + ";";
    else
        for (var $ in s) {
            var _e = s[$];
            if (typeof _e != "object")
                i != null && i[_e] !== void 0 ? a += $ + "{" + i[_e] + "}" : isProcessableValue(_e) && (a += processStyleName($) + ":" + processStyleValue($, _e) + ";");
            else if (Array.isArray(_e) && typeof _e[0] == "string" && (i == null || i[_e[0]] === void 0))
                for (var tt = 0; tt < _e.length; tt++)
                    isProcessableValue(_e[tt]) && (a += processStyleName($) + ":" + processStyleValue($, _e[tt]) + ";");
            else {
                var nt = handleInterpolation(o, i, _e);
                switch ($) {
                case "animation":
                case "animationName":
                    {
                        a += processStyleName($) + ":" + nt + ";";
                        break
                    }
                default:
                    a += $ + "{" + nt + "}"
                }
            }
        }
    return a
}
var labelPattern = /label:\s*([^\s;\n{]+)\s*(;|$)/g, cursor, serializeStyles = function(i, s, a) {
    if (i.length === 1 && typeof i[0] == "object" && i[0] !== null && i[0].styles !== void 0)
        return i[0];
    var _ = !0
      , $ = "";
    cursor = void 0;
    var _e = i[0];
    _e == null || _e.raw === void 0 ? (_ = !1,
    $ += handleInterpolation(a, s, _e)) : $ += _e[0];
    for (var tt = 1; tt < i.length; tt++)
        $ += handleInterpolation(a, s, i[tt]),
        _ && ($ += _e[tt]);
    labelPattern.lastIndex = 0;
    for (var nt = "", rt; (rt = labelPattern.exec($)) !== null; )
        nt += "-" + rt[1];
    var ot = murmur2($) + nt;
    return {
        name: ot,
        styles: $,
        next: cursor
    }
}, useInsertionEffect$1 = React$1["useInsertionEffect"] ? React$1["useInsertionEffect"] : !1, useInsertionEffectWithLayoutFallback = useInsertionEffect$1 || reactExports.useLayoutEffect, EmotionCacheContext = reactExports.createContext(typeof HTMLElement < "u" ? createCache({
    key: "css"
}) : null);
EmotionCacheContext.Provider;
var withEmotionCache = function(i) {
    return reactExports.forwardRef(function(s, a) {
        var _ = reactExports.useContext(EmotionCacheContext);
        return i(s, _, a)
    })
}
  , ThemeContext = reactExports.createContext({})
  , getTheme = function(i, s) {
    if (typeof s == "function") {
        var a = s(i);
        return a
    }
    return _extends({}, i, s)
}
  , createCacheWithTheme = weakMemoize(function(o) {
    return weakMemoize(function(i) {
        return getTheme(o, i)
    })
})
  , ThemeProvider = function(i) {
    var s = reactExports.useContext(ThemeContext);
    return i.theme !== s && (s = createCacheWithTheme(s)(i.theme)),
    reactExports.createElement(ThemeContext.Provider, {
        value: s
    }, i.children)
}
  , Global = withEmotionCache(function(o, i) {
    var s = o.styles
      , a = serializeStyles([s], void 0, reactExports.useContext(ThemeContext))
      , _ = reactExports.useRef();
    return useInsertionEffectWithLayoutFallback(function() {
        var $ = i.key + "-global"
          , _e = new i.sheet.constructor({
            key: $,
            nonce: i.sheet.nonce,
            container: i.sheet.container,
            speedy: i.sheet.isSpeedy
        })
          , tt = !1
          , nt = document.querySelector('style[data-emotion="' + $ + " " + a.name + '"]');
        return i.sheet.tags.length && (_e.before = i.sheet.tags[0]),
        nt !== null && (tt = !0,
        nt.setAttribute("data-emotion", $),
        _e.hydrate([nt])),
        _.current = [_e, tt],
        function() {
            _e.flush()
        }
    }, [i]),
    useInsertionEffectWithLayoutFallback(function() {
        var $ = _.current
          , _e = $[0]
          , tt = $[1];
        if (tt) {
            $[1] = !1;
            return
        }
        if (a.next !== void 0 && insertStyles(i, a.next, !0),
        _e.tags.length) {
            var nt = _e.tags[_e.tags.length - 1].nextElementSibling;
            _e.before = nt,
            _e.flush()
        }
        i.insert("", a, _e, !1)
    }, [i, a.name]),
    null
})
  , __defProp$1C = Object.defineProperty
  , __defProps$N = Object.defineProperties
  , __getOwnPropDescs$N = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$1E = Object.getOwnPropertySymbols
  , __hasOwnProp$1E = Object.prototype.hasOwnProperty
  , __propIsEnum$1E = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1C = (o, i, s) => i in o ? __defProp$1C(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1C = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1E.call(i, s) && __defNormalProp$1C(o, s, i[s]);
    if (__getOwnPropSymbols$1E)
        for (var s of __getOwnPropSymbols$1E(i))
            __propIsEnum$1E.call(i, s) && __defNormalProp$1C(o, s, i[s]);
    return o
}
  , __spreadProps$N = (o, i) => __defProps$N(o, __getOwnPropDescs$N(i));
function GlobalStyles({theme: o}) {
    return React.createElement(Global, {
        styles: {
            "*, *::before, *::after": {
                boxSizing: "border-box"
            },
            html: {
                colorScheme: o.colorScheme === "dark" ? "dark" : "light"
            },
            body: __spreadProps$N(__spreadValues$1C({}, o.fn.fontStyles()), {
                backgroundColor: o.colorScheme === "dark" ? o.colors.dark[7] : o.white,
                color: o.colorScheme === "dark" ? o.colors.dark[0] : o.black,
                lineHeight: o.lineHeight,
                fontSize: o.fontSizes.md,
                WebkitFontSmoothing: "antialiased",
                MozOsxFontSmoothing: "grayscale"
            })
        }
    })
}
function assignSizeVariables(o, i, s, a=rem) {
    Object.keys(i).forEach(_ => {
        o[`--mantine-${s}-${_}`] = a(i[_])
    }
    )
}
function MantineCssVariables({theme: o}) {
    const i = {
        "--mantine-color-white": o.white,
        "--mantine-color-black": o.black,
        "--mantine-transition-timing-function": o.transitionTimingFunction,
        "--mantine-line-height": `${o.lineHeight}`,
        "--mantine-font-family": o.fontFamily,
        "--mantine-font-family-monospace": o.fontFamilyMonospace,
        "--mantine-font-family-headings": o.headings.fontFamily,
        "--mantine-heading-font-weight": `${o.headings.fontWeight}`
    };
    assignSizeVariables(i, o.shadows, "shadow"),
    assignSizeVariables(i, o.fontSizes, "font-size"),
    assignSizeVariables(i, o.radius, "radius"),
    assignSizeVariables(i, o.spacing, "spacing"),
    assignSizeVariables(i, o.breakpoints, "breakpoints", em),
    Object.keys(o.colors).forEach(a => {
        o.colors[a].forEach( (_, $) => {
            i[`--mantine-color-${a}-${$}`] = _
        }
        )
    }
    );
    const s = o.headings.sizes;
    return Object.keys(s).forEach(a => {
        i[`--mantine-${a}-font-size`] = s[a].fontSize,
        i[`--mantine-${a}-line-height`] = `${s[a].lineHeight}`
    }
    ),
    React.createElement(Global, {
        styles: {
            ":root": i
        }
    })
}
var __defProp$1B = Object.defineProperty
  , __defProps$M = Object.defineProperties
  , __getOwnPropDescs$M = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$1D = Object.getOwnPropertySymbols
  , __hasOwnProp$1D = Object.prototype.hasOwnProperty
  , __propIsEnum$1D = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1B = (o, i, s) => i in o ? __defProp$1B(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1B = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1D.call(i, s) && __defNormalProp$1B(o, s, i[s]);
    if (__getOwnPropSymbols$1D)
        for (var s of __getOwnPropSymbols$1D(i))
            __propIsEnum$1D.call(i, s) && __defNormalProp$1B(o, s, i[s]);
    return o
}
  , __spreadProps$M = (o, i) => __defProps$M(o, __getOwnPropDescs$M(i));
function mergeTheme(o, i) {
    var s;
    if (!i)
        return o;
    const a = Object.keys(o).reduce( (_, $) => {
        if ($ === "headings" && i.headings) {
            const _e = i.headings.sizes ? Object.keys(o.headings.sizes).reduce( (tt, nt) => (tt[nt] = __spreadValues$1B(__spreadValues$1B({}, o.headings.sizes[nt]), i.headings.sizes[nt]),
            tt), {}) : o.headings.sizes;
            return __spreadProps$M(__spreadValues$1B({}, _), {
                headings: __spreadProps$M(__spreadValues$1B(__spreadValues$1B({}, o.headings), i.headings), {
                    sizes: _e
                })
            })
        }
        if ($ === "breakpoints" && i.breakpoints) {
            const _e = __spreadValues$1B(__spreadValues$1B({}, o.breakpoints), i.breakpoints);
            return __spreadProps$M(__spreadValues$1B({}, _), {
                breakpoints: Object.fromEntries(Object.entries(_e).sort( (tt, nt) => getBreakpointValue(tt[1]) - getBreakpointValue(nt[1])))
            })
        }
        return _[$] = typeof i[$] == "object" ? __spreadValues$1B(__spreadValues$1B({}, o[$]), i[$]) : typeof i[$] == "number" || typeof i[$] == "boolean" || typeof i[$] == "function" ? i[$] : i[$] || o[$],
        _
    }
    , {});
    if (i != null && i.fontFamily && !((s = i == null ? void 0 : i.headings) != null && s.fontFamily) && (a.headings.fontFamily = i.fontFamily),
    !(a.primaryColor in a.colors))
        throw new Error("MantineProvider: Invalid theme.primaryColor, it accepts only key of theme.colors, learn more – https://mantine.dev/theming/colors/#primary-color");
    return a
}
function mergeThemeWithFunctions(o, i) {
    return attachFunctions(mergeTheme(o, i))
}
function filterProps(o) {
    return Object.keys(o).reduce( (i, s) => (o[s] !== void 0 && (i[s] = o[s]),
    i), {})
}
const styles$2 = {
    html: {
        fontFamily: "sans-serif",
        lineHeight: "1.15",
        textSizeAdjust: "100%"
    },
    body: {
        margin: 0
    },
    "article, aside, footer, header, nav, section, figcaption, figure, main": {
        display: "block"
    },
    h1: {
        fontSize: "2em"
    },
    hr: {
        boxSizing: "content-box",
        height: 0,
        overflow: "visible"
    },
    pre: {
        fontFamily: "monospace, monospace",
        fontSize: "1em"
    },
    a: {
        background: "transparent",
        textDecorationSkip: "objects"
    },
    "a:active, a:hover": {
        outlineWidth: 0
    },
    "abbr[title]": {
        borderBottom: "none",
        textDecoration: "underline"
    },
    "b, strong": {
        fontWeight: "bolder"
    },
    "code, kbp, samp": {
        fontFamily: "monospace, monospace",
        fontSize: "1em"
    },
    dfn: {
        fontStyle: "italic"
    },
    mark: {
        backgroundColor: "#ff0",
        color: "#000"
    },
    small: {
        fontSize: "80%"
    },
    "sub, sup": {
        fontSize: "75%",
        lineHeight: 0,
        position: "relative",
        verticalAlign: "baseline"
    },
    sup: {
        top: "-0.5em"
    },
    sub: {
        bottom: "-0.25em"
    },
    "audio, video": {
        display: "inline-block"
    },
    "audio:not([controls])": {
        display: "none",
        height: 0
    },
    img: {
        borderStyle: "none",
        verticalAlign: "middle"
    },
    "svg:not(:root)": {
        overflow: "hidden"
    },
    "button, input, optgroup, select, textarea": {
        fontFamily: "sans-serif",
        fontSize: "100%",
        lineHeight: "1.15",
        margin: 0
    },
    "button, input": {
        overflow: "visible"
    },
    "button, select": {
        textTransform: "none"
    },
    "button, [type=reset], [type=submit]": {
        WebkitAppearance: "button"
    },
    "button::-moz-focus-inner, [type=button]::-moz-focus-inner, [type=reset]::-moz-focus-inner, [type=submit]::-moz-focus-inner": {
        borderStyle: "none",
        padding: 0
    },
    "button:-moz-focusring, [type=button]:-moz-focusring, [type=reset]:-moz-focusring, [type=submit]:-moz-focusring": {
        outline: `${rem(1)} dotted ButtonText`
    },
    legend: {
        boxSizing: "border-box",
        color: "inherit",
        display: "table",
        maxWidth: "100%",
        padding: 0,
        whiteSpace: "normal"
    },
    progress: {
        display: "inline-block",
        verticalAlign: "baseline"
    },
    textarea: {
        overflow: "auto"
    },
    "[type=checkbox], [type=radio]": {
        boxSizing: "border-box",
        padding: 0
    },
    "[type=number]::-webkit-inner-spin-button, [type=number]::-webkit-outer-spin-button": {
        height: "auto"
    },
    "[type=search]": {
        appearance: "none"
    },
    "[type=search]::-webkit-search-cancel-button, [type=search]::-webkit-search-decoration": {
        appearance: "none"
    },
    "::-webkit-file-upload-button": {
        appearance: "button",
        font: "inherit"
    },
    "details, menu": {
        display: "block"
    },
    summary: {
        display: "list-item"
    },
    canvas: {
        display: "inline-block"
    },
    template: {
        display: "none"
    }
};
function NormalizeCSS() {
    return React.createElement(Global, {
        styles: styles$2
    })
}
var __defProp$1A = Object.defineProperty
  , __getOwnPropSymbols$1C = Object.getOwnPropertySymbols
  , __hasOwnProp$1C = Object.prototype.hasOwnProperty
  , __propIsEnum$1C = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1A = (o, i, s) => i in o ? __defProp$1A(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1A = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1C.call(i, s) && __defNormalProp$1A(o, s, i[s]);
    if (__getOwnPropSymbols$1C)
        for (var s of __getOwnPropSymbols$1C(i))
            __propIsEnum$1C.call(i, s) && __defNormalProp$1A(o, s, i[s]);
    return o
}
;
const MantineProviderContext = reactExports.createContext({
    theme: DEFAULT_THEME
});
function useMantineTheme() {
    var o;
    return ((o = reactExports.useContext(MantineProviderContext)) == null ? void 0 : o.theme) || DEFAULT_THEME
}
function useMantineProviderStyles(o) {
    const i = useMantineTheme()
      , s = a => {
        var _, $, _e, tt;
        return {
            styles: ((_ = i.components[a]) == null ? void 0 : _.styles) || {},
            classNames: (($ = i.components[a]) == null ? void 0 : $.classNames) || {},
            variants: (_e = i.components[a]) == null ? void 0 : _e.variants,
            sizes: (tt = i.components[a]) == null ? void 0 : tt.sizes
        }
    }
    ;
    return Array.isArray(o) ? o.map(s) : [s(o)]
}
function useMantineEmotionCache() {
    var o;
    return (o = reactExports.useContext(MantineProviderContext)) == null ? void 0 : o.emotionCache
}
function useComponentDefaultProps(o, i, s) {
    var a;
    const _ = useMantineTheme()
      , $ = (a = _.components[o]) == null ? void 0 : a.defaultProps
      , _e = typeof $ == "function" ? $(_) : $;
    return __spreadValues$1A(__spreadValues$1A(__spreadValues$1A({}, i), _e), filterProps(s))
}
function MantineProvider({theme: o, emotionCache: i, withNormalizeCSS: s=!1, withGlobalStyles: a=!1, withCSSVariables: _=!1, inherit: $=!1, children: _e}) {
    const tt = reactExports.useContext(MantineProviderContext)
      , nt = mergeThemeWithFunctions(DEFAULT_THEME, $ ? __spreadValues$1A(__spreadValues$1A({}, tt.theme), o) : o);
    return React.createElement(ThemeProvider, {
        theme: nt
    }, React.createElement(MantineProviderContext.Provider, {
        value: {
            theme: nt,
            emotionCache: i
        }
    }, s && React.createElement(NormalizeCSS, null), a && React.createElement(GlobalStyles, {
        theme: nt
    }), _ && React.createElement(MantineCssVariables, {
        theme: nt
    }), typeof nt.globalStyles == "function" && React.createElement(Global, {
        styles: nt.globalStyles(nt)
    }), _e))
}
MantineProvider.displayName = "@mantine/core/MantineProvider";
const elevations = {
    app: 100,
    modal: 200,
    popover: 300,
    overlay: 400,
    max: 9999
};
function getDefaultZIndex(o) {
    return elevations[o]
}
function useGuaranteedMemo(o, i) {
    const s = reactExports.useRef();
    return (!s.current || i.length !== s.current.prevDeps.length || s.current.prevDeps.map( (a, _) => a === i[_]).indexOf(!1) >= 0) && (s.current = {
        v: o(),
        prevDeps: [...i]
    }),
    s.current.v
}
const defaultMantineEmotionCache = createCache({
    key: "mantine",
    prepend: !0
});
function useEmotionCache() {
    return useMantineEmotionCache() || defaultMantineEmotionCache
}
var __defProp$1z = Object.defineProperty
  , __getOwnPropSymbols$1B = Object.getOwnPropertySymbols
  , __hasOwnProp$1B = Object.prototype.hasOwnProperty
  , __propIsEnum$1B = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1z = (o, i, s) => i in o ? __defProp$1z(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1z = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1B.call(i, s) && __defNormalProp$1z(o, s, i[s]);
    if (__getOwnPropSymbols$1B)
        for (var s of __getOwnPropSymbols$1B(i))
            __propIsEnum$1B.call(i, s) && __defNormalProp$1z(o, s, i[s]);
    return o
}
;
const refPropertyName = "ref";
function getRef(o) {
    let i;
    if (o.length !== 1)
        return {
            args: o,
            ref: i
        };
    const [s] = o;
    if (!(s instanceof Object))
        return {
            args: o,
            ref: i
        };
    if (!(refPropertyName in s))
        return {
            args: o,
            ref: i
        };
    i = s[refPropertyName];
    const a = __spreadValues$1z({}, s);
    return delete a[refPropertyName],
    {
        args: [a],
        ref: i
    }
}
const {cssFactory} = ( () => {
    function o(s, a, _) {
        const $ = []
          , _e = getRegisteredStyles(s, $, _);
        return $.length < 2 ? _ : _e + a($)
    }
    function i(s) {
        const {cache: a} = s
          , _ = (..._e) => {
            const {ref: tt, args: nt} = getRef(_e)
              , rt = serializeStyles(nt, a.registered);
            return insertStyles(a, rt, !1),
            `${a.key}-${rt.name}${tt === void 0 ? "" : ` ${tt}`}`
        }
        ;
        return {
            css: _,
            cx: (..._e) => o(a.registered, _, clsx(_e))
        }
    }
    return {
        cssFactory: i
    }
}
)();
function useCss() {
    const o = useEmotionCache();
    return useGuaranteedMemo( () => cssFactory({
        cache: o
    }), [o])
}
function mergeClassNames({cx: o, classes: i, context: s, classNames: a, name: _, cache: $}) {
    const _e = s.reduce( (tt, nt) => (Object.keys(nt.classNames).forEach(rt => {
        typeof tt[rt] != "string" ? tt[rt] = `${nt.classNames[rt]}` : tt[rt] = `${tt[rt]} ${nt.classNames[rt]}`
    }
    ),
    tt), {});
    return Object.keys(i).reduce( (tt, nt) => (tt[nt] = o(i[nt], _e[nt], a != null && a[nt], Array.isArray(_) ? _.filter(Boolean).map(rt => `${($ == null ? void 0 : $.key) || "mantine"}-${rt}-${nt}`).join(" ") : _ ? `${($ == null ? void 0 : $.key) || "mantine"}-${_}-${nt}` : null),
    tt), {})
}
var __defProp$1y = Object.defineProperty
  , __getOwnPropSymbols$1A = Object.getOwnPropertySymbols
  , __hasOwnProp$1A = Object.prototype.hasOwnProperty
  , __propIsEnum$1A = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1y = (o, i, s) => i in o ? __defProp$1y(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1y = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1A.call(i, s) && __defNormalProp$1y(o, s, i[s]);
    if (__getOwnPropSymbols$1A)
        for (var s of __getOwnPropSymbols$1A(i))
            __propIsEnum$1A.call(i, s) && __defNormalProp$1y(o, s, i[s]);
    return o
}
;
function assignAccStyles(o, i) {
    return i && Object.keys(i).forEach(s => {
        o[s] ? o[s] = __spreadValues$1y(__spreadValues$1y({}, o[s]), i[s]) : o[s] = __spreadValues$1y({}, i[s])
    }
    ),
    o
}
function getStyles(o, i, s, a) {
    const _ = $ => typeof $ == "function" ? $(i, s || {}, a) : $ || {};
    return Array.isArray(o) ? o.map($ => _($.styles)).reduce( ($, _e) => assignAccStyles($, _e), {}) : _(o)
}
function getContextVariation({ctx: o, theme: i, params: s, variant: a, size: _}) {
    return o.reduce( ($, _e) => (_e.variants && a in _e.variants && assignAccStyles($, _e.variants[a](i, s, {
        variant: a,
        size: _
    })),
    _e.sizes && _ in _e.sizes && assignAccStyles($, _e.sizes[_](i, s, {
        variant: a,
        size: _
    })),
    $), {})
}
function createStyles(o) {
    const i = typeof o == "function" ? o : () => o;
    function s(a, _) {
        const $ = useMantineTheme()
          , _e = useMantineProviderStyles(_ == null ? void 0 : _.name)
          , tt = useMantineEmotionCache()
          , nt = {
            variant: _ == null ? void 0 : _.variant,
            size: _ == null ? void 0 : _.size
        }
          , {css: rt, cx: ot} = useCss()
          , et = i($, a, nt)
          , j = getStyles(_ == null ? void 0 : _.styles, $, a, nt)
          , it = getStyles(_e, $, a, nt)
          , st = getContextVariation({
            ctx: _e,
            theme: $,
            params: a,
            variant: _ == null ? void 0 : _.variant,
            size: _ == null ? void 0 : _.size
        })
          , at = Object.fromEntries(Object.keys(et).map(lt => {
            const ct = ot({
                [rt(et[lt])]: !(_ != null && _.unstyled)
            }, rt(st[lt]), rt(it[lt]), rt(j[lt]));
            return [lt, ct]
        }
        ));
        return {
            classes: mergeClassNames({
                cx: ot,
                classes: at,
                context: _e,
                classNames: _ == null ? void 0 : _.classNames,
                name: _ == null ? void 0 : _.name,
                cache: tt
            }),
            cx: ot,
            theme: $
        }
    }
    return s
}
function getStylesRef(o) {
    return `___ref-${o || ""}`
}
var __defProp$1x = Object.defineProperty
  , __defProps$L = Object.defineProperties
  , __getOwnPropDescs$L = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$1z = Object.getOwnPropertySymbols
  , __hasOwnProp$1z = Object.prototype.hasOwnProperty
  , __propIsEnum$1z = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1x = (o, i, s) => i in o ? __defProp$1x(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1x = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1z.call(i, s) && __defNormalProp$1x(o, s, i[s]);
    if (__getOwnPropSymbols$1z)
        for (var s of __getOwnPropSymbols$1z(i))
            __propIsEnum$1z.call(i, s) && __defNormalProp$1x(o, s, i[s]);
    return o
}
  , __spreadProps$L = (o, i) => __defProps$L(o, __getOwnPropDescs$L(i));
const popIn = {
    in: {
        opacity: 1,
        transform: "scale(1)"
    },
    out: {
        opacity: 0,
        transform: `scale(.9) translateY(${rem(10)})`
    },
    transitionProperty: "transform, opacity"
}
  , transitions = {
    fade: {
        in: {
            opacity: 1
        },
        out: {
            opacity: 0
        },
        transitionProperty: "opacity"
    },
    scale: {
        in: {
            opacity: 1,
            transform: "scale(1)"
        },
        out: {
            opacity: 0,
            transform: "scale(0)"
        },
        common: {
            transformOrigin: "top"
        },
        transitionProperty: "transform, opacity"
    },
    "scale-y": {
        in: {
            opacity: 1,
            transform: "scaleY(1)"
        },
        out: {
            opacity: 0,
            transform: "scaleY(0)"
        },
        common: {
            transformOrigin: "top"
        },
        transitionProperty: "transform, opacity"
    },
    "scale-x": {
        in: {
            opacity: 1,
            transform: "scaleX(1)"
        },
        out: {
            opacity: 0,
            transform: "scaleX(0)"
        },
        common: {
            transformOrigin: "left"
        },
        transitionProperty: "transform, opacity"
    },
    "skew-up": {
        in: {
            opacity: 1,
            transform: "translateY(0) skew(0deg, 0deg)"
        },
        out: {
            opacity: 0,
            transform: `translateY(-${rem(20)}) skew(-10deg, -5deg)`
        },
        common: {
            transformOrigin: "top"
        },
        transitionProperty: "transform, opacity"
    },
    "skew-down": {
        in: {
            opacity: 1,
            transform: "translateY(0) skew(0deg, 0deg)"
        },
        out: {
            opacity: 0,
            transform: `translateY(${rem(20)}) skew(-10deg, -5deg)`
        },
        common: {
            transformOrigin: "bottom"
        },
        transitionProperty: "transform, opacity"
    },
    "rotate-left": {
        in: {
            opacity: 1,
            transform: "translateY(0) rotate(0deg)"
        },
        out: {
            opacity: 0,
            transform: `translateY(${rem(20)}) rotate(-5deg)`
        },
        common: {
            transformOrigin: "bottom"
        },
        transitionProperty: "transform, opacity"
    },
    "rotate-right": {
        in: {
            opacity: 1,
            transform: "translateY(0) rotate(0deg)"
        },
        out: {
            opacity: 0,
            transform: `translateY(${rem(20)}) rotate(5deg)`
        },
        common: {
            transformOrigin: "top"
        },
        transitionProperty: "transform, opacity"
    },
    "slide-down": {
        in: {
            opacity: 1,
            transform: "translateY(0)"
        },
        out: {
            opacity: 0,
            transform: "translateY(-100%)"
        },
        common: {
            transformOrigin: "top"
        },
        transitionProperty: "transform, opacity"
    },
    "slide-up": {
        in: {
            opacity: 1,
            transform: "translateY(0)"
        },
        out: {
            opacity: 0,
            transform: "translateY(100%)"
        },
        common: {
            transformOrigin: "bottom"
        },
        transitionProperty: "transform, opacity"
    },
    "slide-left": {
        in: {
            opacity: 1,
            transform: "translateX(0)"
        },
        out: {
            opacity: 0,
            transform: "translateX(100%)"
        },
        common: {
            transformOrigin: "left"
        },
        transitionProperty: "transform, opacity"
    },
    "slide-right": {
        in: {
            opacity: 1,
            transform: "translateX(0)"
        },
        out: {
            opacity: 0,
            transform: "translateX(-100%)"
        },
        common: {
            transformOrigin: "right"
        },
        transitionProperty: "transform, opacity"
    },
    pop: __spreadProps$L(__spreadValues$1x({}, popIn), {
        common: {
            transformOrigin: "center center"
        }
    }),
    "pop-bottom-left": __spreadProps$L(__spreadValues$1x({}, popIn), {
        common: {
            transformOrigin: "bottom left"
        }
    }),
    "pop-bottom-right": __spreadProps$L(__spreadValues$1x({}, popIn), {
        common: {
            transformOrigin: "bottom right"
        }
    }),
    "pop-top-left": __spreadProps$L(__spreadValues$1x({}, popIn), {
        common: {
            transformOrigin: "top left"
        }
    }),
    "pop-top-right": __spreadProps$L(__spreadValues$1x({}, popIn), {
        common: {
            transformOrigin: "top right"
        }
    })
}
  , DEFAULT_EVENTS = ["mousedown", "touchstart"];
function useClickOutside(o, i, s) {
    const a = reactExports.useRef();
    return reactExports.useEffect( () => {
        const _ = $ => {
            const {target: _e} = $ ?? {};
            if (Array.isArray(s)) {
                const tt = (_e == null ? void 0 : _e.hasAttribute("data-ignore-outside-clicks")) || !document.body.contains(_e) && _e.tagName !== "HTML";
                s.every(rt => !!rt && !$.composedPath().includes(rt)) && !tt && o()
            } else
                a.current && !a.current.contains(_e) && o()
        }
        ;
        return (i || DEFAULT_EVENTS).forEach($ => document.addEventListener($, _)),
        () => {
            (i || DEFAULT_EVENTS).forEach($ => document.removeEventListener($, _))
        }
    }
    , [a, o, s]),
    a
}
function attachMediaListener(o, i) {
    try {
        return o.addEventListener("change", i),
        () => o.removeEventListener("change", i)
    } catch {
        return o.addListener(i),
        () => o.removeListener(i)
    }
}
function getInitialValue(o, i) {
    return typeof i == "boolean" ? i : typeof window < "u" && "matchMedia"in window ? window.matchMedia(o).matches : !1
}
function useMediaQuery(o, i, {getInitialValueInEffect: s}={
    getInitialValueInEffect: !0
}) {
    const [a,_] = reactExports.useState(s ? i : getInitialValue(o, i))
      , $ = reactExports.useRef();
    return reactExports.useEffect( () => {
        if ("matchMedia"in window)
            return $.current = window.matchMedia(o),
            _($.current.matches),
            attachMediaListener($.current, _e => _(_e.matches))
    }
    , [o]),
    a
}
function clamp$2(o, i, s) {
    return Math.min(Math.max(o, i), s)
}
const useIsomorphicEffect = typeof document < "u" ? reactExports.useLayoutEffect : reactExports.useEffect;
function useDidUpdate(o, i) {
    const s = reactExports.useRef(!1);
    reactExports.useEffect( () => () => {
        s.current = !1
    }
    , []),
    reactExports.useEffect( () => {
        if (s.current)
            return o();
        s.current = !0
    }
    , i)
}
function useFocusReturn({opened: o, shouldReturnFocus: i=!0}) {
    const s = reactExports.useRef()
      , a = () => {
        var _;
        s.current && "focus"in s.current && typeof s.current.focus == "function" && ((_ = s.current) == null || _.focus({
            preventScroll: !0
        }))
    }
    ;
    return useDidUpdate( () => {
        let _ = -1;
        const $ = _e => {
            _e.key === "Tab" && window.clearTimeout(_)
        }
        ;
        return document.addEventListener("keydown", $),
        o ? s.current = document.activeElement : i && (_ = window.setTimeout(a, 10)),
        () => {
            window.clearTimeout(_),
            document.removeEventListener("keydown", $)
        }
    }
    , [o, i]),
    a
}
const TABBABLE_NODES = /input|select|textarea|button|object/
  , FOCUS_SELECTOR = "a, input, select, textarea, button, object, [tabindex]";
function hidden(o) {
    return o.style.display === "none"
}
function visible(o) {
    if (o.getAttribute("aria-hidden") || o.getAttribute("hidden") || o.getAttribute("type") === "hidden")
        return !1;
    let s = o;
    for (; s && !(s === document.body || s.nodeType === 11); ) {
        if (hidden(s))
            return !1;
        s = s.parentNode
    }
    return !0
}
function getElementTabIndex(o) {
    let i = o.getAttribute("tabindex");
    return i === null && (i = void 0),
    parseInt(i, 10)
}
function focusable(o) {
    const i = o.nodeName.toLowerCase()
      , s = !Number.isNaN(getElementTabIndex(o));
    return (TABBABLE_NODES.test(i) && !o.disabled || o instanceof HTMLAnchorElement && o.href || s) && visible(o)
}
function tabbable(o) {
    const i = getElementTabIndex(o);
    return (Number.isNaN(i) || i >= 0) && focusable(o)
}
function findTabbableDescendants(o) {
    return Array.from(o.querySelectorAll(FOCUS_SELECTOR)).filter(tabbable)
}
function scopeTab(o, i) {
    const s = findTabbableDescendants(o);
    if (!s.length) {
        i.preventDefault();
        return
    }
    const a = s[i.shiftKey ? 0 : s.length - 1]
      , _ = o.getRootNode();
    if (!(a === _.activeElement || o === _.activeElement))
        return;
    i.preventDefault();
    const _e = s[i.shiftKey ? s.length - 1 : 0];
    _e && _e.focus()
}
function randomId() {
    return `mantine-${Math.random().toString(36).slice(2, 11)}`
}
function createAriaHider(o, i="body > :not(script)") {
    const s = randomId()
      , a = Array.from(document.querySelectorAll(i)).map(_ => {
        var $;
        if (($ = _ == null ? void 0 : _.shadowRoot) != null && $.contains(o) || _.contains(o))
            return;
        const _e = _.getAttribute("aria-hidden")
          , tt = _.getAttribute("data-hidden")
          , nt = _.getAttribute("data-focus-id");
        return _.setAttribute("data-focus-id", s),
        _e === null || _e === "false" ? _.setAttribute("aria-hidden", "true") : !tt && !nt && _.setAttribute("data-hidden", _e),
        {
            node: _,
            ariaHidden: tt || null
        }
    }
    );
    return () => {
        a.forEach(_ => {
            !_ || s !== _.node.getAttribute("data-focus-id") || (_.ariaHidden === null ? _.node.removeAttribute("aria-hidden") : _.node.setAttribute("aria-hidden", _.ariaHidden),
            _.node.removeAttribute("data-focus-id"),
            _.node.removeAttribute("data-hidden"))
        }
        )
    }
}
function useFocusTrap(o=!0) {
    const i = reactExports.useRef()
      , s = reactExports.useRef(null)
      , a = $ => {
        let _e = $.querySelector("[data-autofocus]");
        if (!_e) {
            const tt = Array.from($.querySelectorAll(FOCUS_SELECTOR));
            _e = tt.find(tabbable) || tt.find(focusable) || null,
            !_e && focusable($) && (_e = $)
        }
        _e && _e.focus({
            preventScroll: !0
        })
    }
      , _ = reactExports.useCallback($ => {
        if (o) {
            if ($ === null) {
                s.current && (s.current(),
                s.current = null);
                return
            }
            s.current = createAriaHider($),
            i.current !== $ && ($ ? (setTimeout( () => {
                $.getRootNode() && a($)
            }
            ),
            i.current = $) : i.current = null)
        }
    }
    , [o]);
    return reactExports.useEffect( () => {
        if (!o)
            return;
        i.current && setTimeout( () => a(i.current));
        const $ = _e => {
            _e.key === "Tab" && i.current && scopeTab(i.current, _e)
        }
        ;
        return document.addEventListener("keydown", $),
        () => {
            document.removeEventListener("keydown", $),
            s.current && s.current()
        }
    }
    , [o]),
    _
}
const reducer = o => (o + 1) % 1e6;
function useForceUpdate() {
    const [,o] = reactExports.useReducer(reducer, 0);
    return o
}
const __useId = React["useId".toString()] || ( () => {}
);
function useReactId() {
    const o = __useId();
    return o ? `mantine-${o.replace(/:/g, "")}` : ""
}
function useId(o) {
    const i = useReactId()
      , [s,a] = reactExports.useState(i);
    return useIsomorphicEffect( () => {
        a(randomId())
    }
    , []),
    typeof o == "string" ? o : typeof window > "u" ? i : s
}
function useWindowEvent(o, i, s) {
    reactExports.useEffect( () => (window.addEventListener(o, i, s),
    () => window.removeEventListener(o, i, s)), [o, i])
}
function assignRef(o, i) {
    typeof o == "function" ? o(i) : typeof o == "object" && o !== null && "current"in o && (o.current = i)
}
function mergeRefs(...o) {
    return i => {
        o.forEach(s => assignRef(s, i))
    }
}
function useMergedRef(...o) {
    return reactExports.useCallback(mergeRefs(...o), o)
}
function useUncontrolled({value: o, defaultValue: i, finalValue: s, onChange: a= () => {}
}) {
    const [_,$] = reactExports.useState(i !== void 0 ? i : s)
      , _e = tt => {
        $(tt),
        a == null || a(tt)
    }
    ;
    return o !== void 0 ? [o, a, !0] : [_, _e, !1]
}
function useQueue({initialValues: o=[], limit: i}) {
    const [{state: s, queue: a},_] = reactExports.useState({
        state: o.slice(0, i),
        queue: o.slice(i)
    });
    return {
        state: s,
        queue: a,
        add: (...nt) => _(rt => {
            const ot = [...rt.state, ...rt.queue, ...nt];
            return {
                state: ot.slice(0, i),
                queue: ot.slice(i)
            }
        }
        ),
        update: nt => _(rt => {
            const ot = nt([...rt.state, ...rt.queue]);
            return {
                state: ot.slice(0, i),
                queue: ot.slice(i)
            }
        }
        ),
        cleanQueue: () => _(nt => ({
            state: nt.state,
            queue: []
        }))
    }
}
function useReducedMotion(o, i) {
    return useMediaQuery("(prefers-reduced-motion: reduce)", o, i)
}
const easeInOutQuad = o => o < .5 ? 2 * o * o : -1 + (4 - 2 * o) * o
  , getRelativePosition = ({axis: o, target: i, parent: s, alignment: a, offset: _, isList: $}) => {
    if (!i || !s && typeof document > "u")
        return 0;
    const _e = !!s
      , nt = (s || document.body).getBoundingClientRect()
      , rt = i.getBoundingClientRect()
      , ot = et => rt[et] - nt[et];
    if (o === "y") {
        const et = ot("top");
        if (et === 0)
            return 0;
        if (a === "start") {
            const it = et - _;
            return it <= rt.height * ($ ? 0 : 1) || !$ ? it : 0
        }
        const j = _e ? nt.height : window.innerHeight;
        if (a === "end") {
            const it = et + _ - j + rt.height;
            return it >= -rt.height * ($ ? 0 : 1) || !$ ? it : 0
        }
        return a === "center" ? et - j / 2 + rt.height / 2 : 0
    }
    if (o === "x") {
        const et = ot("left");
        if (et === 0)
            return 0;
        if (a === "start") {
            const it = et - _;
            return it <= rt.width || !$ ? it : 0
        }
        const j = _e ? nt.width : window.innerWidth;
        if (a === "end") {
            const it = et + _ - j + rt.width;
            return it >= -rt.width || !$ ? it : 0
        }
        return a === "center" ? et - j / 2 + rt.width / 2 : 0
    }
    return 0
}
  , getScrollStart = ({axis: o, parent: i}) => {
    if (!i && typeof document > "u")
        return 0;
    const s = o === "y" ? "scrollTop" : "scrollLeft";
    if (i)
        return i[s];
    const {body: a, documentElement: _} = document;
    return a[s] + _[s]
}
  , setScrollParam = ({axis: o, parent: i, distance: s}) => {
    if (!i && typeof document > "u")
        return;
    const a = o === "y" ? "scrollTop" : "scrollLeft";
    if (i)
        i[a] = s;
    else {
        const {body: _, documentElement: $} = document;
        _[a] = s,
        $[a] = s
    }
}
;
function useScrollIntoView({duration: o=1250, axis: i="y", onScrollFinish: s, easing: a=easeInOutQuad, offset: _=0, cancelable: $=!0, isList: _e=!1}={}) {
    const tt = reactExports.useRef(0)
      , nt = reactExports.useRef(0)
      , rt = reactExports.useRef(!1)
      , ot = reactExports.useRef(null)
      , et = reactExports.useRef(null)
      , j = useReducedMotion()
      , it = () => {
        tt.current && cancelAnimationFrame(tt.current)
    }
      , st = reactExports.useCallback( ({alignment: lt="start"}={}) => {
        var ct;
        rt.current = !1,
        tt.current && it();
        const ut = (ct = getScrollStart({
            parent: ot.current,
            axis: i
        })) != null ? ct : 0
          , dt = getRelativePosition({
            parent: ot.current,
            target: et.current,
            axis: i,
            alignment: lt,
            offset: _,
            isList: _e
        }) - (ot.current ? 0 : ut);
        function ft() {
            nt.current === 0 && (nt.current = performance.now());
            const pt = performance.now() - nt.current
              , gt = j || o === 0 ? 1 : pt / o
              , _t = ut + dt * a(gt);
            setScrollParam({
                parent: ot.current,
                axis: i,
                distance: _t
            }),
            !rt.current && gt < 1 ? tt.current = requestAnimationFrame(ft) : (typeof s == "function" && s(),
            nt.current = 0,
            tt.current = 0,
            it())
        }
        ft()
    }
    , [i, o, a, _e, _, s, j])
      , at = () => {
        $ && (rt.current = !0)
    }
    ;
    return useWindowEvent("wheel", at, {
        passive: !0
    }),
    useWindowEvent("touchmove", at, {
        passive: !0
    }),
    reactExports.useEffect( () => it, []),
    {
        scrollableRef: ot,
        targetRef: et,
        scrollIntoView: st,
        cancel: it
    }
}
const defaultState = {
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    top: 0,
    left: 0,
    bottom: 0,
    right: 0
};
function useResizeObserver() {
    const o = reactExports.useRef(0)
      , i = reactExports.useRef(null)
      , [s,a] = reactExports.useState(defaultState)
      , _ = reactExports.useMemo( () => typeof window < "u" ? new ResizeObserver($ => {
        const _e = $[0];
        _e && (cancelAnimationFrame(o.current),
        o.current = requestAnimationFrame( () => {
            i.current && a(_e.contentRect)
        }
        ))
    }
    ) : null, []);
    return useIsomorphicEffect( () => (i.current && (_.observe(i.current),
    a(i.current.getBoundingClientRect())),
    () => {
        _.disconnect(),
        o.current && cancelAnimationFrame(o.current)
    }
    ), [i.current]),
    [i, s]
}
function getOS() {
    if (typeof window > "u")
        return "undetermined";
    const {userAgent: o} = window.navigator
      , i = /(Macintosh)|(MacIntel)|(MacPPC)|(Mac68K)/i
      , s = /(Win32)|(Win64)|(Windows)|(WinCE)/i
      , a = /(iPhone)|(iPad)|(iPod)/i;
    return i.test(o) ? "macos" : a.test(o) ? "ios" : s.test(o) ? "windows" : /Android/i.test(o) ? "android" : /Linux/i.test(o) ? "linux" : "undetermined"
}
function useOs(o={
    getValueInEffect: !0
}) {
    const [i,s] = reactExports.useState(o.getValueInEffect ? "undetermined" : getOS());
    return useIsomorphicEffect( () => {
        o.getValueInEffect && s(getOS)
    }
    , []),
    i
}
function useDisclosure(o=!1, i) {
    const {onOpen: s, onClose: a} = i || {}
      , [_,$] = reactExports.useState(o)
      , _e = reactExports.useCallback( () => {
        $(rt => rt || (s == null || s(),
        !0))
    }
    , [s])
      , tt = reactExports.useCallback( () => {
        $(rt => rt && (a == null || a(),
        !1))
    }
    , [a])
      , nt = reactExports.useCallback( () => {
        _ ? tt() : _e()
    }
    , [tt, _e, _]);
    return [_, {
        open: _e,
        close: tt,
        toggle: nt
    }]
}
var __getOwnPropSymbols$1y = Object.getOwnPropertySymbols
  , __hasOwnProp$1y = Object.prototype.hasOwnProperty
  , __propIsEnum$1y = Object.prototype.propertyIsEnumerable
  , __objRest$15 = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$1y.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$1y)
        for (var a of __getOwnPropSymbols$1y(o))
            i.indexOf(a) < 0 && __propIsEnum$1y.call(o, a) && (s[a] = o[a]);
    return s
}
;
function extractSystemStyles(o) {
    const i = o
      , {m: s, mx: a, my: _, mt: $, mb: _e, ml: tt, mr: nt, p: rt, px: ot, py: et, pt: j, pb: it, pl: st, pr: at, bg: lt, c: ct, opacity: ut, ff: dt, fz: ft, fw: ht, lts: pt, ta: gt, lh: _t, fs: mt, tt: yt, td: bt, w: vt, miw: wt, maw: Tt, h: $t, mih: Et, mah: Pt, bgsz: Rt, bgp: At, bgr: Mt, bga: Ut, pos: Lt, top: tn, left: Vt, bottom: Nt, right: Yt, inset: Xt, display: jt} = i
      , Gt = __objRest$15(i, ["m", "mx", "my", "mt", "mb", "ml", "mr", "p", "px", "py", "pt", "pb", "pl", "pr", "bg", "c", "opacity", "ff", "fz", "fw", "lts", "ta", "lh", "fs", "tt", "td", "w", "miw", "maw", "h", "mih", "mah", "bgsz", "bgp", "bgr", "bga", "pos", "top", "left", "bottom", "right", "inset", "display"]);
    return {
        systemStyles: filterProps({
            m: s,
            mx: a,
            my: _,
            mt: $,
            mb: _e,
            ml: tt,
            mr: nt,
            p: rt,
            px: ot,
            py: et,
            pt: j,
            pb: it,
            pl: st,
            pr: at,
            bg: lt,
            c: ct,
            opacity: ut,
            ff: dt,
            fz: ft,
            fw: ht,
            lts: pt,
            ta: gt,
            lh: _t,
            fs: mt,
            tt: yt,
            td: bt,
            w: vt,
            miw: wt,
            maw: Tt,
            h: $t,
            mih: Et,
            mah: Pt,
            bgsz: Rt,
            bgp: At,
            bgr: Mt,
            bga: Ut,
            pos: Lt,
            top: tn,
            left: Vt,
            bottom: Nt,
            right: Yt,
            inset: Xt,
            display: jt
        }),
        rest: Gt
    }
}
function getSortedKeys(o, i) {
    const s = Object.keys(o).filter(a => a !== "base").sort( (a, _) => getBreakpointValue(getSize({
        size: a,
        sizes: i.breakpoints
    })) - getBreakpointValue(getSize({
        size: _,
        sizes: i.breakpoints
    })));
    return "base"in o ? ["base", ...s] : s
}
function getResponsiveValue({value: o, theme: i, getValue: s, property: a}) {
    if (o == null)
        return;
    if (typeof o == "object")
        return getSortedKeys(o, i).reduce( (_e, tt) => {
            if (tt === "base" && o.base !== void 0) {
                const rt = s(o.base, i);
                return Array.isArray(a) ? (a.forEach(ot => {
                    _e[ot] = rt
                }
                ),
                _e) : (_e[a] = rt,
                _e)
            }
            const nt = s(o[tt], i);
            return Array.isArray(a) ? (_e[i.fn.largerThan(tt)] = {},
            a.forEach(rt => {
                _e[i.fn.largerThan(tt)][rt] = nt
            }
            ),
            _e) : (_e[i.fn.largerThan(tt)] = {
                [a]: nt
            },
            _e)
        }
        , {});
    const _ = s(o, i);
    return Array.isArray(a) ? a.reduce( ($, _e) => ($[_e] = _,
    $), {}) : {
        [a]: _
    }
}
function getColorValue(o, i) {
    return o === "dimmed" ? i.colorScheme === "dark" ? i.colors.dark[2] : i.colors.gray[6] : i.fn.variant({
        variant: "filled",
        color: o,
        primaryFallback: !1
    }).background
}
function getSizeValue(o) {
    return rem(o)
}
function identity(o) {
    return o
}
function getFontSizeValue(o, i) {
    return getSize({
        size: o,
        sizes: i.fontSizes
    })
}
const NEGATIVE_VALUES = ["-xs", "-sm", "-md", "-lg", "-xl"];
function getSpacingValue(o, i) {
    return NEGATIVE_VALUES.includes(o) ? `calc(${getSize({
        size: o.replace("-", ""),
        sizes: i.spacing
    })} * -1)` : getSize({
        size: o,
        sizes: i.spacing
    })
}
const valueGetters = {
    identity,
    color: getColorValue,
    size: getSizeValue,
    fontSize: getFontSizeValue,
    spacing: getSpacingValue
}
  , SYSTEM_PROPS = {
    m: {
        type: "spacing",
        property: "margin"
    },
    mt: {
        type: "spacing",
        property: "marginTop"
    },
    mb: {
        type: "spacing",
        property: "marginBottom"
    },
    ml: {
        type: "spacing",
        property: "marginLeft"
    },
    mr: {
        type: "spacing",
        property: "marginRight"
    },
    mx: {
        type: "spacing",
        property: ["marginRight", "marginLeft"]
    },
    my: {
        type: "spacing",
        property: ["marginTop", "marginBottom"]
    },
    p: {
        type: "spacing",
        property: "padding"
    },
    pt: {
        type: "spacing",
        property: "paddingTop"
    },
    pb: {
        type: "spacing",
        property: "paddingBottom"
    },
    pl: {
        type: "spacing",
        property: "paddingLeft"
    },
    pr: {
        type: "spacing",
        property: "paddingRight"
    },
    px: {
        type: "spacing",
        property: ["paddingRight", "paddingLeft"]
    },
    py: {
        type: "spacing",
        property: ["paddingTop", "paddingBottom"]
    },
    bg: {
        type: "color",
        property: "background"
    },
    c: {
        type: "color",
        property: "color"
    },
    opacity: {
        type: "identity",
        property: "opacity"
    },
    ff: {
        type: "identity",
        property: "fontFamily"
    },
    fz: {
        type: "fontSize",
        property: "fontSize"
    },
    fw: {
        type: "identity",
        property: "fontWeight"
    },
    lts: {
        type: "size",
        property: "letterSpacing"
    },
    ta: {
        type: "identity",
        property: "textAlign"
    },
    lh: {
        type: "identity",
        property: "lineHeight"
    },
    fs: {
        type: "identity",
        property: "fontStyle"
    },
    tt: {
        type: "identity",
        property: "textTransform"
    },
    td: {
        type: "identity",
        property: "textDecoration"
    },
    w: {
        type: "spacing",
        property: "width"
    },
    miw: {
        type: "spacing",
        property: "minWidth"
    },
    maw: {
        type: "spacing",
        property: "maxWidth"
    },
    h: {
        type: "spacing",
        property: "height"
    },
    mih: {
        type: "spacing",
        property: "minHeight"
    },
    mah: {
        type: "spacing",
        property: "maxHeight"
    },
    bgsz: {
        type: "size",
        property: "backgroundSize"
    },
    bgp: {
        type: "identity",
        property: "backgroundPosition"
    },
    bgr: {
        type: "identity",
        property: "backgroundRepeat"
    },
    bga: {
        type: "identity",
        property: "backgroundAttachment"
    },
    pos: {
        type: "identity",
        property: "position"
    },
    top: {
        type: "identity",
        property: "top"
    },
    left: {
        type: "size",
        property: "left"
    },
    bottom: {
        type: "size",
        property: "bottom"
    },
    right: {
        type: "size",
        property: "right"
    },
    inset: {
        type: "size",
        property: "inset"
    },
    display: {
        type: "identity",
        property: "display"
    }
};
var __defProp$1w = Object.defineProperty
  , __getOwnPropSymbols$1x = Object.getOwnPropertySymbols
  , __hasOwnProp$1x = Object.prototype.hasOwnProperty
  , __propIsEnum$1x = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1w = (o, i, s) => i in o ? __defProp$1w(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1w = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1x.call(i, s) && __defNormalProp$1w(o, s, i[s]);
    if (__getOwnPropSymbols$1x)
        for (var s of __getOwnPropSymbols$1x(i))
            __propIsEnum$1x.call(i, s) && __defNormalProp$1w(o, s, i[s]);
    return o
}
;
function getSystemStyles(o, i, s=SYSTEM_PROPS) {
    return Object.keys(s).reduce( (_, $) => ($ in o && o[$] !== void 0 && _.push(getResponsiveValue({
        value: o[$],
        getValue: valueGetters[s[$].type],
        property: s[$].property,
        theme: i
    })),
    _), []).reduce( (_, $) => (Object.keys($).forEach(_e => {
        typeof $[_e] == "object" && $[_e] !== null && _e in _ ? _[_e] = __spreadValues$1w(__spreadValues$1w({}, _[_e]), $[_e]) : _[_e] = $[_e]
    }
    ),
    _), {})
}
function extractSx(o, i) {
    return typeof o == "function" ? o(i) : o
}
function useSx(o, i, s) {
    const a = useMantineTheme()
      , {css: _, cx: $} = useCss();
    return Array.isArray(o) ? $(s, _(getSystemStyles(i, a)), o.map(_e => _(extractSx(_e, a)))) : $(s, _(extractSx(o, a)), _(getSystemStyles(i, a)))
}
var __defProp$1v = Object.defineProperty
  , __getOwnPropSymbols$1w = Object.getOwnPropertySymbols
  , __hasOwnProp$1w = Object.prototype.hasOwnProperty
  , __propIsEnum$1w = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1v = (o, i, s) => i in o ? __defProp$1v(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1v = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1w.call(i, s) && __defNormalProp$1v(o, s, i[s]);
    if (__getOwnPropSymbols$1w)
        for (var s of __getOwnPropSymbols$1w(i))
            __propIsEnum$1w.call(i, s) && __defNormalProp$1v(o, s, i[s]);
    return o
}
  , __objRest$14 = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$1w.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$1w)
        for (var a of __getOwnPropSymbols$1w(o))
            i.indexOf(a) < 0 && __propIsEnum$1w.call(o, a) && (s[a] = o[a]);
    return s
}
;
const _Box = reactExports.forwardRef( (o, i) => {
    var s = o
      , {className: a, component: _, style: $, sx: _e} = s
      , tt = __objRest$14(s, ["className", "component", "style", "sx"]);
    const {systemStyles: nt, rest: rt} = extractSystemStyles(tt)
      , ot = _ || "div";
    return React.createElement(ot, __spreadValues$1v({
        ref: i,
        className: useSx(_e, nt, a),
        style: $
    }, rt))
}
);
_Box.displayName = "@mantine/core/Box";
const Box = _Box;
var __defProp$1u = Object.defineProperty
  , __defProps$K = Object.defineProperties
  , __getOwnPropDescs$K = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$1v = Object.getOwnPropertySymbols
  , __hasOwnProp$1v = Object.prototype.hasOwnProperty
  , __propIsEnum$1v = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1u = (o, i, s) => i in o ? __defProp$1u(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1u = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1v.call(i, s) && __defNormalProp$1u(o, s, i[s]);
    if (__getOwnPropSymbols$1v)
        for (var s of __getOwnPropSymbols$1v(i))
            __propIsEnum$1v.call(i, s) && __defNormalProp$1u(o, s, i[s]);
    return o
}
  , __spreadProps$K = (o, i) => __defProps$K(o, __getOwnPropDescs$K(i))
  , useStyles$1k = createStyles(o => ({
    root: __spreadProps$K(__spreadValues$1u(__spreadValues$1u({}, o.fn.focusStyles()), o.fn.fontStyles()), {
        cursor: "pointer",
        border: 0,
        padding: 0,
        appearance: "none",
        fontSize: o.fontSizes.md,
        backgroundColor: "transparent",
        textAlign: "left",
        color: o.colorScheme === "dark" ? o.colors.dark[0] : o.black,
        textDecoration: "none",
        boxSizing: "border-box"
    })
}));
const useStyles$1l = useStyles$1k;
var __defProp$1t = Object.defineProperty
  , __getOwnPropSymbols$1u = Object.getOwnPropertySymbols
  , __hasOwnProp$1u = Object.prototype.hasOwnProperty
  , __propIsEnum$1u = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1t = (o, i, s) => i in o ? __defProp$1t(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1t = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1u.call(i, s) && __defNormalProp$1t(o, s, i[s]);
    if (__getOwnPropSymbols$1u)
        for (var s of __getOwnPropSymbols$1u(i))
            __propIsEnum$1u.call(i, s) && __defNormalProp$1t(o, s, i[s]);
    return o
}
  , __objRest$13 = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$1u.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$1u)
        for (var a of __getOwnPropSymbols$1u(o))
            i.indexOf(a) < 0 && __propIsEnum$1u.call(o, a) && (s[a] = o[a]);
    return s
}
;
const _UnstyledButton = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("UnstyledButton", {}, o)
      , {className: a, component: _="button", unstyled: $, variant: _e} = s
      , tt = __objRest$13(s, ["className", "component", "unstyled", "variant"])
      , {classes: nt, cx: rt} = useStyles$1l(null, {
        name: "UnstyledButton",
        unstyled: $,
        variant: _e
    });
    return React.createElement(Box, __spreadValues$1t({
        component: _,
        ref: i,
        className: rt(nt.root, a),
        type: _ === "button" ? "button" : void 0
    }, tt))
}
);
_UnstyledButton.displayName = "@mantine/core/UnstyledButton";
const UnstyledButton = _UnstyledButton;
var __defProp$1s = Object.defineProperty
  , __defProps$J = Object.defineProperties
  , __getOwnPropDescs$J = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$1t = Object.getOwnPropertySymbols
  , __hasOwnProp$1t = Object.prototype.hasOwnProperty
  , __propIsEnum$1t = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1s = (o, i, s) => i in o ? __defProp$1s(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1s = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1t.call(i, s) && __defNormalProp$1s(o, s, i[s]);
    if (__getOwnPropSymbols$1t)
        for (var s of __getOwnPropSymbols$1t(i))
            __propIsEnum$1t.call(i, s) && __defNormalProp$1s(o, s, i[s]);
    return o
}
  , __spreadProps$J = (o, i) => __defProps$J(o, __getOwnPropDescs$J(i));
const ACTION_ICON_VARIANTS = ["subtle", "filled", "outline", "light", "default", "transparent", "gradient"]
  , sizes$9 = {
    xs: rem(18),
    sm: rem(22),
    md: rem(28),
    lg: rem(34),
    xl: rem(44)
};
function getVariantStyles$3({variant: o, theme: i, color: s, gradient: a}) {
    const _ = i.fn.variant({
        color: s,
        variant: o,
        gradient: a
    });
    return o === "gradient" ? {
        border: 0,
        backgroundImage: _.background,
        color: _.color,
        "&:hover": i.fn.hover({
            backgroundSize: "200%"
        })
    } : ACTION_ICON_VARIANTS.includes(o) ? __spreadValues$1s({
        border: `${rem(1)} solid ${_.border}`,
        backgroundColor: _.background,
        color: _.color
    }, i.fn.hover({
        backgroundColor: _.hover
    })) : null
}
var useStyles$1i = createStyles( (o, {radius: i, color: s, gradient: a}, {variant: _, size: $}) => ({
    root: __spreadProps$J(__spreadValues$1s({
        position: "relative",
        borderRadius: o.fn.radius(i),
        padding: 0,
        lineHeight: 1,
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        height: getSize({
            size: $,
            sizes: sizes$9
        }),
        minHeight: getSize({
            size: $,
            sizes: sizes$9
        }),
        width: getSize({
            size: $,
            sizes: sizes$9
        }),
        minWidth: getSize({
            size: $,
            sizes: sizes$9
        })
    }, getVariantStyles$3({
        variant: _,
        theme: o,
        color: s,
        gradient: a
    })), {
        "&:active": o.activeStyles,
        "& [data-action-icon-loader]": {
            maxWidth: "70%"
        },
        "&:disabled, &[data-disabled]": {
            color: o.colors.gray[o.colorScheme === "dark" ? 6 : 4],
            cursor: "not-allowed",
            backgroundColor: _ === "transparent" ? void 0 : o.fn.themeColor("gray", o.colorScheme === "dark" ? 8 : 1),
            borderColor: _ === "transparent" ? void 0 : o.fn.themeColor("gray", o.colorScheme === "dark" ? 8 : 1),
            backgroundImage: "none",
            pointerEvents: "none",
            "&:active": {
                transform: "none"
            }
        },
        "&[data-loading]": {
            pointerEvents: "none",
            "&::before": __spreadProps$J(__spreadValues$1s({
                content: '""'
            }, o.fn.cover(rem(-1))), {
                backgroundColor: o.colorScheme === "dark" ? o.fn.rgba(o.colors.dark[7], .5) : "rgba(255, 255, 255, .5)",
                borderRadius: o.fn.radius(i),
                cursor: "not-allowed"
            })
        }
    })
}));
const useStyles$1j = useStyles$1i;
var __defProp$1r = Object.defineProperty
  , __getOwnPropSymbols$1s = Object.getOwnPropertySymbols
  , __hasOwnProp$1s = Object.prototype.hasOwnProperty
  , __propIsEnum$1s = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1r = (o, i, s) => i in o ? __defProp$1r(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1r = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1s.call(i, s) && __defNormalProp$1r(o, s, i[s]);
    if (__getOwnPropSymbols$1s)
        for (var s of __getOwnPropSymbols$1s(i))
            __propIsEnum$1s.call(i, s) && __defNormalProp$1r(o, s, i[s]);
    return o
}
  , __objRest$12 = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$1s.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$1s)
        for (var a of __getOwnPropSymbols$1s(o))
            i.indexOf(a) < 0 && __propIsEnum$1s.call(o, a) && (s[a] = o[a]);
    return s
}
;
function Bars(o) {
    var i = o
      , {size: s, color: a} = i
      , _ = __objRest$12(i, ["size", "color"]);
    const $ = _
      , {style: _e} = $
      , tt = __objRest$12($, ["style"]);
    return React.createElement("svg", __spreadValues$1r({
        viewBox: "0 0 135 140",
        xmlns: "http://www.w3.org/2000/svg",
        fill: a,
        style: __spreadValues$1r({
            width: s
        }, _e)
    }, tt), React.createElement("rect", {
        y: "10",
        width: "15",
        height: "120",
        rx: "6"
    }, React.createElement("animate", {
        attributeName: "height",
        begin: "0.5s",
        dur: "1s",
        values: "120;110;100;90;80;70;60;50;40;140;120",
        calcMode: "linear",
        repeatCount: "indefinite"
    }), React.createElement("animate", {
        attributeName: "y",
        begin: "0.5s",
        dur: "1s",
        values: "10;15;20;25;30;35;40;45;50;0;10",
        calcMode: "linear",
        repeatCount: "indefinite"
    })), React.createElement("rect", {
        x: "30",
        y: "10",
        width: "15",
        height: "120",
        rx: "6"
    }, React.createElement("animate", {
        attributeName: "height",
        begin: "0.25s",
        dur: "1s",
        values: "120;110;100;90;80;70;60;50;40;140;120",
        calcMode: "linear",
        repeatCount: "indefinite"
    }), React.createElement("animate", {
        attributeName: "y",
        begin: "0.25s",
        dur: "1s",
        values: "10;15;20;25;30;35;40;45;50;0;10",
        calcMode: "linear",
        repeatCount: "indefinite"
    })), React.createElement("rect", {
        x: "60",
        width: "15",
        height: "140",
        rx: "6"
    }, React.createElement("animate", {
        attributeName: "height",
        begin: "0s",
        dur: "1s",
        values: "120;110;100;90;80;70;60;50;40;140;120",
        calcMode: "linear",
        repeatCount: "indefinite"
    }), React.createElement("animate", {
        attributeName: "y",
        begin: "0s",
        dur: "1s",
        values: "10;15;20;25;30;35;40;45;50;0;10",
        calcMode: "linear",
        repeatCount: "indefinite"
    })), React.createElement("rect", {
        x: "90",
        y: "10",
        width: "15",
        height: "120",
        rx: "6"
    }, React.createElement("animate", {
        attributeName: "height",
        begin: "0.25s",
        dur: "1s",
        values: "120;110;100;90;80;70;60;50;40;140;120",
        calcMode: "linear",
        repeatCount: "indefinite"
    }), React.createElement("animate", {
        attributeName: "y",
        begin: "0.25s",
        dur: "1s",
        values: "10;15;20;25;30;35;40;45;50;0;10",
        calcMode: "linear",
        repeatCount: "indefinite"
    })), React.createElement("rect", {
        x: "120",
        y: "10",
        width: "15",
        height: "120",
        rx: "6"
    }, React.createElement("animate", {
        attributeName: "height",
        begin: "0.5s",
        dur: "1s",
        values: "120;110;100;90;80;70;60;50;40;140;120",
        calcMode: "linear",
        repeatCount: "indefinite"
    }), React.createElement("animate", {
        attributeName: "y",
        begin: "0.5s",
        dur: "1s",
        values: "10;15;20;25;30;35;40;45;50;0;10",
        calcMode: "linear",
        repeatCount: "indefinite"
    })))
}
var __defProp$1q = Object.defineProperty
  , __getOwnPropSymbols$1r = Object.getOwnPropertySymbols
  , __hasOwnProp$1r = Object.prototype.hasOwnProperty
  , __propIsEnum$1r = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1q = (o, i, s) => i in o ? __defProp$1q(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1q = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1r.call(i, s) && __defNormalProp$1q(o, s, i[s]);
    if (__getOwnPropSymbols$1r)
        for (var s of __getOwnPropSymbols$1r(i))
            __propIsEnum$1r.call(i, s) && __defNormalProp$1q(o, s, i[s]);
    return o
}
  , __objRest$11 = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$1r.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$1r)
        for (var a of __getOwnPropSymbols$1r(o))
            i.indexOf(a) < 0 && __propIsEnum$1r.call(o, a) && (s[a] = o[a]);
    return s
}
;
function Oval(o) {
    var i = o
      , {size: s, color: a} = i
      , _ = __objRest$11(i, ["size", "color"]);
    const $ = _
      , {style: _e} = $
      , tt = __objRest$11($, ["style"]);
    return React.createElement("svg", __spreadValues$1q({
        viewBox: "0 0 38 38",
        xmlns: "http://www.w3.org/2000/svg",
        stroke: a,
        style: __spreadValues$1q({
            width: s,
            height: s
        }, _e)
    }, tt), React.createElement("g", {
        fill: "none",
        fillRule: "evenodd"
    }, React.createElement("g", {
        transform: "translate(2.5 2.5)",
        strokeWidth: "5"
    }, React.createElement("circle", {
        strokeOpacity: ".5",
        cx: "16",
        cy: "16",
        r: "16"
    }), React.createElement("path", {
        d: "M32 16c0-9.94-8.06-16-16-16"
    }, React.createElement("animateTransform", {
        attributeName: "transform",
        type: "rotate",
        from: "0 16 16",
        to: "360 16 16",
        dur: "1s",
        repeatCount: "indefinite"
    })))))
}
var __defProp$1p = Object.defineProperty
  , __getOwnPropSymbols$1q = Object.getOwnPropertySymbols
  , __hasOwnProp$1q = Object.prototype.hasOwnProperty
  , __propIsEnum$1q = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1p = (o, i, s) => i in o ? __defProp$1p(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1p = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1q.call(i, s) && __defNormalProp$1p(o, s, i[s]);
    if (__getOwnPropSymbols$1q)
        for (var s of __getOwnPropSymbols$1q(i))
            __propIsEnum$1q.call(i, s) && __defNormalProp$1p(o, s, i[s]);
    return o
}
  , __objRest$10 = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$1q.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$1q)
        for (var a of __getOwnPropSymbols$1q(o))
            i.indexOf(a) < 0 && __propIsEnum$1q.call(o, a) && (s[a] = o[a]);
    return s
}
;
function Dots(o) {
    var i = o
      , {size: s, color: a} = i
      , _ = __objRest$10(i, ["size", "color"]);
    const $ = _
      , {style: _e} = $
      , tt = __objRest$10($, ["style"]);
    return React.createElement("svg", __spreadValues$1p({
        viewBox: "0 0 120 30",
        xmlns: "http://www.w3.org/2000/svg",
        fill: a,
        style: __spreadValues$1p({
            width: s
        }, _e)
    }, tt), React.createElement("circle", {
        cx: "15",
        cy: "15",
        r: "15"
    }, React.createElement("animate", {
        attributeName: "r",
        from: "15",
        to: "15",
        begin: "0s",
        dur: "0.8s",
        values: "15;9;15",
        calcMode: "linear",
        repeatCount: "indefinite"
    }), React.createElement("animate", {
        attributeName: "fill-opacity",
        from: "1",
        to: "1",
        begin: "0s",
        dur: "0.8s",
        values: "1;.5;1",
        calcMode: "linear",
        repeatCount: "indefinite"
    })), React.createElement("circle", {
        cx: "60",
        cy: "15",
        r: "9",
        fillOpacity: "0.3"
    }, React.createElement("animate", {
        attributeName: "r",
        from: "9",
        to: "9",
        begin: "0s",
        dur: "0.8s",
        values: "9;15;9",
        calcMode: "linear",
        repeatCount: "indefinite"
    }), React.createElement("animate", {
        attributeName: "fill-opacity",
        from: "0.5",
        to: "0.5",
        begin: "0s",
        dur: "0.8s",
        values: ".5;1;.5",
        calcMode: "linear",
        repeatCount: "indefinite"
    })), React.createElement("circle", {
        cx: "105",
        cy: "15",
        r: "15"
    }, React.createElement("animate", {
        attributeName: "r",
        from: "15",
        to: "15",
        begin: "0s",
        dur: "0.8s",
        values: "15;9;15",
        calcMode: "linear",
        repeatCount: "indefinite"
    }), React.createElement("animate", {
        attributeName: "fill-opacity",
        from: "1",
        to: "1",
        begin: "0s",
        dur: "0.8s",
        values: "1;.5;1",
        calcMode: "linear",
        repeatCount: "indefinite"
    })))
}
var __defProp$1o = Object.defineProperty
  , __getOwnPropSymbols$1p = Object.getOwnPropertySymbols
  , __hasOwnProp$1p = Object.prototype.hasOwnProperty
  , __propIsEnum$1p = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1o = (o, i, s) => i in o ? __defProp$1o(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1o = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1p.call(i, s) && __defNormalProp$1o(o, s, i[s]);
    if (__getOwnPropSymbols$1p)
        for (var s of __getOwnPropSymbols$1p(i))
            __propIsEnum$1p.call(i, s) && __defNormalProp$1o(o, s, i[s]);
    return o
}
  , __objRest$$ = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$1p.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$1p)
        for (var a of __getOwnPropSymbols$1p(o))
            i.indexOf(a) < 0 && __propIsEnum$1p.call(o, a) && (s[a] = o[a]);
    return s
}
;
const LOADERS = {
    bars: Bars,
    oval: Oval,
    dots: Dots
}
  , sizes$8 = {
    xs: rem(18),
    sm: rem(22),
    md: rem(36),
    lg: rem(44),
    xl: rem(58)
}
  , defaultProps$L = {
    size: "md"
};
function Loader(o) {
    const i = useComponentDefaultProps("Loader", defaultProps$L, o)
      , {size: s, color: a, variant: _} = i
      , $ = __objRest$$(i, ["size", "color", "variant"])
      , _e = useMantineTheme()
      , tt = _ in LOADERS ? _ : _e.loader;
    return React.createElement(Box, __spreadValues$1o({
        role: "presentation",
        component: LOADERS[tt] || LOADERS.bars,
        size: getSize({
            size: s,
            sizes: sizes$8
        }),
        color: _e.fn.variant({
            variant: "filled",
            primaryFallback: !1,
            color: a || _e.primaryColor
        }).background
    }, $))
}
Loader.displayName = "@mantine/core/Loader";
var __defProp$1n = Object.defineProperty
  , __getOwnPropSymbols$1o = Object.getOwnPropertySymbols
  , __hasOwnProp$1o = Object.prototype.hasOwnProperty
  , __propIsEnum$1o = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1n = (o, i, s) => i in o ? __defProp$1n(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1n = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1o.call(i, s) && __defNormalProp$1n(o, s, i[s]);
    if (__getOwnPropSymbols$1o)
        for (var s of __getOwnPropSymbols$1o(i))
            __propIsEnum$1o.call(i, s) && __defNormalProp$1n(o, s, i[s]);
    return o
}
  , __objRest$_ = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$1o.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$1o)
        for (var a of __getOwnPropSymbols$1o(o))
            i.indexOf(a) < 0 && __propIsEnum$1o.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$K = {
    color: "gray",
    size: "md",
    variant: "subtle"
}
  , _ActionIcon = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("ActionIcon", defaultProps$K, o)
      , {className: a, color: _, children: $, radius: _e, size: tt, variant: nt, gradient: rt, disabled: ot, loaderProps: et, loading: j, unstyled: it, __staticSelector: st} = s
      , at = __objRest$_(s, ["className", "color", "children", "radius", "size", "variant", "gradient", "disabled", "loaderProps", "loading", "unstyled", "__staticSelector"])
      , {classes: lt, cx: ct, theme: ut} = useStyles$1j({
        radius: _e,
        color: _,
        gradient: rt
    }, {
        name: ["ActionIcon", st],
        unstyled: it,
        size: tt,
        variant: nt
    })
      , dt = React.createElement(Loader, __spreadValues$1n({
        color: ut.fn.variant({
            color: _,
            variant: nt
        }).color,
        size: "100%",
        "data-action-icon-loader": !0
    }, et));
    return React.createElement(UnstyledButton, __spreadValues$1n({
        className: ct(lt.root, a),
        ref: i,
        disabled: ot,
        "data-disabled": ot || void 0,
        "data-loading": j || void 0,
        unstyled: it
    }, at), j ? dt : $)
}
);
_ActionIcon.displayName = "@mantine/core/ActionIcon";
const ActionIcon = _ActionIcon;
var __defProp$1m = Object.defineProperty
  , __defProps$I = Object.defineProperties
  , __getOwnPropDescs$I = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$1n = Object.getOwnPropertySymbols
  , __hasOwnProp$1n = Object.prototype.hasOwnProperty
  , __propIsEnum$1n = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1m = (o, i, s) => i in o ? __defProp$1m(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1m = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1n.call(i, s) && __defNormalProp$1m(o, s, i[s]);
    if (__getOwnPropSymbols$1n)
        for (var s of __getOwnPropSymbols$1n(i))
            __propIsEnum$1n.call(i, s) && __defNormalProp$1m(o, s, i[s]);
    return o
}
  , __spreadProps$I = (o, i) => __defProps$I(o, __getOwnPropDescs$I(i))
  , __objRest$Z = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$1n.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$1n)
        for (var a of __getOwnPropSymbols$1n(o))
            i.indexOf(a) < 0 && __propIsEnum$1n.call(o, a) && (s[a] = o[a]);
    return s
}
;
function Portal(o) {
    const i = useComponentDefaultProps("Portal", {}, o)
      , {children: s, target: a, className: _, innerRef: $} = i
      , _e = __objRest$Z(i, ["children", "target", "className", "innerRef"])
      , tt = useMantineTheme()
      , [nt,rt] = reactExports.useState(!1)
      , ot = reactExports.useRef();
    return useIsomorphicEffect( () => (rt(!0),
    ot.current = a ? typeof a == "string" ? document.querySelector(a) : a : document.createElement("div"),
    a || document.body.appendChild(ot.current),
    () => {
        !a && document.body.removeChild(ot.current)
    }
    ), [a]),
    nt ? reactDomExports.createPortal(React.createElement("div", __spreadProps$I(__spreadValues$1m({
        className: _,
        dir: tt.dir
    }, _e), {
        ref: $
    }), s), ot.current) : null
}
Portal.displayName = "@mantine/core/Portal";
var __defProp$1l = Object.defineProperty
  , __getOwnPropSymbols$1m = Object.getOwnPropertySymbols
  , __hasOwnProp$1m = Object.prototype.hasOwnProperty
  , __propIsEnum$1m = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1l = (o, i, s) => i in o ? __defProp$1l(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1l = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1m.call(i, s) && __defNormalProp$1l(o, s, i[s]);
    if (__getOwnPropSymbols$1m)
        for (var s of __getOwnPropSymbols$1m(i))
            __propIsEnum$1m.call(i, s) && __defNormalProp$1l(o, s, i[s]);
    return o
}
  , __objRest$Y = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$1m.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$1m)
        for (var a of __getOwnPropSymbols$1m(o))
            i.indexOf(a) < 0 && __propIsEnum$1m.call(o, a) && (s[a] = o[a]);
    return s
}
;
function OptionalPortal(o) {
    var i = o
      , {withinPortal: s=!0, children: a} = i
      , _ = __objRest$Y(i, ["withinPortal", "children"]);
    return s ? React.createElement(Portal, __spreadValues$1l({}, _), a) : React.createElement(React.Fragment, null, a)
}
OptionalPortal.displayName = "@mantine/core/OptionalPortal";
var __defProp$1k = Object.defineProperty
  , __getOwnPropSymbols$1l = Object.getOwnPropertySymbols
  , __hasOwnProp$1l = Object.prototype.hasOwnProperty
  , __propIsEnum$1l = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1k = (o, i, s) => i in o ? __defProp$1k(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1k = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1l.call(i, s) && __defNormalProp$1k(o, s, i[s]);
    if (__getOwnPropSymbols$1l)
        for (var s of __getOwnPropSymbols$1l(i))
            __propIsEnum$1l.call(i, s) && __defNormalProp$1k(o, s, i[s]);
    return o
}
  , __objRest$X = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$1l.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$1l)
        for (var a of __getOwnPropSymbols$1l(o))
            i.indexOf(a) < 0 && __propIsEnum$1l.call(o, a) && (s[a] = o[a]);
    return s
}
;
function CloseIcon(o) {
    const i = o
      , {width: s, height: a, style: _} = i
      , $ = __objRest$X(i, ["width", "height", "style"]);
    return React.createElement("svg", __spreadValues$1k({
        viewBox: "0 0 15 15",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        style: __spreadValues$1k({
            width: s,
            height: a
        }, _)
    }, $), React.createElement("path", {
        d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z",
        fill: "currentColor",
        fillRule: "evenodd",
        clipRule: "evenodd"
    }))
}
CloseIcon.displayName = "@mantine/core/CloseIcon";
var __defProp$1j = Object.defineProperty
  , __getOwnPropSymbols$1k = Object.getOwnPropertySymbols
  , __hasOwnProp$1k = Object.prototype.hasOwnProperty
  , __propIsEnum$1k = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1j = (o, i, s) => i in o ? __defProp$1j(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1j = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1k.call(i, s) && __defNormalProp$1j(o, s, i[s]);
    if (__getOwnPropSymbols$1k)
        for (var s of __getOwnPropSymbols$1k(i))
            __propIsEnum$1k.call(i, s) && __defNormalProp$1j(o, s, i[s]);
    return o
}
  , __objRest$W = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$1k.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$1k)
        for (var a of __getOwnPropSymbols$1k(o))
            i.indexOf(a) < 0 && __propIsEnum$1k.call(o, a) && (s[a] = o[a]);
    return s
}
;
const iconSizes$2 = {
    xs: rem(12),
    sm: rem(16),
    md: rem(20),
    lg: rem(28),
    xl: rem(34)
}
  , defaultProps$J = {
    size: "sm"
}
  , _CloseButton = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("CloseButton", defaultProps$J, o)
      , {iconSize: a, size: _, children: $} = s
      , _e = __objRest$W(s, ["iconSize", "size", "children"])
      , tt = rem(a || iconSizes$2[_]);
    return React.createElement(ActionIcon, __spreadValues$1j({
        ref: i,
        __staticSelector: "CloseButton",
        size: _
    }, _e), $ || React.createElement(CloseIcon, {
        width: tt,
        height: tt
    }))
}
);
_CloseButton.displayName = "@mantine/core/CloseButton";
const CloseButton = _CloseButton;
var __defProp$1i = Object.defineProperty
  , __defProps$H = Object.defineProperties
  , __getOwnPropDescs$H = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$1j = Object.getOwnPropertySymbols
  , __hasOwnProp$1j = Object.prototype.hasOwnProperty
  , __propIsEnum$1j = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1i = (o, i, s) => i in o ? __defProp$1i(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1i = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1j.call(i, s) && __defNormalProp$1i(o, s, i[s]);
    if (__getOwnPropSymbols$1j)
        for (var s of __getOwnPropSymbols$1j(i))
            __propIsEnum$1j.call(i, s) && __defNormalProp$1i(o, s, i[s]);
    return o
}
  , __spreadProps$H = (o, i) => __defProps$H(o, __getOwnPropDescs$H(i));
function getTextDecoration({underline: o, strikethrough: i}) {
    const s = [];
    return o && s.push("underline"),
    i && s.push("line-through"),
    s.length > 0 ? s.join(" ") : "none"
}
function getTextColor({theme: o, color: i}) {
    return i === "dimmed" ? o.fn.dimmed() : typeof i == "string" && (i in o.colors || i.split(".")[0]in o.colors) ? o.fn.variant({
        variant: "filled",
        color: i
    }).background : i || "inherit"
}
function getLineClamp(o) {
    return typeof o == "number" ? {
        overflow: "hidden",
        textOverflow: "ellipsis",
        display: "-webkit-box",
        WebkitLineClamp: o,
        WebkitBoxOrient: "vertical"
    } : null
}
function getTruncate({theme: o, truncate: i}) {
    return i === "start" ? {
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap",
        direction: o.dir === "ltr" ? "rtl" : "ltr",
        textAlign: o.dir === "ltr" ? "right" : "left"
    } : i ? {
        overflow: "hidden",
        textOverflow: "ellipsis",
        whiteSpace: "nowrap"
    } : null
}
var useStyles$1g = createStyles( (o, {color: i, lineClamp: s, truncate: a, inline: _, inherit: $, underline: _e, gradient: tt, weight: nt, transform: rt, align: ot, strikethrough: et, italic: j}, {size: it}) => {
    const st = o.fn.variant({
        variant: "gradient",
        gradient: tt
    });
    return {
        root: __spreadProps$H(__spreadValues$1i(__spreadValues$1i(__spreadValues$1i(__spreadValues$1i({}, o.fn.fontStyles()), o.fn.focusStyles()), getLineClamp(s)), getTruncate({
            theme: o,
            truncate: a
        })), {
            color: getTextColor({
                color: i,
                theme: o
            }),
            fontFamily: $ ? "inherit" : o.fontFamily,
            fontSize: $ || it === void 0 ? "inherit" : getSize({
                size: it,
                sizes: o.fontSizes
            }),
            lineHeight: $ ? "inherit" : _ ? 1 : o.lineHeight,
            textDecoration: getTextDecoration({
                underline: _e,
                strikethrough: et
            }),
            WebkitTapHighlightColor: "transparent",
            fontWeight: $ ? "inherit" : nt,
            textTransform: rt,
            textAlign: ot,
            fontStyle: j ? "italic" : void 0
        }),
        gradient: {
            backgroundImage: st.background,
            WebkitBackgroundClip: "text",
            WebkitTextFillColor: "transparent"
        }
    }
}
);
const useStyles$1h = useStyles$1g;
var __defProp$1h = Object.defineProperty
  , __getOwnPropSymbols$1i = Object.getOwnPropertySymbols
  , __hasOwnProp$1i = Object.prototype.hasOwnProperty
  , __propIsEnum$1i = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1h = (o, i, s) => i in o ? __defProp$1h(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1h = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1i.call(i, s) && __defNormalProp$1h(o, s, i[s]);
    if (__getOwnPropSymbols$1i)
        for (var s of __getOwnPropSymbols$1i(i))
            __propIsEnum$1i.call(i, s) && __defNormalProp$1h(o, s, i[s]);
    return o
}
  , __objRest$V = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$1i.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$1i)
        for (var a of __getOwnPropSymbols$1i(o))
            i.indexOf(a) < 0 && __propIsEnum$1i.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$I = {
    variant: "text"
}
  , _Text = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("Text", defaultProps$I, o)
      , {className: a, size: _, weight: $, transform: _e, color: tt, align: nt, variant: rt, lineClamp: ot, truncate: et, gradient: j, inline: it, inherit: st, underline: at, strikethrough: lt, italic: ct, classNames: ut, styles: dt, unstyled: ft, span: ht, __staticSelector: pt} = s
      , gt = __objRest$V(s, ["className", "size", "weight", "transform", "color", "align", "variant", "lineClamp", "truncate", "gradient", "inline", "inherit", "underline", "strikethrough", "italic", "classNames", "styles", "unstyled", "span", "__staticSelector"])
      , {classes: _t, cx: mt} = useStyles$1h({
        color: tt,
        lineClamp: ot,
        truncate: et,
        inline: it,
        inherit: st,
        underline: at,
        strikethrough: lt,
        italic: ct,
        weight: $,
        transform: _e,
        align: nt,
        gradient: j
    }, {
        unstyled: ft,
        name: pt || "Text",
        variant: rt,
        size: _
    });
    return React.createElement(Box, __spreadValues$1h({
        ref: i,
        className: mt(_t.root, {
            [_t.gradient]: rt === "gradient"
        }, a),
        component: ht ? "span" : "div"
    }, gt))
}
);
_Text.displayName = "@mantine/core/Text";
const Text$2 = _Text;
var __defProp$1g = Object.defineProperty
  , __getOwnPropSymbols$1h = Object.getOwnPropertySymbols
  , __hasOwnProp$1h = Object.prototype.hasOwnProperty
  , __propIsEnum$1h = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1g = (o, i, s) => i in o ? __defProp$1g(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1g = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1h.call(i, s) && __defNormalProp$1g(o, s, i[s]);
    if (__getOwnPropSymbols$1h)
        for (var s of __getOwnPropSymbols$1h(i))
            __propIsEnum$1h.call(i, s) && __defNormalProp$1g(o, s, i[s]);
    return o
}
;
function getAnchorColor({theme: o, color: i}) {
    return i === "dimmed" ? o.fn.dimmed() : o.fn.themeColor(i || o.primaryColor, o.colorScheme === "dark" ? 4 : 7, !1, !0)
}
var useStyles$1e = createStyles( (o, {color: i, underline: s}) => ({
    root: __spreadValues$1g({
        backgroundColor: "transparent",
        cursor: "pointer",
        padding: 0,
        border: 0,
        color: getAnchorColor({
            theme: o,
            color: i
        })
    }, o.fn.hover({
        textDecoration: s ? "underline" : "none"
    }))
}));
const useStyles$1f = useStyles$1e;
var __defProp$1f = Object.defineProperty
  , __getOwnPropSymbols$1g = Object.getOwnPropertySymbols
  , __hasOwnProp$1g = Object.prototype.hasOwnProperty
  , __propIsEnum$1g = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1f = (o, i, s) => i in o ? __defProp$1f(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1f = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1g.call(i, s) && __defNormalProp$1f(o, s, i[s]);
    if (__getOwnPropSymbols$1g)
        for (var s of __getOwnPropSymbols$1g(i))
            __propIsEnum$1g.call(i, s) && __defNormalProp$1f(o, s, i[s]);
    return o
}
  , __objRest$U = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$1g.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$1g)
        for (var a of __getOwnPropSymbols$1g(o))
            i.indexOf(a) < 0 && __propIsEnum$1g.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$H = {
    underline: !0
}
  , _Anchor = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("Anchor", defaultProps$H, o)
      , {component: a, className: _, unstyled: $, variant: _e, size: tt, color: nt, underline: rt} = s
      , ot = __objRest$U(s, ["component", "className", "unstyled", "variant", "size", "color", "underline"])
      , {classes: et, cx: j} = useStyles$1f({
        color: nt,
        underline: rt
    }, {
        name: "Anchor",
        unstyled: $,
        variant: _e,
        size: tt
    })
      , it = a === "button" ? {
        type: "button"
    } : null;
    return React.createElement(Text$2, __spreadValues$1f(__spreadValues$1f({
        component: a || "a",
        ref: i,
        className: j(et.root, _),
        size: tt
    }, it), ot))
}
);
_Anchor.displayName = "@mantine/core/Anchor";
const Anchor = _Anchor
  , sizes$7 = {
    xs: rem(1),
    sm: rem(2),
    md: rem(3),
    lg: rem(4),
    xl: rem(5)
};
function getColor(o, i) {
    const s = o.fn.variant({
        variant: "outline",
        color: i
    }).border;
    return typeof i == "string" && (i in o.colors || i.split(".")[0]in o.colors) ? s : i === void 0 ? o.colorScheme === "dark" ? o.colors.dark[4] : o.colors.gray[4] : i
}
var useStyles$1c = createStyles( (o, {color: i}, {size: s, variant: a}) => ({
    root: {},
    withLabel: {
        borderTop: "0 !important"
    },
    left: {
        "&::before": {
            display: "none"
        }
    },
    right: {
        "&::after": {
            display: "none"
        }
    },
    label: {
        display: "flex",
        alignItems: "center",
        "&::before": {
            content: '""',
            flex: 1,
            height: rem(1),
            borderTop: `${getSize({
                size: s,
                sizes: sizes$7
            })} ${a} ${getColor(o, i)}`,
            marginRight: o.spacing.xs
        },
        "&::after": {
            content: '""',
            flex: 1,
            borderTop: `${getSize({
                size: s,
                sizes: sizes$7
            })} ${a} ${getColor(o, i)}`,
            marginLeft: o.spacing.xs
        }
    },
    labelDefaultStyles: {
        color: i === "dark" ? o.colors.dark[1] : o.fn.themeColor(i, o.colorScheme === "dark" ? 5 : o.fn.primaryShade(), !1)
    },
    horizontal: {
        border: 0,
        borderTopWidth: rem(getSize({
            size: s,
            sizes: sizes$7
        })),
        borderTopColor: getColor(o, i),
        borderTopStyle: a,
        margin: 0
    },
    vertical: {
        border: 0,
        alignSelf: "stretch",
        height: "auto",
        borderLeftWidth: rem(getSize({
            size: s,
            sizes: sizes$7
        })),
        borderLeftColor: getColor(o, i),
        borderLeftStyle: a
    }
}));
const useStyles$1d = useStyles$1c;
var __defProp$1e = Object.defineProperty
  , __defProps$G = Object.defineProperties
  , __getOwnPropDescs$G = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$1f = Object.getOwnPropertySymbols
  , __hasOwnProp$1f = Object.prototype.hasOwnProperty
  , __propIsEnum$1f = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1e = (o, i, s) => i in o ? __defProp$1e(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1e = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1f.call(i, s) && __defNormalProp$1e(o, s, i[s]);
    if (__getOwnPropSymbols$1f)
        for (var s of __getOwnPropSymbols$1f(i))
            __propIsEnum$1f.call(i, s) && __defNormalProp$1e(o, s, i[s]);
    return o
}
  , __spreadProps$G = (o, i) => __defProps$G(o, __getOwnPropDescs$G(i))
  , __objRest$T = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$1f.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$1f)
        for (var a of __getOwnPropSymbols$1f(o))
            i.indexOf(a) < 0 && __propIsEnum$1f.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$G = {
    orientation: "horizontal",
    size: "xs",
    labelPosition: "left",
    variant: "solid"
}
  , Divider = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("Divider", defaultProps$G, o)
      , {className: a, color: _, orientation: $, size: _e, label: tt, labelPosition: nt, labelProps: rt, variant: ot, styles: et, classNames: j, unstyled: it} = s
      , st = __objRest$T(s, ["className", "color", "orientation", "size", "label", "labelPosition", "labelProps", "variant", "styles", "classNames", "unstyled"])
      , {classes: at, cx: lt} = useStyles$1d({
        color: _
    }, {
        classNames: j,
        styles: et,
        unstyled: it,
        name: "Divider",
        variant: ot,
        size: _e
    })
      , ct = $ === "vertical"
      , ut = $ === "horizontal"
      , dt = !!tt && ut
      , ft = !(rt != null && rt.color);
    return React.createElement(Box, __spreadValues$1e({
        ref: i,
        className: lt(at.root, {
            [at.vertical]: ct,
            [at.horizontal]: ut,
            [at.withLabel]: dt
        }, a),
        role: "separator"
    }, st), dt && React.createElement(Text$2, __spreadProps$G(__spreadValues$1e({}, rt), {
        size: (rt == null ? void 0 : rt.size) || "xs",
        mt: rem(2),
        className: lt(at.label, at[nt], {
            [at.labelDefaultStyles]: ft
        })
    }), tt))
}
);
Divider.displayName = "@mantine/core/Divider";
var __defProp$1d = Object.defineProperty
  , __defProps$F = Object.defineProperties
  , __getOwnPropDescs$F = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$1e = Object.getOwnPropertySymbols
  , __hasOwnProp$1e = Object.prototype.hasOwnProperty
  , __propIsEnum$1e = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1d = (o, i, s) => i in o ? __defProp$1d(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1d = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1e.call(i, s) && __defNormalProp$1d(o, s, i[s]);
    if (__getOwnPropSymbols$1e)
        for (var s of __getOwnPropSymbols$1e(i))
            __propIsEnum$1e.call(i, s) && __defNormalProp$1d(o, s, i[s]);
    return o
}
  , __spreadProps$F = (o, i) => __defProps$F(o, __getOwnPropDescs$F(i))
  , useStyles$1a = createStyles( (o, i, {size: s}) => ({
    item: __spreadProps$F(__spreadValues$1d({}, o.fn.fontStyles()), {
        boxSizing: "border-box",
        wordBreak: "break-all",
        textAlign: "left",
        width: "100%",
        padding: `calc(${getSize({
            size: s,
            sizes: o.spacing
        })} / 1.5) ${getSize({
            size: s,
            sizes: o.spacing
        })}`,
        cursor: "pointer",
        fontSize: getSize({
            size: s,
            sizes: o.fontSizes
        }),
        color: o.colorScheme === "dark" ? o.colors.dark[0] : o.black,
        borderRadius: o.fn.radius(),
        "&[data-hovered]": {
            backgroundColor: o.colorScheme === "dark" ? o.colors.dark[4] : o.colors.gray[1]
        },
        "&[data-selected]": __spreadValues$1d({
            backgroundColor: o.fn.variant({
                variant: "filled"
            }).background,
            color: o.fn.variant({
                variant: "filled"
            }).color
        }, o.fn.hover({
            backgroundColor: o.fn.variant({
                variant: "filled"
            }).hover
        })),
        "&[data-disabled]": {
            cursor: "default",
            color: o.colors.dark[2]
        }
    }),
    nothingFound: {
        boxSizing: "border-box",
        color: o.colors.gray[6],
        paddingTop: `calc(${getSize({
            size: s,
            sizes: o.spacing
        })} / 2)`,
        paddingBottom: `calc(${getSize({
            size: s,
            sizes: o.spacing
        })} / 2)`,
        textAlign: "center"
    },
    separator: {
        boxSizing: "border-box",
        textAlign: "left",
        width: "100%",
        padding: `calc(${getSize({
            size: s,
            sizes: o.spacing
        })} / 1.5) ${getSize({
            size: s,
            sizes: o.spacing
        })}`
    },
    separatorLabel: {
        color: o.colorScheme === "dark" ? o.colors.dark[3] : o.colors.gray[5]
    }
}));
const useStyles$1b = useStyles$1a;
var __defProp$1c = Object.defineProperty
  , __getOwnPropSymbols$1d = Object.getOwnPropertySymbols
  , __hasOwnProp$1d = Object.prototype.hasOwnProperty
  , __propIsEnum$1d = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1c = (o, i, s) => i in o ? __defProp$1c(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1c = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1d.call(i, s) && __defNormalProp$1c(o, s, i[s]);
    if (__getOwnPropSymbols$1d)
        for (var s of __getOwnPropSymbols$1d(i))
            __propIsEnum$1d.call(i, s) && __defNormalProp$1c(o, s, i[s]);
    return o
}
;
function SelectItems({data: o, hovered: i, classNames: s, styles: a, isItemSelected: _, uuid: $, __staticSelector: _e, onItemHover: tt, onItemSelect: nt, itemsRefs: rt, itemComponent: ot, size: et, nothingFound: j, creatable: it, createLabel: st, unstyled: at, variant: lt}) {
    const {classes: ct} = useStyles$1b(null, {
        classNames: s,
        styles: a,
        unstyled: at,
        name: _e,
        variant: lt,
        size: et
    })
      , ut = []
      , dt = [];
    let ft = null;
    const ht = (gt, _t) => {
        const mt = typeof _ == "function" ? _(gt.value) : !1;
        return React.createElement(ot, __spreadValues$1c({
            key: gt.value,
            className: ct.item,
            "data-disabled": gt.disabled || void 0,
            "data-hovered": !gt.disabled && i === _t || void 0,
            "data-selected": !gt.disabled && mt || void 0,
            selected: mt,
            onMouseEnter: () => tt(_t),
            id: `${$}-${_t}`,
            role: "option",
            tabIndex: -1,
            "aria-selected": i === _t,
            ref: yt => {
                rt && rt.current && (rt.current[gt.value] = yt)
            }
            ,
            onMouseDown: gt.disabled ? null : yt => {
                yt.preventDefault(),
                nt(gt)
            }
            ,
            disabled: gt.disabled,
            variant: lt
        }, gt))
    }
    ;
    let pt = null;
    if (o.forEach( (gt, _t) => {
        gt.creatable ? ft = _t : gt.group ? (pt !== gt.group && (pt = gt.group,
        dt.push(React.createElement("div", {
            className: ct.separator,
            key: `__mantine-divider-${_t}`
        }, React.createElement(Divider, {
            classNames: {
                label: ct.separatorLabel
            },
            label: gt.group
        })))),
        dt.push(ht(gt, _t))) : ut.push(ht(gt, _t))
    }
    ),
    it) {
        const gt = o[ft];
        ut.push(React.createElement("div", {
            key: randomId(),
            className: ct.item,
            "data-hovered": i === ft || void 0,
            onMouseEnter: () => tt(ft),
            onMouseDown: _t => {
                _t.preventDefault(),
                nt(gt)
            }
            ,
            tabIndex: -1,
            ref: _t => {
                rt && rt.current && (rt.current[gt.value] = _t)
            }
        }, st))
    }
    return dt.length > 0 && ut.length > 0 && ut.unshift(React.createElement("div", {
        className: ct.separator,
        key: "empty-group-separator"
    }, React.createElement(Divider, null))),
    dt.length > 0 || ut.length > 0 ? React.createElement(React.Fragment, null, dt, ut) : React.createElement(Text$2, {
        size: et,
        unstyled: at,
        className: ct.nothingFound
    }, j)
}
SelectItems.displayName = "@mantine/core/SelectItems";
var __defProp$1b = Object.defineProperty
  , __getOwnPropSymbols$1c = Object.getOwnPropertySymbols
  , __hasOwnProp$1c = Object.prototype.hasOwnProperty
  , __propIsEnum$1c = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1b = (o, i, s) => i in o ? __defProp$1b(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1b = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1c.call(i, s) && __defNormalProp$1b(o, s, i[s]);
    if (__getOwnPropSymbols$1c)
        for (var s of __getOwnPropSymbols$1c(i))
            __propIsEnum$1c.call(i, s) && __defNormalProp$1b(o, s, i[s]);
    return o
}
  , __objRest$S = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$1c.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$1c)
        for (var a of __getOwnPropSymbols$1c(o))
            i.indexOf(a) < 0 && __propIsEnum$1c.call(o, a) && (s[a] = o[a]);
    return s
}
;
const DefaultItem = reactExports.forwardRef( (o, i) => {
    var s = o
      , {label: a, value: _} = s
      , $ = __objRest$S(s, ["label", "value"]);
    return React.createElement("div", __spreadValues$1b({
        ref: i
    }, $), a || _)
}
);
DefaultItem.displayName = "@mantine/core/DefaultItem";
function $6ed0406888f73fc4$var$setRef(o, i) {
    typeof o == "function" ? o(i) : o != null && (o.current = i)
}
function $6ed0406888f73fc4$export$43e446d32b3d21af(...o) {
    return i => o.forEach(s => $6ed0406888f73fc4$var$setRef(s, i))
}
function $6ed0406888f73fc4$export$c7b2cbe3552a0d05(...o) {
    return reactExports.useCallback($6ed0406888f73fc4$export$43e446d32b3d21af(...o), o)
}
const $5e63c961fc1ce211$export$8c6ed5c666ac1360 = reactExports.forwardRef( (o, i) => {
    const {children: s, ...a} = o
      , _ = reactExports.Children.toArray(s)
      , $ = _.find($5e63c961fc1ce211$var$isSlottable);
    if ($) {
        const _e = $.props.children
          , tt = _.map(nt => nt === $ ? reactExports.Children.count(_e) > 1 ? reactExports.Children.only(null) : reactExports.isValidElement(_e) ? _e.props.children : null : nt);
        return reactExports.createElement($5e63c961fc1ce211$var$SlotClone, _extends({}, a, {
            ref: i
        }), reactExports.isValidElement(_e) ? reactExports.cloneElement(_e, void 0, tt) : null)
    }
    return reactExports.createElement($5e63c961fc1ce211$var$SlotClone, _extends({}, a, {
        ref: i
    }), s)
}
);
$5e63c961fc1ce211$export$8c6ed5c666ac1360.displayName = "Slot";
const $5e63c961fc1ce211$var$SlotClone = reactExports.forwardRef( (o, i) => {
    const {children: s, ...a} = o;
    return reactExports.isValidElement(s) ? reactExports.cloneElement(s, {
        ...$5e63c961fc1ce211$var$mergeProps(a, s.props),
        ref: $6ed0406888f73fc4$export$43e446d32b3d21af(i, s.ref)
    }) : reactExports.Children.count(s) > 1 ? reactExports.Children.only(null) : null
}
);
$5e63c961fc1ce211$var$SlotClone.displayName = "SlotClone";
const $5e63c961fc1ce211$export$d9f1ccf0bdb05d45 = ({children: o}) => reactExports.createElement(reactExports.Fragment, null, o);
function $5e63c961fc1ce211$var$isSlottable(o) {
    return reactExports.isValidElement(o) && o.type === $5e63c961fc1ce211$export$d9f1ccf0bdb05d45
}
function $5e63c961fc1ce211$var$mergeProps(o, i) {
    const s = {
        ...i
    };
    for (const a in i) {
        const _ = o[a]
          , $ = i[a];
        /^on[A-Z]/.test(a) ? _ && $ ? s[a] = (...tt) => {
            $(...tt),
            _(...tt)
        }
        : _ && (s[a] = _) : a === "style" ? s[a] = {
            ..._,
            ...$
        } : a === "className" && (s[a] = [_, $].filter(Boolean).join(" "))
    }
    return {
        ...o,
        ...s
    }
}
const $8927f6f2acc4f386$var$NODES = ["a", "button", "div", "h2", "h3", "img", "label", "li", "nav", "ol", "p", "span", "svg", "ul"]
  , $8927f6f2acc4f386$export$250ffa63cdc0d034 = $8927f6f2acc4f386$var$NODES.reduce( (o, i) => {
    const s = reactExports.forwardRef( (a, _) => {
        const {asChild: $, ..._e} = a
          , tt = $ ? $5e63c961fc1ce211$export$8c6ed5c666ac1360 : i;
        return reactExports.useEffect( () => {
            window[Symbol.for("radix-ui")] = !0
        }
        , []),
        reactExports.createElement(tt, _extends({}, _e, {
            ref: _
        }))
    }
    );
    return s.displayName = `Primitive.${i}`,
    {
        ...o,
        [i]: s
    }
}
, {})
  , $9f79659886946c16$export$e5c5a5f917a5871c = globalThis != null && globalThis.document ? reactExports.useLayoutEffect : () => {}
;
function $fe963b355347cc68$export$3e6543de14f8614f(o, i) {
    return reactExports.useReducer( (s, a) => {
        const _ = i[s][a];
        return _ ?? s
    }
    , o)
}
const $921a889cee6df7e8$export$99c2b779aa4e8b8b = o => {
    const {present: i, children: s} = o
      , a = $921a889cee6df7e8$var$usePresence(i)
      , _ = typeof s == "function" ? s({
        present: a.isPresent
    }) : reactExports.Children.only(s)
      , $ = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(a.ref, _.ref);
    return typeof s == "function" || a.isPresent ? reactExports.cloneElement(_, {
        ref: $
    }) : null
}
;
$921a889cee6df7e8$export$99c2b779aa4e8b8b.displayName = "Presence";
function $921a889cee6df7e8$var$usePresence(o) {
    const [i,s] = reactExports.useState()
      , a = reactExports.useRef({})
      , _ = reactExports.useRef(o)
      , $ = reactExports.useRef("none")
      , _e = o ? "mounted" : "unmounted"
      , [tt,nt] = $fe963b355347cc68$export$3e6543de14f8614f(_e, {
        mounted: {
            UNMOUNT: "unmounted",
            ANIMATION_OUT: "unmountSuspended"
        },
        unmountSuspended: {
            MOUNT: "mounted",
            ANIMATION_END: "unmounted"
        },
        unmounted: {
            MOUNT: "mounted"
        }
    });
    return reactExports.useEffect( () => {
        const rt = $921a889cee6df7e8$var$getAnimationName(a.current);
        $.current = tt === "mounted" ? rt : "none"
    }
    , [tt]),
    $9f79659886946c16$export$e5c5a5f917a5871c( () => {
        const rt = a.current
          , ot = _.current;
        if (ot !== o) {
            const j = $.current
              , it = $921a889cee6df7e8$var$getAnimationName(rt);
            o ? nt("MOUNT") : it === "none" || (rt == null ? void 0 : rt.display) === "none" ? nt("UNMOUNT") : nt(ot && j !== it ? "ANIMATION_OUT" : "UNMOUNT"),
            _.current = o
        }
    }
    , [o, nt]),
    $9f79659886946c16$export$e5c5a5f917a5871c( () => {
        if (i) {
            const rt = et => {
                const it = $921a889cee6df7e8$var$getAnimationName(a.current).includes(et.animationName);
                et.target === i && it && reactDomExports.flushSync( () => nt("ANIMATION_END"))
            }
              , ot = et => {
                et.target === i && ($.current = $921a889cee6df7e8$var$getAnimationName(a.current))
            }
            ;
            return i.addEventListener("animationstart", ot),
            i.addEventListener("animationcancel", rt),
            i.addEventListener("animationend", rt),
            () => {
                i.removeEventListener("animationstart", ot),
                i.removeEventListener("animationcancel", rt),
                i.removeEventListener("animationend", rt)
            }
        } else
            nt("ANIMATION_END")
    }
    , [i, nt]),
    {
        isPresent: ["mounted", "unmountSuspended"].includes(tt),
        ref: reactExports.useCallback(rt => {
            rt && (a.current = getComputedStyle(rt)),
            s(rt)
        }
        , [])
    }
}
function $921a889cee6df7e8$var$getAnimationName(o) {
    return (o == null ? void 0 : o.animationName) || "none"
}
function $c512c27ab02ef895$export$50c7b4e9d9f19c1(o, i=[]) {
    let s = [];
    function a($, _e) {
        const tt = reactExports.createContext(_e)
          , nt = s.length;
        s = [...s, _e];
        function rt(et) {
            const {scope: j, children: it, ...st} = et
              , at = (j == null ? void 0 : j[o][nt]) || tt
              , lt = reactExports.useMemo( () => st, Object.values(st));
            return reactExports.createElement(at.Provider, {
                value: lt
            }, it)
        }
        function ot(et, j) {
            const it = (j == null ? void 0 : j[o][nt]) || tt
              , st = reactExports.useContext(it);
            if (st)
                return st;
            if (_e !== void 0)
                return _e;
            throw new Error(`\`${et}\` must be used within \`${$}\``)
        }
        return rt.displayName = $ + "Provider",
        [rt, ot]
    }
    const _ = () => {
        const $ = s.map(_e => reactExports.createContext(_e));
        return function(tt) {
            const nt = (tt == null ? void 0 : tt[o]) || $;
            return reactExports.useMemo( () => ({
                [`__scope${o}`]: {
                    ...tt,
                    [o]: nt
                }
            }), [tt, nt])
        }
    }
    ;
    return _.scopeName = o,
    [a, $c512c27ab02ef895$var$composeContextScopes(_, ...i)]
}
function $c512c27ab02ef895$var$composeContextScopes(...o) {
    const i = o[0];
    if (o.length === 1)
        return i;
    const s = () => {
        const a = o.map(_ => ({
            useScope: _(),
            scopeName: _.scopeName
        }));
        return function($) {
            const _e = a.reduce( (tt, {useScope: nt, scopeName: rt}) => {
                const et = nt($)[`__scope${rt}`];
                return {
                    ...tt,
                    ...et
                }
            }
            , {});
            return reactExports.useMemo( () => ({
                [`__scope${i.scopeName}`]: _e
            }), [_e])
        }
    }
    ;
    return s.scopeName = i.scopeName,
    s
}
function $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(o) {
    const i = reactExports.useRef(o);
    return reactExports.useEffect( () => {
        i.current = o
    }
    ),
    reactExports.useMemo( () => (...s) => {
        var a;
        return (a = i.current) === null || a === void 0 ? void 0 : a.call(i, ...s)
    }
    , [])
}
const $f631663db3294ace$var$DirectionContext = reactExports.createContext(void 0);
function $f631663db3294ace$export$b39126d51d94e6f3(o) {
    const i = reactExports.useContext($f631663db3294ace$var$DirectionContext);
    return o || i || "ltr"
}
function $ae6933e535247d3d$export$7d15b64cf5a3a4c4(o, [i,s]) {
    return Math.min(s, Math.max(i, o))
}
function $e42e1063c40fb3ef$export$b9ecd428b558ff10(o, i, {checkForDefaultPrevented: s=!0}={}) {
    return function(_) {
        if (o == null || o(_),
        s === !1 || !_.defaultPrevented)
            return i == null ? void 0 : i(_)
    }
}
function $6c2e24571c90391f$export$3e6543de14f8614f(o, i) {
    return reactExports.useReducer( (s, a) => {
        const _ = i[s][a];
        return _ ?? s
    }
    , o)
}
const $57acba87d6e25586$var$SCROLL_AREA_NAME = "ScrollArea"
  , [$57acba87d6e25586$var$createScrollAreaContext,$57acba87d6e25586$export$488468afe3a6f2b1] = $c512c27ab02ef895$export$50c7b4e9d9f19c1($57acba87d6e25586$var$SCROLL_AREA_NAME)
  , [$57acba87d6e25586$var$ScrollAreaProvider,$57acba87d6e25586$var$useScrollAreaContext] = $57acba87d6e25586$var$createScrollAreaContext($57acba87d6e25586$var$SCROLL_AREA_NAME)
  , $57acba87d6e25586$export$ccf8d8d7bbf3c2cc = reactExports.forwardRef( (o, i) => {
    const {__scopeScrollArea: s, type: a="hover", dir: _, scrollHideDelay: $=600, ..._e} = o
      , [tt,nt] = reactExports.useState(null)
      , [rt,ot] = reactExports.useState(null)
      , [et,j] = reactExports.useState(null)
      , [it,st] = reactExports.useState(null)
      , [at,lt] = reactExports.useState(null)
      , [ct,ut] = reactExports.useState(0)
      , [dt,ft] = reactExports.useState(0)
      , [ht,pt] = reactExports.useState(!1)
      , [gt,_t] = reactExports.useState(!1)
      , mt = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(i, bt => nt(bt))
      , yt = $f631663db3294ace$export$b39126d51d94e6f3(_);
    return reactExports.createElement($57acba87d6e25586$var$ScrollAreaProvider, {
        scope: s,
        type: a,
        dir: yt,
        scrollHideDelay: $,
        scrollArea: tt,
        viewport: rt,
        onViewportChange: ot,
        content: et,
        onContentChange: j,
        scrollbarX: it,
        onScrollbarXChange: st,
        scrollbarXEnabled: ht,
        onScrollbarXEnabledChange: pt,
        scrollbarY: at,
        onScrollbarYChange: lt,
        scrollbarYEnabled: gt,
        onScrollbarYEnabledChange: _t,
        onCornerWidthChange: ut,
        onCornerHeightChange: ft
    }, reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
        dir: yt
    }, _e, {
        ref: mt,
        style: {
            position: "relative",
            "--radix-scroll-area-corner-width": ct + "px",
            "--radix-scroll-area-corner-height": dt + "px",
            ...o.style
        }
    })))
}
)
  , $57acba87d6e25586$var$VIEWPORT_NAME = "ScrollAreaViewport"
  , $57acba87d6e25586$export$a21cbf9f11fca853 = reactExports.forwardRef( (o, i) => {
    const {__scopeScrollArea: s, children: a, ..._} = o
      , $ = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$VIEWPORT_NAME, s)
      , _e = reactExports.useRef(null)
      , tt = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(i, _e, $.onViewportChange);
    return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("style", {
        dangerouslySetInnerHTML: {
            __html: "[data-radix-scroll-area-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-scroll-area-viewport]::-webkit-scrollbar{display:none}"
        }
    }), reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
        "data-radix-scroll-area-viewport": ""
    }, _, {
        ref: tt,
        style: {
            overflowX: $.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: $.scrollbarYEnabled ? "scroll" : "hidden",
            ...o.style
        }
    }), reactExports.createElement("div", {
        ref: $.onContentChange,
        style: {
            minWidth: "100%",
            display: "table"
        }
    }, a)))
}
)
  , $57acba87d6e25586$var$SCROLLBAR_NAME = "ScrollAreaScrollbar"
  , $57acba87d6e25586$export$2fabd85d0eba3c57 = reactExports.forwardRef( (o, i) => {
    const {forceMount: s, ...a} = o
      , _ = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$SCROLLBAR_NAME, o.__scopeScrollArea)
      , {onScrollbarXEnabledChange: $, onScrollbarYEnabledChange: _e} = _
      , tt = o.orientation === "horizontal";
    return reactExports.useEffect( () => (tt ? $(!0) : _e(!0),
    () => {
        tt ? $(!1) : _e(!1)
    }
    ), [tt, $, _e]),
    _.type === "hover" ? reactExports.createElement($57acba87d6e25586$var$ScrollAreaScrollbarHover, _extends({}, a, {
        ref: i,
        forceMount: s
    })) : _.type === "scroll" ? reactExports.createElement($57acba87d6e25586$var$ScrollAreaScrollbarScroll, _extends({}, a, {
        ref: i,
        forceMount: s
    })) : _.type === "auto" ? reactExports.createElement($57acba87d6e25586$var$ScrollAreaScrollbarAuto, _extends({}, a, {
        ref: i,
        forceMount: s
    })) : _.type === "always" ? reactExports.createElement($57acba87d6e25586$var$ScrollAreaScrollbarVisible, _extends({}, a, {
        ref: i
    })) : null
}
)
  , $57acba87d6e25586$var$ScrollAreaScrollbarHover = reactExports.forwardRef( (o, i) => {
    const {forceMount: s, ...a} = o
      , _ = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$SCROLLBAR_NAME, o.__scopeScrollArea)
      , [$,_e] = reactExports.useState(!1);
    return reactExports.useEffect( () => {
        const tt = _.scrollArea;
        let nt = 0;
        if (tt) {
            const rt = () => {
                window.clearTimeout(nt),
                _e(!0)
            }
              , ot = () => {
                nt = window.setTimeout( () => _e(!1), _.scrollHideDelay)
            }
            ;
            return tt.addEventListener("pointerenter", rt),
            tt.addEventListener("pointerleave", ot),
            () => {
                window.clearTimeout(nt),
                tt.removeEventListener("pointerenter", rt),
                tt.removeEventListener("pointerleave", ot)
            }
        }
    }
    , [_.scrollArea, _.scrollHideDelay]),
    reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
        present: s || $
    }, reactExports.createElement($57acba87d6e25586$var$ScrollAreaScrollbarAuto, _extends({
        "data-state": $ ? "visible" : "hidden"
    }, a, {
        ref: i
    })))
}
)
  , $57acba87d6e25586$var$ScrollAreaScrollbarScroll = reactExports.forwardRef( (o, i) => {
    const {forceMount: s, ...a} = o
      , _ = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$SCROLLBAR_NAME, o.__scopeScrollArea)
      , $ = o.orientation === "horizontal"
      , _e = $57acba87d6e25586$var$useDebounceCallback( () => nt("SCROLL_END"), 100)
      , [tt,nt] = $6c2e24571c90391f$export$3e6543de14f8614f("hidden", {
        hidden: {
            SCROLL: "scrolling"
        },
        scrolling: {
            SCROLL_END: "idle",
            POINTER_ENTER: "interacting"
        },
        interacting: {
            SCROLL: "interacting",
            POINTER_LEAVE: "idle"
        },
        idle: {
            HIDE: "hidden",
            SCROLL: "scrolling",
            POINTER_ENTER: "interacting"
        }
    });
    return reactExports.useEffect( () => {
        if (tt === "idle") {
            const rt = window.setTimeout( () => nt("HIDE"), _.scrollHideDelay);
            return () => window.clearTimeout(rt)
        }
    }
    , [tt, _.scrollHideDelay, nt]),
    reactExports.useEffect( () => {
        const rt = _.viewport
          , ot = $ ? "scrollLeft" : "scrollTop";
        if (rt) {
            let et = rt[ot];
            const j = () => {
                const it = rt[ot];
                et !== it && (nt("SCROLL"),
                _e()),
                et = it
            }
            ;
            return rt.addEventListener("scroll", j),
            () => rt.removeEventListener("scroll", j)
        }
    }
    , [_.viewport, $, nt, _e]),
    reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
        present: s || tt !== "hidden"
    }, reactExports.createElement($57acba87d6e25586$var$ScrollAreaScrollbarVisible, _extends({
        "data-state": tt === "hidden" ? "hidden" : "visible"
    }, a, {
        ref: i,
        onPointerEnter: $e42e1063c40fb3ef$export$b9ecd428b558ff10(o.onPointerEnter, () => nt("POINTER_ENTER")),
        onPointerLeave: $e42e1063c40fb3ef$export$b9ecd428b558ff10(o.onPointerLeave, () => nt("POINTER_LEAVE"))
    })))
}
)
  , $57acba87d6e25586$var$ScrollAreaScrollbarAuto = reactExports.forwardRef( (o, i) => {
    const s = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$SCROLLBAR_NAME, o.__scopeScrollArea)
      , {forceMount: a, ..._} = o
      , [$,_e] = reactExports.useState(!1)
      , tt = o.orientation === "horizontal"
      , nt = $57acba87d6e25586$var$useDebounceCallback( () => {
        if (s.viewport) {
            const rt = s.viewport.offsetWidth < s.viewport.scrollWidth
              , ot = s.viewport.offsetHeight < s.viewport.scrollHeight;
            _e(tt ? rt : ot)
        }
    }
    , 10);
    return $57acba87d6e25586$var$useResizeObserver(s.viewport, nt),
    $57acba87d6e25586$var$useResizeObserver(s.content, nt),
    reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
        present: a || $
    }, reactExports.createElement($57acba87d6e25586$var$ScrollAreaScrollbarVisible, _extends({
        "data-state": $ ? "visible" : "hidden"
    }, _, {
        ref: i
    })))
}
)
  , $57acba87d6e25586$var$ScrollAreaScrollbarVisible = reactExports.forwardRef( (o, i) => {
    const {orientation: s="vertical", ...a} = o
      , _ = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$SCROLLBAR_NAME, o.__scopeScrollArea)
      , $ = reactExports.useRef(null)
      , _e = reactExports.useRef(0)
      , [tt,nt] = reactExports.useState({
        content: 0,
        viewport: 0,
        scrollbar: {
            size: 0,
            paddingStart: 0,
            paddingEnd: 0
        }
    })
      , rt = $57acba87d6e25586$var$getThumbRatio(tt.viewport, tt.content)
      , ot = {
        ...a,
        sizes: tt,
        onSizesChange: nt,
        hasThumb: rt > 0 && rt < 1,
        onThumbChange: j => $.current = j,
        onThumbPointerUp: () => _e.current = 0,
        onThumbPointerDown: j => _e.current = j
    };
    function et(j, it) {
        return $57acba87d6e25586$var$getScrollPositionFromPointer(j, _e.current, tt, it)
    }
    return s === "horizontal" ? reactExports.createElement($57acba87d6e25586$var$ScrollAreaScrollbarX, _extends({}, ot, {
        ref: i,
        onThumbPositionChange: () => {
            if (_.viewport && $.current) {
                const j = _.viewport.scrollLeft
                  , it = $57acba87d6e25586$var$getThumbOffsetFromScroll(j, tt, _.dir);
                $.current.style.transform = `translate3d(${it}px, 0, 0)`
            }
        }
        ,
        onWheelScroll: j => {
            _.viewport && (_.viewport.scrollLeft = j)
        }
        ,
        onDragScroll: j => {
            _.viewport && (_.viewport.scrollLeft = et(j, _.dir))
        }
    })) : s === "vertical" ? reactExports.createElement($57acba87d6e25586$var$ScrollAreaScrollbarY, _extends({}, ot, {
        ref: i,
        onThumbPositionChange: () => {
            if (_.viewport && $.current) {
                const j = _.viewport.scrollTop
                  , it = $57acba87d6e25586$var$getThumbOffsetFromScroll(j, tt);
                $.current.style.transform = `translate3d(0, ${it}px, 0)`
            }
        }
        ,
        onWheelScroll: j => {
            _.viewport && (_.viewport.scrollTop = j)
        }
        ,
        onDragScroll: j => {
            _.viewport && (_.viewport.scrollTop = et(j))
        }
    })) : null
}
)
  , $57acba87d6e25586$var$ScrollAreaScrollbarX = reactExports.forwardRef( (o, i) => {
    const {sizes: s, onSizesChange: a, ..._} = o
      , $ = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$SCROLLBAR_NAME, o.__scopeScrollArea)
      , [_e,tt] = reactExports.useState()
      , nt = reactExports.useRef(null)
      , rt = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(i, nt, $.onScrollbarXChange);
    return reactExports.useEffect( () => {
        nt.current && tt(getComputedStyle(nt.current))
    }
    , [nt]),
    reactExports.createElement($57acba87d6e25586$var$ScrollAreaScrollbarImpl, _extends({
        "data-orientation": "horizontal"
    }, _, {
        ref: rt,
        sizes: s,
        style: {
            bottom: 0,
            left: $.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
            right: $.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
            "--radix-scroll-area-thumb-width": $57acba87d6e25586$var$getThumbSize(s) + "px",
            ...o.style
        },
        onThumbPointerDown: ot => o.onThumbPointerDown(ot.x),
        onDragScroll: ot => o.onDragScroll(ot.x),
        onWheelScroll: (ot, et) => {
            if ($.viewport) {
                const j = $.viewport.scrollLeft + ot.deltaX;
                o.onWheelScroll(j),
                $57acba87d6e25586$var$isScrollingWithinScrollbarBounds(j, et) && ot.preventDefault()
            }
        }
        ,
        onResize: () => {
            nt.current && $.viewport && _e && a({
                content: $.viewport.scrollWidth,
                viewport: $.viewport.offsetWidth,
                scrollbar: {
                    size: nt.current.clientWidth,
                    paddingStart: $57acba87d6e25586$var$toInt(_e.paddingLeft),
                    paddingEnd: $57acba87d6e25586$var$toInt(_e.paddingRight)
                }
            })
        }
    }))
}
)
  , $57acba87d6e25586$var$ScrollAreaScrollbarY = reactExports.forwardRef( (o, i) => {
    const {sizes: s, onSizesChange: a, ..._} = o
      , $ = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$SCROLLBAR_NAME, o.__scopeScrollArea)
      , [_e,tt] = reactExports.useState()
      , nt = reactExports.useRef(null)
      , rt = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(i, nt, $.onScrollbarYChange);
    return reactExports.useEffect( () => {
        nt.current && tt(getComputedStyle(nt.current))
    }
    , [nt]),
    reactExports.createElement($57acba87d6e25586$var$ScrollAreaScrollbarImpl, _extends({
        "data-orientation": "vertical"
    }, _, {
        ref: rt,
        sizes: s,
        style: {
            top: 0,
            right: $.dir === "ltr" ? 0 : void 0,
            left: $.dir === "rtl" ? 0 : void 0,
            bottom: "var(--radix-scroll-area-corner-height)",
            "--radix-scroll-area-thumb-height": $57acba87d6e25586$var$getThumbSize(s) + "px",
            ...o.style
        },
        onThumbPointerDown: ot => o.onThumbPointerDown(ot.y),
        onDragScroll: ot => o.onDragScroll(ot.y),
        onWheelScroll: (ot, et) => {
            if ($.viewport) {
                const j = $.viewport.scrollTop + ot.deltaY;
                o.onWheelScroll(j),
                $57acba87d6e25586$var$isScrollingWithinScrollbarBounds(j, et) && ot.preventDefault()
            }
        }
        ,
        onResize: () => {
            nt.current && $.viewport && _e && a({
                content: $.viewport.scrollHeight,
                viewport: $.viewport.offsetHeight,
                scrollbar: {
                    size: nt.current.clientHeight,
                    paddingStart: $57acba87d6e25586$var$toInt(_e.paddingTop),
                    paddingEnd: $57acba87d6e25586$var$toInt(_e.paddingBottom)
                }
            })
        }
    }))
}
)
  , [$57acba87d6e25586$var$ScrollbarProvider,$57acba87d6e25586$var$useScrollbarContext] = $57acba87d6e25586$var$createScrollAreaContext($57acba87d6e25586$var$SCROLLBAR_NAME)
  , $57acba87d6e25586$var$ScrollAreaScrollbarImpl = reactExports.forwardRef( (o, i) => {
    const {__scopeScrollArea: s, sizes: a, hasThumb: _, onThumbChange: $, onThumbPointerUp: _e, onThumbPointerDown: tt, onThumbPositionChange: nt, onDragScroll: rt, onWheelScroll: ot, onResize: et, ...j} = o
      , it = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$SCROLLBAR_NAME, s)
      , [st,at] = reactExports.useState(null)
      , lt = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(i, mt => at(mt))
      , ct = reactExports.useRef(null)
      , ut = reactExports.useRef("")
      , dt = it.viewport
      , ft = a.content - a.viewport
      , ht = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(ot)
      , pt = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(nt)
      , gt = $57acba87d6e25586$var$useDebounceCallback(et, 10);
    function _t(mt) {
        if (ct.current) {
            const yt = mt.clientX - ct.current.left
              , bt = mt.clientY - ct.current.top;
            rt({
                x: yt,
                y: bt
            })
        }
    }
    return reactExports.useEffect( () => {
        const mt = yt => {
            const bt = yt.target;
            (st == null ? void 0 : st.contains(bt)) && ht(yt, ft)
        }
        ;
        return document.addEventListener("wheel", mt, {
            passive: !1
        }),
        () => document.removeEventListener("wheel", mt, {
            passive: !1
        })
    }
    , [dt, st, ft, ht]),
    reactExports.useEffect(pt, [a, pt]),
    $57acba87d6e25586$var$useResizeObserver(st, gt),
    $57acba87d6e25586$var$useResizeObserver(it.content, gt),
    reactExports.createElement($57acba87d6e25586$var$ScrollbarProvider, {
        scope: s,
        scrollbar: st,
        hasThumb: _,
        onThumbChange: $b1b2314f5f9a1d84$export$25bec8c6f54ee79a($),
        onThumbPointerUp: $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(_e),
        onThumbPositionChange: pt,
        onThumbPointerDown: $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(tt)
    }, reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, j, {
        ref: lt,
        style: {
            position: "absolute",
            ...j.style
        },
        onPointerDown: $e42e1063c40fb3ef$export$b9ecd428b558ff10(o.onPointerDown, mt => {
            mt.button === 0 && (mt.target.setPointerCapture(mt.pointerId),
            ct.current = st.getBoundingClientRect(),
            ut.current = document.body.style.webkitUserSelect,
            document.body.style.webkitUserSelect = "none",
            _t(mt))
        }
        ),
        onPointerMove: $e42e1063c40fb3ef$export$b9ecd428b558ff10(o.onPointerMove, _t),
        onPointerUp: $e42e1063c40fb3ef$export$b9ecd428b558ff10(o.onPointerUp, mt => {
            const yt = mt.target;
            yt.hasPointerCapture(mt.pointerId) && yt.releasePointerCapture(mt.pointerId),
            document.body.style.webkitUserSelect = ut.current,
            ct.current = null
        }
        )
    })))
}
)
  , $57acba87d6e25586$var$THUMB_NAME = "ScrollAreaThumb"
  , $57acba87d6e25586$export$9fba1154677d7cd2 = reactExports.forwardRef( (o, i) => {
    const {forceMount: s, ...a} = o
      , _ = $57acba87d6e25586$var$useScrollbarContext($57acba87d6e25586$var$THUMB_NAME, o.__scopeScrollArea);
    return reactExports.createElement($921a889cee6df7e8$export$99c2b779aa4e8b8b, {
        present: s || _.hasThumb
    }, reactExports.createElement($57acba87d6e25586$var$ScrollAreaThumbImpl, _extends({
        ref: i
    }, a)))
}
)
  , $57acba87d6e25586$var$ScrollAreaThumbImpl = reactExports.forwardRef( (o, i) => {
    const {__scopeScrollArea: s, style: a, ..._} = o
      , $ = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$THUMB_NAME, s)
      , _e = $57acba87d6e25586$var$useScrollbarContext($57acba87d6e25586$var$THUMB_NAME, s)
      , {onThumbPositionChange: tt} = _e
      , nt = $6ed0406888f73fc4$export$c7b2cbe3552a0d05(i, et => _e.onThumbChange(et))
      , rt = reactExports.useRef()
      , ot = $57acba87d6e25586$var$useDebounceCallback( () => {
        rt.current && (rt.current(),
        rt.current = void 0)
    }
    , 100);
    return reactExports.useEffect( () => {
        const et = $.viewport;
        if (et) {
            const j = () => {
                if (ot(),
                !rt.current) {
                    const it = $57acba87d6e25586$var$addUnlinkedScrollListener(et, tt);
                    rt.current = it,
                    tt()
                }
            }
            ;
            return tt(),
            et.addEventListener("scroll", j),
            () => et.removeEventListener("scroll", j)
        }
    }
    , [$.viewport, ot, tt]),
    reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({
        "data-state": _e.hasThumb ? "visible" : "hidden"
    }, _, {
        ref: nt,
        style: {
            width: "var(--radix-scroll-area-thumb-width)",
            height: "var(--radix-scroll-area-thumb-height)",
            ...a
        },
        onPointerDownCapture: $e42e1063c40fb3ef$export$b9ecd428b558ff10(o.onPointerDownCapture, et => {
            const it = et.target.getBoundingClientRect()
              , st = et.clientX - it.left
              , at = et.clientY - it.top;
            _e.onThumbPointerDown({
                x: st,
                y: at
            })
        }
        ),
        onPointerUp: $e42e1063c40fb3ef$export$b9ecd428b558ff10(o.onPointerUp, _e.onThumbPointerUp)
    }))
}
)
  , $57acba87d6e25586$var$CORNER_NAME = "ScrollAreaCorner"
  , $57acba87d6e25586$export$56969d565df7cc4b = reactExports.forwardRef( (o, i) => {
    const s = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$CORNER_NAME, o.__scopeScrollArea)
      , a = !!(s.scrollbarX && s.scrollbarY);
    return s.type !== "scroll" && a ? reactExports.createElement($57acba87d6e25586$var$ScrollAreaCornerImpl, _extends({}, o, {
        ref: i
    })) : null
}
)
  , $57acba87d6e25586$var$ScrollAreaCornerImpl = reactExports.forwardRef( (o, i) => {
    const {__scopeScrollArea: s, ...a} = o
      , _ = $57acba87d6e25586$var$useScrollAreaContext($57acba87d6e25586$var$CORNER_NAME, s)
      , [$,_e] = reactExports.useState(0)
      , [tt,nt] = reactExports.useState(0)
      , rt = !!($ && tt);
    return $57acba87d6e25586$var$useResizeObserver(_.scrollbarX, () => {
        var ot;
        const et = ((ot = _.scrollbarX) === null || ot === void 0 ? void 0 : ot.offsetHeight) || 0;
        _.onCornerHeightChange(et),
        nt(et)
    }
    ),
    $57acba87d6e25586$var$useResizeObserver(_.scrollbarY, () => {
        var ot;
        const et = ((ot = _.scrollbarY) === null || ot === void 0 ? void 0 : ot.offsetWidth) || 0;
        _.onCornerWidthChange(et),
        _e(et)
    }
    ),
    rt ? reactExports.createElement($8927f6f2acc4f386$export$250ffa63cdc0d034.div, _extends({}, a, {
        ref: i,
        style: {
            width: $,
            height: tt,
            position: "absolute",
            right: _.dir === "ltr" ? 0 : void 0,
            left: _.dir === "rtl" ? 0 : void 0,
            bottom: 0,
            ...o.style
        }
    })) : null
}
);
function $57acba87d6e25586$var$toInt(o) {
    return o ? parseInt(o, 10) : 0
}
function $57acba87d6e25586$var$getThumbRatio(o, i) {
    const s = o / i;
    return isNaN(s) ? 0 : s
}
function $57acba87d6e25586$var$getThumbSize(o) {
    const i = $57acba87d6e25586$var$getThumbRatio(o.viewport, o.content)
      , s = o.scrollbar.paddingStart + o.scrollbar.paddingEnd
      , a = (o.scrollbar.size - s) * i;
    return Math.max(a, 18)
}
function $57acba87d6e25586$var$getScrollPositionFromPointer(o, i, s, a="ltr") {
    const _ = $57acba87d6e25586$var$getThumbSize(s)
      , $ = _ / 2
      , _e = i || $
      , tt = _ - _e
      , nt = s.scrollbar.paddingStart + _e
      , rt = s.scrollbar.size - s.scrollbar.paddingEnd - tt
      , ot = s.content - s.viewport
      , et = a === "ltr" ? [0, ot] : [ot * -1, 0];
    return $57acba87d6e25586$var$linearScale([nt, rt], et)(o)
}
function $57acba87d6e25586$var$getThumbOffsetFromScroll(o, i, s="ltr") {
    const a = $57acba87d6e25586$var$getThumbSize(i)
      , _ = i.scrollbar.paddingStart + i.scrollbar.paddingEnd
      , $ = i.scrollbar.size - _
      , _e = i.content - i.viewport
      , tt = $ - a
      , nt = s === "ltr" ? [0, _e] : [_e * -1, 0]
      , rt = $ae6933e535247d3d$export$7d15b64cf5a3a4c4(o, nt);
    return $57acba87d6e25586$var$linearScale([0, _e], [0, tt])(rt)
}
function $57acba87d6e25586$var$linearScale(o, i) {
    return s => {
        if (o[0] === o[1] || i[0] === i[1])
            return i[0];
        const a = (i[1] - i[0]) / (o[1] - o[0]);
        return i[0] + a * (s - o[0])
    }
}
function $57acba87d6e25586$var$isScrollingWithinScrollbarBounds(o, i) {
    return o > 0 && o < i
}
const $57acba87d6e25586$var$addUnlinkedScrollListener = (o, i= () => {}
) => {
    let s = {
        left: o.scrollLeft,
        top: o.scrollTop
    }
      , a = 0;
    return function _() {
        const $ = {
            left: o.scrollLeft,
            top: o.scrollTop
        }
          , _e = s.left !== $.left
          , tt = s.top !== $.top;
        (_e || tt) && i(),
        s = $,
        a = window.requestAnimationFrame(_)
    }(),
    () => window.cancelAnimationFrame(a)
}
;
function $57acba87d6e25586$var$useDebounceCallback(o, i) {
    const s = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(o)
      , a = reactExports.useRef(0);
    return reactExports.useEffect( () => () => window.clearTimeout(a.current), []),
    reactExports.useCallback( () => {
        window.clearTimeout(a.current),
        a.current = window.setTimeout(s, i)
    }
    , [s, i])
}
function $57acba87d6e25586$var$useResizeObserver(o, i) {
    const s = $b1b2314f5f9a1d84$export$25bec8c6f54ee79a(i);
    $9f79659886946c16$export$e5c5a5f917a5871c( () => {
        let a = 0;
        if (o) {
            const _ = new ResizeObserver( () => {
                cancelAnimationFrame(a),
                a = window.requestAnimationFrame(s)
            }
            );
            return _.observe(o),
            () => {
                window.cancelAnimationFrame(a),
                _.unobserve(o)
            }
        }
    }
    , [o, s])
}
const $57acba87d6e25586$export$be92b6f5f03c0fe9 = $57acba87d6e25586$export$ccf8d8d7bbf3c2cc
  , $57acba87d6e25586$export$d5c6c08dc2d3ca7 = $57acba87d6e25586$export$a21cbf9f11fca853
  , $57acba87d6e25586$export$9a4e88b92edfce6b = $57acba87d6e25586$export$2fabd85d0eba3c57
  , $57acba87d6e25586$export$6521433ed15a34db = $57acba87d6e25586$export$9fba1154677d7cd2
  , $57acba87d6e25586$export$ac61190d9fc311a9 = $57acba87d6e25586$export$56969d565df7cc4b;
var useStyles$18 = createStyles( (o, {scrollbarSize: i, offsetScrollbars: s, scrollbarHovered: a, hidden: _}) => ({
    root: {
        overflow: "hidden"
    },
    viewport: {
        width: "100%",
        height: "100%",
        paddingRight: s ? rem(i) : void 0,
        paddingBottom: s ? rem(i) : void 0
    },
    scrollbar: {
        display: _ ? "none" : "flex",
        userSelect: "none",
        touchAction: "none",
        boxSizing: "border-box",
        padding: `calc(${rem(i)}  / 5)`,
        transition: "background-color 150ms ease, opacity 150ms ease",
        "&:hover": {
            backgroundColor: o.colorScheme === "dark" ? o.colors.dark[8] : o.colors.gray[0],
            [`& .${getStylesRef("thumb")}`]: {
                backgroundColor: o.colorScheme === "dark" ? o.fn.rgba(o.white, .5) : o.fn.rgba(o.black, .5)
            }
        },
        '&[data-orientation="vertical"]': {
            width: rem(i)
        },
        '&[data-orientation="horizontal"]': {
            flexDirection: "column",
            height: rem(i)
        },
        '&[data-state="hidden"]': {
            display: "none",
            opacity: 0
        }
    },
    thumb: {
        ref: getStylesRef("thumb"),
        flex: 1,
        backgroundColor: o.colorScheme === "dark" ? o.fn.rgba(o.white, .4) : o.fn.rgba(o.black, .4),
        borderRadius: rem(i),
        position: "relative",
        transition: "background-color 150ms ease",
        display: _ ? "none" : void 0,
        overflow: "hidden",
        "&::before": {
            content: '""',
            position: "absolute",
            top: "50%",
            left: "50%",
            transform: "translate(-50%, -50%)",
            width: "100%",
            height: "100%",
            minWidth: rem(44),
            minHeight: rem(44)
        }
    },
    corner: {
        backgroundColor: o.colorScheme === "dark" ? o.colors.dark[6] : o.colors.gray[0],
        transition: "opacity 150ms ease",
        opacity: a ? 1 : 0,
        display: _ ? "none" : void 0
    }
}));
const useStyles$19 = useStyles$18;
var __defProp$1a = Object.defineProperty
  , __defProps$E = Object.defineProperties
  , __getOwnPropDescs$E = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$1b = Object.getOwnPropertySymbols
  , __hasOwnProp$1b = Object.prototype.hasOwnProperty
  , __propIsEnum$1b = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1a = (o, i, s) => i in o ? __defProp$1a(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1a = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1b.call(i, s) && __defNormalProp$1a(o, s, i[s]);
    if (__getOwnPropSymbols$1b)
        for (var s of __getOwnPropSymbols$1b(i))
            __propIsEnum$1b.call(i, s) && __defNormalProp$1a(o, s, i[s]);
    return o
}
  , __spreadProps$E = (o, i) => __defProps$E(o, __getOwnPropDescs$E(i))
  , __objRest$R = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$1b.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$1b)
        for (var a of __getOwnPropSymbols$1b(o))
            i.indexOf(a) < 0 && __propIsEnum$1b.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$F = {
    scrollbarSize: 12,
    scrollHideDelay: 1e3,
    type: "hover",
    offsetScrollbars: !1
}
  , _ScrollArea = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("ScrollArea", defaultProps$F, o)
      , {children: a, className: _, classNames: $, styles: _e, scrollbarSize: tt, scrollHideDelay: nt, type: rt, dir: ot, offsetScrollbars: et, viewportRef: j, onScrollPositionChange: it, unstyled: st, variant: at, viewportProps: lt} = s
      , ct = __objRest$R(s, ["children", "className", "classNames", "styles", "scrollbarSize", "scrollHideDelay", "type", "dir", "offsetScrollbars", "viewportRef", "onScrollPositionChange", "unstyled", "variant", "viewportProps"])
      , [ut,dt] = reactExports.useState(!1)
      , ft = useMantineTheme()
      , {classes: ht, cx: pt} = useStyles$19({
        scrollbarSize: tt,
        offsetScrollbars: et,
        scrollbarHovered: ut,
        hidden: rt === "never"
    }, {
        name: "ScrollArea",
        classNames: $,
        styles: _e,
        unstyled: st,
        variant: at
    });
    return React.createElement($57acba87d6e25586$export$be92b6f5f03c0fe9, {
        type: rt === "never" ? "always" : rt,
        scrollHideDelay: nt,
        dir: ot || ft.dir,
        ref: i,
        asChild: !0
    }, React.createElement(Box, __spreadValues$1a({
        className: pt(ht.root, _)
    }, ct), React.createElement($57acba87d6e25586$export$d5c6c08dc2d3ca7, __spreadProps$E(__spreadValues$1a({}, lt), {
        className: ht.viewport,
        ref: j,
        onScroll: typeof it == "function" ? ({currentTarget: gt}) => it({
            x: gt.scrollLeft,
            y: gt.scrollTop
        }) : void 0
    }), a), React.createElement($57acba87d6e25586$export$9a4e88b92edfce6b, {
        orientation: "horizontal",
        className: ht.scrollbar,
        forceMount: !0,
        onMouseEnter: () => dt(!0),
        onMouseLeave: () => dt(!1)
    }, React.createElement($57acba87d6e25586$export$6521433ed15a34db, {
        className: ht.thumb
    })), React.createElement($57acba87d6e25586$export$9a4e88b92edfce6b, {
        orientation: "vertical",
        className: ht.scrollbar,
        forceMount: !0,
        onMouseEnter: () => dt(!0),
        onMouseLeave: () => dt(!1)
    }, React.createElement($57acba87d6e25586$export$6521433ed15a34db, {
        className: ht.thumb
    })), React.createElement($57acba87d6e25586$export$ac61190d9fc311a9, {
        className: ht.corner
    })))
}
)
  , ScrollAreaAutosize = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("ScrollAreaAutosize", defaultProps$F, o)
      , {children: a, classNames: _, styles: $, scrollbarSize: _e, scrollHideDelay: tt, type: nt, dir: rt, offsetScrollbars: ot, viewportRef: et, onScrollPositionChange: j, unstyled: it, sx: st, variant: at, viewportProps: lt} = s
      , ct = __objRest$R(s, ["children", "classNames", "styles", "scrollbarSize", "scrollHideDelay", "type", "dir", "offsetScrollbars", "viewportRef", "onScrollPositionChange", "unstyled", "sx", "variant", "viewportProps"]);
    return React.createElement(Box, __spreadProps$E(__spreadValues$1a({}, ct), {
        ref: i,
        sx: [{
            display: "flex"
        }, ...packSx(st)]
    }), React.createElement(Box, {
        sx: {
            display: "flex",
            flexDirection: "column",
            flex: 1
        }
    }, React.createElement(_ScrollArea, {
        classNames: _,
        styles: $,
        scrollHideDelay: tt,
        scrollbarSize: _e,
        type: nt,
        dir: rt,
        offsetScrollbars: ot,
        viewportRef: et,
        onScrollPositionChange: j,
        unstyled: it,
        variant: at,
        viewportProps: lt
    }, a)))
}
);
ScrollAreaAutosize.displayName = "@mantine/core/ScrollAreaAutosize";
_ScrollArea.displayName = "@mantine/core/ScrollArea";
_ScrollArea.Autosize = ScrollAreaAutosize;
const ScrollArea = _ScrollArea;
var __defProp$19 = Object.defineProperty
  , __defProps$D = Object.defineProperties
  , __getOwnPropDescs$D = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$1a = Object.getOwnPropertySymbols
  , __hasOwnProp$1a = Object.prototype.hasOwnProperty
  , __propIsEnum$1a = Object.prototype.propertyIsEnumerable
  , __defNormalProp$19 = (o, i, s) => i in o ? __defProp$19(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$19 = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1a.call(i, s) && __defNormalProp$19(o, s, i[s]);
    if (__getOwnPropSymbols$1a)
        for (var s of __getOwnPropSymbols$1a(i))
            __propIsEnum$1a.call(i, s) && __defNormalProp$19(o, s, i[s]);
    return o
}
  , __spreadProps$D = (o, i) => __defProps$D(o, __getOwnPropDescs$D(i))
  , __objRest$Q = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$1a.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$1a)
        for (var a of __getOwnPropSymbols$1a(o))
            i.indexOf(a) < 0 && __propIsEnum$1a.call(o, a) && (s[a] = o[a]);
    return s
}
;
const SelectScrollArea = reactExports.forwardRef( (o, i) => {
    var s = o
      , {style: a} = s
      , _ = __objRest$Q(s, ["style"]);
    return React.createElement(ScrollArea, __spreadProps$D(__spreadValues$19({}, _), {
        style: __spreadValues$19({
            width: "100%"
        }, a),
        viewportProps: {
            tabIndex: -1
        },
        viewportRef: i
    }), _.children)
}
);
SelectScrollArea.displayName = "@mantine/core/SelectScrollArea";
var useStyles$16 = createStyles( () => ({
    dropdown: {},
    itemsWrapper: {
        padding: rem(4),
        display: "flex",
        width: "100%",
        boxSizing: "border-box"
    }
}));
const useStyles$17 = useStyles$16
  , min = Math.min
  , max = Math.max
  , round$1 = Math.round
  , floor$1 = Math.floor
  , createCoords = o => ({
    x: o,
    y: o
})
  , oppositeSideMap = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
}
  , oppositeAlignmentMap = {
    start: "end",
    end: "start"
};
function clamp$1(o, i, s) {
    return max(o, min(i, s))
}
function evaluate(o, i) {
    return typeof o == "function" ? o(i) : o
}
function getSide(o) {
    return o.split("-")[0]
}
function getAlignment(o) {
    return o.split("-")[1]
}
function getOppositeAxis(o) {
    return o === "x" ? "y" : "x"
}
function getAxisLength(o) {
    return o === "y" ? "height" : "width"
}
function getSideAxis(o) {
    return ["top", "bottom"].includes(getSide(o)) ? "y" : "x"
}
function getAlignmentAxis(o) {
    return getOppositeAxis(getSideAxis(o))
}
function getAlignmentSides(o, i, s) {
    s === void 0 && (s = !1);
    const a = getAlignment(o)
      , _ = getAlignmentAxis(o)
      , $ = getAxisLength(_);
    let _e = _ === "x" ? a === (s ? "end" : "start") ? "right" : "left" : a === "start" ? "bottom" : "top";
    return i.reference[$] > i.floating[$] && (_e = getOppositePlacement(_e)),
    [_e, getOppositePlacement(_e)]
}
function getExpandedPlacements(o) {
    const i = getOppositePlacement(o);
    return [getOppositeAlignmentPlacement(o), i, getOppositeAlignmentPlacement(i)]
}
function getOppositeAlignmentPlacement(o) {
    return o.replace(/start|end/g, i => oppositeAlignmentMap[i])
}
function getSideList(o, i, s) {
    const a = ["left", "right"]
      , _ = ["right", "left"]
      , $ = ["top", "bottom"]
      , _e = ["bottom", "top"];
    switch (o) {
    case "top":
    case "bottom":
        return s ? i ? _ : a : i ? a : _;
    case "left":
    case "right":
        return i ? $ : _e;
    default:
        return []
    }
}
function getOppositeAxisPlacements(o, i, s, a) {
    const _ = getAlignment(o);
    let $ = getSideList(getSide(o), s === "start", a);
    return _ && ($ = $.map(_e => _e + "-" + _),
    i && ($ = $.concat($.map(getOppositeAlignmentPlacement)))),
    $
}
function getOppositePlacement(o) {
    return o.replace(/left|right|bottom|top/g, i => oppositeSideMap[i])
}
function expandPaddingObject(o) {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...o
    }
}
function getPaddingObject(o) {
    return typeof o != "number" ? expandPaddingObject(o) : {
        top: o,
        right: o,
        bottom: o,
        left: o
    }
}
function rectToClientRect(o) {
    return {
        ...o,
        top: o.y,
        left: o.x,
        right: o.x + o.width,
        bottom: o.y + o.height
    }
}
function computeCoordsFromPlacement(o, i, s) {
    let {reference: a, floating: _} = o;
    const $ = getSideAxis(i)
      , _e = getAlignmentAxis(i)
      , tt = getAxisLength(_e)
      , nt = getSide(i)
      , rt = $ === "y"
      , ot = a.x + a.width / 2 - _.width / 2
      , et = a.y + a.height / 2 - _.height / 2
      , j = a[tt] / 2 - _[tt] / 2;
    let it;
    switch (nt) {
    case "top":
        it = {
            x: ot,
            y: a.y - _.height
        };
        break;
    case "bottom":
        it = {
            x: ot,
            y: a.y + a.height
        };
        break;
    case "right":
        it = {
            x: a.x + a.width,
            y: et
        };
        break;
    case "left":
        it = {
            x: a.x - _.width,
            y: et
        };
        break;
    default:
        it = {
            x: a.x,
            y: a.y
        }
    }
    switch (getAlignment(i)) {
    case "start":
        it[_e] -= j * (s && rt ? -1 : 1);
        break;
    case "end":
        it[_e] += j * (s && rt ? -1 : 1);
        break
    }
    return it
}
const computePosition$1 = async (o, i, s) => {
    const {placement: a="bottom", strategy: _="absolute", middleware: $=[], platform: _e} = s
      , tt = $.filter(Boolean)
      , nt = await (_e.isRTL == null ? void 0 : _e.isRTL(i));
    let rt = await _e.getElementRects({
        reference: o,
        floating: i,
        strategy: _
    })
      , {x: ot, y: et} = computeCoordsFromPlacement(rt, a, nt)
      , j = a
      , it = {}
      , st = 0;
    for (let at = 0; at < tt.length; at++) {
        const {name: lt, fn: ct} = tt[at]
          , {x: ut, y: dt, data: ft, reset: ht} = await ct({
            x: ot,
            y: et,
            initialPlacement: a,
            placement: j,
            strategy: _,
            middlewareData: it,
            rects: rt,
            platform: _e,
            elements: {
                reference: o,
                floating: i
            }
        });
        if (ot = ut ?? ot,
        et = dt ?? et,
        it = {
            ...it,
            [lt]: {
                ...it[lt],
                ...ft
            }
        },
        ht && st <= 50) {
            st++,
            typeof ht == "object" && (ht.placement && (j = ht.placement),
            ht.rects && (rt = ht.rects === !0 ? await _e.getElementRects({
                reference: o,
                floating: i,
                strategy: _
            }) : ht.rects),
            {x: ot, y: et} = computeCoordsFromPlacement(rt, j, nt)),
            at = -1;
            continue
        }
    }
    return {
        x: ot,
        y: et,
        placement: j,
        strategy: _,
        middlewareData: it
    }
}
;
async function detectOverflow(o, i) {
    var s;
    i === void 0 && (i = {});
    const {x: a, y: _, platform: $, rects: _e, elements: tt, strategy: nt} = o
      , {boundary: rt="clippingAncestors", rootBoundary: ot="viewport", elementContext: et="floating", altBoundary: j=!1, padding: it=0} = evaluate(i, o)
      , st = getPaddingObject(it)
      , lt = tt[j ? et === "floating" ? "reference" : "floating" : et]
      , ct = rectToClientRect(await $.getClippingRect({
        element: (s = await ($.isElement == null ? void 0 : $.isElement(lt))) == null || s ? lt : lt.contextElement || await ($.getDocumentElement == null ? void 0 : $.getDocumentElement(tt.floating)),
        boundary: rt,
        rootBoundary: ot,
        strategy: nt
    }))
      , ut = et === "floating" ? {
        ..._e.floating,
        x: a,
        y: _
    } : _e.reference
      , dt = await ($.getOffsetParent == null ? void 0 : $.getOffsetParent(tt.floating))
      , ft = await ($.isElement == null ? void 0 : $.isElement(dt)) ? await ($.getScale == null ? void 0 : $.getScale(dt)) || {
        x: 1,
        y: 1
    } : {
        x: 1,
        y: 1
    }
      , ht = rectToClientRect($.convertOffsetParentRelativeRectToViewportRelativeRect ? await $.convertOffsetParentRelativeRectToViewportRelativeRect({
        rect: ut,
        offsetParent: dt,
        strategy: nt
    }) : ut);
    return {
        top: (ct.top - ht.top + st.top) / ft.y,
        bottom: (ht.bottom - ct.bottom + st.bottom) / ft.y,
        left: (ct.left - ht.left + st.left) / ft.x,
        right: (ht.right - ct.right + st.right) / ft.x
    }
}
const arrow$1 = o => ({
    name: "arrow",
    options: o,
    async fn(i) {
        const {x: s, y: a, placement: _, rects: $, platform: _e, elements: tt} = i
          , {element: nt, padding: rt=0} = evaluate(o, i) || {};
        if (nt == null)
            return {};
        const ot = getPaddingObject(rt)
          , et = {
            x: s,
            y: a
        }
          , j = getAlignmentAxis(_)
          , it = getAxisLength(j)
          , st = await _e.getDimensions(nt)
          , at = j === "y"
          , lt = at ? "top" : "left"
          , ct = at ? "bottom" : "right"
          , ut = at ? "clientHeight" : "clientWidth"
          , dt = $.reference[it] + $.reference[j] - et[j] - $.floating[it]
          , ft = et[j] - $.reference[j]
          , ht = await (_e.getOffsetParent == null ? void 0 : _e.getOffsetParent(nt));
        let pt = ht ? ht[ut] : 0;
        (!pt || !await (_e.isElement == null ? void 0 : _e.isElement(ht))) && (pt = tt.floating[ut] || $.floating[it]);
        const gt = dt / 2 - ft / 2
          , _t = pt / 2 - st[it] / 2 - 1
          , mt = min(ot[lt], _t)
          , yt = min(ot[ct], _t)
          , bt = mt
          , vt = pt - st[it] - yt
          , wt = pt / 2 - st[it] / 2 + gt
          , Tt = clamp$1(bt, wt, vt)
          , Et = getAlignment(_) != null && wt != Tt && $.reference[it] / 2 - (wt < bt ? mt : yt) - st[it] / 2 < 0 ? wt < bt ? bt - wt : vt - wt : 0;
        return {
            [j]: et[j] - Et,
            data: {
                [j]: Tt,
                centerOffset: wt - Tt + Et
            }
        }
    }
})
  , flip = function(o) {
    return o === void 0 && (o = {}),
    {
        name: "flip",
        options: o,
        async fn(i) {
            var s;
            const {placement: a, middlewareData: _, rects: $, initialPlacement: _e, platform: tt, elements: nt} = i
              , {mainAxis: rt=!0, crossAxis: ot=!0, fallbackPlacements: et, fallbackStrategy: j="bestFit", fallbackAxisSideDirection: it="none", flipAlignment: st=!0, ...at} = evaluate(o, i)
              , lt = getSide(a)
              , ct = getSide(_e) === _e
              , ut = await (tt.isRTL == null ? void 0 : tt.isRTL(nt.floating))
              , dt = et || (ct || !st ? [getOppositePlacement(_e)] : getExpandedPlacements(_e));
            !et && it !== "none" && dt.push(...getOppositeAxisPlacements(_e, st, it, ut));
            const ft = [_e, ...dt]
              , ht = await detectOverflow(i, at)
              , pt = [];
            let gt = ((s = _.flip) == null ? void 0 : s.overflows) || [];
            if (rt && pt.push(ht[lt]),
            ot) {
                const bt = getAlignmentSides(a, $, ut);
                pt.push(ht[bt[0]], ht[bt[1]])
            }
            if (gt = [...gt, {
                placement: a,
                overflows: pt
            }],
            !pt.every(bt => bt <= 0)) {
                var _t, mt;
                const bt = (((_t = _.flip) == null ? void 0 : _t.index) || 0) + 1
                  , vt = ft[bt];
                if (vt)
                    return {
                        data: {
                            index: bt,
                            overflows: gt
                        },
                        reset: {
                            placement: vt
                        }
                    };
                let wt = (mt = gt.filter(Tt => Tt.overflows[0] <= 0).sort( (Tt, $t) => Tt.overflows[1] - $t.overflows[1])[0]) == null ? void 0 : mt.placement;
                if (!wt)
                    switch (j) {
                    case "bestFit":
                        {
                            var yt;
                            const Tt = (yt = gt.map($t => [$t.placement, $t.overflows.filter(Et => Et > 0).reduce( (Et, Pt) => Et + Pt, 0)]).sort( ($t, Et) => $t[1] - Et[1])[0]) == null ? void 0 : yt[0];
                            Tt && (wt = Tt);
                            break
                        }
                    case "initialPlacement":
                        wt = _e;
                        break
                    }
                if (a !== wt)
                    return {
                        reset: {
                            placement: wt
                        }
                    }
            }
            return {}
        }
    }
};
function getBoundingRect(o) {
    const i = min(...o.map($ => $.left))
      , s = min(...o.map($ => $.top))
      , a = max(...o.map($ => $.right))
      , _ = max(...o.map($ => $.bottom));
    return {
        x: i,
        y: s,
        width: a - i,
        height: _ - s
    }
}
function getRectsByLine(o) {
    const i = o.slice().sort( (_, $) => _.y - $.y)
      , s = [];
    let a = null;
    for (let _ = 0; _ < i.length; _++) {
        const $ = i[_];
        !a || $.y - a.y > a.height / 2 ? s.push([$]) : s[s.length - 1].push($),
        a = $
    }
    return s.map(_ => rectToClientRect(getBoundingRect(_)))
}
const inline = function(o) {
    return o === void 0 && (o = {}),
    {
        name: "inline",
        options: o,
        async fn(i) {
            const {placement: s, elements: a, rects: _, platform: $, strategy: _e} = i
              , {padding: tt=2, x: nt, y: rt} = evaluate(o, i)
              , ot = Array.from(await ($.getClientRects == null ? void 0 : $.getClientRects(a.reference)) || [])
              , et = getRectsByLine(ot)
              , j = rectToClientRect(getBoundingRect(ot))
              , it = getPaddingObject(tt);
            function st() {
                if (et.length === 2 && et[0].left > et[1].right && nt != null && rt != null)
                    return et.find(lt => nt > lt.left - it.left && nt < lt.right + it.right && rt > lt.top - it.top && rt < lt.bottom + it.bottom) || j;
                if (et.length >= 2) {
                    if (getSideAxis(s) === "y") {
                        const yt = et[0]
                          , bt = et[et.length - 1]
                          , vt = getSide(s) === "top"
                          , wt = yt.top
                          , Tt = bt.bottom
                          , $t = vt ? yt.left : bt.left
                          , Et = vt ? yt.right : bt.right
                          , Pt = Et - $t
                          , Rt = Tt - wt;
                        return {
                            top: wt,
                            bottom: Tt,
                            left: $t,
                            right: Et,
                            width: Pt,
                            height: Rt,
                            x: $t,
                            y: wt
                        }
                    }
                    const lt = getSide(s) === "left"
                      , ct = max(...et.map(yt => yt.right))
                      , ut = min(...et.map(yt => yt.left))
                      , dt = et.filter(yt => lt ? yt.left === ut : yt.right === ct)
                      , ft = dt[0].top
                      , ht = dt[dt.length - 1].bottom
                      , pt = ut
                      , gt = ct
                      , _t = gt - pt
                      , mt = ht - ft;
                    return {
                        top: ft,
                        bottom: ht,
                        left: pt,
                        right: gt,
                        width: _t,
                        height: mt,
                        x: pt,
                        y: ft
                    }
                }
                return j
            }
            const at = await $.getElementRects({
                reference: {
                    getBoundingClientRect: st
                },
                floating: a.floating,
                strategy: _e
            });
            return _.reference.x !== at.reference.x || _.reference.y !== at.reference.y || _.reference.width !== at.reference.width || _.reference.height !== at.reference.height ? {
                reset: {
                    rects: at
                }
            } : {}
        }
    }
};
async function convertValueToCoords(o, i) {
    const {placement: s, platform: a, elements: _} = o
      , $ = await (a.isRTL == null ? void 0 : a.isRTL(_.floating))
      , _e = getSide(s)
      , tt = getAlignment(s)
      , nt = getSideAxis(s) === "y"
      , rt = ["left", "top"].includes(_e) ? -1 : 1
      , ot = $ && nt ? -1 : 1
      , et = evaluate(i, o);
    let {mainAxis: j, crossAxis: it, alignmentAxis: st} = typeof et == "number" ? {
        mainAxis: et,
        crossAxis: 0,
        alignmentAxis: null
    } : {
        mainAxis: 0,
        crossAxis: 0,
        alignmentAxis: null,
        ...et
    };
    return tt && typeof st == "number" && (it = tt === "end" ? st * -1 : st),
    nt ? {
        x: it * ot,
        y: j * rt
    } : {
        x: j * rt,
        y: it * ot
    }
}
const offset = function(o) {
    return o === void 0 && (o = 0),
    {
        name: "offset",
        options: o,
        async fn(i) {
            const {x: s, y: a} = i
              , _ = await convertValueToCoords(i, o);
            return {
                x: s + _.x,
                y: a + _.y,
                data: _
            }
        }
    }
}
  , shift = function(o) {
    return o === void 0 && (o = {}),
    {
        name: "shift",
        options: o,
        async fn(i) {
            const {x: s, y: a, placement: _} = i
              , {mainAxis: $=!0, crossAxis: _e=!1, limiter: tt={
                fn: lt => {
                    let {x: ct, y: ut} = lt;
                    return {
                        x: ct,
                        y: ut
                    }
                }
            }, ...nt} = evaluate(o, i)
              , rt = {
                x: s,
                y: a
            }
              , ot = await detectOverflow(i, nt)
              , et = getSideAxis(getSide(_))
              , j = getOppositeAxis(et);
            let it = rt[j]
              , st = rt[et];
            if ($) {
                const lt = j === "y" ? "top" : "left"
                  , ct = j === "y" ? "bottom" : "right"
                  , ut = it + ot[lt]
                  , dt = it - ot[ct];
                it = clamp$1(ut, it, dt)
            }
            if (_e) {
                const lt = et === "y" ? "top" : "left"
                  , ct = et === "y" ? "bottom" : "right"
                  , ut = st + ot[lt]
                  , dt = st - ot[ct];
                st = clamp$1(ut, st, dt)
            }
            const at = tt.fn({
                ...i,
                [j]: it,
                [et]: st
            });
            return {
                ...at,
                data: {
                    x: at.x - s,
                    y: at.y - a
                }
            }
        }
    }
}
  , limitShift = function(o) {
    return o === void 0 && (o = {}),
    {
        options: o,
        fn(i) {
            const {x: s, y: a, placement: _, rects: $, middlewareData: _e} = i
              , {offset: tt=0, mainAxis: nt=!0, crossAxis: rt=!0} = evaluate(o, i)
              , ot = {
                x: s,
                y: a
            }
              , et = getSideAxis(_)
              , j = getOppositeAxis(et);
            let it = ot[j]
              , st = ot[et];
            const at = evaluate(tt, i)
              , lt = typeof at == "number" ? {
                mainAxis: at,
                crossAxis: 0
            } : {
                mainAxis: 0,
                crossAxis: 0,
                ...at
            };
            if (nt) {
                const dt = j === "y" ? "height" : "width"
                  , ft = $.reference[j] - $.floating[dt] + lt.mainAxis
                  , ht = $.reference[j] + $.reference[dt] - lt.mainAxis;
                it < ft ? it = ft : it > ht && (it = ht)
            }
            if (rt) {
                var ct, ut;
                const dt = j === "y" ? "width" : "height"
                  , ft = ["top", "left"].includes(getSide(_))
                  , ht = $.reference[et] - $.floating[dt] + (ft && ((ct = _e.offset) == null ? void 0 : ct[et]) || 0) + (ft ? 0 : lt.crossAxis)
                  , pt = $.reference[et] + $.reference[dt] + (ft ? 0 : ((ut = _e.offset) == null ? void 0 : ut[et]) || 0) - (ft ? lt.crossAxis : 0);
                st < ht ? st = ht : st > pt && (st = pt)
            }
            return {
                [j]: it,
                [et]: st
            }
        }
    }
}
  , size = function(o) {
    return o === void 0 && (o = {}),
    {
        name: "size",
        options: o,
        async fn(i) {
            const {placement: s, rects: a, platform: _, elements: $} = i
              , {apply: _e= () => {}
            , ...tt} = evaluate(o, i)
              , nt = await detectOverflow(i, tt)
              , rt = getSide(s)
              , ot = getAlignment(s)
              , et = getSideAxis(s) === "y"
              , {width: j, height: it} = a.floating;
            let st, at;
            rt === "top" || rt === "bottom" ? (st = rt,
            at = ot === (await (_.isRTL == null ? void 0 : _.isRTL($.floating)) ? "start" : "end") ? "left" : "right") : (at = rt,
            st = ot === "end" ? "top" : "bottom");
            const lt = it - nt[st]
              , ct = j - nt[at]
              , ut = !i.middlewareData.shift;
            let dt = lt
              , ft = ct;
            if (et) {
                const pt = j - nt.left - nt.right;
                ft = ot || ut ? min(ct, pt) : pt
            } else {
                const pt = it - nt.top - nt.bottom;
                dt = ot || ut ? min(lt, pt) : pt
            }
            if (ut && !ot) {
                const pt = max(nt.left, 0)
                  , gt = max(nt.right, 0)
                  , _t = max(nt.top, 0)
                  , mt = max(nt.bottom, 0);
                et ? ft = j - 2 * (pt !== 0 || gt !== 0 ? pt + gt : max(nt.left, nt.right)) : dt = it - 2 * (_t !== 0 || mt !== 0 ? _t + mt : max(nt.top, nt.bottom))
            }
            await _e({
                ...i,
                availableWidth: ft,
                availableHeight: dt
            });
            const ht = await _.getDimensions($.floating);
            return j !== ht.width || it !== ht.height ? {
                reset: {
                    rects: !0
                }
            } : {}
        }
    }
};
function getNodeName(o) {
    return isNode(o) ? (o.nodeName || "").toLowerCase() : "#document"
}
function getWindow$1(o) {
    var i;
    return (o == null || (i = o.ownerDocument) == null ? void 0 : i.defaultView) || window
}
function getDocumentElement(o) {
    var i;
    return (i = (isNode(o) ? o.ownerDocument : o.document) || window.document) == null ? void 0 : i.documentElement
}
function isNode(o) {
    return o instanceof Node || o instanceof getWindow$1(o).Node
}
function isElement$1(o) {
    return o instanceof Element || o instanceof getWindow$1(o).Element
}
function isHTMLElement(o) {
    return o instanceof HTMLElement || o instanceof getWindow$1(o).HTMLElement
}
function isShadowRoot(o) {
    return typeof ShadowRoot > "u" ? !1 : o instanceof ShadowRoot || o instanceof getWindow$1(o).ShadowRoot
}
function isOverflowElement(o) {
    const {overflow: i, overflowX: s, overflowY: a, display: _} = getComputedStyle$1(o);
    return /auto|scroll|overlay|hidden|clip/.test(i + a + s) && !["inline", "contents"].includes(_)
}
function isTableElement(o) {
    return ["table", "td", "th"].includes(getNodeName(o))
}
function isContainingBlock(o) {
    const i = isWebKit()
      , s = getComputedStyle$1(o);
    return s.transform !== "none" || s.perspective !== "none" || (s.containerType ? s.containerType !== "normal" : !1) || !i && (s.backdropFilter ? s.backdropFilter !== "none" : !1) || !i && (s.filter ? s.filter !== "none" : !1) || ["transform", "perspective", "filter"].some(a => (s.willChange || "").includes(a)) || ["paint", "layout", "strict", "content"].some(a => (s.contain || "").includes(a))
}
function getContainingBlock(o) {
    let i = getParentNode(o);
    for (; isHTMLElement(i) && !isLastTraversableNode(i); ) {
        if (isContainingBlock(i))
            return i;
        i = getParentNode(i)
    }
    return null
}
function isWebKit() {
    return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none")
}
function isLastTraversableNode(o) {
    return ["html", "body", "#document"].includes(getNodeName(o))
}
function getComputedStyle$1(o) {
    return getWindow$1(o).getComputedStyle(o)
}
function getNodeScroll(o) {
    return isElement$1(o) ? {
        scrollLeft: o.scrollLeft,
        scrollTop: o.scrollTop
    } : {
        scrollLeft: o.pageXOffset,
        scrollTop: o.pageYOffset
    }
}
function getParentNode(o) {
    if (getNodeName(o) === "html")
        return o;
    const i = o.assignedSlot || o.parentNode || isShadowRoot(o) && o.host || getDocumentElement(o);
    return isShadowRoot(i) ? i.host : i
}
function getNearestOverflowAncestor(o) {
    const i = getParentNode(o);
    return isLastTraversableNode(i) ? o.ownerDocument ? o.ownerDocument.body : o.body : isHTMLElement(i) && isOverflowElement(i) ? i : getNearestOverflowAncestor(i)
}
function getOverflowAncestors(o, i) {
    var s;
    i === void 0 && (i = []);
    const a = getNearestOverflowAncestor(o)
      , _ = a === ((s = o.ownerDocument) == null ? void 0 : s.body)
      , $ = getWindow$1(a);
    return _ ? i.concat($, $.visualViewport || [], isOverflowElement(a) ? a : []) : i.concat(a, getOverflowAncestors(a))
}
function getCssDimensions(o) {
    const i = getComputedStyle$1(o);
    let s = parseFloat(i.width) || 0
      , a = parseFloat(i.height) || 0;
    const _ = isHTMLElement(o)
      , $ = _ ? o.offsetWidth : s
      , _e = _ ? o.offsetHeight : a
      , tt = round$1(s) !== $ || round$1(a) !== _e;
    return tt && (s = $,
    a = _e),
    {
        width: s,
        height: a,
        $: tt
    }
}
function unwrapElement(o) {
    return isElement$1(o) ? o : o.contextElement
}
function getScale(o) {
    const i = unwrapElement(o);
    if (!isHTMLElement(i))
        return createCoords(1);
    const s = i.getBoundingClientRect()
      , {width: a, height: _, $} = getCssDimensions(i);
    let _e = ($ ? round$1(s.width) : s.width) / a
      , tt = ($ ? round$1(s.height) : s.height) / _;
    return (!_e || !Number.isFinite(_e)) && (_e = 1),
    (!tt || !Number.isFinite(tt)) && (tt = 1),
    {
        x: _e,
        y: tt
    }
}
const noOffsets = createCoords(0);
function getVisualOffsets(o) {
    const i = getWindow$1(o);
    return !isWebKit() || !i.visualViewport ? noOffsets : {
        x: i.visualViewport.offsetLeft,
        y: i.visualViewport.offsetTop
    }
}
function shouldAddVisualOffsets(o, i, s) {
    return i === void 0 && (i = !1),
    !s || i && s !== getWindow$1(o) ? !1 : i
}
function getBoundingClientRect(o, i, s, a) {
    i === void 0 && (i = !1),
    s === void 0 && (s = !1);
    const _ = o.getBoundingClientRect()
      , $ = unwrapElement(o);
    let _e = createCoords(1);
    i && (a ? isElement$1(a) && (_e = getScale(a)) : _e = getScale(o));
    const tt = shouldAddVisualOffsets($, s, a) ? getVisualOffsets($) : createCoords(0);
    let nt = (_.left + tt.x) / _e.x
      , rt = (_.top + tt.y) / _e.y
      , ot = _.width / _e.x
      , et = _.height / _e.y;
    if ($) {
        const j = getWindow$1($)
          , it = a && isElement$1(a) ? getWindow$1(a) : a;
        let st = j.frameElement;
        for (; st && a && it !== j; ) {
            const at = getScale(st)
              , lt = st.getBoundingClientRect()
              , ct = getComputedStyle$1(st)
              , ut = lt.left + (st.clientLeft + parseFloat(ct.paddingLeft)) * at.x
              , dt = lt.top + (st.clientTop + parseFloat(ct.paddingTop)) * at.y;
            nt *= at.x,
            rt *= at.y,
            ot *= at.x,
            et *= at.y,
            nt += ut,
            rt += dt,
            st = getWindow$1(st).frameElement
        }
    }
    return rectToClientRect({
        width: ot,
        height: et,
        x: nt,
        y: rt
    })
}
function convertOffsetParentRelativeRectToViewportRelativeRect(o) {
    let {rect: i, offsetParent: s, strategy: a} = o;
    const _ = isHTMLElement(s)
      , $ = getDocumentElement(s);
    if (s === $)
        return i;
    let _e = {
        scrollLeft: 0,
        scrollTop: 0
    }
      , tt = createCoords(1);
    const nt = createCoords(0);
    if ((_ || !_ && a !== "fixed") && ((getNodeName(s) !== "body" || isOverflowElement($)) && (_e = getNodeScroll(s)),
    isHTMLElement(s))) {
        const rt = getBoundingClientRect(s);
        tt = getScale(s),
        nt.x = rt.x + s.clientLeft,
        nt.y = rt.y + s.clientTop
    }
    return {
        width: i.width * tt.x,
        height: i.height * tt.y,
        x: i.x * tt.x - _e.scrollLeft * tt.x + nt.x,
        y: i.y * tt.y - _e.scrollTop * tt.y + nt.y
    }
}
function getClientRects(o) {
    return Array.from(o.getClientRects())
}
function getWindowScrollBarX(o) {
    return getBoundingClientRect(getDocumentElement(o)).left + getNodeScroll(o).scrollLeft
}
function getDocumentRect(o) {
    const i = getDocumentElement(o)
      , s = getNodeScroll(o)
      , a = o.ownerDocument.body
      , _ = max(i.scrollWidth, i.clientWidth, a.scrollWidth, a.clientWidth)
      , $ = max(i.scrollHeight, i.clientHeight, a.scrollHeight, a.clientHeight);
    let _e = -s.scrollLeft + getWindowScrollBarX(o);
    const tt = -s.scrollTop;
    return getComputedStyle$1(a).direction === "rtl" && (_e += max(i.clientWidth, a.clientWidth) - _),
    {
        width: _,
        height: $,
        x: _e,
        y: tt
    }
}
function getViewportRect(o, i) {
    const s = getWindow$1(o)
      , a = getDocumentElement(o)
      , _ = s.visualViewport;
    let $ = a.clientWidth
      , _e = a.clientHeight
      , tt = 0
      , nt = 0;
    if (_) {
        $ = _.width,
        _e = _.height;
        const rt = isWebKit();
        (!rt || rt && i === "fixed") && (tt = _.offsetLeft,
        nt = _.offsetTop)
    }
    return {
        width: $,
        height: _e,
        x: tt,
        y: nt
    }
}
function getInnerBoundingClientRect(o, i) {
    const s = getBoundingClientRect(o, !0, i === "fixed")
      , a = s.top + o.clientTop
      , _ = s.left + o.clientLeft
      , $ = isHTMLElement(o) ? getScale(o) : createCoords(1)
      , _e = o.clientWidth * $.x
      , tt = o.clientHeight * $.y
      , nt = _ * $.x
      , rt = a * $.y;
    return {
        width: _e,
        height: tt,
        x: nt,
        y: rt
    }
}
function getClientRectFromClippingAncestor(o, i, s) {
    let a;
    if (i === "viewport")
        a = getViewportRect(o, s);
    else if (i === "document")
        a = getDocumentRect(getDocumentElement(o));
    else if (isElement$1(i))
        a = getInnerBoundingClientRect(i, s);
    else {
        const _ = getVisualOffsets(o);
        a = {
            ...i,
            x: i.x - _.x,
            y: i.y - _.y
        }
    }
    return rectToClientRect(a)
}
function hasFixedPositionAncestor(o, i) {
    const s = getParentNode(o);
    return s === i || !isElement$1(s) || isLastTraversableNode(s) ? !1 : getComputedStyle$1(s).position === "fixed" || hasFixedPositionAncestor(s, i)
}
function getClippingElementAncestors(o, i) {
    const s = i.get(o);
    if (s)
        return s;
    let a = getOverflowAncestors(o).filter(tt => isElement$1(tt) && getNodeName(tt) !== "body")
      , _ = null;
    const $ = getComputedStyle$1(o).position === "fixed";
    let _e = $ ? getParentNode(o) : o;
    for (; isElement$1(_e) && !isLastTraversableNode(_e); ) {
        const tt = getComputedStyle$1(_e)
          , nt = isContainingBlock(_e);
        !nt && tt.position === "fixed" && (_ = null),
        ($ ? !nt && !_ : !nt && tt.position === "static" && !!_ && ["absolute", "fixed"].includes(_.position) || isOverflowElement(_e) && !nt && hasFixedPositionAncestor(o, _e)) ? a = a.filter(ot => ot !== _e) : _ = tt,
        _e = getParentNode(_e)
    }
    return i.set(o, a),
    a
}
function getClippingRect(o) {
    let {element: i, boundary: s, rootBoundary: a, strategy: _} = o;
    const _e = [...s === "clippingAncestors" ? getClippingElementAncestors(i, this._c) : [].concat(s), a]
      , tt = _e[0]
      , nt = _e.reduce( (rt, ot) => {
        const et = getClientRectFromClippingAncestor(i, ot, _);
        return rt.top = max(et.top, rt.top),
        rt.right = min(et.right, rt.right),
        rt.bottom = min(et.bottom, rt.bottom),
        rt.left = max(et.left, rt.left),
        rt
    }
    , getClientRectFromClippingAncestor(i, tt, _));
    return {
        width: nt.right - nt.left,
        height: nt.bottom - nt.top,
        x: nt.left,
        y: nt.top
    }
}
function getDimensions(o) {
    return getCssDimensions(o)
}
function getRectRelativeToOffsetParent(o, i, s) {
    const a = isHTMLElement(i)
      , _ = getDocumentElement(i)
      , $ = s === "fixed"
      , _e = getBoundingClientRect(o, !0, $, i);
    let tt = {
        scrollLeft: 0,
        scrollTop: 0
    };
    const nt = createCoords(0);
    if (a || !a && !$)
        if ((getNodeName(i) !== "body" || isOverflowElement(_)) && (tt = getNodeScroll(i)),
        a) {
            const rt = getBoundingClientRect(i, !0, $, i);
            nt.x = rt.x + i.clientLeft,
            nt.y = rt.y + i.clientTop
        } else
            _ && (nt.x = getWindowScrollBarX(_));
    return {
        x: _e.left + tt.scrollLeft - nt.x,
        y: _e.top + tt.scrollTop - nt.y,
        width: _e.width,
        height: _e.height
    }
}
function getTrueOffsetParent(o, i) {
    return !isHTMLElement(o) || getComputedStyle$1(o).position === "fixed" ? null : i ? i(o) : o.offsetParent
}
function getOffsetParent(o, i) {
    const s = getWindow$1(o);
    if (!isHTMLElement(o))
        return s;
    let a = getTrueOffsetParent(o, i);
    for (; a && isTableElement(a) && getComputedStyle$1(a).position === "static"; )
        a = getTrueOffsetParent(a, i);
    return a && (getNodeName(a) === "html" || getNodeName(a) === "body" && getComputedStyle$1(a).position === "static" && !isContainingBlock(a)) ? s : a || getContainingBlock(o) || s
}
const getElementRects = async function(o) {
    let {reference: i, floating: s, strategy: a} = o;
    const _ = this.getOffsetParent || getOffsetParent
      , $ = this.getDimensions;
    return {
        reference: getRectRelativeToOffsetParent(i, await _(s), a),
        floating: {
            x: 0,
            y: 0,
            ...await $(s)
        }
    }
};
function isRTL(o) {
    return getComputedStyle$1(o).direction === "rtl"
}
const platform = {
    convertOffsetParentRelativeRectToViewportRelativeRect,
    getDocumentElement,
    getClippingRect,
    getOffsetParent,
    getElementRects,
    getClientRects,
    getDimensions,
    getScale,
    isElement: isElement$1,
    isRTL
};
function observeMove(o, i) {
    let s = null, a;
    const _ = getDocumentElement(o);
    function $() {
        clearTimeout(a),
        s && s.disconnect(),
        s = null
    }
    function _e(tt, nt) {
        tt === void 0 && (tt = !1),
        nt === void 0 && (nt = 1),
        $();
        const {left: rt, top: ot, width: et, height: j} = o.getBoundingClientRect();
        if (tt || i(),
        !et || !j)
            return;
        const it = floor$1(ot)
          , st = floor$1(_.clientWidth - (rt + et))
          , at = floor$1(_.clientHeight - (ot + j))
          , lt = floor$1(rt)
          , ut = {
            rootMargin: -it + "px " + -st + "px " + -at + "px " + -lt + "px",
            threshold: max(0, min(1, nt)) || 1
        };
        let dt = !0;
        function ft(ht) {
            const pt = ht[0].intersectionRatio;
            if (pt !== nt) {
                if (!dt)
                    return _e();
                pt ? _e(!1, pt) : a = setTimeout( () => {
                    _e(!1, 1e-7)
                }
                , 100)
            }
            dt = !1
        }
        try {
            s = new IntersectionObserver(ft,{
                ...ut,
                root: _.ownerDocument
            })
        } catch {
            s = new IntersectionObserver(ft,ut)
        }
        s.observe(o)
    }
    return _e(!0),
    $
}
function autoUpdate(o, i, s, a) {
    a === void 0 && (a = {});
    const {ancestorScroll: _=!0, ancestorResize: $=!0, elementResize: _e=typeof ResizeObserver == "function", layoutShift: tt=typeof IntersectionObserver == "function", animationFrame: nt=!1} = a
      , rt = unwrapElement(o)
      , ot = _ || $ ? [...rt ? getOverflowAncestors(rt) : [], ...getOverflowAncestors(i)] : [];
    ot.forEach(ct => {
        _ && ct.addEventListener("scroll", s, {
            passive: !0
        }),
        $ && ct.addEventListener("resize", s)
    }
    );
    const et = rt && tt ? observeMove(rt, s) : null;
    let j = -1
      , it = null;
    _e && (it = new ResizeObserver(ct => {
        let[ut] = ct;
        ut && ut.target === rt && it && (it.unobserve(i),
        cancelAnimationFrame(j),
        j = requestAnimationFrame( () => {
            it && it.observe(i)
        }
        )),
        s()
    }
    ),
    rt && !nt && it.observe(rt),
    it.observe(i));
    let st, at = nt ? getBoundingClientRect(o) : null;
    nt && lt();
    function lt() {
        const ct = getBoundingClientRect(o);
        at && (ct.x !== at.x || ct.y !== at.y || ct.width !== at.width || ct.height !== at.height) && s(),
        at = ct,
        st = requestAnimationFrame(lt)
    }
    return s(),
    () => {
        ot.forEach(ct => {
            _ && ct.removeEventListener("scroll", s),
            $ && ct.removeEventListener("resize", s)
        }
        ),
        et && et(),
        it && it.disconnect(),
        it = null,
        nt && cancelAnimationFrame(st)
    }
}
const computePosition = (o, i, s) => {
    const a = new Map
      , _ = {
        platform,
        ...s
    }
      , $ = {
        ..._.platform,
        _c: a
    };
    return computePosition$1(o, i, {
        ..._,
        platform: $
    })
}
  , arrow = o => {
    const {element: i, padding: s} = o;
    function a(_) {
        return Object.prototype.hasOwnProperty.call(_, "current")
    }
    return {
        name: "arrow",
        options: o,
        fn(_) {
            return a(i) ? i.current != null ? arrow$1({
                element: i.current,
                padding: s
            }).fn(_) : {} : i ? arrow$1({
                element: i,
                padding: s
            }).fn(_) : {}
        }
    }
}
;
var index$1 = typeof document < "u" ? reactExports.useLayoutEffect : reactExports.useEffect;
function deepEqual$1(o, i) {
    if (o === i)
        return !0;
    if (typeof o != typeof i)
        return !1;
    if (typeof o == "function" && o.toString() === i.toString())
        return !0;
    let s, a, _;
    if (o && i && typeof o == "object") {
        if (Array.isArray(o)) {
            if (s = o.length,
            s != i.length)
                return !1;
            for (a = s; a-- !== 0; )
                if (!deepEqual$1(o[a], i[a]))
                    return !1;
            return !0
        }
        if (_ = Object.keys(o),
        s = _.length,
        s !== Object.keys(i).length)
            return !1;
        for (a = s; a-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(i, _[a]))
                return !1;
        for (a = s; a-- !== 0; ) {
            const $ = _[a];
            if (!($ === "_owner" && o.$$typeof) && !deepEqual$1(o[$], i[$]))
                return !1
        }
        return !0
    }
    return o !== o && i !== i
}
function useLatestRef(o) {
    const i = reactExports.useRef(o);
    return index$1( () => {
        i.current = o
    }
    ),
    i
}
function useFloating$1(o) {
    o === void 0 && (o = {});
    const {placement: i="bottom", strategy: s="absolute", middleware: a=[], platform: _, whileElementsMounted: $, open: _e} = o
      , [tt,nt] = reactExports.useState({
        x: null,
        y: null,
        strategy: s,
        placement: i,
        middlewareData: {},
        isPositioned: !1
    })
      , [rt,ot] = reactExports.useState(a);
    deepEqual$1(rt, a) || ot(a);
    const et = reactExports.useRef(null)
      , j = reactExports.useRef(null)
      , it = reactExports.useRef(tt)
      , st = useLatestRef($)
      , at = useLatestRef(_)
      , [lt,ct] = reactExports.useState(null)
      , [ut,dt] = reactExports.useState(null)
      , ft = reactExports.useCallback(yt => {
        et.current !== yt && (et.current = yt,
        ct(yt))
    }
    , [])
      , ht = reactExports.useCallback(yt => {
        j.current !== yt && (j.current = yt,
        dt(yt))
    }
    , [])
      , pt = reactExports.useCallback( () => {
        if (!et.current || !j.current)
            return;
        const yt = {
            placement: i,
            strategy: s,
            middleware: rt
        };
        at.current && (yt.platform = at.current),
        computePosition(et.current, j.current, yt).then(bt => {
            const vt = {
                ...bt,
                isPositioned: !0
            };
            gt.current && !deepEqual$1(it.current, vt) && (it.current = vt,
            reactDomExports.flushSync( () => {
                nt(vt)
            }
            ))
        }
        )
    }
    , [rt, i, s, at]);
    index$1( () => {
        _e === !1 && it.current.isPositioned && (it.current.isPositioned = !1,
        nt(yt => ({
            ...yt,
            isPositioned: !1
        })))
    }
    , [_e]);
    const gt = reactExports.useRef(!1);
    index$1( () => (gt.current = !0,
    () => {
        gt.current = !1
    }
    ), []),
    index$1( () => {
        if (lt && ut) {
            if (st.current)
                return st.current(lt, ut, pt);
            pt()
        }
    }
    , [lt, ut, pt, st]);
    const _t = reactExports.useMemo( () => ({
        reference: et,
        floating: j,
        setReference: ft,
        setFloating: ht
    }), [ft, ht])
      , mt = reactExports.useMemo( () => ({
        reference: lt,
        floating: ut
    }), [lt, ut]);
    return reactExports.useMemo( () => ({
        ...tt,
        update: pt,
        refs: _t,
        elements: mt,
        reference: ft,
        floating: ht
    }), [tt, pt, _t, mt, ft, ht])
}
var index = typeof document < "u" ? reactExports.useLayoutEffect : reactExports.useEffect;
function createPubSub() {
    const o = new Map;
    return {
        emit(i, s) {
            var a;
            (a = o.get(i)) == null || a.forEach(_ => _(s))
        },
        on(i, s) {
            o.set(i, [...o.get(i) || [], s])
        },
        off(i, s) {
            o.set(i, (o.get(i) || []).filter(a => a !== s))
        }
    }
}
const FloatingTreeContext = reactExports.createContext(null)
  , useFloatingTree = () => reactExports.useContext(FloatingTreeContext);
function getDocument(o) {
    return (o == null ? void 0 : o.ownerDocument) || document
}
function getWindow(o) {
    return getDocument(o).defaultView || window
}
function isElement(o) {
    return o ? o instanceof getWindow(o).Element : !1
}
const useInsertionEffect = React$1["useInsertionEffect".toString()]
  , useSafeInsertionEffect = useInsertionEffect || (o => o());
function useEvent(o) {
    const i = reactExports.useRef( () => {}
    );
    return useSafeInsertionEffect( () => {
        i.current = o
    }
    ),
    reactExports.useCallback(function() {
        for (var s = arguments.length, a = new Array(s), _ = 0; _ < s; _++)
            a[_] = arguments[_];
        return i.current == null ? void 0 : i.current(...a)
    }, [])
}
function useFloating(o) {
    o === void 0 && (o = {});
    const {open: i=!1, onOpenChange: s, nodeId: a} = o
      , _ = useFloating$1(o)
      , $ = useFloatingTree()
      , _e = reactExports.useRef(null)
      , tt = reactExports.useRef({})
      , nt = reactExports.useState( () => createPubSub())[0]
      , [rt,ot] = reactExports.useState(null)
      , et = reactExports.useCallback(ct => {
        const ut = isElement(ct) ? {
            getBoundingClientRect: () => ct.getBoundingClientRect(),
            contextElement: ct
        } : ct;
        _.refs.setReference(ut)
    }
    , [_.refs])
      , j = reactExports.useCallback(ct => {
        (isElement(ct) || ct === null) && (_e.current = ct,
        ot(ct)),
        (isElement(_.refs.reference.current) || _.refs.reference.current === null || ct !== null && !isElement(ct)) && _.refs.setReference(ct)
    }
    , [_.refs])
      , it = reactExports.useMemo( () => ({
        ..._.refs,
        setReference: j,
        setPositionReference: et,
        domReference: _e
    }), [_.refs, j, et])
      , st = reactExports.useMemo( () => ({
        ..._.elements,
        domReference: rt
    }), [_.elements, rt])
      , at = useEvent(s)
      , lt = reactExports.useMemo( () => ({
        ..._,
        refs: it,
        elements: st,
        dataRef: tt,
        nodeId: a,
        events: nt,
        open: i,
        onOpenChange: at
    }), [_, a, nt, i, at, it, st]);
    return index( () => {
        const ct = $ == null ? void 0 : $.nodesRef.current.find(ut => ut.id === a);
        ct && (ct.context = lt)
    }
    ),
    reactExports.useMemo( () => ({
        ..._,
        context: lt,
        refs: it,
        reference: j,
        positionReference: et
    }), [_, it, lt, j, et])
}
function useFloatingAutoUpdate({opened: o, floating: i, position: s, positionDependencies: a}) {
    const [_,$] = reactExports.useState(0);
    reactExports.useEffect( () => {
        if (i.refs.reference.current && i.refs.floating.current)
            return autoUpdate(i.refs.reference.current, i.refs.floating.current, i.update)
    }
    , [i.refs.reference.current, i.refs.floating.current, o, _, s]),
    useDidUpdate( () => {
        i.update()
    }
    , a),
    useDidUpdate( () => {
        $(_e => _e + 1)
    }
    , [o])
}
function getPopoverMiddlewares(o) {
    const i = [offset(o.offset)];
    return o.middlewares.shift && i.push(shift({
        limiter: limitShift()
    })),
    o.middlewares.flip && i.push(flip()),
    o.middlewares.inline && i.push(inline()),
    i.push(arrow({
        element: o.arrowRef,
        padding: o.arrowOffset
    })),
    i
}
function usePopover(o) {
    const [i,s] = useUncontrolled({
        value: o.opened,
        defaultValue: o.defaultOpened,
        finalValue: !1,
        onChange: o.onChange
    })
      , a = () => {
        var _e;
        (_e = o.onClose) == null || _e.call(o),
        s(!1)
    }
      , _ = () => {
        var _e, tt;
        i ? ((_e = o.onClose) == null || _e.call(o),
        s(!1)) : ((tt = o.onOpen) == null || tt.call(o),
        s(!0))
    }
      , $ = useFloating({
        placement: o.position,
        middleware: [...getPopoverMiddlewares(o), ...o.width === "target" ? [size({
            apply({rects: _e}) {
                var tt, nt;
                Object.assign((nt = (tt = $.refs.floating.current) == null ? void 0 : tt.style) != null ? nt : {}, {
                    width: `${_e.reference.width}px`
                })
            }
        })] : []]
    });
    return useFloatingAutoUpdate({
        opened: o.opened,
        position: o.position,
        positionDependencies: o.positionDependencies,
        floating: $
    }),
    useDidUpdate( () => {
        var _e;
        (_e = o.onPositionChange) == null || _e.call(o, $.placement)
    }
    , [$.placement]),
    useDidUpdate( () => {
        var _e, tt;
        o.opened ? (tt = o.onOpen) == null || tt.call(o) : (_e = o.onClose) == null || _e.call(o)
    }
    , [o.opened]),
    {
        floating: $,
        controlled: typeof o.opened == "boolean",
        opened: i,
        onClose: a,
        onToggle: _
    }
}
const POPOVER_ERRORS = {
    context: "Popover component was not found in the tree",
    children: "Popover.Target component children should be an element or a component that accepts ref. Fragments, strings, numbers and other primitive values are not supported"
}
  , [PopoverContextProvider,usePopoverContext] = createSafeContext(POPOVER_ERRORS.context);
var __defProp$18 = Object.defineProperty
  , __defProps$C = Object.defineProperties
  , __getOwnPropDescs$C = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$19 = Object.getOwnPropertySymbols
  , __hasOwnProp$19 = Object.prototype.hasOwnProperty
  , __propIsEnum$19 = Object.prototype.propertyIsEnumerable
  , __defNormalProp$18 = (o, i, s) => i in o ? __defProp$18(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$18 = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$19.call(i, s) && __defNormalProp$18(o, s, i[s]);
    if (__getOwnPropSymbols$19)
        for (var s of __getOwnPropSymbols$19(i))
            __propIsEnum$19.call(i, s) && __defNormalProp$18(o, s, i[s]);
    return o
}
  , __spreadProps$C = (o, i) => __defProps$C(o, __getOwnPropDescs$C(i))
  , __objRest$P = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$19.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$19)
        for (var a of __getOwnPropSymbols$19(o))
            i.indexOf(a) < 0 && __propIsEnum$19.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$E = {
    refProp: "ref",
    popupType: "dialog",
    shouldOverrideDefaultTargetId: !0
}
  , PopoverTarget = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("PopoverTarget", defaultProps$E, o)
      , {children: a, refProp: _, popupType: $, shouldOverrideDefaultTargetId: _e} = s
      , tt = __objRest$P(s, ["children", "refProp", "popupType", "shouldOverrideDefaultTargetId"]);
    if (!isElement$2(a))
        throw new Error(POPOVER_ERRORS.children);
    const nt = tt
      , rt = usePopoverContext()
      , ot = useMergedRef(rt.reference, a.ref, i)
      , et = rt.withRoles ? {
        "aria-haspopup": $,
        "aria-expanded": rt.opened,
        "aria-controls": rt.getDropdownId(),
        id: _e ? rt.getTargetId() : a.props.id
    } : {};
    return reactExports.cloneElement(a, __spreadValues$18(__spreadProps$C(__spreadValues$18(__spreadValues$18(__spreadValues$18({}, nt), et), rt.targetProps), {
        className: clsx(rt.targetProps.className, nt.className, a.props.className),
        [_]: ot
    }), rt.controlled ? null : {
        onClick: rt.onToggle
    }))
}
);
PopoverTarget.displayName = "@mantine/core/PopoverTarget";
var useStyles$14 = createStyles( (o, {radius: i, shadow: s}) => ({
    dropdown: {
        position: "absolute",
        backgroundColor: o.white,
        background: o.colorScheme === "dark" ? o.colors.dark[6] : o.white,
        border: `${rem(1)} solid ${o.colorScheme === "dark" ? o.colors.dark[4] : o.colors.gray[2]}`,
        padding: `${o.spacing.sm} ${o.spacing.md}`,
        boxShadow: o.shadows[s] || s || "none",
        borderRadius: o.fn.radius(i),
        "&:focus": {
            outline: 0
        }
    },
    arrow: {
        backgroundColor: "inherit",
        border: `${rem(1)} solid ${o.colorScheme === "dark" ? o.colors.dark[4] : o.colors.gray[2]}`,
        zIndex: 1
    }
}));
const useStyles$15 = useStyles$14;
var __defProp$17 = Object.defineProperty
  , __getOwnPropSymbols$18 = Object.getOwnPropertySymbols
  , __hasOwnProp$18 = Object.prototype.hasOwnProperty
  , __propIsEnum$18 = Object.prototype.propertyIsEnumerable
  , __defNormalProp$17 = (o, i, s) => i in o ? __defProp$17(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$17 = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$18.call(i, s) && __defNormalProp$17(o, s, i[s]);
    if (__getOwnPropSymbols$18)
        for (var s of __getOwnPropSymbols$18(i))
            __propIsEnum$18.call(i, s) && __defNormalProp$17(o, s, i[s]);
    return o
}
;
const transitionStatuses = {
    entering: "in",
    entered: "in",
    exiting: "out",
    exited: "out",
    "pre-exiting": "out",
    "pre-entering": "out"
};
function getTransitionStyles({transition: o, state: i, duration: s, timingFunction: a}) {
    const _ = {
        transitionDuration: `${s}ms`,
        transitionTimingFunction: a
    };
    return typeof o == "string" ? o in transitions ? __spreadValues$17(__spreadValues$17(__spreadValues$17({
        transitionProperty: transitions[o].transitionProperty
    }, _), transitions[o].common), transitions[o][transitionStatuses[i]]) : null : __spreadValues$17(__spreadValues$17(__spreadValues$17({
        transitionProperty: o.transitionProperty
    }, _), o.common), o[transitionStatuses[i]])
}
function useTransition({duration: o, exitDuration: i, timingFunction: s, mounted: a, onEnter: _, onExit: $, onEntered: _e, onExited: tt}) {
    const nt = useMantineTheme()
      , rt = useReducedMotion()
      , ot = nt.respectReducedMotion ? rt : !1
      , [et,j] = reactExports.useState(ot ? 0 : o)
      , [it,st] = reactExports.useState(a ? "entered" : "exited")
      , at = reactExports.useRef(-1)
      , lt = ct => {
        const ut = ct ? _ : $
          , dt = ct ? _e : tt;
        st(ct ? "pre-entering" : "pre-exiting"),
        window.clearTimeout(at.current);
        const ft = ot ? 0 : ct ? o : i;
        if (j(ft),
        ft === 0)
            typeof ut == "function" && ut(),
            typeof dt == "function" && dt(),
            st(ct ? "entered" : "exited");
        else {
            const ht = window.setTimeout( () => {
                typeof ut == "function" && ut(),
                st(ct ? "entering" : "exiting")
            }
            , 10);
            at.current = window.setTimeout( () => {
                window.clearTimeout(ht),
                typeof dt == "function" && dt(),
                st(ct ? "entered" : "exited")
            }
            , ft)
        }
    }
    ;
    return useDidUpdate( () => {
        lt(a)
    }
    , [a]),
    reactExports.useEffect( () => () => window.clearTimeout(at.current), []),
    {
        transitionDuration: et,
        transitionStatus: it,
        transitionTimingFunction: s || nt.transitionTimingFunction
    }
}
function Transition$2({keepMounted: o, transition: i, duration: s=250, exitDuration: a=s, mounted: _, children: $, timingFunction: _e, onExit: tt, onEntered: nt, onEnter: rt, onExited: ot}) {
    const {transitionDuration: et, transitionStatus: j, transitionTimingFunction: it} = useTransition({
        mounted: _,
        exitDuration: a,
        duration: s,
        timingFunction: _e,
        onExit: tt,
        onEntered: nt,
        onEnter: rt,
        onExited: ot
    });
    return et === 0 ? _ ? React.createElement(React.Fragment, null, $({})) : o ? $({
        display: "none"
    }) : null : j === "exited" ? o ? $({
        display: "none"
    }) : null : React.createElement(React.Fragment, null, $(getTransitionStyles({
        transition: i,
        duration: et,
        state: j,
        timingFunction: it
    })))
}
Transition$2.displayName = "@mantine/core/Transition";
function FocusTrap({children: o, active: i=!0, refProp: s="ref"}) {
    const a = useFocusTrap(i)
      , _ = useMergedRef(a, o == null ? void 0 : o.ref);
    return isElement$2(o) ? reactExports.cloneElement(o, {
        [s]: _
    }) : o
}
FocusTrap.displayName = "@mantine/core/FocusTrap";
var __defProp$16 = Object.defineProperty
  , __defProps$B = Object.defineProperties
  , __getOwnPropDescs$B = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$17 = Object.getOwnPropertySymbols
  , __hasOwnProp$17 = Object.prototype.hasOwnProperty
  , __propIsEnum$17 = Object.prototype.propertyIsEnumerable
  , __defNormalProp$16 = (o, i, s) => i in o ? __defProp$16(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$16 = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$17.call(i, s) && __defNormalProp$16(o, s, i[s]);
    if (__getOwnPropSymbols$17)
        for (var s of __getOwnPropSymbols$17(i))
            __propIsEnum$17.call(i, s) && __defNormalProp$16(o, s, i[s]);
    return o
}
  , __spreadProps$B = (o, i) => __defProps$B(o, __getOwnPropDescs$B(i));
function horizontalSide(o, i, s, a) {
    return o === "center" || a === "center" ? {
        top: i
    } : o === "end" ? {
        bottom: s
    } : o === "start" ? {
        top: s
    } : {}
}
function verticalSide(o, i, s, a, _) {
    return o === "center" || a === "center" ? {
        left: i
    } : o === "end" ? {
        [_ === "ltr" ? "right" : "left"]: s
    } : o === "start" ? {
        [_ === "ltr" ? "left" : "right"]: s
    } : {}
}
const radiusByFloatingSide = {
    bottom: "borderTopLeftRadius",
    left: "borderTopRightRadius",
    right: "borderBottomLeftRadius",
    top: "borderBottomRightRadius"
};
function getArrowPositionStyles({position: o, arrowSize: i, arrowOffset: s, arrowRadius: a, arrowPosition: _, arrowX: $, arrowY: _e, dir: tt}) {
    const [nt,rt="center"] = o.split("-")
      , ot = {
        width: rem(i),
        height: rem(i),
        transform: "rotate(45deg)",
        position: "absolute",
        [radiusByFloatingSide[nt]]: rem(a)
    }
      , et = rem(-i / 2);
    return nt === "left" ? __spreadProps$B(__spreadValues$16(__spreadValues$16({}, ot), horizontalSide(rt, _e, s, _)), {
        right: et,
        borderLeftColor: "transparent",
        borderBottomColor: "transparent"
    }) : nt === "right" ? __spreadProps$B(__spreadValues$16(__spreadValues$16({}, ot), horizontalSide(rt, _e, s, _)), {
        left: et,
        borderRightColor: "transparent",
        borderTopColor: "transparent"
    }) : nt === "top" ? __spreadProps$B(__spreadValues$16(__spreadValues$16({}, ot), verticalSide(rt, $, s, _, tt)), {
        bottom: et,
        borderTopColor: "transparent",
        borderLeftColor: "transparent"
    }) : nt === "bottom" ? __spreadProps$B(__spreadValues$16(__spreadValues$16({}, ot), verticalSide(rt, $, s, _, tt)), {
        top: et,
        borderBottomColor: "transparent",
        borderRightColor: "transparent"
    }) : {}
}
var __defProp$15 = Object.defineProperty
  , __defProps$A = Object.defineProperties
  , __getOwnPropDescs$A = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$16 = Object.getOwnPropertySymbols
  , __hasOwnProp$16 = Object.prototype.hasOwnProperty
  , __propIsEnum$16 = Object.prototype.propertyIsEnumerable
  , __defNormalProp$15 = (o, i, s) => i in o ? __defProp$15(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$15 = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$16.call(i, s) && __defNormalProp$15(o, s, i[s]);
    if (__getOwnPropSymbols$16)
        for (var s of __getOwnPropSymbols$16(i))
            __propIsEnum$16.call(i, s) && __defNormalProp$15(o, s, i[s]);
    return o
}
  , __spreadProps$A = (o, i) => __defProps$A(o, __getOwnPropDescs$A(i))
  , __objRest$O = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$16.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$16)
        for (var a of __getOwnPropSymbols$16(o))
            i.indexOf(a) < 0 && __propIsEnum$16.call(o, a) && (s[a] = o[a]);
    return s
}
;
const FloatingArrow = reactExports.forwardRef( (o, i) => {
    var s = o
      , {position: a, arrowSize: _, arrowOffset: $, arrowRadius: _e, arrowPosition: tt, visible: nt, arrowX: rt, arrowY: ot} = s
      , et = __objRest$O(s, ["position", "arrowSize", "arrowOffset", "arrowRadius", "arrowPosition", "visible", "arrowX", "arrowY"]);
    const j = useMantineTheme();
    return nt ? React.createElement("div", __spreadProps$A(__spreadValues$15({}, et), {
        ref: i,
        style: getArrowPositionStyles({
            position: a,
            arrowSize: _,
            arrowOffset: $,
            arrowRadius: _e,
            arrowPosition: tt,
            dir: j.dir,
            arrowX: rt,
            arrowY: ot
        })
    })) : null
}
);
FloatingArrow.displayName = "@mantine/core/FloatingArrow";
var __defProp$14 = Object.defineProperty
  , __defProps$z = Object.defineProperties
  , __getOwnPropDescs$z = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$15 = Object.getOwnPropertySymbols
  , __hasOwnProp$15 = Object.prototype.hasOwnProperty
  , __propIsEnum$15 = Object.prototype.propertyIsEnumerable
  , __defNormalProp$14 = (o, i, s) => i in o ? __defProp$14(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$14 = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$15.call(i, s) && __defNormalProp$14(o, s, i[s]);
    if (__getOwnPropSymbols$15)
        for (var s of __getOwnPropSymbols$15(i))
            __propIsEnum$15.call(i, s) && __defNormalProp$14(o, s, i[s]);
    return o
}
  , __spreadProps$z = (o, i) => __defProps$z(o, __getOwnPropDescs$z(i))
  , __objRest$N = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$15.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$15)
        for (var a of __getOwnPropSymbols$15(o))
            i.indexOf(a) < 0 && __propIsEnum$15.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$D = {};
function PopoverDropdown(o) {
    var i;
    const s = useComponentDefaultProps("PopoverDropdown", defaultProps$D, o)
      , {style: a, className: _, children: $, onKeyDownCapture: _e} = s
      , tt = __objRest$N(s, ["style", "className", "children", "onKeyDownCapture"])
      , nt = usePopoverContext()
      , {classes: rt, cx: ot} = useStyles$15({
        radius: nt.radius,
        shadow: nt.shadow
    }, {
        name: nt.__staticSelector,
        classNames: nt.classNames,
        styles: nt.styles,
        unstyled: nt.unstyled,
        variant: nt.variant
    })
      , et = useFocusReturn({
        opened: nt.opened,
        shouldReturnFocus: nt.returnFocus
    })
      , j = nt.withRoles ? {
        "aria-labelledby": nt.getTargetId(),
        id: nt.getDropdownId(),
        role: "dialog"
    } : {};
    return nt.disabled ? null : React.createElement(OptionalPortal, __spreadProps$z(__spreadValues$14({}, nt.portalProps), {
        withinPortal: nt.withinPortal
    }), React.createElement(Transition$2, __spreadProps$z(__spreadValues$14({
        mounted: nt.opened
    }, nt.transitionProps), {
        transition: nt.transitionProps.transition || "fade",
        duration: (i = nt.transitionProps.duration) != null ? i : 150,
        keepMounted: nt.keepMounted,
        exitDuration: typeof nt.transitionProps.exitDuration == "number" ? nt.transitionProps.exitDuration : nt.transitionProps.duration
    }), it => {
        var st, at;
        return React.createElement(FocusTrap, {
            active: nt.trapFocus
        }, React.createElement(Box, __spreadValues$14(__spreadProps$z(__spreadValues$14({}, j), {
            tabIndex: -1,
            ref: nt.floating,
            style: __spreadProps$z(__spreadValues$14(__spreadValues$14({}, a), it), {
                zIndex: nt.zIndex,
                top: (st = nt.y) != null ? st : 0,
                left: (at = nt.x) != null ? at : 0,
                width: nt.width === "target" ? void 0 : rem(nt.width)
            }),
            className: ot(rt.dropdown, _),
            onKeyDownCapture: closeOnEscape(nt.onClose, {
                active: nt.closeOnEscape,
                onTrigger: et,
                onKeyDown: _e
            }),
            "data-position": nt.placement
        }), tt), $, React.createElement(FloatingArrow, {
            ref: nt.arrowRef,
            arrowX: nt.arrowX,
            arrowY: nt.arrowY,
            visible: nt.withArrow,
            position: nt.placement,
            arrowSize: nt.arrowSize,
            arrowRadius: nt.arrowRadius,
            arrowOffset: nt.arrowOffset,
            arrowPosition: nt.arrowPosition,
            className: rt.arrow
        })))
    }
    ))
}
PopoverDropdown.displayName = "@mantine/core/PopoverDropdown";
function getFloatingPosition(o, i) {
    if (o === "rtl" && (i.includes("right") || i.includes("left"))) {
        const [s,a] = i.split("-")
          , _ = s === "right" ? "left" : "right";
        return a === void 0 ? _ : `${_}-${a}`
    }
    return i
}
var __getOwnPropSymbols$14 = Object.getOwnPropertySymbols
  , __hasOwnProp$14 = Object.prototype.hasOwnProperty
  , __propIsEnum$14 = Object.prototype.propertyIsEnumerable
  , __objRest$M = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$14.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$14)
        for (var a of __getOwnPropSymbols$14(o))
            i.indexOf(a) < 0 && __propIsEnum$14.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$C = {
    position: "bottom",
    offset: 8,
    positionDependencies: [],
    transitionProps: {
        transition: "fade",
        duration: 150
    },
    middlewares: {
        flip: !0,
        shift: !0,
        inline: !1
    },
    arrowSize: 7,
    arrowOffset: 5,
    arrowRadius: 0,
    arrowPosition: "side",
    closeOnClickOutside: !0,
    withinPortal: !1,
    closeOnEscape: !0,
    trapFocus: !1,
    withRoles: !0,
    returnFocus: !1,
    clickOutsideEvents: ["mousedown", "touchstart"],
    zIndex: getDefaultZIndex("popover"),
    __staticSelector: "Popover",
    width: "max-content"
};
function Popover(o) {
    var i, s, a, _, $, _e;
    const tt = reactExports.useRef(null)
      , nt = useComponentDefaultProps("Popover", defaultProps$C, o)
      , {children: rt, position: ot, offset: et, onPositionChange: j, positionDependencies: it, opened: st, transitionProps: at, width: lt, middlewares: ct, withArrow: ut, arrowSize: dt, arrowOffset: ft, arrowRadius: ht, arrowPosition: pt, unstyled: gt, classNames: _t, styles: mt, closeOnClickOutside: yt, withinPortal: bt, portalProps: vt, closeOnEscape: wt, clickOutsideEvents: Tt, trapFocus: $t, onClose: Et, onOpen: Pt, onChange: Rt, zIndex: At, radius: Mt, shadow: Ut, id: Lt, defaultOpened: tn, __staticSelector: Vt, withRoles: Nt, disabled: Yt, returnFocus: Xt, variant: jt, keepMounted: Gt} = nt
      , Kt = __objRest$M(nt, ["children", "position", "offset", "onPositionChange", "positionDependencies", "opened", "transitionProps", "width", "middlewares", "withArrow", "arrowSize", "arrowOffset", "arrowRadius", "arrowPosition", "unstyled", "classNames", "styles", "closeOnClickOutside", "withinPortal", "portalProps", "closeOnEscape", "clickOutsideEvents", "trapFocus", "onClose", "onOpen", "onChange", "zIndex", "radius", "shadow", "id", "defaultOpened", "__staticSelector", "withRoles", "disabled", "returnFocus", "variant", "keepMounted"])
      , [qt,rn] = reactExports.useState(null)
      , [on,_n] = reactExports.useState(null)
      , mn = useId(Lt)
      , Sn = useMantineTheme()
      , bn = usePopover({
        middlewares: ct,
        width: lt,
        position: getFloatingPosition(Sn.dir, ot),
        offset: typeof et == "number" ? et + (ut ? dt / 2 : 0) : et,
        arrowRef: tt,
        arrowOffset: ft,
        onPositionChange: j,
        positionDependencies: it,
        opened: st,
        defaultOpened: tn,
        onChange: Rt,
        onOpen: Pt,
        onClose: Et
    });
    useClickOutside( () => bn.opened && yt && bn.onClose(), Tt, [qt, on]);
    const In = reactExports.useCallback(cn => {
        rn(cn),
        bn.floating.reference(cn)
    }
    , [bn.floating.reference])
      , Nn = reactExports.useCallback(cn => {
        _n(cn),
        bn.floating.floating(cn)
    }
    , [bn.floating.floating]);
    return React.createElement(PopoverContextProvider, {
        value: {
            returnFocus: Xt,
            disabled: Yt,
            controlled: bn.controlled,
            reference: In,
            floating: Nn,
            x: bn.floating.x,
            y: bn.floating.y,
            arrowX: (a = (s = (i = bn.floating) == null ? void 0 : i.middlewareData) == null ? void 0 : s.arrow) == null ? void 0 : a.x,
            arrowY: (_e = ($ = (_ = bn.floating) == null ? void 0 : _.middlewareData) == null ? void 0 : $.arrow) == null ? void 0 : _e.y,
            opened: bn.opened,
            arrowRef: tt,
            transitionProps: at,
            width: lt,
            withArrow: ut,
            arrowSize: dt,
            arrowOffset: ft,
            arrowRadius: ht,
            arrowPosition: pt,
            placement: bn.floating.placement,
            trapFocus: $t,
            withinPortal: bt,
            portalProps: vt,
            zIndex: At,
            radius: Mt,
            shadow: Ut,
            closeOnEscape: wt,
            onClose: bn.onClose,
            onToggle: bn.onToggle,
            getTargetId: () => `${mn}-target`,
            getDropdownId: () => `${mn}-dropdown`,
            withRoles: Nt,
            targetProps: Kt,
            __staticSelector: Vt,
            classNames: _t,
            styles: mt,
            unstyled: gt,
            variant: jt,
            keepMounted: Gt
        }
    }, rt)
}
Popover.Target = PopoverTarget;
Popover.Dropdown = PopoverDropdown;
Popover.displayName = "@mantine/core/Popover";
var __defProp$13 = Object.defineProperty
  , __getOwnPropSymbols$13 = Object.getOwnPropertySymbols
  , __hasOwnProp$13 = Object.prototype.hasOwnProperty
  , __propIsEnum$13 = Object.prototype.propertyIsEnumerable
  , __defNormalProp$13 = (o, i, s) => i in o ? __defProp$13(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$13 = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$13.call(i, s) && __defNormalProp$13(o, s, i[s]);
    if (__getOwnPropSymbols$13)
        for (var s of __getOwnPropSymbols$13(i))
            __propIsEnum$13.call(i, s) && __defNormalProp$13(o, s, i[s]);
    return o
}
  , __objRest$L = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$13.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$13)
        for (var a of __getOwnPropSymbols$13(o))
            i.indexOf(a) < 0 && __propIsEnum$13.call(o, a) && (s[a] = o[a]);
    return s
}
;
function SelectPopoverDropdown(o) {
    var i = o
      , {children: s, component: a="div", maxHeight: _=220, direction: $="column", id: _e, innerRef: tt, __staticSelector: nt, styles: rt, classNames: ot, unstyled: et} = i
      , j = __objRest$L(i, ["children", "component", "maxHeight", "direction", "id", "innerRef", "__staticSelector", "styles", "classNames", "unstyled"]);
    const {classes: it} = useStyles$17(null, {
        name: nt,
        styles: rt,
        classNames: ot,
        unstyled: et
    });
    return React.createElement(Popover.Dropdown, __spreadValues$13({
        p: 0,
        onMouseDown: st => st.preventDefault()
    }, j), React.createElement("div", {
        style: {
            maxHeight: rem(_),
            display: "flex"
        }
    }, React.createElement(Box, {
        component: a || "div",
        id: `${_e}-items`,
        "aria-labelledby": `${_e}-label`,
        role: "listbox",
        onMouseDown: st => st.preventDefault(),
        style: {
            flex: 1,
            overflowY: a !== SelectScrollArea ? "auto" : void 0
        },
        "data-combobox-popover": !0,
        tabIndex: -1,
        ref: tt
    }, React.createElement("div", {
        className: it.itemsWrapper,
        style: {
            flexDirection: $
        }
    }, s))))
}
function SelectPopover({opened: o, transitionProps: i={
    transition: "fade",
    duration: 0
}, shadow: s, withinPortal: a, portalProps: _, children: $, __staticSelector: _e, onDirectionChange: tt, switchDirectionOnFlip: nt, zIndex: rt, dropdownPosition: ot, positionDependencies: et=[], classNames: j, styles: it, unstyled: st, readOnly: at, variant: lt}) {
    return React.createElement(Popover, {
        unstyled: st,
        classNames: j,
        styles: it,
        width: "target",
        withRoles: !1,
        opened: o,
        middlewares: {
            flip: ot === "flip",
            shift: !1
        },
        position: ot === "flip" ? "bottom" : ot,
        positionDependencies: et,
        zIndex: rt,
        __staticSelector: _e,
        withinPortal: a,
        portalProps: _,
        transitionProps: i,
        shadow: s,
        disabled: at,
        onPositionChange: ct => nt && (tt == null ? void 0 : tt(ct === "top" ? "column-reverse" : "column")),
        variant: lt
    }, $)
}
SelectPopover.Target = Popover.Target;
SelectPopover.Dropdown = SelectPopoverDropdown;
var __defProp$12 = Object.defineProperty
  , __defProps$y = Object.defineProperties
  , __getOwnPropDescs$y = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$12 = Object.getOwnPropertySymbols
  , __hasOwnProp$12 = Object.prototype.hasOwnProperty
  , __propIsEnum$12 = Object.prototype.propertyIsEnumerable
  , __defNormalProp$12 = (o, i, s) => i in o ? __defProp$12(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$12 = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$12.call(i, s) && __defNormalProp$12(o, s, i[s]);
    if (__getOwnPropSymbols$12)
        for (var s of __getOwnPropSymbols$12(i))
            __propIsEnum$12.call(i, s) && __defNormalProp$12(o, s, i[s]);
    return o
}
  , __spreadProps$y = (o, i) => __defProps$y(o, __getOwnPropDescs$y(i))
  , __objRest$K = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$12.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$12)
        for (var a of __getOwnPropSymbols$12(o))
            i.indexOf(a) < 0 && __propIsEnum$12.call(o, a) && (s[a] = o[a]);
    return s
}
;
function useInputProps(o, i, s) {
    const a = useComponentDefaultProps(o, i, s)
      , {label: _, description: $, error: _e, required: tt, classNames: nt, styles: rt, className: ot, unstyled: et, __staticSelector: j, sx: it, errorProps: st, labelProps: at, descriptionProps: lt, wrapperProps: ct, id: ut, size: dt, style: ft, inputContainer: ht, inputWrapperOrder: pt, withAsterisk: gt, variant: _t} = a
      , mt = __objRest$K(a, ["label", "description", "error", "required", "classNames", "styles", "className", "unstyled", "__staticSelector", "sx", "errorProps", "labelProps", "descriptionProps", "wrapperProps", "id", "size", "style", "inputContainer", "inputWrapperOrder", "withAsterisk", "variant"])
      , yt = useId(ut)
      , {systemStyles: bt, rest: vt} = extractSystemStyles(mt)
      , wt = __spreadValues$12({
        label: _,
        description: $,
        error: _e,
        required: tt,
        classNames: nt,
        className: ot,
        __staticSelector: j,
        sx: it,
        errorProps: st,
        labelProps: at,
        descriptionProps: lt,
        unstyled: et,
        styles: rt,
        id: yt,
        size: dt,
        style: ft,
        inputContainer: ht,
        inputWrapperOrder: pt,
        withAsterisk: gt,
        variant: _t
    }, ct);
    return __spreadProps$y(__spreadValues$12({}, vt), {
        classNames: nt,
        styles: rt,
        unstyled: et,
        wrapperProps: __spreadValues$12(__spreadValues$12({}, wt), bt),
        inputProps: {
            required: tt,
            classNames: nt,
            styles: rt,
            unstyled: et,
            id: yt,
            size: dt,
            __staticSelector: j,
            error: _e,
            variant: _t
        }
    })
}
var useStyles$12 = createStyles( (o, i, {size: s}) => ({
    label: {
        display: "inline-block",
        fontSize: getSize({
            size: s,
            sizes: o.fontSizes
        }),
        fontWeight: 500,
        color: o.colorScheme === "dark" ? o.colors.dark[0] : o.colors.gray[9],
        wordBreak: "break-word",
        cursor: "default",
        WebkitTapHighlightColor: "transparent"
    },
    required: {
        color: o.fn.variant({
            variant: "filled",
            color: "red"
        }).background
    }
}));
const useStyles$13 = useStyles$12;
var __defProp$11 = Object.defineProperty
  , __getOwnPropSymbols$11 = Object.getOwnPropertySymbols
  , __hasOwnProp$11 = Object.prototype.hasOwnProperty
  , __propIsEnum$11 = Object.prototype.propertyIsEnumerable
  , __defNormalProp$11 = (o, i, s) => i in o ? __defProp$11(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$11 = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$11.call(i, s) && __defNormalProp$11(o, s, i[s]);
    if (__getOwnPropSymbols$11)
        for (var s of __getOwnPropSymbols$11(i))
            __propIsEnum$11.call(i, s) && __defNormalProp$11(o, s, i[s]);
    return o
}
  , __objRest$J = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$11.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$11)
        for (var a of __getOwnPropSymbols$11(o))
            i.indexOf(a) < 0 && __propIsEnum$11.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$B = {
    labelElement: "label",
    size: "sm"
}
  , InputLabel = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("InputLabel", defaultProps$B, o)
      , {labelElement: a, children: _, required: $, size: _e, classNames: tt, styles: nt, unstyled: rt, className: ot, htmlFor: et, __staticSelector: j, variant: it, onMouseDown: st} = s
      , at = __objRest$J(s, ["labelElement", "children", "required", "size", "classNames", "styles", "unstyled", "className", "htmlFor", "__staticSelector", "variant", "onMouseDown"])
      , {classes: lt, cx: ct} = useStyles$13(null, {
        name: ["InputWrapper", j],
        classNames: tt,
        styles: nt,
        unstyled: rt,
        variant: it,
        size: _e
    });
    return React.createElement(Box, __spreadValues$11({
        component: a,
        ref: i,
        className: ct(lt.label, ot),
        htmlFor: a === "label" ? et : void 0,
        onMouseDown: ut => {
            st == null || st(ut),
            !ut.defaultPrevented && ut.detail > 1 && ut.preventDefault()
        }
    }, at), _, $ && React.createElement("span", {
        className: lt.required,
        "aria-hidden": !0
    }, " *"))
}
);
InputLabel.displayName = "@mantine/core/InputLabel";
var useStyles$10 = createStyles( (o, i, {size: s}) => ({
    error: {
        wordBreak: "break-word",
        color: o.fn.variant({
            variant: "filled",
            color: "red"
        }).background,
        fontSize: `calc(${getSize({
            size: s,
            sizes: o.fontSizes
        })} - ${rem(2)})`,
        lineHeight: 1.2,
        display: "block"
    }
}));
const useStyles$11 = useStyles$10;
var __defProp$10 = Object.defineProperty
  , __getOwnPropSymbols$10 = Object.getOwnPropertySymbols
  , __hasOwnProp$10 = Object.prototype.hasOwnProperty
  , __propIsEnum$10 = Object.prototype.propertyIsEnumerable
  , __defNormalProp$10 = (o, i, s) => i in o ? __defProp$10(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$10 = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$10.call(i, s) && __defNormalProp$10(o, s, i[s]);
    if (__getOwnPropSymbols$10)
        for (var s of __getOwnPropSymbols$10(i))
            __propIsEnum$10.call(i, s) && __defNormalProp$10(o, s, i[s]);
    return o
}
  , __objRest$I = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$10.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$10)
        for (var a of __getOwnPropSymbols$10(o))
            i.indexOf(a) < 0 && __propIsEnum$10.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$A = {
    size: "sm"
}
  , InputError = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("InputError", defaultProps$A, o)
      , {children: a, className: _, classNames: $, styles: _e, unstyled: tt, size: nt, __staticSelector: rt, variant: ot} = s
      , et = __objRest$I(s, ["children", "className", "classNames", "styles", "unstyled", "size", "__staticSelector", "variant"])
      , {classes: j, cx: it} = useStyles$11(null, {
        name: ["InputWrapper", rt],
        classNames: $,
        styles: _e,
        unstyled: tt,
        variant: ot,
        size: nt
    });
    return React.createElement(Text$2, __spreadValues$10({
        className: it(j.error, _),
        ref: i
    }, et), a)
}
);
InputError.displayName = "@mantine/core/InputError";
var useStyles$_ = createStyles( (o, i, {size: s}) => ({
    description: {
        wordBreak: "break-word",
        color: o.colorScheme === "dark" ? o.colors.dark[2] : o.colors.gray[6],
        fontSize: `calc(${getSize({
            size: s,
            sizes: o.fontSizes
        })} - ${rem(2)})`,
        lineHeight: 1.2,
        display: "block"
    }
}));
const useStyles$$ = useStyles$_;
var __defProp$$ = Object.defineProperty
  , __getOwnPropSymbols$$ = Object.getOwnPropertySymbols
  , __hasOwnProp$$ = Object.prototype.hasOwnProperty
  , __propIsEnum$$ = Object.prototype.propertyIsEnumerable
  , __defNormalProp$$ = (o, i, s) => i in o ? __defProp$$(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$$ = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$$.call(i, s) && __defNormalProp$$(o, s, i[s]);
    if (__getOwnPropSymbols$$)
        for (var s of __getOwnPropSymbols$$(i))
            __propIsEnum$$.call(i, s) && __defNormalProp$$(o, s, i[s]);
    return o
}
  , __objRest$H = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$$.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$$)
        for (var a of __getOwnPropSymbols$$(o))
            i.indexOf(a) < 0 && __propIsEnum$$.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$z = {
    size: "sm"
}
  , InputDescription = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("InputDescription", defaultProps$z, o)
      , {children: a, className: _, classNames: $, styles: _e, unstyled: tt, size: nt, __staticSelector: rt, variant: ot} = s
      , et = __objRest$H(s, ["children", "className", "classNames", "styles", "unstyled", "size", "__staticSelector", "variant"])
      , {classes: j, cx: it} = useStyles$$(null, {
        name: ["InputWrapper", rt],
        classNames: $,
        styles: _e,
        unstyled: tt,
        variant: ot,
        size: nt
    });
    return React.createElement(Text$2, __spreadValues$$({
        color: "dimmed",
        className: it(j.description, _),
        ref: i,
        unstyled: tt
    }, et), a)
}
);
InputDescription.displayName = "@mantine/core/InputDescription";
const InputWrapperContext = reactExports.createContext({
    offsetBottom: !1,
    offsetTop: !1,
    describedBy: void 0
})
  , InputWrapperProvider = InputWrapperContext.Provider
  , useInputWrapperContext = () => reactExports.useContext(InputWrapperContext);
function getInputOffsets(o, {hasDescription: i, hasError: s}) {
    const a = o.findIndex(nt => nt === "input")
      , _ = o[a - 1]
      , $ = o[a + 1];
    return {
        offsetBottom: i && $ === "description" || s && $ === "error",
        offsetTop: i && _ === "description" || s && _ === "error"
    }
}
var __defProp$_ = Object.defineProperty
  , __defProps$x = Object.defineProperties
  , __getOwnPropDescs$x = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$_ = Object.getOwnPropertySymbols
  , __hasOwnProp$_ = Object.prototype.hasOwnProperty
  , __propIsEnum$_ = Object.prototype.propertyIsEnumerable
  , __defNormalProp$_ = (o, i, s) => i in o ? __defProp$_(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$_ = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$_.call(i, s) && __defNormalProp$_(o, s, i[s]);
    if (__getOwnPropSymbols$_)
        for (var s of __getOwnPropSymbols$_(i))
            __propIsEnum$_.call(i, s) && __defNormalProp$_(o, s, i[s]);
    return o
}
  , __spreadProps$x = (o, i) => __defProps$x(o, __getOwnPropDescs$x(i))
  , useStyles$Y = createStyles(o => ({
    root: __spreadProps$x(__spreadValues$_({}, o.fn.fontStyles()), {
        lineHeight: o.lineHeight
    })
}));
const useStyles$Z = useStyles$Y;
var __defProp$Z = Object.defineProperty
  , __defProps$w = Object.defineProperties
  , __getOwnPropDescs$w = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$Z = Object.getOwnPropertySymbols
  , __hasOwnProp$Z = Object.prototype.hasOwnProperty
  , __propIsEnum$Z = Object.prototype.propertyIsEnumerable
  , __defNormalProp$Z = (o, i, s) => i in o ? __defProp$Z(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$Z = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$Z.call(i, s) && __defNormalProp$Z(o, s, i[s]);
    if (__getOwnPropSymbols$Z)
        for (var s of __getOwnPropSymbols$Z(i))
            __propIsEnum$Z.call(i, s) && __defNormalProp$Z(o, s, i[s]);
    return o
}
  , __spreadProps$w = (o, i) => __defProps$w(o, __getOwnPropDescs$w(i))
  , __objRest$G = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$Z.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$Z)
        for (var a of __getOwnPropSymbols$Z(o))
            i.indexOf(a) < 0 && __propIsEnum$Z.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$y = {
    labelElement: "label",
    size: "sm",
    inputContainer: o => o,
    inputWrapperOrder: ["label", "description", "input", "error"]
}
  , InputWrapper = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("InputWrapper", defaultProps$y, o)
      , {className: a, label: _, children: $, required: _e, id: tt, error: nt, description: rt, labelElement: ot, labelProps: et, descriptionProps: j, errorProps: it, classNames: st, styles: at, size: lt, inputContainer: ct, __staticSelector: ut, unstyled: dt, inputWrapperOrder: ft, withAsterisk: ht, variant: pt} = s
      , gt = __objRest$G(s, ["className", "label", "children", "required", "id", "error", "description", "labelElement", "labelProps", "descriptionProps", "errorProps", "classNames", "styles", "size", "inputContainer", "__staticSelector", "unstyled", "inputWrapperOrder", "withAsterisk", "variant"])
      , {classes: _t, cx: mt} = useStyles$Z(null, {
        classNames: st,
        styles: at,
        name: ["InputWrapper", ut],
        unstyled: dt,
        variant: pt,
        size: lt
    })
      , yt = {
        classNames: st,
        styles: at,
        unstyled: dt,
        size: lt,
        variant: pt,
        __staticSelector: ut
    }
      , bt = typeof ht == "boolean" ? ht : _e
      , vt = tt ? `${tt}-error` : it == null ? void 0 : it.id
      , wt = tt ? `${tt}-description` : j == null ? void 0 : j.id
      , $t = `${!!nt && typeof nt != "boolean" ? vt : ""} ${rt ? wt : ""}`
      , Et = $t.trim().length > 0 ? $t.trim() : void 0
      , Pt = _ && React.createElement(InputLabel, __spreadValues$Z(__spreadValues$Z({
        key: "label",
        labelElement: ot,
        id: tt ? `${tt}-label` : void 0,
        htmlFor: tt,
        required: bt
    }, yt), et), _)
      , Rt = rt && React.createElement(InputDescription, __spreadProps$w(__spreadValues$Z(__spreadValues$Z({
        key: "description"
    }, j), yt), {
        size: (j == null ? void 0 : j.size) || yt.size,
        id: (j == null ? void 0 : j.id) || wt
    }), rt)
      , At = React.createElement(reactExports.Fragment, {
        key: "input"
    }, ct($))
      , Mt = typeof nt != "boolean" && nt && React.createElement(InputError, __spreadProps$w(__spreadValues$Z(__spreadValues$Z({}, it), yt), {
        size: (it == null ? void 0 : it.size) || yt.size,
        key: "error",
        id: (it == null ? void 0 : it.id) || vt
    }), nt)
      , Ut = ft.map(Lt => {
        switch (Lt) {
        case "label":
            return Pt;
        case "input":
            return At;
        case "description":
            return Rt;
        case "error":
            return Mt;
        default:
            return null
        }
    }
    );
    return React.createElement(InputWrapperProvider, {
        value: __spreadValues$Z({
            describedBy: Et
        }, getInputOffsets(ft, {
            hasDescription: !!Rt,
            hasError: !!Mt
        }))
    }, React.createElement(Box, __spreadValues$Z({
        className: mt(_t.root, a),
        ref: i
    }, gt), Ut))
}
);
InputWrapper.displayName = "@mantine/core/InputWrapper";
var __defProp$Y = Object.defineProperty
  , __getOwnPropSymbols$Y = Object.getOwnPropertySymbols
  , __hasOwnProp$Y = Object.prototype.hasOwnProperty
  , __propIsEnum$Y = Object.prototype.propertyIsEnumerable
  , __defNormalProp$Y = (o, i, s) => i in o ? __defProp$Y(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$Y = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$Y.call(i, s) && __defNormalProp$Y(o, s, i[s]);
    if (__getOwnPropSymbols$Y)
        for (var s of __getOwnPropSymbols$Y(i))
            __propIsEnum$Y.call(i, s) && __defNormalProp$Y(o, s, i[s]);
    return o
}
  , __objRest$F = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$Y.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$Y)
        for (var a of __getOwnPropSymbols$Y(o))
            i.indexOf(a) < 0 && __propIsEnum$Y.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$x = {}
  , InputPlaceholder = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("InputPlaceholder", defaultProps$x, o)
      , {sx: a} = s
      , _ = __objRest$F(s, ["sx"]);
    return React.createElement(Box, __spreadValues$Y({
        component: "span",
        sx: [$ => $.fn.placeholderStyles(), ...packSx(a)],
        ref: i
    }, _))
}
);
InputPlaceholder.displayName = "@mantine/core/InputPlaceholder";
var __defProp$X = Object.defineProperty
  , __defProps$v = Object.defineProperties
  , __getOwnPropDescs$v = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$X = Object.getOwnPropertySymbols
  , __hasOwnProp$X = Object.prototype.hasOwnProperty
  , __propIsEnum$X = Object.prototype.propertyIsEnumerable
  , __defNormalProp$X = (o, i, s) => i in o ? __defProp$X(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$X = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$X.call(i, s) && __defNormalProp$X(o, s, i[s]);
    if (__getOwnPropSymbols$X)
        for (var s of __getOwnPropSymbols$X(i))
            __propIsEnum$X.call(i, s) && __defNormalProp$X(o, s, i[s]);
    return o
}
  , __spreadProps$v = (o, i) => __defProps$v(o, __getOwnPropDescs$v(i));
const sizes$6 = {
    xs: rem(30),
    sm: rem(36),
    md: rem(42),
    lg: rem(50),
    xl: rem(60)
}
  , INPUT_VARIANTS = ["default", "filled", "unstyled"];
function getVariantStyles$2({theme: o, variant: i}) {
    return INPUT_VARIANTS.includes(i) ? i === "default" ? {
        border: `${rem(1)} solid ${o.colorScheme === "dark" ? o.colors.dark[4] : o.colors.gray[4]}`,
        backgroundColor: o.colorScheme === "dark" ? o.colors.dark[6] : o.white,
        transition: "border-color 100ms ease",
        "&:focus, &:focus-within": o.focusRingStyles.inputStyles(o)
    } : i === "filled" ? {
        border: `${rem(1)} solid transparent`,
        backgroundColor: o.colorScheme === "dark" ? o.colors.dark[5] : o.colors.gray[1],
        "&:focus, &:focus-within": o.focusRingStyles.inputStyles(o)
    } : {
        borderWidth: 0,
        color: o.colorScheme === "dark" ? o.colors.dark[0] : o.black,
        backgroundColor: "transparent",
        minHeight: rem(28),
        outline: 0,
        "&:focus, &:focus-within": {
            outline: "none",
            borderColor: "transparent"
        },
        "&:disabled": {
            backgroundColor: "transparent",
            "&:focus, &:focus-within": {
                outline: "none",
                borderColor: "transparent"
            }
        }
    } : null
}
var useStyles$W = createStyles( (o, {multiline: i, radius: s, invalid: a, rightSectionWidth: _, withRightSection: $, iconWidth: _e, offsetBottom: tt, offsetTop: nt, pointer: rt}, {variant: ot, size: et}) => {
    const j = o.fn.variant({
        variant: "filled",
        color: "red"
    }).background
      , it = ot === "default" || ot === "filled" ? {
        minHeight: getSize({
            size: et,
            sizes: sizes$6
        }),
        paddingLeft: `calc(${getSize({
            size: et,
            sizes: sizes$6
        })}  / 3)`,
        paddingRight: $ ? _ || getSize({
            size: et,
            sizes: sizes$6
        }) : `calc(${getSize({
            size: et,
            sizes: sizes$6
        })}  / 3)`,
        borderRadius: o.fn.radius(s)
    } : ot === "unstyled" && $ ? {
        paddingRight: _ || getSize({
            size: et,
            sizes: sizes$6
        })
    } : null;
    return {
        wrapper: {
            position: "relative",
            marginTop: nt ? `calc(${o.spacing.xs} / 2)` : void 0,
            marginBottom: tt ? `calc(${o.spacing.xs} / 2)` : void 0,
            "&:has(input:disabled)": {
                "& .mantine-Input-rightSection": {
                    display: "none"
                }
            }
        },
        input: __spreadProps$v(__spreadValues$X(__spreadValues$X(__spreadProps$v(__spreadValues$X({}, o.fn.fontStyles()), {
            height: i ? ot === "unstyled" ? void 0 : "auto" : getSize({
                size: et,
                sizes: sizes$6
            }),
            WebkitTapHighlightColor: "transparent",
            lineHeight: i ? o.lineHeight : `calc(${getSize({
                size: et,
                sizes: sizes$6
            })} - ${rem(2)})`,
            appearance: "none",
            resize: "none",
            boxSizing: "border-box",
            fontSize: getSize({
                size: et,
                sizes: o.fontSizes
            }),
            width: "100%",
            color: o.colorScheme === "dark" ? o.colors.dark[0] : o.black,
            display: "block",
            textAlign: "left",
            cursor: rt ? "pointer" : void 0
        }), getVariantStyles$2({
            theme: o,
            variant: ot
        })), it), {
            "&:disabled, &[data-disabled]": {
                backgroundColor: o.colorScheme === "dark" ? o.colors.dark[6] : o.colors.gray[1],
                color: o.colors.dark[2],
                opacity: .6,
                cursor: "not-allowed",
                pointerEvents: "none",
                "&::placeholder": {
                    color: o.colors.dark[2]
                }
            },
            "&[data-invalid]": {
                color: j,
                borderColor: j,
                "&::placeholder": {
                    opacity: 1,
                    color: j
                }
            },
            "&[data-with-icon]": {
                paddingLeft: typeof _e == "number" ? rem(_e) : getSize({
                    size: et,
                    sizes: sizes$6
                })
            },
            "&::placeholder": __spreadProps$v(__spreadValues$X({}, o.fn.placeholderStyles()), {
                opacity: 1
            }),
            "&::-webkit-inner-spin-button, &::-webkit-outer-spin-button, &::-webkit-search-decoration, &::-webkit-search-cancel-button, &::-webkit-search-results-button, &::-webkit-search-results-decoration": {
                appearance: "none"
            },
            "&[type=number]": {
                MozAppearance: "textfield"
            }
        }),
        icon: {
            pointerEvents: "none",
            position: "absolute",
            zIndex: 1,
            left: 0,
            top: 0,
            bottom: 0,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            width: _e ? rem(_e) : getSize({
                size: et,
                sizes: sizes$6
            }),
            color: a ? o.colors.red[o.colorScheme === "dark" ? 6 : 7] : o.colorScheme === "dark" ? o.colors.dark[2] : o.colors.gray[5]
        },
        rightSection: {
            position: "absolute",
            top: 0,
            bottom: 0,
            right: 0,
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            width: _ || getSize({
                size: et,
                sizes: sizes$6
            })
        }
    }
}
);
const useStyles$X = useStyles$W;
var __defProp$W = Object.defineProperty
  , __defProps$u = Object.defineProperties
  , __getOwnPropDescs$u = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$W = Object.getOwnPropertySymbols
  , __hasOwnProp$W = Object.prototype.hasOwnProperty
  , __propIsEnum$W = Object.prototype.propertyIsEnumerable
  , __defNormalProp$W = (o, i, s) => i in o ? __defProp$W(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$W = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$W.call(i, s) && __defNormalProp$W(o, s, i[s]);
    if (__getOwnPropSymbols$W)
        for (var s of __getOwnPropSymbols$W(i))
            __propIsEnum$W.call(i, s) && __defNormalProp$W(o, s, i[s]);
    return o
}
  , __spreadProps$u = (o, i) => __defProps$u(o, __getOwnPropDescs$u(i))
  , __objRest$E = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$W.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$W)
        for (var a of __getOwnPropSymbols$W(o))
            i.indexOf(a) < 0 && __propIsEnum$W.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$w = {
    size: "sm",
    variant: "default"
}
  , _Input = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("Input", defaultProps$w, o)
      , {className: a, error: _, required: $, disabled: _e, variant: tt, icon: nt, style: rt, rightSectionWidth: ot, iconWidth: et, rightSection: j, rightSectionProps: it, radius: st, size: at, wrapperProps: lt, classNames: ct, styles: ut, __staticSelector: dt, multiline: ft, sx: ht, unstyled: pt, pointer: gt} = s
      , _t = __objRest$E(s, ["className", "error", "required", "disabled", "variant", "icon", "style", "rightSectionWidth", "iconWidth", "rightSection", "rightSectionProps", "radius", "size", "wrapperProps", "classNames", "styles", "__staticSelector", "multiline", "sx", "unstyled", "pointer"])
      , {offsetBottom: mt, offsetTop: yt, describedBy: bt} = useInputWrapperContext()
      , {classes: vt, cx: wt} = useStyles$X({
        radius: st,
        multiline: ft,
        invalid: !!_,
        rightSectionWidth: ot ? rem(ot) : void 0,
        iconWidth: et,
        withRightSection: !!j,
        offsetBottom: mt,
        offsetTop: yt,
        pointer: gt
    }, {
        classNames: ct,
        styles: ut,
        name: ["Input", dt],
        unstyled: pt,
        variant: tt,
        size: at
    })
      , {systemStyles: Tt, rest: $t} = extractSystemStyles(_t);
    return React.createElement(Box, __spreadValues$W(__spreadValues$W({
        className: wt(vt.wrapper, a),
        sx: ht,
        style: rt
    }, Tt), lt), nt && React.createElement("div", {
        className: vt.icon
    }, nt), React.createElement(Box, __spreadProps$u(__spreadValues$W({
        component: "input"
    }, $t), {
        ref: i,
        required: $,
        "aria-invalid": !!_,
        "aria-describedby": bt,
        disabled: _e,
        "data-disabled": _e || void 0,
        "data-with-icon": !!nt || void 0,
        "data-invalid": !!_ || void 0,
        className: vt.input
    })), j && React.createElement("div", __spreadProps$u(__spreadValues$W({}, it), {
        className: vt.rightSection
    }), j))
}
);
_Input.displayName = "@mantine/core/Input";
_Input.Wrapper = InputWrapper;
_Input.Label = InputLabel;
_Input.Description = InputDescription;
_Input.Error = InputError;
_Input.Placeholder = InputPlaceholder;
const Input = _Input;
var useStyles$U = createStyles( (o, {orientation: i, buttonBorderWidth: s}) => ({
    root: {
        display: "flex",
        flexDirection: i === "vertical" ? "column" : "row",
        "& [data-button]": {
            "&:first-of-type:not(:last-of-type)": {
                borderBottomRightRadius: 0,
                [i === "vertical" ? "borderBottomLeftRadius" : "borderTopRightRadius"]: 0,
                [i === "vertical" ? "borderBottomWidth" : "borderRightWidth"]: `calc(${rem(s)} / 2)`
            },
            "&:last-of-type:not(:first-of-type)": {
                borderTopLeftRadius: 0,
                [i === "vertical" ? "borderTopRightRadius" : "borderBottomLeftRadius"]: 0,
                [i === "vertical" ? "borderTopWidth" : "borderLeftWidth"]: `calc(${rem(s)} / 2)`
            },
            "&:not(:first-of-type):not(:last-of-type)": {
                borderRadius: 0,
                [i === "vertical" ? "borderTopWidth" : "borderLeftWidth"]: `calc(${rem(s)} / 2)`,
                [i === "vertical" ? "borderBottomWidth" : "borderRightWidth"]: `calc(${rem(s)} / 2)`
            },
            "& + [data-button]": {
                [i === "vertical" ? "marginTop" : "marginLeft"]: `calc(${s} * -1)`,
                "@media (min-resolution: 192dpi)": {
                    [i === "vertical" ? "marginTop" : "marginLeft"]: 0
                }
            }
        }
    }
}));
const useStyles$V = useStyles$U;
var __defProp$V = Object.defineProperty
  , __getOwnPropSymbols$V = Object.getOwnPropertySymbols
  , __hasOwnProp$V = Object.prototype.hasOwnProperty
  , __propIsEnum$V = Object.prototype.propertyIsEnumerable
  , __defNormalProp$V = (o, i, s) => i in o ? __defProp$V(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$V = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$V.call(i, s) && __defNormalProp$V(o, s, i[s]);
    if (__getOwnPropSymbols$V)
        for (var s of __getOwnPropSymbols$V(i))
            __propIsEnum$V.call(i, s) && __defNormalProp$V(o, s, i[s]);
    return o
}
  , __objRest$D = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$V.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$V)
        for (var a of __getOwnPropSymbols$V(o))
            i.indexOf(a) < 0 && __propIsEnum$V.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$v = {
    orientation: "horizontal",
    buttonBorderWidth: 1
}
  , ButtonGroup = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("ButtonGroup", defaultProps$v, o)
      , {className: a, orientation: _, buttonBorderWidth: $, unstyled: _e} = s
      , tt = __objRest$D(s, ["className", "orientation", "buttonBorderWidth", "unstyled"])
      , {classes: nt, cx: rt} = useStyles$V({
        orientation: _,
        buttonBorderWidth: $
    }, {
        name: "ButtonGroup",
        unstyled: _e
    });
    return React.createElement(Box, __spreadValues$V({
        className: rt(nt.root, a),
        ref: i
    }, tt))
}
);
ButtonGroup.displayName = "@mantine/core/ButtonGroup";
var __defProp$U = Object.defineProperty
  , __defProps$t = Object.defineProperties
  , __getOwnPropDescs$t = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$U = Object.getOwnPropertySymbols
  , __hasOwnProp$U = Object.prototype.hasOwnProperty
  , __propIsEnum$U = Object.prototype.propertyIsEnumerable
  , __defNormalProp$U = (o, i, s) => i in o ? __defProp$U(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$U = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$U.call(i, s) && __defNormalProp$U(o, s, i[s]);
    if (__getOwnPropSymbols$U)
        for (var s of __getOwnPropSymbols$U(i))
            __propIsEnum$U.call(i, s) && __defNormalProp$U(o, s, i[s]);
    return o
}
  , __spreadProps$t = (o, i) => __defProps$t(o, __getOwnPropDescs$t(i));
const BUTTON_VARIANTS = ["filled", "outline", "light", "white", "default", "subtle", "gradient"]
  , sizes$5 = {
    xs: {
        height: sizes$6.xs,
        paddingLeft: rem(14),
        paddingRight: rem(14)
    },
    sm: {
        height: sizes$6.sm,
        paddingLeft: rem(18),
        paddingRight: rem(18)
    },
    md: {
        height: sizes$6.md,
        paddingLeft: rem(22),
        paddingRight: rem(22)
    },
    lg: {
        height: sizes$6.lg,
        paddingLeft: rem(26),
        paddingRight: rem(26)
    },
    xl: {
        height: sizes$6.xl,
        paddingLeft: rem(32),
        paddingRight: rem(32)
    },
    "compact-xs": {
        height: rem(22),
        paddingLeft: rem(7),
        paddingRight: rem(7)
    },
    "compact-sm": {
        height: rem(26),
        paddingLeft: rem(8),
        paddingRight: rem(8)
    },
    "compact-md": {
        height: rem(30),
        paddingLeft: rem(10),
        paddingRight: rem(10)
    },
    "compact-lg": {
        height: rem(34),
        paddingLeft: rem(12),
        paddingRight: rem(12)
    },
    "compact-xl": {
        height: rem(40),
        paddingLeft: rem(14),
        paddingRight: rem(14)
    }
};
function getSizeStyles({compact: o, size: i, withLeftIcon: s, withRightIcon: a}) {
    if (o)
        return sizes$5[`compact-${i}`];
    const _ = sizes$5[i];
    return _ ? __spreadProps$t(__spreadValues$U({}, _), {
        paddingLeft: s ? `calc(${_.paddingLeft}  / 1.5)` : _.paddingLeft,
        paddingRight: a ? `calc(${_.paddingRight}  / 1.5)` : _.paddingRight
    }) : {}
}
const getWidthStyles = o => ({
    display: o ? "block" : "inline-block",
    width: o ? "100%" : "auto"
});
function getVariantStyles$1({variant: o, theme: i, color: s, gradient: a}) {
    if (!BUTTON_VARIANTS.includes(o))
        return null;
    const _ = i.fn.variant({
        color: s,
        variant: o,
        gradient: a
    });
    return o === "gradient" ? __spreadValues$U({
        border: 0,
        backgroundImage: _.background,
        color: _.color
    }, i.fn.hover({
        backgroundSize: "200%"
    })) : __spreadValues$U({
        border: `${rem(1)} solid ${_.border}`,
        backgroundColor: _.background,
        color: _.color
    }, i.fn.hover({
        backgroundColor: _.hover
    }))
}
var useStyles$S = createStyles( (o, {radius: i, fullWidth: s, compact: a, withLeftIcon: _, withRightIcon: $, color: _e, gradient: tt}, {variant: nt, size: rt}) => ({
    root: __spreadProps$t(__spreadValues$U(__spreadProps$t(__spreadValues$U(__spreadValues$U(__spreadValues$U(__spreadValues$U({}, getSizeStyles({
        compact: a,
        size: rt,
        withLeftIcon: _,
        withRightIcon: $
    })), o.fn.fontStyles()), o.fn.focusStyles()), getWidthStyles(s)), {
        borderRadius: o.fn.radius(i),
        fontWeight: 600,
        position: "relative",
        lineHeight: 1,
        fontSize: getSize({
            size: rt,
            sizes: o.fontSizes
        }),
        userSelect: "none",
        cursor: "pointer"
    }), getVariantStyles$1({
        variant: nt,
        theme: o,
        color: _e,
        gradient: tt
    })), {
        "&:active": o.activeStyles,
        "&:disabled, &[data-disabled]": {
            borderColor: "transparent",
            backgroundColor: o.colorScheme === "dark" ? o.colors.dark[4] : o.colors.gray[2],
            color: o.colorScheme === "dark" ? o.colors.dark[6] : o.colors.gray[5],
            cursor: "not-allowed",
            backgroundImage: "none",
            pointerEvents: "none",
            "&:active": {
                transform: "none"
            }
        },
        "&[data-loading]": {
            pointerEvents: "none",
            "&::before": __spreadProps$t(__spreadValues$U({
                content: '""'
            }, o.fn.cover(rem(-1))), {
                backgroundColor: o.colorScheme === "dark" ? o.fn.rgba(o.colors.dark[7], .5) : "rgba(255, 255, 255, .5)",
                borderRadius: o.fn.radius(i),
                cursor: "not-allowed"
            })
        }
    }),
    icon: {
        display: "flex",
        alignItems: "center"
    },
    leftIcon: {
        marginRight: o.spacing.xs
    },
    rightIcon: {
        marginLeft: o.spacing.xs
    },
    centerLoader: {
        position: "absolute",
        left: "50%",
        transform: "translateX(-50%)",
        opacity: .5
    },
    inner: {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        height: "100%",
        overflow: "visible"
    },
    label: {
        whiteSpace: "nowrap",
        height: "100%",
        overflow: "hidden",
        display: "flex",
        alignItems: "center"
    }
}));
const useStyles$T = useStyles$S;
var __defProp$T = Object.defineProperty
  , __getOwnPropSymbols$T = Object.getOwnPropertySymbols
  , __hasOwnProp$T = Object.prototype.hasOwnProperty
  , __propIsEnum$T = Object.prototype.propertyIsEnumerable
  , __defNormalProp$T = (o, i, s) => i in o ? __defProp$T(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$T = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$T.call(i, s) && __defNormalProp$T(o, s, i[s]);
    if (__getOwnPropSymbols$T)
        for (var s of __getOwnPropSymbols$T(i))
            __propIsEnum$T.call(i, s) && __defNormalProp$T(o, s, i[s]);
    return o
}
  , __objRest$C = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$T.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$T)
        for (var a of __getOwnPropSymbols$T(o))
            i.indexOf(a) < 0 && __propIsEnum$T.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$u = {
    size: "sm",
    type: "button",
    variant: "filled",
    loaderPosition: "left"
}
  , _Button = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("Button", defaultProps$u, o)
      , {className: a, size: _, color: $, type: _e, disabled: tt, children: nt, leftIcon: rt, rightIcon: ot, fullWidth: et, variant: j, radius: it, uppercase: st, compact: at, loading: lt, loaderPosition: ct, loaderProps: ut, gradient: dt, classNames: ft, styles: ht, unstyled: pt} = s
      , gt = __objRest$C(s, ["className", "size", "color", "type", "disabled", "children", "leftIcon", "rightIcon", "fullWidth", "variant", "radius", "uppercase", "compact", "loading", "loaderPosition", "loaderProps", "gradient", "classNames", "styles", "unstyled"])
      , {classes: _t, cx: mt, theme: yt} = useStyles$T({
        radius: it,
        color: $,
        fullWidth: et,
        compact: at,
        gradient: dt,
        withLeftIcon: !!rt,
        withRightIcon: !!ot
    }, {
        name: "Button",
        unstyled: pt,
        classNames: ft,
        styles: ht,
        variant: j,
        size: _
    })
      , bt = yt.fn.variant({
        color: $,
        variant: j
    })
      , vt = React.createElement(Loader, __spreadValues$T({
        color: bt.color,
        size: `calc(${getSize({
            size: _,
            sizes: sizes$5
        }).height} / 2)`
    }, ut));
    return React.createElement(UnstyledButton, __spreadValues$T({
        className: mt(_t.root, a),
        type: _e,
        disabled: tt,
        "data-button": !0,
        "data-disabled": tt || void 0,
        "data-loading": lt || void 0,
        ref: i,
        unstyled: pt
    }, gt), React.createElement("div", {
        className: _t.inner
    }, (rt || lt && ct === "left") && React.createElement("span", {
        className: mt(_t.icon, _t.leftIcon)
    }, lt && ct === "left" ? vt : rt), lt && ct === "center" && React.createElement("span", {
        className: _t.centerLoader
    }, vt), React.createElement("span", {
        className: _t.label,
        style: {
            textTransform: st ? "uppercase" : void 0
        }
    }, nt), (ot || lt && ct === "right") && React.createElement("span", {
        className: mt(_t.icon, _t.rightIcon)
    }, lt && ct === "right" ? vt : ot)))
}
);
_Button.displayName = "@mantine/core/Button";
_Button.Group = ButtonGroup;
const Button = _Button;
var useStyles$Q = createStyles( (o, {radius: i, shadow: s}) => ({
    root: {
        outline: 0,
        WebkitTapHighlightColor: "transparent",
        display: "block",
        textDecoration: "none",
        color: o.colorScheme === "dark" ? o.colors.dark[0] : o.black,
        backgroundColor: o.colorScheme === "dark" ? o.colors.dark[7] : o.white,
        boxSizing: "border-box",
        borderRadius: o.fn.radius(i),
        boxShadow: o.shadows[s] || s || "none",
        "&[data-with-border]": {
            border: `${rem(1)} solid ${o.colorScheme === "dark" ? o.colors.dark[4] : o.colors.gray[3]}`
        }
    }
}));
const useStyles$R = useStyles$Q;
var __defProp$S = Object.defineProperty
  , __getOwnPropSymbols$S = Object.getOwnPropertySymbols
  , __hasOwnProp$S = Object.prototype.hasOwnProperty
  , __propIsEnum$S = Object.prototype.propertyIsEnumerable
  , __defNormalProp$S = (o, i, s) => i in o ? __defProp$S(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$S = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$S.call(i, s) && __defNormalProp$S(o, s, i[s]);
    if (__getOwnPropSymbols$S)
        for (var s of __getOwnPropSymbols$S(i))
            __propIsEnum$S.call(i, s) && __defNormalProp$S(o, s, i[s]);
    return o
}
  , __objRest$B = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$S.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$S)
        for (var a of __getOwnPropSymbols$S(o))
            i.indexOf(a) < 0 && __propIsEnum$S.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$t = {}
  , _Paper = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("Paper", defaultProps$t, o)
      , {className: a, children: _, radius: $, withBorder: _e, shadow: tt, unstyled: nt, variant: rt} = s
      , ot = __objRest$B(s, ["className", "children", "radius", "withBorder", "shadow", "unstyled", "variant"])
      , {classes: et, cx: j} = useStyles$R({
        radius: $,
        shadow: tt
    }, {
        name: "Paper",
        unstyled: nt,
        variant: rt
    });
    return React.createElement(Box, __spreadValues$S({
        className: j(et.root, a),
        "data-with-border": _e || void 0,
        ref: i
    }, ot), _)
}
);
_Paper.displayName = "@mantine/core/Paper";
const Paper = _Paper;
var useStyles$O = createStyles( (o, {inline: i}) => ({
    root: {
        display: i ? "inline-flex" : "flex",
        alignItems: "center",
        justifyContent: "center"
    }
}));
const useStyles$P = useStyles$O;
var __defProp$R = Object.defineProperty
  , __getOwnPropSymbols$R = Object.getOwnPropertySymbols
  , __hasOwnProp$R = Object.prototype.hasOwnProperty
  , __propIsEnum$R = Object.prototype.propertyIsEnumerable
  , __defNormalProp$R = (o, i, s) => i in o ? __defProp$R(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$R = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$R.call(i, s) && __defNormalProp$R(o, s, i[s]);
    if (__getOwnPropSymbols$R)
        for (var s of __getOwnPropSymbols$R(i))
            __propIsEnum$R.call(i, s) && __defNormalProp$R(o, s, i[s]);
    return o
}
  , __objRest$A = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$R.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$R)
        for (var a of __getOwnPropSymbols$R(o))
            i.indexOf(a) < 0 && __propIsEnum$R.call(o, a) && (s[a] = o[a]);
    return s
}
;
const _Center = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("Center", {}, o)
      , {inline: a, className: _, unstyled: $, variant: _e} = s
      , tt = __objRest$A(s, ["inline", "className", "unstyled", "variant"])
      , {classes: nt, cx: rt} = useStyles$P({
        inline: a
    }, {
        name: "Center",
        unstyled: $,
        variant: _e
    });
    return React.createElement(Box, __spreadValues$R({
        ref: i,
        className: rt(nt.root, _)
    }, tt))
}
);
_Center.displayName = "@mantine/core/Center";
const Center = _Center
  , CheckboxGroupContext = reactExports.createContext(null)
  , CheckboxGroupProvider = CheckboxGroupContext.Provider
  , useCheckboxGroupContext = () => reactExports.useContext(CheckboxGroupContext);
var __defProp$Q = Object.defineProperty
  , __getOwnPropSymbols$Q = Object.getOwnPropertySymbols
  , __hasOwnProp$Q = Object.prototype.hasOwnProperty
  , __propIsEnum$Q = Object.prototype.propertyIsEnumerable
  , __defNormalProp$Q = (o, i, s) => i in o ? __defProp$Q(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$Q = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$Q.call(i, s) && __defNormalProp$Q(o, s, i[s]);
    if (__getOwnPropSymbols$Q)
        for (var s of __getOwnPropSymbols$Q(i))
            __propIsEnum$Q.call(i, s) && __defNormalProp$Q(o, s, i[s]);
    return o
}
  , __objRest$z = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$Q.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$Q)
        for (var a of __getOwnPropSymbols$Q(o))
            i.indexOf(a) < 0 && __propIsEnum$Q.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$s = {
    size: "sm"
}
  , CheckboxGroup = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("CheckboxGroup", defaultProps$s, o)
      , {children: a, value: _, defaultValue: $, onChange: _e, size: tt, wrapperProps: nt} = s
      , rt = __objRest$z(s, ["children", "value", "defaultValue", "onChange", "size", "wrapperProps"])
      , [ot,et] = useUncontrolled({
        value: _,
        defaultValue: $,
        finalValue: [],
        onChange: _e
    })
      , j = it => {
        const st = it.currentTarget.value;
        et(ot.includes(st) ? ot.filter(at => at !== st) : [...ot, st])
    }
    ;
    return React.createElement(CheckboxGroupProvider, {
        value: {
            value: ot,
            onChange: j,
            size: tt
        }
    }, React.createElement(Input.Wrapper, __spreadValues$Q(__spreadValues$Q({
        labelElement: "div",
        size: tt,
        __staticSelector: "CheckboxGroup",
        ref: i
    }, nt), rt), a))
}
);
CheckboxGroup.displayName = "@mantine/core/CheckboxGroup";
var __defProp$P = Object.defineProperty
  , __getOwnPropSymbols$P = Object.getOwnPropertySymbols
  , __hasOwnProp$P = Object.prototype.hasOwnProperty
  , __propIsEnum$P = Object.prototype.propertyIsEnumerable
  , __defNormalProp$P = (o, i, s) => i in o ? __defProp$P(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$P = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$P.call(i, s) && __defNormalProp$P(o, s, i[s]);
    if (__getOwnPropSymbols$P)
        for (var s of __getOwnPropSymbols$P(i))
            __propIsEnum$P.call(i, s) && __defNormalProp$P(o, s, i[s]);
    return o
}
  , __objRest$y = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$P.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$P)
        for (var a of __getOwnPropSymbols$P(o))
            i.indexOf(a) < 0 && __propIsEnum$P.call(o, a) && (s[a] = o[a]);
    return s
}
;
function CheckIcon(o) {
    const i = o
      , {width: s, height: a, style: _} = i
      , $ = __objRest$y(i, ["width", "height", "style"]);
    return React.createElement("svg", __spreadValues$P({
        viewBox: "0 0 10 7",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        style: __spreadValues$P({
            width: s,
            height: a
        }, _)
    }, $), React.createElement("path", {
        d: "M4 4.586L1.707 2.293A1 1 0 1 0 .293 3.707l3 3a.997.997 0 0 0 1.414 0l5-5A1 1 0 1 0 8.293.293L4 4.586z",
        fill: "currentColor",
        fillRule: "evenodd",
        clipRule: "evenodd"
    }))
}
function CheckboxIcon(o) {
    var i = o
      , {indeterminate: s} = i
      , a = __objRest$y(i, ["indeterminate"]);
    return s ? React.createElement("svg", __spreadValues$P({
        xmlns: "http://www.w3.org/2000/svg",
        fill: "none",
        viewBox: "0 0 32 6"
    }, a), React.createElement("rect", {
        width: "32",
        height: "6",
        fill: "currentColor",
        rx: "3"
    })) : React.createElement(CheckIcon, __spreadValues$P({}, a))
}
var __defProp$O = Object.defineProperty
  , __defProps$s = Object.defineProperties
  , __getOwnPropDescs$s = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$O = Object.getOwnPropertySymbols
  , __hasOwnProp$O = Object.prototype.hasOwnProperty
  , __propIsEnum$O = Object.prototype.propertyIsEnumerable
  , __defNormalProp$O = (o, i, s) => i in o ? __defProp$O(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$O = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$O.call(i, s) && __defNormalProp$O(o, s, i[s]);
    if (__getOwnPropSymbols$O)
        for (var s of __getOwnPropSymbols$O(i))
            __propIsEnum$O.call(i, s) && __defNormalProp$O(o, s, i[s]);
    return o
}
  , __spreadProps$s = (o, i) => __defProps$s(o, __getOwnPropDescs$s(i));
const sizes$4 = {
    xs: rem(16),
    sm: rem(20),
    md: rem(24),
    lg: rem(30),
    xl: rem(36)
};
var useStyles$M = createStyles( (o, {radius: i, color: s, transitionDuration: a, labelPosition: _, error: $, indeterminate: _e}, {size: tt}) => {
    const nt = getSize({
        size: tt,
        sizes: sizes$4
    })
      , rt = o.fn.variant({
        variant: "filled",
        color: s
    });
    return {
        icon: __spreadProps$s(__spreadValues$O({}, o.fn.cover()), {
            ref: getStylesRef("icon"),
            color: _e ? "inherit" : o.white,
            transform: _e ? "none" : `translateY(${rem(5)}) scale(0.5)`,
            opacity: _e ? 1 : 0,
            transitionProperty: "opacity, transform",
            transitionTimingFunction: "ease",
            transitionDuration: `${a}ms`,
            pointerEvents: "none",
            width: "60%",
            position: "absolute",
            zIndex: 1,
            margin: "auto",
            "@media (prefers-reduced-motion)": {
                transitionDuration: o.respectReducedMotion ? "0ms" : void 0
            }
        }),
        inner: {
            position: "relative",
            width: nt,
            height: nt,
            order: _ === "left" ? 2 : 1
        },
        input: __spreadProps$s(__spreadValues$O({}, o.fn.focusStyles()), {
            appearance: "none",
            backgroundColor: o.colorScheme === "dark" ? o.colors.dark[6] : o.white,
            border: `${rem(1)} solid ${$ ? o.fn.variant({
                variant: "filled",
                color: "red"
            }).background : o.colorScheme === "dark" ? o.colors.dark[4] : o.colors.gray[4]}`,
            width: nt,
            height: nt,
            borderRadius: o.fn.radius(i),
            padding: 0,
            display: "block",
            margin: 0,
            transition: `border-color ${a}ms ease, background-color ${a}ms ease`,
            cursor: o.cursorType,
            "&:checked": {
                backgroundColor: rt.background,
                borderColor: rt.background,
                [`& + .${getStylesRef("icon")}`]: {
                    opacity: 1,
                    color: o.white,
                    transform: "translateY(0) scale(1)"
                }
            },
            "&:disabled": {
                backgroundColor: o.colorScheme === "dark" ? o.colors.dark[4] : o.colors.gray[2],
                borderColor: o.colorScheme === "dark" ? o.colors.dark[6] : o.colors.gray[3],
                cursor: "not-allowed",
                pointerEvents: "none",
                [`& + .${getStylesRef("icon")}`]: {
                    color: o.colorScheme === "dark" ? o.colors.dark[6] : o.colors.gray[5]
                }
            }
        })
    }
}
);
const useStyles$N = useStyles$M;
var __defProp$N = Object.defineProperty
  , __defProps$r = Object.defineProperties
  , __getOwnPropDescs$r = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$N = Object.getOwnPropertySymbols
  , __hasOwnProp$N = Object.prototype.hasOwnProperty
  , __propIsEnum$N = Object.prototype.propertyIsEnumerable
  , __defNormalProp$N = (o, i, s) => i in o ? __defProp$N(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$N = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$N.call(i, s) && __defNormalProp$N(o, s, i[s]);
    if (__getOwnPropSymbols$N)
        for (var s of __getOwnPropSymbols$N(i))
            __propIsEnum$N.call(i, s) && __defNormalProp$N(o, s, i[s]);
    return o
}
  , __spreadProps$r = (o, i) => __defProps$r(o, __getOwnPropDescs$r(i));
const sizes$3 = {
    xs: rem(16),
    sm: rem(20),
    md: rem(24),
    lg: rem(30),
    xl: rem(36)
};
var useStyles$K = createStyles( (o, {labelPosition: i}, {size: s}) => ({
    root: {},
    body: {
        display: "flex",
        "&:has(input:disabled) label": {
            color: o.colorScheme === "dark" ? o.colors.dark[3] : o.colors.gray[5]
        }
    },
    labelWrapper: __spreadProps$r(__spreadValues$N({}, o.fn.fontStyles()), {
        display: "inline-flex",
        flexDirection: "column",
        WebkitTapHighlightColor: "transparent",
        fontSize: s in sizes$3 ? getSize({
            size: s,
            sizes: o.fontSizes
        }) : void 0,
        lineHeight: s in sizes$3 ? getSize({
            size: s,
            sizes: sizes$3
        }) : void 0,
        color: o.colorScheme === "dark" ? o.colors.dark[0] : o.black,
        cursor: o.cursorType,
        order: i === "left" ? 1 : 2
    }),
    description: {
        marginTop: `calc(${o.spacing.xs} / 2)`,
        [i === "left" ? "paddingRight" : "paddingLeft"]: o.spacing.sm
    },
    error: {
        marginTop: `calc(${o.spacing.xs} / 2)`,
        [i === "left" ? "paddingRight" : "paddingLeft"]: o.spacing.sm
    },
    label: {
        cursor: o.cursorType,
        [i === "left" ? "paddingRight" : "paddingLeft"]: o.spacing.sm,
        "&:disabled, &[data-disabled]": {
            color: o.colorScheme === "dark" ? o.colors.dark[3] : o.colors.gray[5]
        }
    }
}));
const useStyles$L = useStyles$K;
var __defProp$M = Object.defineProperty
  , __getOwnPropSymbols$M = Object.getOwnPropertySymbols
  , __hasOwnProp$M = Object.prototype.hasOwnProperty
  , __propIsEnum$M = Object.prototype.propertyIsEnumerable
  , __defNormalProp$M = (o, i, s) => i in o ? __defProp$M(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$M = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$M.call(i, s) && __defNormalProp$M(o, s, i[s]);
    if (__getOwnPropSymbols$M)
        for (var s of __getOwnPropSymbols$M(i))
            __propIsEnum$M.call(i, s) && __defNormalProp$M(o, s, i[s]);
    return o
}
  , __objRest$x = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$M.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$M)
        for (var a of __getOwnPropSymbols$M(o))
            i.indexOf(a) < 0 && __propIsEnum$M.call(o, a) && (s[a] = o[a]);
    return s
}
;
const InlineInput = reactExports.forwardRef( (o, i) => {
    var s = o
      , {__staticSelector: a, className: _, classNames: $, styles: _e, unstyled: tt, children: nt, label: rt, description: ot, id: et, disabled: j, error: it, size: st, labelPosition: at, variant: lt} = s
      , ct = __objRest$x(s, ["__staticSelector", "className", "classNames", "styles", "unstyled", "children", "label", "description", "id", "disabled", "error", "size", "labelPosition", "variant"]);
    const {classes: ut, cx: dt} = useStyles$L({
        labelPosition: at
    }, {
        name: a,
        styles: _e,
        classNames: $,
        unstyled: tt,
        variant: lt,
        size: st
    });
    return React.createElement(Box, __spreadValues$M({
        className: dt(ut.root, _),
        ref: i
    }, ct), React.createElement("div", {
        className: dt(ut.body)
    }, nt, React.createElement("div", {
        className: ut.labelWrapper
    }, rt && React.createElement("label", {
        className: ut.label,
        "data-disabled": j || void 0,
        htmlFor: et
    }, rt), ot && React.createElement(Input.Description, {
        className: ut.description
    }, ot), it && it !== "boolean" && React.createElement(Input.Error, {
        className: ut.error
    }, it))))
}
);
InlineInput.displayName = "@mantine/core/InlineInput";
var __defProp$L = Object.defineProperty
  , __getOwnPropSymbols$L = Object.getOwnPropertySymbols
  , __hasOwnProp$L = Object.prototype.hasOwnProperty
  , __propIsEnum$L = Object.prototype.propertyIsEnumerable
  , __defNormalProp$L = (o, i, s) => i in o ? __defProp$L(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$L = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$L.call(i, s) && __defNormalProp$L(o, s, i[s]);
    if (__getOwnPropSymbols$L)
        for (var s of __getOwnPropSymbols$L(i))
            __propIsEnum$L.call(i, s) && __defNormalProp$L(o, s, i[s]);
    return o
}
  , __objRest$w = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$L.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$L)
        for (var a of __getOwnPropSymbols$L(o))
            i.indexOf(a) < 0 && __propIsEnum$L.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$r = {
    size: "sm",
    transitionDuration: 100,
    icon: CheckboxIcon,
    labelPosition: "right"
}
  , Checkbox = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("Checkbox", defaultProps$r, o)
      , {className: a, style: _, sx: $, checked: _e, disabled: tt, color: nt, label: rt, indeterminate: ot, id: et, size: j, radius: it, wrapperProps: st, children: at, classNames: lt, styles: ct, transitionDuration: ut, icon: dt, unstyled: ft, labelPosition: ht, description: pt, error: gt, variant: _t} = s
      , mt = __objRest$w(s, ["className", "style", "sx", "checked", "disabled", "color", "label", "indeterminate", "id", "size", "radius", "wrapperProps", "children", "classNames", "styles", "transitionDuration", "icon", "unstyled", "labelPosition", "description", "error", "variant"])
      , yt = useCheckboxGroupContext()
      , bt = useId(et)
      , {systemStyles: vt, rest: wt} = extractSystemStyles(mt)
      , {classes: Tt} = useStyles$N({
        radius: it,
        color: nt,
        transitionDuration: ut,
        labelPosition: ht,
        error: !!gt,
        indeterminate: ot
    }, {
        name: "Checkbox",
        classNames: lt,
        styles: ct,
        unstyled: ft,
        variant: _t,
        size: (yt == null ? void 0 : yt.size) || j
    })
      , $t = yt ? {
        checked: yt.value.includes(wt.value),
        onChange: yt.onChange
    } : {};
    return React.createElement(InlineInput, __spreadValues$L(__spreadValues$L({
        className: a,
        sx: $,
        style: _,
        id: bt,
        size: (yt == null ? void 0 : yt.size) || j,
        labelPosition: ht,
        label: rt,
        description: pt,
        error: gt,
        disabled: tt,
        __staticSelector: "Checkbox",
        classNames: lt,
        styles: ct,
        unstyled: ft,
        "data-checked": $t.checked || void 0,
        variant: _t
    }, vt), st), React.createElement("div", {
        className: Tt.inner
    }, React.createElement("input", __spreadValues$L(__spreadValues$L({
        id: bt,
        ref: i,
        type: "checkbox",
        className: Tt.input,
        checked: _e,
        disabled: tt
    }, wt), $t)), React.createElement(dt, {
        indeterminate: ot,
        className: Tt.icon
    })))
}
);
Checkbox.displayName = "@mantine/core/Checkbox";
Checkbox.Group = CheckboxGroup;
var useStyles$I = createStyles( (o, {fluid: i, sizes: s}, {size: a}) => ({
    root: {
        paddingLeft: o.spacing.md,
        paddingRight: o.spacing.md,
        maxWidth: i ? "100%" : getSize({
            size: a,
            sizes: s
        }),
        marginLeft: "auto",
        marginRight: "auto"
    }
}));
const useStyles$J = useStyles$I;
var __defProp$K = Object.defineProperty
  , __getOwnPropSymbols$K = Object.getOwnPropertySymbols
  , __hasOwnProp$K = Object.prototype.hasOwnProperty
  , __propIsEnum$K = Object.prototype.propertyIsEnumerable
  , __defNormalProp$K = (o, i, s) => i in o ? __defProp$K(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$K = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$K.call(i, s) && __defNormalProp$K(o, s, i[s]);
    if (__getOwnPropSymbols$K)
        for (var s of __getOwnPropSymbols$K(i))
            __propIsEnum$K.call(i, s) && __defNormalProp$K(o, s, i[s]);
    return o
}
  , __objRest$v = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$K.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$K)
        for (var a of __getOwnPropSymbols$K(o))
            i.indexOf(a) < 0 && __propIsEnum$K.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$q = {
    sizes: {
        xs: rem(540),
        sm: rem(720),
        md: rem(960),
        lg: rem(1140),
        xl: rem(1320)
    }
}
  , Container = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("Container", defaultProps$q, o)
      , {className: a, fluid: _, size: $, unstyled: _e, sizes: tt, variant: nt} = s
      , rt = __objRest$v(s, ["className", "fluid", "size", "unstyled", "sizes", "variant"])
      , {classes: ot, cx: et} = useStyles$J({
        fluid: _,
        sizes: tt
    }, {
        unstyled: _e,
        name: "Container",
        variant: nt,
        size: $
    });
    return React.createElement(Box, __spreadValues$K({
        className: et(ot.root, a),
        ref: i
    }, rt))
}
);
Container.displayName = "@mantine/core/Container";
const [ModalBaseProvider,useModalBaseContext] = createSafeContext("ModalBase component was not found in tree");
var useStyles$G = createStyles( () => ({
    close: {
        marginLeft: "auto",
        marginRight: 0
    }
}));
const useStyles$H = useStyles$G;
var __defProp$J = Object.defineProperty
  , __getOwnPropSymbols$J = Object.getOwnPropertySymbols
  , __hasOwnProp$J = Object.prototype.hasOwnProperty
  , __propIsEnum$J = Object.prototype.propertyIsEnumerable
  , __defNormalProp$J = (o, i, s) => i in o ? __defProp$J(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$J = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$J.call(i, s) && __defNormalProp$J(o, s, i[s]);
    if (__getOwnPropSymbols$J)
        for (var s of __getOwnPropSymbols$J(i))
            __propIsEnum$J.call(i, s) && __defNormalProp$J(o, s, i[s]);
    return o
}
  , __objRest$u = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$J.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$J)
        for (var a of __getOwnPropSymbols$J(o))
            i.indexOf(a) < 0 && __propIsEnum$J.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$p = {
    size: "sm"
}
  , ModalBaseCloseButton = reactExports.forwardRef( (o, i) => {
    const s = useModalBaseContext()
      , a = useComponentDefaultProps(`${s.__staticSelector}CloseButton`, defaultProps$p, o)
      , {className: _} = a
      , $ = __objRest$u(a, ["className"])
      , {classes: _e, cx: tt} = useStyles$H(null, s.stylesApi);
    return React.createElement(CloseButton, __spreadValues$J({
        className: tt(_e.close, _),
        ref: i,
        onClick: s.onClose
    }, $))
}
);
var useStyles$E = createStyles( () => ({
    overlay: {}
}));
const useStyles$F = useStyles$E;
var __defProp$I = Object.defineProperty
  , __defProps$q = Object.defineProperties
  , __getOwnPropDescs$q = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$I = Object.getOwnPropertySymbols
  , __hasOwnProp$I = Object.prototype.hasOwnProperty
  , __propIsEnum$I = Object.prototype.propertyIsEnumerable
  , __defNormalProp$I = (o, i, s) => i in o ? __defProp$I(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$I = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$I.call(i, s) && __defNormalProp$I(o, s, i[s]);
    if (__getOwnPropSymbols$I)
        for (var s of __getOwnPropSymbols$I(i))
            __propIsEnum$I.call(i, s) && __defNormalProp$I(o, s, i[s]);
    return o
}
  , __spreadProps$q = (o, i) => __defProps$q(o, __getOwnPropDescs$q(i))
  , useStyles$C = createStyles( (o, {color: i, opacity: s, blur: a, radius: _, gradient: $, fixed: _e, zIndex: tt}) => ({
    root: __spreadProps$q(__spreadValues$I({}, o.fn.cover(0)), {
        position: _e ? "fixed" : "absolute",
        backgroundColor: $ ? void 0 : o.fn.rgba(i, s),
        backgroundImage: $,
        backdropFilter: a ? `blur(${rem(a)})` : void 0,
        borderRadius: o.fn.radius(_),
        zIndex: tt,
        "&[data-center]": {
            display: "flex",
            alignItems: "center",
            justifyContent: "center"
        }
    })
}));
const useStyles$D = useStyles$C;
var __defProp$H = Object.defineProperty
  , __getOwnPropSymbols$H = Object.getOwnPropertySymbols
  , __hasOwnProp$H = Object.prototype.hasOwnProperty
  , __propIsEnum$H = Object.prototype.propertyIsEnumerable
  , __defNormalProp$H = (o, i, s) => i in o ? __defProp$H(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$H = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$H.call(i, s) && __defNormalProp$H(o, s, i[s]);
    if (__getOwnPropSymbols$H)
        for (var s of __getOwnPropSymbols$H(i))
            __propIsEnum$H.call(i, s) && __defNormalProp$H(o, s, i[s]);
    return o
}
  , __objRest$t = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$H.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$H)
        for (var a of __getOwnPropSymbols$H(o))
            i.indexOf(a) < 0 && __propIsEnum$H.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$o = {
    opacity: .6,
    color: "#000",
    zIndex: getDefaultZIndex("modal"),
    radius: 0
}
  , _Overlay = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("Overlay", defaultProps$o, o)
      , {variant: a, opacity: _, color: $, blur: _e, gradient: tt, zIndex: nt, radius: rt, children: ot, className: et, classNames: j, styles: it, unstyled: st, center: at, fixed: lt} = s
      , ct = __objRest$t(s, ["variant", "opacity", "color", "blur", "gradient", "zIndex", "radius", "children", "className", "classNames", "styles", "unstyled", "center", "fixed"])
      , {classes: ut, cx: dt} = useStyles$D({
        color: $,
        opacity: _,
        blur: _e,
        radius: rt,
        gradient: tt,
        fixed: lt,
        zIndex: nt
    }, {
        name: "Overlay",
        classNames: j,
        styles: it,
        unstyled: st,
        variant: a
    });
    return React.createElement(Box, __spreadValues$H({
        ref: i,
        className: dt(ut.root, et),
        "data-center": at || void 0
    }, ct), ot)
}
);
_Overlay.displayName = "@mantine/core/Overlay";
const Overlay = _Overlay;
var __defProp$G = Object.defineProperty
  , __defProps$p = Object.defineProperties
  , __getOwnPropDescs$p = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$G = Object.getOwnPropertySymbols
  , __hasOwnProp$G = Object.prototype.hasOwnProperty
  , __propIsEnum$G = Object.prototype.propertyIsEnumerable
  , __defNormalProp$G = (o, i, s) => i in o ? __defProp$G(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$G = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$G.call(i, s) && __defNormalProp$G(o, s, i[s]);
    if (__getOwnPropSymbols$G)
        for (var s of __getOwnPropSymbols$G(i))
            __propIsEnum$G.call(i, s) && __defNormalProp$G(o, s, i[s]);
    return o
}
  , __spreadProps$p = (o, i) => __defProps$p(o, __getOwnPropDescs$p(i))
  , __objRest$s = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$G.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$G)
        for (var a of __getOwnPropSymbols$G(o))
            i.indexOf(a) < 0 && __propIsEnum$G.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$n = {}
  , ModalBaseOverlay = reactExports.forwardRef( (o, i) => {
    const s = useModalBaseContext()
      , a = useComponentDefaultProps(`${s.__staticSelector}Overlay`, defaultProps$n, o)
      , {onClick: _, transitionProps: $, style: _e, className: tt} = a
      , nt = __objRest$s(a, ["onClick", "transitionProps", "style", "className"])
      , {classes: rt, cx: ot} = useStyles$F(null, s.stylesApi)
      , et = j => {
        _ == null || _(j),
        s.closeOnClickOutside && s.onClose()
    }
    ;
    return React.createElement(Transition$2, __spreadProps$p(__spreadValues$G(__spreadValues$G({
        mounted: s.opened
    }, s.transitionProps), $), {
        transition: "fade"
    }), j => React.createElement(Overlay, __spreadValues$G({
        ref: i,
        onClick: et,
        fixed: !0,
        style: __spreadValues$G(__spreadValues$G({}, _e), j),
        className: ot(rt.overlay, tt),
        zIndex: s.zIndex
    }, nt)))
}
);
var useStyles$A = createStyles( (o, {zIndex: i}) => ({
    inner: {
        position: "fixed",
        width: "100%",
        top: 0,
        bottom: 0,
        maxHeight: "100%",
        zIndex: i,
        pointerEvents: "none"
    },
    content: {
        pointerEvents: "all"
    }
}));
const useStyles$B = useStyles$A;
var __defProp$F = Object.defineProperty
  , __getOwnPropSymbols$F = Object.getOwnPropertySymbols
  , __hasOwnProp$F = Object.prototype.hasOwnProperty
  , __propIsEnum$F = Object.prototype.propertyIsEnumerable
  , __defNormalProp$F = (o, i, s) => i in o ? __defProp$F(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$F = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$F.call(i, s) && __defNormalProp$F(o, s, i[s]);
    if (__getOwnPropSymbols$F)
        for (var s of __getOwnPropSymbols$F(i))
            __propIsEnum$F.call(i, s) && __defNormalProp$F(o, s, i[s]);
    return o
}
  , __objRest$r = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$F.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$F)
        for (var a of __getOwnPropSymbols$F(o))
            i.indexOf(a) < 0 && __propIsEnum$F.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$m = {}
  , ModalBaseContent = reactExports.forwardRef( (o, i) => {
    const s = useModalBaseContext()
      , a = useComponentDefaultProps(`${s.__staticSelector}Content`, defaultProps$m, o)
      , {className: _, transitionProps: $, style: _e, onKeyDown: tt} = a
      , nt = __objRest$r(a, ["className", "transitionProps", "style", "onKeyDown"])
      , {classes: rt, cx: ot} = useStyles$B({
        zIndex: s.zIndex
    }, s.stylesApi)
      , et = j => {
        var it;
        ((it = j.target) == null ? void 0 : it.getAttribute("data-mantine-stop-propagation")) !== "true" && j.key === "Escape" && s.closeOnEscape && s.onClose(),
        tt == null || tt(j)
    }
    ;
    return React.createElement(Transition$2, __spreadValues$F(__spreadValues$F({
        mounted: s.opened,
        transition: "pop"
    }, s.transitionProps), $), j => React.createElement("div", {
        className: ot(rt.inner)
    }, React.createElement(FocusTrap, {
        active: s.opened && s.trapFocus
    }, React.createElement(Paper, __spreadValues$F({
        component: "section",
        role: "dialog",
        tabIndex: -1,
        "aria-modal": !0,
        "aria-describedby": s.bodyMounted ? s.getBodyId() : void 0,
        "aria-labelledby": s.titleMounted ? s.getTitleId() : void 0,
        onKeyDown: et,
        ref: i,
        className: ot(rt.content, _),
        style: __spreadValues$F(__spreadValues$F({}, _e), j),
        shadow: s.shadow
    }, nt), nt.children))))
}
);
var useStyles$y = createStyles( (o, {padding: i}) => {
    const s = getSize({
        size: i,
        sizes: o.spacing
    });
    return {
        header: {
            display: "flex",
            justifyContent: "space-between",
            alignItems: "center",
            padding: s,
            paddingRight: `calc(${s} - ${rem(5)})`,
            position: "sticky",
            top: 0,
            backgroundColor: o.colorScheme === "dark" ? o.colors.dark[7] : o.white,
            zIndex: 1e3
        }
    }
}
);
const useStyles$z = useStyles$y;
var __defProp$E = Object.defineProperty
  , __getOwnPropSymbols$E = Object.getOwnPropertySymbols
  , __hasOwnProp$E = Object.prototype.hasOwnProperty
  , __propIsEnum$E = Object.prototype.propertyIsEnumerable
  , __defNormalProp$E = (o, i, s) => i in o ? __defProp$E(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$E = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$E.call(i, s) && __defNormalProp$E(o, s, i[s]);
    if (__getOwnPropSymbols$E)
        for (var s of __getOwnPropSymbols$E(i))
            __propIsEnum$E.call(i, s) && __defNormalProp$E(o, s, i[s]);
    return o
}
  , __objRest$q = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$E.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$E)
        for (var a of __getOwnPropSymbols$E(o))
            i.indexOf(a) < 0 && __propIsEnum$E.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$l = {}
  , ModalBaseHeader = reactExports.forwardRef( (o, i) => {
    const s = useModalBaseContext()
      , a = useComponentDefaultProps(`${s.__staticSelector}Header`, defaultProps$l, o)
      , {className: _} = a
      , $ = __objRest$q(a, ["className"])
      , {classes: _e, cx: tt} = useStyles$z({
        padding: s.padding
    }, s.stylesApi);
    return React.createElement(Box, __spreadValues$E({
        ref: i,
        className: tt(_e.header, _)
    }, $))
}
);
var useStyles$w = createStyles(o => ({
    title: {
        lineHeight: 1,
        padding: 0,
        margin: 0,
        fontWeight: 400,
        fontSize: o.fontSizes.md
    }
}));
const useStyles$x = useStyles$w;
var __defProp$D = Object.defineProperty
  , __getOwnPropSymbols$D = Object.getOwnPropertySymbols
  , __hasOwnProp$D = Object.prototype.hasOwnProperty
  , __propIsEnum$D = Object.prototype.propertyIsEnumerable
  , __defNormalProp$D = (o, i, s) => i in o ? __defProp$D(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$D = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$D.call(i, s) && __defNormalProp$D(o, s, i[s]);
    if (__getOwnPropSymbols$D)
        for (var s of __getOwnPropSymbols$D(i))
            __propIsEnum$D.call(i, s) && __defNormalProp$D(o, s, i[s]);
    return o
}
  , __objRest$p = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$D.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$D)
        for (var a of __getOwnPropSymbols$D(o))
            i.indexOf(a) < 0 && __propIsEnum$D.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$k = {}
  , ModalBaseTitle = reactExports.forwardRef( (o, i) => {
    const s = useModalBaseContext()
      , a = useComponentDefaultProps(`${s.__staticSelector}Title`, defaultProps$k, o)
      , {className: _} = a
      , $ = __objRest$p(a, ["className"])
      , {classes: _e, cx: tt} = useStyles$x(null, s.stylesApi);
    return reactExports.useEffect( () => (s.setTitleMounted(!0),
    () => s.setTitleMounted(!1)), []),
    React.createElement(Box, __spreadValues$D({
        component: "h2",
        id: s.getTitleId(),
        className: tt(_e.title, _),
        ref: i
    }, $))
}
);
var useStyles$u = createStyles( (o, {padding: i}) => ({
    body: {
        padding: getSize({
            size: i,
            sizes: o.spacing
        }),
        "&:not(:only-child)": {
            paddingTop: 0
        }
    }
}));
const useStyles$v = useStyles$u;
var __defProp$C = Object.defineProperty
  , __getOwnPropSymbols$C = Object.getOwnPropertySymbols
  , __hasOwnProp$C = Object.prototype.hasOwnProperty
  , __propIsEnum$C = Object.prototype.propertyIsEnumerable
  , __defNormalProp$C = (o, i, s) => i in o ? __defProp$C(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$C = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$C.call(i, s) && __defNormalProp$C(o, s, i[s]);
    if (__getOwnPropSymbols$C)
        for (var s of __getOwnPropSymbols$C(i))
            __propIsEnum$C.call(i, s) && __defNormalProp$C(o, s, i[s]);
    return o
}
  , __objRest$o = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$C.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$C)
        for (var a of __getOwnPropSymbols$C(o))
            i.indexOf(a) < 0 && __propIsEnum$C.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$j = {}
  , ModalBaseBody = reactExports.forwardRef( (o, i) => {
    const s = useModalBaseContext()
      , a = useComponentDefaultProps(`${s.__staticSelector}Body`, defaultProps$j, o)
      , {className: _} = a
      , $ = __objRest$o(a, ["className"])
      , {classes: _e, cx: tt} = useStyles$v({
        padding: s.padding
    }, s.stylesApi);
    return reactExports.useEffect( () => (s.setBodyMounted(!0),
    () => s.setBodyMounted(!1)), []),
    React.createElement(Box, __spreadValues$C({
        id: s.getBodyId(),
        className: tt(_e.body, _),
        ref: i
    }, $))
}
);
function NativeScrollArea({children: o}) {
    return React.createElement(React.Fragment, null, o)
}
function useLockScroll({opened: o, transitionDuration: i}) {
    const [s,a] = reactExports.useState(o)
      , _ = reactExports.useRef()
      , _e = useReducedMotion() ? 0 : i;
    return reactExports.useEffect( () => (o ? (a(!0),
    window.clearTimeout(_.current)) : _e === 0 ? a(!1) : _.current = window.setTimeout( () => a(!1), _e),
    () => window.clearTimeout(_.current)), [o, _e]),
    s
}
var useStyles$s = createStyles( () => ({
    root: {}
}));
const useStyles$t = useStyles$s;
var __defProp$B = Object.defineProperty
  , __defProps$o = Object.defineProperties
  , __getOwnPropDescs$o = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$B = Object.getOwnPropertySymbols
  , __hasOwnProp$B = Object.prototype.hasOwnProperty
  , __propIsEnum$B = Object.prototype.propertyIsEnumerable
  , __defNormalProp$B = (o, i, s) => i in o ? __defProp$B(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$B = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$B.call(i, s) && __defNormalProp$B(o, s, i[s]);
    if (__getOwnPropSymbols$B)
        for (var s of __getOwnPropSymbols$B(i))
            __propIsEnum$B.call(i, s) && __defNormalProp$B(o, s, i[s]);
    return o
}
  , __spreadProps$o = (o, i) => __defProps$o(o, __getOwnPropDescs$o(i))
  , __objRest$n = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$B.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$B)
        for (var a of __getOwnPropSymbols$B(o))
            i.indexOf(a) < 0 && __propIsEnum$B.call(o, a) && (s[a] = o[a]);
    return s
}
;
const ModalBaseDefaultProps = {
    closeOnClickOutside: !0,
    withinPortal: !0,
    lockScroll: !0,
    trapFocus: !0,
    returnFocus: !0,
    closeOnEscape: !0,
    keepMounted: !1,
    zIndex: getDefaultZIndex("modal"),
    padding: "md",
    size: "md",
    shadow: "xl"
};
function ModalBase(o) {
    const i = useComponentDefaultProps("ModalBase", ModalBaseDefaultProps, o)
      , {opened: s, onClose: a, children: _, closeOnClickOutside: $, __staticSelector: _e, transitionProps: tt, withinPortal: nt, portalProps: rt, keepMounted: ot, target: et, zIndex: j, lockScroll: it, trapFocus: st, closeOnEscape: at, returnFocus: lt, padding: ct, shadow: ut, id: dt, size: ft, variant: ht, classNames: pt, unstyled: gt, styles: _t, className: mt} = i
      , yt = __objRest$n(i, ["opened", "onClose", "children", "closeOnClickOutside", "__staticSelector", "transitionProps", "withinPortal", "portalProps", "keepMounted", "target", "zIndex", "lockScroll", "trapFocus", "closeOnEscape", "returnFocus", "padding", "shadow", "id", "size", "variant", "classNames", "unstyled", "styles", "className"])
      , {classes: bt, cx: vt} = useStyles$t(null, {
        name: _e,
        classNames: pt,
        styles: _t,
        unstyled: gt,
        variant: ht,
        size: ft
    })
      , wt = useId(dt)
      , [Tt,$t] = reactExports.useState(!1)
      , [Et,Pt] = reactExports.useState(!1)
      , Rt = typeof (tt == null ? void 0 : tt.duration) == "number" ? tt == null ? void 0 : tt.duration : 200
      , At = useLockScroll({
        opened: s,
        transitionDuration: Rt
    });
    return useWindowEvent("keydown", Mt => {
        !st && Mt.key === "Escape" && at && a()
    }
    ),
    useFocusReturn({
        opened: s,
        shouldReturnFocus: st && lt
    }),
    React.createElement(OptionalPortal, __spreadProps$o(__spreadValues$B({}, rt), {
        withinPortal: nt,
        target: et
    }), React.createElement(ModalBaseProvider, {
        value: {
            __staticSelector: _e,
            opened: s,
            onClose: a,
            closeOnClickOutside: $,
            transitionProps: __spreadProps$o(__spreadValues$B({}, tt), {
                duration: Rt,
                keepMounted: ot
            }),
            zIndex: j,
            padding: ct,
            id: wt,
            getTitleId: () => `${wt}-title`,
            getBodyId: () => `${wt}-body`,
            titleMounted: Tt,
            bodyMounted: Et,
            setTitleMounted: $t,
            setBodyMounted: Pt,
            trapFocus: st,
            closeOnEscape: at,
            shadow: ut,
            stylesApi: {
                name: _e,
                size: ft,
                variant: ht,
                classNames: pt,
                styles: _t,
                unstyled: gt
            }
        }
    }, React.createElement(RemoveScroll, {
        enabled: At && it
    }, React.createElement(Box, __spreadValues$B({
        className: vt(bt.root, mt)
    }, yt), _))))
}
ModalBase.CloseButton = ModalBaseCloseButton;
ModalBase.Overlay = ModalBaseOverlay;
ModalBase.Content = ModalBaseContent;
ModalBase.Header = ModalBaseHeader;
ModalBase.Title = ModalBaseTitle;
ModalBase.Body = ModalBaseBody;
ModalBase.NativeScrollArea = NativeScrollArea;
const FLEX_SYSTEM_PROPS = {
    gap: {
        type: "spacing",
        property: "gap"
    },
    rowGap: {
        type: "spacing",
        property: "rowGap"
    },
    columnGap: {
        type: "spacing",
        property: "columnGap"
    },
    align: {
        type: "identity",
        property: "alignItems"
    },
    justify: {
        type: "identity",
        property: "justifyContent"
    },
    wrap: {
        type: "identity",
        property: "flexWrap"
    },
    direction: {
        type: "identity",
        property: "flexDirection"
    }
};
var __defProp$A = Object.defineProperty
  , __defProps$n = Object.defineProperties
  , __getOwnPropDescs$n = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$A = Object.getOwnPropertySymbols
  , __hasOwnProp$A = Object.prototype.hasOwnProperty
  , __propIsEnum$A = Object.prototype.propertyIsEnumerable
  , __defNormalProp$A = (o, i, s) => i in o ? __defProp$A(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$A = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$A.call(i, s) && __defNormalProp$A(o, s, i[s]);
    if (__getOwnPropSymbols$A)
        for (var s of __getOwnPropSymbols$A(i))
            __propIsEnum$A.call(i, s) && __defNormalProp$A(o, s, i[s]);
    return o
}
  , __spreadProps$n = (o, i) => __defProps$n(o, __getOwnPropDescs$n(i))
  , __objRest$m = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$A.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$A)
        for (var a of __getOwnPropSymbols$A(o))
            i.indexOf(a) < 0 && __propIsEnum$A.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$i = {}
  , Flex = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("Flex", defaultProps$i, o)
      , {gap: a, rowGap: _, columnGap: $, align: _e, justify: tt, wrap: nt, direction: rt, sx: ot} = s
      , et = __objRest$m(s, ["gap", "rowGap", "columnGap", "align", "justify", "wrap", "direction", "sx"]);
    return React.createElement(Box, __spreadProps$n(__spreadValues$A({}, et), {
        sx: [{
            display: "flex"
        }, j => getSystemStyles({
            gap: a,
            rowGap: _,
            columnGap: $,
            align: _e,
            justify: tt,
            wrap: nt,
            direction: rt
        }, j, FLEX_SYSTEM_PROPS), ...packSx(ot)],
        ref: i
    }))
}
);
Flex.displayName = "@mantine/core/Flex";
function filterFalsyChildren(o) {
    return reactExports.Children.toArray(o).filter(Boolean)
}
const GROUP_POSITIONS = {
    left: "flex-start",
    center: "center",
    right: "flex-end",
    apart: "space-between"
};
var useStyles$q = createStyles( (o, {spacing: i, position: s, noWrap: a, grow: _, align: $, count: _e}) => ({
    root: {
        boxSizing: "border-box",
        display: "flex",
        flexDirection: "row",
        alignItems: $ || "center",
        flexWrap: a ? "nowrap" : "wrap",
        justifyContent: GROUP_POSITIONS[s],
        gap: getSize({
            size: i,
            sizes: o.spacing
        }),
        "& > *": {
            boxSizing: "border-box",
            maxWidth: _ ? `calc(${100 / _e}% - (${rem(getSize({
                size: i,
                sizes: o.spacing
            }))} - ${getSize({
                size: i,
                sizes: o.spacing
            })} / ${_e}))` : void 0,
            flexGrow: _ ? 1 : 0
        }
    }
}));
const useStyles$r = useStyles$q;
var __defProp$z = Object.defineProperty
  , __getOwnPropSymbols$z = Object.getOwnPropertySymbols
  , __hasOwnProp$z = Object.prototype.hasOwnProperty
  , __propIsEnum$z = Object.prototype.propertyIsEnumerable
  , __defNormalProp$z = (o, i, s) => i in o ? __defProp$z(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$z = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$z.call(i, s) && __defNormalProp$z(o, s, i[s]);
    if (__getOwnPropSymbols$z)
        for (var s of __getOwnPropSymbols$z(i))
            __propIsEnum$z.call(i, s) && __defNormalProp$z(o, s, i[s]);
    return o
}
  , __objRest$l = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$z.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$z)
        for (var a of __getOwnPropSymbols$z(o))
            i.indexOf(a) < 0 && __propIsEnum$z.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$h = {
    position: "left",
    spacing: "md"
}
  , Group = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("Group", defaultProps$h, o)
      , {className: a, position: _, align: $, children: _e, noWrap: tt, grow: nt, spacing: rt, unstyled: ot, variant: et} = s
      , j = __objRest$l(s, ["className", "position", "align", "children", "noWrap", "grow", "spacing", "unstyled", "variant"])
      , it = filterFalsyChildren(_e)
      , {classes: st, cx: at} = useStyles$r({
        align: $,
        grow: nt,
        noWrap: tt,
        spacing: rt,
        position: _,
        count: it.length
    }, {
        unstyled: ot,
        name: "Group",
        variant: et
    });
    return React.createElement(Box, __spreadValues$z({
        className: at(st.root, a),
        ref: i
    }, j), it)
}
);
Group.displayName = "@mantine/core/Group";
function _objectWithoutPropertiesLoose(o, i) {
    if (o == null)
        return {};
    var s = {}, a = Object.keys(o), _, $;
    for ($ = 0; $ < a.length; $++)
        _ = a[$],
        !(i.indexOf(_) >= 0) && (s[_] = o[_]);
    return s
}
var __defProp$y = Object.defineProperty
  , __defProps$m = Object.defineProperties
  , __getOwnPropDescs$m = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$y = Object.getOwnPropertySymbols
  , __hasOwnProp$y = Object.prototype.hasOwnProperty
  , __propIsEnum$y = Object.prototype.propertyIsEnumerable
  , __defNormalProp$y = (o, i, s) => i in o ? __defProp$y(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$y = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$y.call(i, s) && __defNormalProp$y(o, s, i[s]);
    if (__getOwnPropSymbols$y)
        for (var s of __getOwnPropSymbols$y(i))
            __propIsEnum$y.call(i, s) && __defNormalProp$y(o, s, i[s]);
    return o
}
  , __spreadProps$m = (o, i) => __defProps$m(o, __getOwnPropDescs$m(i))
  , useStyles$o = createStyles(o => ({
    root: __spreadProps$m(__spreadValues$y({}, o.fn.cover()), {
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        overflow: "hidden"
    })
}));
const useStyles$p = useStyles$o;
var __defProp$x = Object.defineProperty
  , __defProps$l = Object.defineProperties
  , __getOwnPropDescs$l = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$x = Object.getOwnPropertySymbols
  , __hasOwnProp$x = Object.prototype.hasOwnProperty
  , __propIsEnum$x = Object.prototype.propertyIsEnumerable
  , __defNormalProp$x = (o, i, s) => i in o ? __defProp$x(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$x = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$x.call(i, s) && __defNormalProp$x(o, s, i[s]);
    if (__getOwnPropSymbols$x)
        for (var s of __getOwnPropSymbols$x(i))
            __propIsEnum$x.call(i, s) && __defNormalProp$x(o, s, i[s]);
    return o
}
  , __spreadProps$l = (o, i) => __defProps$l(o, __getOwnPropDescs$l(i))
  , __objRest$k = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$x.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$x)
        for (var a of __getOwnPropSymbols$x(o))
            i.indexOf(a) < 0 && __propIsEnum$x.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$g = {
    overlayOpacity: .75,
    transitionDuration: 0,
    radius: 0,
    zIndex: getDefaultZIndex("overlay")
}
  , LoadingOverlay = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("LoadingOverlay", defaultProps$g, o)
      , {className: a, visible: _, loaderProps: $, overlayOpacity: _e, overlayColor: tt, transitionDuration: nt, exitTransitionDuration: rt, zIndex: ot, style: et, loader: j, radius: it, overlayBlur: st, unstyled: at, variant: lt, keepMounted: ct} = s
      , ut = __objRest$k(s, ["className", "visible", "loaderProps", "overlayOpacity", "overlayColor", "transitionDuration", "exitTransitionDuration", "zIndex", "style", "loader", "radius", "overlayBlur", "unstyled", "variant", "keepMounted"])
      , {classes: dt, cx: ft, theme: ht} = useStyles$p(null, {
        name: "LoadingOverlay",
        unstyled: at,
        variant: lt
    })
      , pt = `calc(${ot} + 1)`;
    return React.createElement(Transition$2, {
        keepMounted: ct,
        duration: nt,
        exitDuration: rt,
        mounted: _,
        transition: "fade"
    }, gt => React.createElement(Box, __spreadValues$x({
        className: ft(dt.root, a),
        style: __spreadProps$l(__spreadValues$x(__spreadValues$x({}, gt), et), {
            zIndex: ot
        }),
        ref: i
    }, ut), j ? React.createElement("div", {
        style: {
            zIndex: pt
        }
    }, j) : React.createElement(Loader, __spreadValues$x({
        style: {
            zIndex: pt
        }
    }, $)), React.createElement(Overlay, {
        opacity: _e,
        zIndex: ot,
        radius: it,
        blur: st,
        unstyled: at,
        color: tt || (ht.colorScheme === "dark" ? ht.colors.dark[5] : ht.white)
    })))
}
);
LoadingOverlay.displayName = "@mantine/core/LoadingOverlay";
const [ModalProvider,useModalContext] = createSafeContext("Modal component was not found in tree")
  , sizes$2 = {
    xs: rem(320),
    sm: rem(380),
    md: rem(440),
    lg: rem(620),
    xl: rem(780)
};
var useStyles$m = createStyles( (o, {yOffset: i, xOffset: s, centered: a, fullScreen: _}, {size: $}) => ({
    content: {
        flex: _ ? "0 0 100%" : `0 0 ${getSize({
            size: $,
            sizes: sizes$2
        })}`,
        maxWidth: "100%",
        maxHeight: _ ? void 0 : `calc(100dvh - (${rem(i)} * 2))`,
        height: _ ? "100vh" : void 0,
        borderRadius: _ ? 0 : void 0,
        overflowY: "auto"
    },
    inner: {
        paddingTop: _ ? 0 : i,
        paddingBottom: _ ? 0 : i,
        paddingLeft: _ ? 0 : s,
        paddingRight: _ ? 0 : s,
        display: "flex",
        justifyContent: "center",
        alignItems: a ? "center" : "flex-start"
    }
}));
const useStyles$n = useStyles$m;
var __defProp$w = Object.defineProperty
  , __defProps$k = Object.defineProperties
  , __getOwnPropDescs$k = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$w = Object.getOwnPropertySymbols
  , __hasOwnProp$w = Object.prototype.hasOwnProperty
  , __propIsEnum$w = Object.prototype.propertyIsEnumerable
  , __defNormalProp$w = (o, i, s) => i in o ? __defProp$w(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$w = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$w.call(i, s) && __defNormalProp$w(o, s, i[s]);
    if (__getOwnPropSymbols$w)
        for (var s of __getOwnPropSymbols$w(i))
            __propIsEnum$w.call(i, s) && __defNormalProp$w(o, s, i[s]);
    return o
}
  , __spreadProps$k = (o, i) => __defProps$k(o, __getOwnPropDescs$k(i))
  , __objRest$j = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$w.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$w)
        for (var a of __getOwnPropSymbols$w(o))
            i.indexOf(a) < 0 && __propIsEnum$w.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$f = __spreadProps$k(__spreadValues$w({}, ModalBaseDefaultProps), {
    yOffset: "5dvh",
    xOffset: "5vw"
});
function ModalRoot(o) {
    const i = useComponentDefaultProps("ModalRoot", defaultProps$f, o)
      , {classNames: s, variant: a, size: _, yOffset: $, xOffset: _e, scrollAreaComponent: tt, radius: nt, centered: rt, fullScreen: ot} = i
      , et = __objRest$j(i, ["classNames", "variant", "size", "yOffset", "xOffset", "scrollAreaComponent", "radius", "centered", "fullScreen"])
      , {classes: j, cx: it} = useStyles$n({
        yOffset: $,
        xOffset: _e,
        centered: rt,
        fullScreen: ot
    }, {
        name: "Modal",
        variant: a,
        size: _
    });
    return React.createElement(ModalProvider, {
        value: {
            yOffset: $,
            scrollAreaComponent: tt,
            radius: nt
        }
    }, React.createElement(ModalBase, __spreadValues$w({
        __staticSelector: "Modal",
        size: _,
        variant: a,
        classNames: __spreadProps$k(__spreadValues$w({}, s), {
            content: it(j.content, s == null ? void 0 : s.content),
            inner: it(j.inner, s == null ? void 0 : s.inner)
        })
    }, et)))
}
var __defProp$v = Object.defineProperty
  , __getOwnPropSymbols$v = Object.getOwnPropertySymbols
  , __hasOwnProp$v = Object.prototype.hasOwnProperty
  , __propIsEnum$v = Object.prototype.propertyIsEnumerable
  , __defNormalProp$v = (o, i, s) => i in o ? __defProp$v(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$v = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$v.call(i, s) && __defNormalProp$v(o, s, i[s]);
    if (__getOwnPropSymbols$v)
        for (var s of __getOwnPropSymbols$v(i))
            __propIsEnum$v.call(i, s) && __defNormalProp$v(o, s, i[s]);
    return o
}
  , __objRest$i = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$v.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$v)
        for (var a of __getOwnPropSymbols$v(o))
            i.indexOf(a) < 0 && __propIsEnum$v.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$e = {
    shadow: "xl"
}
  , ModalContent = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("ModalContent", defaultProps$e, o)
      , {children: a, scrollAreaComponent: _} = s
      , $ = __objRest$i(s, ["children", "scrollAreaComponent"])
      , _e = useModalContext()
      , tt = _ || _e.scrollAreaComponent || ModalBase.NativeScrollArea;
    return React.createElement(ModalBase.Content, __spreadValues$v({
        ref: i,
        radius: _e.radius
    }, $), React.createElement(tt, {
        style: {
            maxHeight: `calc(100dvh - (${rem(_e.yOffset)} * 2))`
        }
    }, a))
}
);
var __defProp$u = Object.defineProperty
  , __defProps$j = Object.defineProperties
  , __getOwnPropDescs$j = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$u = Object.getOwnPropertySymbols
  , __hasOwnProp$u = Object.prototype.hasOwnProperty
  , __propIsEnum$u = Object.prototype.propertyIsEnumerable
  , __defNormalProp$u = (o, i, s) => i in o ? __defProp$u(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$u = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$u.call(i, s) && __defNormalProp$u(o, s, i[s]);
    if (__getOwnPropSymbols$u)
        for (var s of __getOwnPropSymbols$u(i))
            __propIsEnum$u.call(i, s) && __defNormalProp$u(o, s, i[s]);
    return o
}
  , __spreadProps$j = (o, i) => __defProps$j(o, __getOwnPropDescs$j(i))
  , __objRest$h = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$u.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$u)
        for (var a of __getOwnPropSymbols$u(o))
            i.indexOf(a) < 0 && __propIsEnum$u.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$d = __spreadProps$j(__spreadValues$u({}, ModalBaseDefaultProps), {
    transitionProps: {
        duration: 200,
        transition: "pop"
    },
    withOverlay: !0,
    withCloseButton: !0
});
function Modal(o) {
    const i = useComponentDefaultProps("Modal", defaultProps$d, o)
      , {title: s, withOverlay: a, overlayProps: _, withCloseButton: $, closeButtonProps: _e, children: tt} = i
      , nt = __objRest$h(i, ["title", "withOverlay", "overlayProps", "withCloseButton", "closeButtonProps", "children"])
      , rt = !!s || $;
    return React.createElement(ModalRoot, __spreadValues$u({}, nt), a && React.createElement(ModalBase.Overlay, __spreadValues$u({}, _)), React.createElement(ModalContent, null, rt && React.createElement(ModalBase.Header, null, s && React.createElement(ModalBase.Title, null, s), $ && React.createElement(ModalBase.CloseButton, __spreadValues$u({}, _e))), React.createElement(ModalBase.Body, null, tt)))
}
Modal.Root = ModalRoot;
Modal.CloseButton = ModalBase.CloseButton;
Modal.Overlay = ModalBase.Overlay;
Modal.Content = ModalContent;
Modal.Header = ModalBase.Header;
Modal.Title = ModalBase.Title;
Modal.Body = ModalBase.Body;
Modal.NativeScrollArea = ModalBase.NativeScrollArea;
var __defProp$t = Object.defineProperty
  , __getOwnPropSymbols$t = Object.getOwnPropertySymbols
  , __hasOwnProp$t = Object.prototype.hasOwnProperty
  , __propIsEnum$t = Object.prototype.propertyIsEnumerable
  , __defNormalProp$t = (o, i, s) => i in o ? __defProp$t(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$t = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$t.call(i, s) && __defNormalProp$t(o, s, i[s]);
    if (__getOwnPropSymbols$t)
        for (var s of __getOwnPropSymbols$t(i))
            __propIsEnum$t.call(i, s) && __defNormalProp$t(o, s, i[s]);
    return o
}
  , __objRest$g = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$t.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$t)
        for (var a of __getOwnPropSymbols$t(o))
            i.indexOf(a) < 0 && __propIsEnum$t.call(o, a) && (s[a] = o[a]);
    return s
}
;
const iconSizes$1 = {
    xs: rem(14),
    sm: rem(18),
    md: rem(20),
    lg: rem(24),
    xl: rem(28)
};
function ChevronIcon(o) {
    var i = o
      , {size: s, error: a, style: _} = i
      , $ = __objRest$g(i, ["size", "error", "style"]);
    const _e = useMantineTheme()
      , tt = getSize({
        size: s,
        sizes: iconSizes$1
    });
    return React.createElement("svg", __spreadValues$t({
        viewBox: "0 0 15 15",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        style: __spreadValues$t({
            color: a ? _e.colors.red[6] : _e.colors.gray[6],
            width: tt,
            height: tt
        }, _),
        "data-chevron": !0
    }, $), React.createElement("path", {
        d: "M4.93179 5.43179C4.75605 5.60753 4.75605 5.89245 4.93179 6.06819C5.10753 6.24392 5.39245 6.24392 5.56819 6.06819L7.49999 4.13638L9.43179 6.06819C9.60753 6.24392 9.89245 6.24392 10.0682 6.06819C10.2439 5.89245 10.2439 5.60753 10.0682 5.43179L7.81819 3.18179C7.73379 3.0974 7.61933 3.04999 7.49999 3.04999C7.38064 3.04999 7.26618 3.0974 7.18179 3.18179L4.93179 5.43179ZM10.0682 9.56819C10.2439 9.39245 10.2439 9.10753 10.0682 8.93179C9.89245 8.75606 9.60753 8.75606 9.43179 8.93179L7.49999 10.8636L5.56819 8.93179C5.39245 8.75606 5.10753 8.75606 4.93179 8.93179C4.75605 9.10753 4.75605 9.39245 4.93179 9.56819L7.18179 11.8182C7.35753 11.9939 7.64245 11.9939 7.81819 11.8182L10.0682 9.56819Z",
        fill: "currentColor",
        fillRule: "evenodd",
        clipRule: "evenodd"
    }))
}
var __defProp$s = Object.defineProperty
  , __defProps$i = Object.defineProperties
  , __getOwnPropDescs$i = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$s = Object.getOwnPropertySymbols
  , __hasOwnProp$s = Object.prototype.hasOwnProperty
  , __propIsEnum$s = Object.prototype.propertyIsEnumerable
  , __defNormalProp$s = (o, i, s) => i in o ? __defProp$s(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$s = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$s.call(i, s) && __defNormalProp$s(o, s, i[s]);
    if (__getOwnPropSymbols$s)
        for (var s of __getOwnPropSymbols$s(i))
            __propIsEnum$s.call(i, s) && __defNormalProp$s(o, s, i[s]);
    return o
}
  , __spreadProps$i = (o, i) => __defProps$i(o, __getOwnPropDescs$i(i));
function SelectRightSection({shouldClear: o, clearButtonProps: i, onClear: s, size: a, error: _}) {
    return o ? React.createElement(CloseButton, __spreadProps$i(__spreadValues$s({}, i), {
        variant: "transparent",
        onClick: s,
        size: a,
        onMouseDown: $ => $.preventDefault()
    })) : React.createElement(ChevronIcon, {
        error: _,
        size: a
    })
}
SelectRightSection.displayName = "@mantine/core/SelectRightSection";
var __defProp$r = Object.defineProperty
  , __defProps$h = Object.defineProperties
  , __getOwnPropDescs$h = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$r = Object.getOwnPropertySymbols
  , __hasOwnProp$r = Object.prototype.hasOwnProperty
  , __propIsEnum$r = Object.prototype.propertyIsEnumerable
  , __defNormalProp$r = (o, i, s) => i in o ? __defProp$r(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$r = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$r.call(i, s) && __defNormalProp$r(o, s, i[s]);
    if (__getOwnPropSymbols$r)
        for (var s of __getOwnPropSymbols$r(i))
            __propIsEnum$r.call(i, s) && __defNormalProp$r(o, s, i[s]);
    return o
}
  , __spreadProps$h = (o, i) => __defProps$h(o, __getOwnPropDescs$h(i))
  , __objRest$f = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$r.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$r)
        for (var a of __getOwnPropSymbols$r(o))
            i.indexOf(a) < 0 && __propIsEnum$r.call(o, a) && (s[a] = o[a]);
    return s
}
;
function getSelectRightSectionProps(o) {
    var i = o
      , {styles: s, rightSection: a, rightSectionWidth: _, theme: $} = i
      , _e = __objRest$f(i, ["styles", "rightSection", "rightSectionWidth", "theme"]);
    if (a)
        return {
            rightSection: a,
            rightSectionWidth: _,
            styles: s
        };
    const tt = typeof s == "function" ? s($) : s;
    return {
        rightSection: !_e.readOnly && !(_e.disabled && _e.shouldClear) && React.createElement(SelectRightSection, __spreadValues$r({}, _e)),
        styles: __spreadProps$h(__spreadValues$r({}, tt), {
            rightSection: __spreadProps$h(__spreadValues$r({}, tt == null ? void 0 : tt.rightSection), {
                pointerEvents: _e.shouldClear ? void 0 : "none"
            })
        })
    }
}
var useStyles$k = createStyles( (o, {color: i, radius: s, withTitle: a}) => {
    const _ = o.fn.radius(s)
      , $ = o.fn.variant({
        variant: "filled",
        color: i
    });
    return {
        closeButton: o.fn.hover({
            backgroundColor: o.colorScheme === "dark" ? o.colors.dark[8] : o.colors.gray[0]
        }),
        icon: {
            boxSizing: "border-box",
            marginRight: o.spacing.md,
            width: rem(28),
            height: rem(28),
            borderRadius: rem(28),
            display: "flex",
            flex: "none",
            alignItems: "center",
            justifyContent: "center",
            backgroundColor: $.background,
            color: o.white
        },
        root: {
            overflow: "hidden",
            boxSizing: "border-box",
            position: "relative",
            display: "flex",
            alignItems: "center",
            paddingLeft: rem(22),
            paddingRight: o.spacing.xs,
            paddingTop: o.spacing.xs,
            paddingBottom: o.spacing.xs,
            borderRadius: _,
            backgroundColor: o.colorScheme === "dark" ? o.colors.dark[6] : o.white,
            boxShadow: o.shadows.lg,
            "&::before": {
                content: '""',
                display: "block",
                position: "absolute",
                width: rem(6),
                top: _,
                bottom: _,
                left: rem(4),
                borderRadius: _,
                backgroundColor: $.background
            },
            "&[data-with-icon]": {
                paddingLeft: o.spacing.xs,
                "&::before": {
                    display: "none"
                }
            },
            "&[data-with-border]": {
                border: `${rem(1)} solid ${o.colorScheme === "dark" ? o.colors.dark[4] : o.colors.gray[3]}`
            }
        },
        body: {
            flex: 1,
            overflow: "hidden",
            marginRight: o.spacing.xs
        },
        loader: {
            marginRight: o.spacing.md
        },
        title: {
            lineHeight: 1.4,
            marginBottom: rem(2),
            overflow: "hidden",
            textOverflow: "ellipsis",
            color: o.colorScheme === "dark" ? o.white : o.colors.gray[9]
        },
        description: {
            color: a ? o.colorScheme === "dark" ? o.colors.dark[2] : o.colors.gray[6] : o.colorScheme === "dark" ? o.colors.dark[0] : o.black,
            lineHeight: 1.4,
            overflow: "hidden",
            textOverflow: "ellipsis"
        }
    }
}
);
const useStyles$l = useStyles$k;
var __defProp$q = Object.defineProperty
  , __defProps$g = Object.defineProperties
  , __getOwnPropDescs$g = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$q = Object.getOwnPropertySymbols
  , __hasOwnProp$q = Object.prototype.hasOwnProperty
  , __propIsEnum$q = Object.prototype.propertyIsEnumerable
  , __defNormalProp$q = (o, i, s) => i in o ? __defProp$q(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$q = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$q.call(i, s) && __defNormalProp$q(o, s, i[s]);
    if (__getOwnPropSymbols$q)
        for (var s of __getOwnPropSymbols$q(i))
            __propIsEnum$q.call(i, s) && __defNormalProp$q(o, s, i[s]);
    return o
}
  , __spreadProps$g = (o, i) => __defProps$g(o, __getOwnPropDescs$g(i))
  , __objRest$e = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$q.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$q)
        for (var a of __getOwnPropSymbols$q(o))
            i.indexOf(a) < 0 && __propIsEnum$q.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$c = {
    withCloseButton: !0
}
  , Notification = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("Notification", defaultProps$c, o)
      , {className: a, color: _, radius: $, loading: _e, withCloseButton: tt, withBorder: nt, title: rt, icon: ot, children: et, onClose: j, closeButtonProps: it, classNames: st, styles: at, unstyled: lt, variant: ct} = s
      , ut = __objRest$e(s, ["className", "color", "radius", "loading", "withCloseButton", "withBorder", "title", "icon", "children", "onClose", "closeButtonProps", "classNames", "styles", "unstyled", "variant"])
      , {classes: dt, cx: ft} = useStyles$l({
        color: _,
        radius: $,
        withTitle: !!rt
    }, {
        name: "Notification",
        classNames: st,
        styles: at,
        unstyled: lt,
        variant: ct
    });
    return React.createElement(Box, __spreadValues$q({
        className: ft(dt.root, a),
        "data-with-icon": !!ot || _e || void 0,
        "data-with-border": nt || void 0,
        role: "alert",
        ref: i
    }, ut), ot && !_e && React.createElement("div", {
        className: dt.icon
    }, ot), _e && React.createElement(Loader, {
        size: 28,
        color: _,
        className: dt.loader
    }), React.createElement("div", {
        className: dt.body
    }, rt && React.createElement(Text$2, {
        className: dt.title,
        size: "sm",
        weight: 500
    }, rt), React.createElement(Text$2, {
        color: "dimmed",
        className: dt.description,
        size: "sm"
    }, et)), tt && React.createElement(CloseButton, __spreadProps$g(__spreadValues$q({
        iconSize: 16,
        color: "gray"
    }, it), {
        onClick: j,
        className: dt.closeButton
    })))
}
);
Notification.displayName = "@mantine/core/Notification";
const getInputMode = (o, i, s) => Number.isInteger(o) && o >= 0 && i === 0 ? "numeric" : !Number.isInteger(o) && o >= 0 && i !== 0 ? "decimal" : Number.isInteger(o) && o < 0 && i === 0 || !Number.isInteger(o) && o < 0 && i !== 0 ? s === "ios" ? "text" : "decimal" : "numeric";
function Chevron({direction: o, size: i}) {
    return React.createElement("svg", {
        style: {
            width: rem(i),
            height: rem(i),
            transform: o === "up" ? "rotate(180deg)" : void 0
        },
        viewBox: "0 0 15 15",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg"
    }, React.createElement("path", {
        d: "M3.13523 6.15803C3.3241 5.95657 3.64052 5.94637 3.84197 6.13523L7.5 9.56464L11.158 6.13523C11.3595 5.94637 11.6759 5.95657 11.8648 6.15803C12.0536 6.35949 12.0434 6.67591 11.842 6.86477L7.84197 10.6148C7.64964 10.7951 7.35036 10.7951 7.15803 10.6148L3.15803 6.86477C2.95657 6.67591 2.94637 6.35949 3.13523 6.15803Z",
        fill: "currentColor",
        fillRule: "evenodd",
        clipRule: "evenodd"
    }))
}
const CONTROL_SIZES = {
    xs: rem(20),
    sm: rem(24),
    md: rem(30),
    lg: rem(34),
    xl: rem(36)
};
var useStyles$i = createStyles( (o, {radius: i}, {size: s}) => ({
    rightSection: {
        display: "flex",
        flexDirection: "column",
        height: `calc(100% - ${rem(2)})`,
        margin: rem(1),
        overflow: "hidden",
        borderTopRightRadius: o.fn.radius(i),
        borderBottomRightRadius: o.fn.radius(i)
    },
    control: {
        margin: 0,
        position: "relative",
        flex: "0 0 50%",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        boxSizing: "border-box",
        width: getSize({
            size: s,
            sizes: CONTROL_SIZES
        }),
        padding: 0,
        WebkitTapHighlightColor: "transparent",
        borderBottom: `${rem(1)} solid ${o.colorScheme === "dark" ? o.colors.dark[4] : o.colors.gray[4]}`,
        borderLeft: `${rem(1)} solid ${o.colorScheme === "dark" ? o.colors.dark[4] : o.colors.gray[4]}`,
        borderTop: 0,
        borderRight: 0,
        backgroundColor: "transparent",
        marginRight: rem(1),
        color: o.colorScheme === "dark" ? o.colors.dark[0] : o.black,
        "&:not(:disabled):hover": {
            backgroundColor: o.colorScheme === "dark" ? o.colors.dark[5] : o.colors.gray[0]
        },
        "&:disabled": {
            color: o.colorScheme === "dark" ? o.colors.dark[3] : o.colors.gray[4]
        }
    },
    controlUp: {},
    controlDown: {
        borderBottom: 0
    }
}));
const useStyles$j = useStyles$i;
var __defProp$p = Object.defineProperty
  , __defProps$f = Object.defineProperties
  , __getOwnPropDescs$f = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$p = Object.getOwnPropertySymbols
  , __hasOwnProp$p = Object.prototype.hasOwnProperty
  , __propIsEnum$p = Object.prototype.propertyIsEnumerable
  , __defNormalProp$p = (o, i, s) => i in o ? __defProp$p(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$p = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$p.call(i, s) && __defNormalProp$p(o, s, i[s]);
    if (__getOwnPropSymbols$p)
        for (var s of __getOwnPropSymbols$p(i))
            __propIsEnum$p.call(i, s) && __defNormalProp$p(o, s, i[s]);
    return o
}
  , __spreadProps$f = (o, i) => __defProps$f(o, __getOwnPropDescs$f(i))
  , __objRest$d = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$p.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$p)
        for (var a of __getOwnPropSymbols$p(o))
            i.indexOf(a) < 0 && __propIsEnum$p.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$b = {
    type: "text",
    size: "sm",
    __staticSelector: "TextInput"
}
  , TextInput = reactExports.forwardRef( (o, i) => {
    const s = useInputProps("TextInput", defaultProps$b, o)
      , {inputProps: a, wrapperProps: _} = s
      , $ = __objRest$d(s, ["inputProps", "wrapperProps"]);
    return React.createElement(Input.Wrapper, __spreadValues$p({}, _), React.createElement(Input, __spreadProps$f(__spreadValues$p(__spreadValues$p({}, a), $), {
        ref: i
    })))
}
);
TextInput.displayName = "@mantine/core/TextInput";
var __defProp$o = Object.defineProperty
  , __defProps$e = Object.defineProperties
  , __getOwnPropDescs$e = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$o = Object.getOwnPropertySymbols
  , __hasOwnProp$o = Object.prototype.hasOwnProperty
  , __propIsEnum$o = Object.prototype.propertyIsEnumerable
  , __defNormalProp$o = (o, i, s) => i in o ? __defProp$o(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$o = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$o.call(i, s) && __defNormalProp$o(o, s, i[s]);
    if (__getOwnPropSymbols$o)
        for (var s of __getOwnPropSymbols$o(i))
            __propIsEnum$o.call(i, s) && __defNormalProp$o(o, s, i[s]);
    return o
}
  , __spreadProps$e = (o, i) => __defProps$e(o, __getOwnPropDescs$e(i))
  , __objRest$c = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$o.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$o)
        for (var a of __getOwnPropSymbols$o(o))
            i.indexOf(a) < 0 && __propIsEnum$o.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultFormatter = o => o || ""
  , defaultParser = o => {
    if (o === "-")
        return o;
    let i = o;
    i[0] === "." && (i = `0${o}`);
    const s = parseFloat(i);
    return Number.isNaN(s) ? "" : o
}
  , CHEVRON_SIZES = {
    xs: rem(10),
    sm: rem(14),
    md: rem(16),
    lg: rem(18),
    xl: rem(20)
}
  , defaultProps$a = {
    step: 1,
    hideControls: !1,
    size: "sm",
    precision: 0,
    noClampOnBlur: !1,
    removeTrailingZeros: !1,
    decimalSeparator: ".",
    formatter: defaultFormatter,
    parser: defaultParser,
    type: "text"
}
  , NumberInput = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("NumberInput", defaultProps$a, o)
      , {readOnly: a, disabled: _, value: $, onChange: _e, decimalSeparator: tt, thousandsSeparator: nt, min: rt, max: ot, startValue: et, step: j, stepHoldInterval: it, stepHoldDelay: st, onFocus: at, onBlur: lt, onKeyDown: ct, onKeyUp: ut, hideControls: dt, radius: ft, variant: ht, precision: pt, removeTrailingZeros: gt, defaultValue: _t, noClampOnBlur: mt, handlersRef: yt, classNames: bt, styles: vt, size: wt, rightSection: Tt, rightSectionWidth: $t, formatter: Et, parser: Pt, inputMode: Rt, unstyled: At, type: Mt} = s
      , Ut = __objRest$c(s, ["readOnly", "disabled", "value", "onChange", "decimalSeparator", "thousandsSeparator", "min", "max", "startValue", "step", "stepHoldInterval", "stepHoldDelay", "onFocus", "onBlur", "onKeyDown", "onKeyUp", "hideControls", "radius", "variant", "precision", "removeTrailingZeros", "defaultValue", "noClampOnBlur", "handlersRef", "classNames", "styles", "size", "rightSection", "rightSectionWidth", "formatter", "parser", "inputMode", "unstyled", "type"])
      , {classes: Lt, cx: tn} = useStyles$j({
        radius: ft
    }, {
        classNames: bt,
        styles: vt,
        unstyled: At,
        name: "NumberInput",
        variant: ht,
        size: wt
    })
      , Vt = xt => {
        if (xt === "")
            return "";
        let Ot = xt.toFixed(pt);
        return gt && pt > 0 && (Ot = Ot.replace(new RegExp(`[0]{0,${pt}}$`), ""),
        Ot.endsWith(".") && (Ot = Ot.slice(0, -1))),
        Ot
    }
      , Nt = xt => {
        let Ot = xt;
        return tt && (Ot = Ot.replace(".", tt)),
        Et(Ot)
    }
      , Yt = xt => {
        let Ot = xt;
        return tt && (Ot = Ot.replaceAll(nt, "").replace(tt, ".")),
        Pt(Ot)
    }
      , Xt = xt => Nt(Vt(xt))
      , [jt,Gt] = reactExports.useState(typeof $ == "number" ? $ : typeof _t == "number" ? _t : "")
      , [Kt,qt] = reactExports.useState( () => Xt(jt))
      , rn = reactExports.useRef()
      , [on,_n] = reactExports.useState(!1)
      , mn = (xt, Ot) => {
        if (!on || Ot) {
            const Dt = Xt(xt);
            Dt !== Kt && qt(Dt)
        }
        xt !== jt && Gt(xt)
    }
      , Sn = typeof rt == "number" ? rt : -1 / 0
      , bn = typeof ot == "number" ? ot : 1 / 0
      , In = reactExports.useRef();
    In.current = () => {
        var xt;
        let Ot;
        jt === "" ? Ot = (xt = et ?? rt) != null ? xt : 0 : Ot = parseFloat(Vt(clamp$2(jt + j, Sn, bn))),
        mn(Ot, !0),
        _e == null || _e(Ot)
    }
    ;
    const Nn = reactExports.useRef();
    Nn.current = () => {
        var xt;
        let Ot;
        jt === "" ? Ot = (xt = et ?? rt) != null ? xt : 0 : Ot = parseFloat(Vt(clamp$2(jt - j, Sn, bn))),
        mn(Ot, !0),
        _e == null || _e(Ot)
    }
    ,
    assignRef(yt, {
        increment: In.current,
        decrement: Nn.current
    }),
    reactExports.useEffect( () => {
        on || mn($ === void 0 ? jt : $, !0)
    }
    , [$, on]);
    const cn = st !== void 0 && it !== void 0
      , $n = reactExports.useRef(null)
      , gn = reactExports.useRef(0)
      , dn = () => {
        $n.current && window.clearTimeout($n.current),
        $n.current = null,
        gn.current = 0
    }
      , Dn = xt => {
        xt ? In.current() : Nn.current(),
        gn.current += 1
    }
      , kn = xt => {
        if (Dn(xt),
        cn) {
            const Ot = typeof it == "number" ? it : it(gn.current);
            $n.current = window.setTimeout( () => kn(xt), Ot)
        }
    }
      , An = (xt, Ot) => {
        xt.preventDefault(),
        rn.current.focus(),
        Dn(Ot),
        cn && ($n.current = window.setTimeout( () => kn(Ot), st))
    }
    ;
    reactExports.useEffect( () => (dn(),
    dn), []);
    const Fn = React.createElement("div", {
        className: Lt.rightSection
    }, React.createElement("button", {
        type: "button",
        tabIndex: -1,
        "aria-hidden": !0,
        disabled: jt >= ot,
        className: tn(Lt.control, Lt.controlUp),
        onPointerDown: xt => {
            An(xt, !0)
        }
        ,
        onPointerUp: dn,
        onPointerLeave: dn
    }, React.createElement(Chevron, {
        size: getSize({
            size: wt,
            sizes: CHEVRON_SIZES
        }),
        direction: "up"
    })), React.createElement("button", {
        type: "button",
        tabIndex: -1,
        "aria-hidden": !0,
        disabled: jt <= rt,
        className: tn(Lt.control, Lt.controlDown),
        onPointerDown: xt => {
            An(xt, !1)
        }
        ,
        onPointerUp: dn,
        onPointerLeave: dn
    }, React.createElement(Chevron, {
        size: getSize({
            size: wt,
            sizes: CHEVRON_SIZES
        }),
        direction: "down"
    })))
      , On = xt => {
        let Ot = xt;
        (Ot[0] === `${tt}` || Ot[0] === ".") && (Ot = `0${Ot}`);
        const Dt = parseFloat(Vt(parseFloat(Yt(Ot))))
          , Bt = mt ? Dt : clamp$2(Dt, Sn, bn)
          , Wt = Number.isNaN(Bt) ? "" : Bt
          , Zt = jt !== Wt;
        qt(xt),
        mn(Wt),
        Zt && (_e == null || _e(Wt))
    }
      , jn = xt => {
        xt.nativeEvent.isComposing || On(xt.target.value)
    }
      , Vn = xt => {
        _n(!0),
        at == null || at(xt)
    }
      , Mn = xt => {
        _n(!1),
        lt == null || lt(xt)
    }
      , fn = xt => {
        if (typeof ct == "function" && ct(xt),
        xt.repeat && cn && (xt.key === "ArrowUp" || xt.key === "ArrowDown")) {
            xt.preventDefault();
            return
        }
        a || (xt.key === "ArrowUp" ? An(xt, !0) : xt.key === "ArrowDown" && An(xt, !1))
    }
      , It = xt => {
        typeof ut == "function" && ut(xt),
        (xt.key === "ArrowUp" || xt.key === "ArrowDown") && dn()
    }
    ;
    return React.createElement(TextInput, __spreadProps$e(__spreadValues$o({}, Ut), {
        type: Mt,
        variant: ht,
        value: Kt,
        disabled: _,
        readOnly: a,
        ref: useMergedRef(rn, i),
        onChange: jn,
        onFocus: Vn,
        onBlur: Mn,
        onKeyDown: fn,
        onKeyUp: It,
        rightSection: Tt || (_ || a || dt || ht === "unstyled" ? null : Fn),
        rightSectionWidth: $t ?? `calc(${getSize({
            size: wt,
            sizes: CONTROL_SIZES
        })} + ${rem(1)})`,
        radius: ft,
        max: ot,
        min: rt,
        step: j,
        size: wt,
        styles: vt,
        classNames: bt,
        inputMode: Rt || getInputMode(j, pt, useOs()),
        __staticSelector: "NumberInput",
        unstyled: At
    }))
}
);
NumberInput.displayName = "@mantine/core/NumberInput";
const PasswordToggleIcon = ({reveal: o, size: i}) => React.createElement("svg", {
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    style: {
        width: i,
        height: i
    }
}, React.createElement("path", {
    d: o ? "M13.3536 2.35355C13.5488 2.15829 13.5488 1.84171 13.3536 1.64645C13.1583 1.45118 12.8417 1.45118 12.6464 1.64645L10.6828 3.61012C9.70652 3.21671 8.63759 3 7.5 3C4.30786 3 1.65639 4.70638 0.0760002 7.23501C-0.0253338 7.39715 -0.0253334 7.60288 0.0760014 7.76501C0.902945 9.08812 2.02314 10.1861 3.36061 10.9323L1.64645 12.6464C1.45118 12.8417 1.45118 13.1583 1.64645 13.3536C1.84171 13.5488 2.15829 13.5488 2.35355 13.3536L4.31723 11.3899C5.29348 11.7833 6.36241 12 7.5 12C10.6921 12 13.3436 10.2936 14.924 7.76501C15.0253 7.60288 15.0253 7.39715 14.924 7.23501C14.0971 5.9119 12.9769 4.81391 11.6394 4.06771L13.3536 2.35355ZM9.90428 4.38861C9.15332 4.1361 8.34759 4 7.5 4C4.80285 4 2.52952 5.37816 1.09622 7.50001C1.87284 8.6497 2.89609 9.58106 4.09974 10.1931L9.90428 4.38861ZM5.09572 10.6114L10.9003 4.80685C12.1039 5.41894 13.1272 6.35031 13.9038 7.50001C12.4705 9.62183 10.1971 11 7.5 11C6.65241 11 5.84668 10.8639 5.09572 10.6114Z" : "M7.5 11C4.80285 11 2.52952 9.62184 1.09622 7.50001C2.52952 5.37816 4.80285 4 7.5 4C10.1971 4 12.4705 5.37816 13.9038 7.50001C12.4705 9.62183 10.1971 11 7.5 11ZM7.5 3C4.30786 3 1.65639 4.70638 0.0760002 7.23501C-0.0253338 7.39715 -0.0253334 7.60288 0.0760014 7.76501C1.65639 10.2936 4.30786 12 7.5 12C10.6921 12 13.3436 10.2936 14.924 7.76501C15.0253 7.60288 15.0253 7.39715 14.924 7.23501C13.3436 4.70638 10.6921 3 7.5 3ZM7.5 9.5C8.60457 9.5 9.5 8.60457 9.5 7.5C9.5 6.39543 8.60457 5.5 7.5 5.5C6.39543 5.5 5.5 6.39543 5.5 7.5C5.5 8.60457 6.39543 9.5 7.5 9.5Z",
    fill: "currentColor",
    fillRule: "evenodd",
    clipRule: "evenodd"
}));
var __defProp$n = Object.defineProperty
  , __defProps$d = Object.defineProperties
  , __getOwnPropDescs$d = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$n = Object.getOwnPropertySymbols
  , __hasOwnProp$n = Object.prototype.hasOwnProperty
  , __propIsEnum$n = Object.prototype.propertyIsEnumerable
  , __defNormalProp$n = (o, i, s) => i in o ? __defProp$n(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$n = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$n.call(i, s) && __defNormalProp$n(o, s, i[s]);
    if (__getOwnPropSymbols$n)
        for (var s of __getOwnPropSymbols$n(i))
            __propIsEnum$n.call(i, s) && __defNormalProp$n(o, s, i[s]);
    return o
}
  , __spreadProps$d = (o, i) => __defProps$d(o, __getOwnPropDescs$d(i))
  , useStyles$g = createStyles( (o, {rightSectionWidth: i}, {size: s}) => ({
    visibilityToggle: {},
    input: {
        position: "relative",
        overflow: "hidden"
    },
    innerInput: __spreadProps$d(__spreadValues$n(__spreadValues$n({}, o.fn.fontStyles()), o.fn.cover(0)), {
        backgroundColor: "transparent",
        border: `${rem(1)} solid transparent`,
        borderLeftWidth: 0,
        borderRightWidth: 0,
        boxSizing: "border-box",
        display: "block",
        width: `calc(100% - ${rem(i)})`,
        paddingLeft: `calc(${getSize({
            size: s,
            sizes: sizes$6
        })}  / 3)`,
        fontSize: getSize({
            size: s,
            sizes: o.fontSizes
        }),
        height: `calc(${getSize({
            size: s,
            sizes: sizes$6
        })} - ${rem(2)})`,
        lineHeight: `calc(${getSize({
            size: s,
            sizes: sizes$6
        })} - ${rem(4)})`,
        color: o.colorScheme === "dark" ? o.colors.dark[0] : o.black,
        "&::-ms-reveal, &::-ms-clear": {
            display: "none"
        },
        "&:focus": {
            outline: 0
        },
        "&:disabled": {
            cursor: "not-allowed",
            pointerEvents: "none",
            backgroundColor: o.colorScheme === "dark" ? o.colors.dark[6] : o.colors.gray[1],
            color: o.colors.dark[2],
            opacity: .6,
            "&::placeholder": {
                color: o.colors.dark[2]
            }
        },
        "&::placeholder": __spreadProps$d(__spreadValues$n({}, o.fn.placeholderStyles()), {
            opacity: 1
        }),
        "&[data-invalid]": {
            color: o.fn.variant({
                variant: "filled",
                color: "red"
            }).background,
            "&::placeholder": {
                opacity: 1,
                color: o.fn.variant({
                    variant: "filled",
                    color: "red"
                }).background
            }
        },
        "&[data-with-icon]": {
            paddingLeft: getSize({
                size: s,
                sizes: sizes$6
            })
        }
    })
}));
const useStyles$h = useStyles$g;
var __defProp$m = Object.defineProperty
  , __defProps$c = Object.defineProperties
  , __getOwnPropDescs$c = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$m = Object.getOwnPropertySymbols
  , __hasOwnProp$m = Object.prototype.hasOwnProperty
  , __propIsEnum$m = Object.prototype.propertyIsEnumerable
  , __defNormalProp$m = (o, i, s) => i in o ? __defProp$m(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$m = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$m.call(i, s) && __defNormalProp$m(o, s, i[s]);
    if (__getOwnPropSymbols$m)
        for (var s of __getOwnPropSymbols$m(i))
            __propIsEnum$m.call(i, s) && __defNormalProp$m(o, s, i[s]);
    return o
}
  , __spreadProps$c = (o, i) => __defProps$c(o, __getOwnPropDescs$c(i))
  , __objRest$b = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$m.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$m)
        for (var a of __getOwnPropSymbols$m(o))
            i.indexOf(a) < 0 && __propIsEnum$m.call(o, a) && (s[a] = o[a]);
    return s
}
;
const buttonSizes = {
    xs: rem(22),
    sm: rem(26),
    md: rem(28),
    lg: rem(32),
    xl: rem(40)
}
  , iconSizes = {
    xs: rem(12),
    sm: rem(15),
    md: rem(17),
    lg: rem(19),
    xl: rem(21)
}
  , rightSectionSizes = {
    xs: rem(28),
    sm: rem(32),
    md: rem(34),
    lg: rem(44),
    xl: rem(54)
}
  , defaultProps$9 = {
    size: "sm",
    toggleTabIndex: -1,
    visibilityToggleIcon: PasswordToggleIcon,
    __staticSelector: "PasswordInput"
}
  , PasswordInput = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("PasswordInput", defaultProps$9, o)
      , {radius: a, disabled: _, size: $, toggleTabIndex: _e, className: tt, id: nt, label: rt, error: ot, required: et, style: j, icon: it, description: st, wrapperProps: at, classNames: lt, styles: ct, variant: ut, visibilityToggleIcon: dt, __staticSelector: ft, sx: ht, labelProps: pt, descriptionProps: gt, errorProps: _t, unstyled: mt, visibilityToggleLabel: yt, withAsterisk: bt, inputContainer: vt, iconWidth: wt, inputWrapperOrder: Tt, visible: $t, defaultVisible: Et, onVisibilityChange: Pt} = s
      , Rt = __objRest$b(s, ["radius", "disabled", "size", "toggleTabIndex", "className", "id", "label", "error", "required", "style", "icon", "description", "wrapperProps", "classNames", "styles", "variant", "visibilityToggleIcon", "__staticSelector", "sx", "labelProps", "descriptionProps", "errorProps", "unstyled", "visibilityToggleLabel", "withAsterisk", "inputContainer", "iconWidth", "inputWrapperOrder", "visible", "defaultVisible", "onVisibilityChange"])
      , At = getSize({
        size: $,
        sizes: rightSectionSizes
    })
      , {classes: Mt} = useStyles$h({
        rightSectionWidth: At
    }, {
        name: "PasswordInput",
        classNames: lt,
        styles: ct,
        unstyled: mt,
        size: $,
        variant: ut
    })
      , Ut = useId(nt)
      , {systemStyles: Lt, rest: tn} = extractSystemStyles(Rt)
      , [Vt,Nt] = useUncontrolled({
        value: $t,
        defaultValue: Et,
        finalValue: !1,
        onChange: Pt
    })
      , Yt = () => Nt(!Vt)
      , Xt = React.createElement(ActionIcon, {
        className: Mt.visibilityToggle,
        tabIndex: _e,
        radius: a,
        size: getSize({
            size: $,
            sizes: buttonSizes
        }),
        "aria-hidden": !yt,
        "aria-label": yt,
        unstyled: mt,
        onMouseDown: jt => {
            jt.preventDefault(),
            Yt()
        }
        ,
        onKeyDown: jt => {
            jt.key === " " && (jt.preventDefault(),
            Yt())
        }
    }, React.createElement(dt, {
        reveal: Vt,
        size: getSize({
            size: $,
            sizes: iconSizes
        })
    }));
    return React.createElement(Input.Wrapper, __spreadValues$m(__spreadValues$m({
        required: et,
        id: Ut,
        label: rt,
        error: ot,
        description: st,
        size: $,
        className: tt,
        style: j,
        classNames: lt,
        styles: ct,
        __staticSelector: ft,
        sx: ht,
        errorProps: _t,
        descriptionProps: gt,
        labelProps: pt,
        unstyled: mt,
        withAsterisk: bt,
        inputWrapperOrder: Tt,
        inputContainer: vt,
        variant: ut
    }, Lt), at), React.createElement(Input, {
        component: "div",
        error: ot,
        icon: it,
        size: $,
        classNames: __spreadProps$c(__spreadValues$m({}, lt), {
            input: Mt.input
        }),
        styles: ct,
        radius: a,
        disabled: _,
        __staticSelector: ft,
        rightSectionWidth: At,
        rightSection: !_ && Xt,
        variant: ut,
        unstyled: mt,
        iconWidth: wt
    }, React.createElement("input", __spreadValues$m({
        type: Vt ? "text" : "password",
        required: et,
        "data-invalid": !!ot || void 0,
        "data-with-icon": !!it || void 0,
        className: Mt.innerInput,
        disabled: _,
        id: Ut,
        ref: i,
        autoComplete: "off"
    }, tn))))
}
);
PasswordInput.displayName = "@mantine/core/PasswordInput";
var __defProp$l = Object.defineProperty
  , __defProps$b = Object.defineProperties
  , __getOwnPropDescs$b = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$l = Object.getOwnPropertySymbols
  , __hasOwnProp$l = Object.prototype.hasOwnProperty
  , __propIsEnum$l = Object.prototype.propertyIsEnumerable
  , __defNormalProp$l = (o, i, s) => i in o ? __defProp$l(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$l = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$l.call(i, s) && __defNormalProp$l(o, s, i[s]);
    if (__getOwnPropSymbols$l)
        for (var s of __getOwnPropSymbols$l(i))
            __propIsEnum$l.call(i, s) && __defNormalProp$l(o, s, i[s]);
    return o
}
  , __spreadProps$b = (o, i) => __defProps$b(o, __getOwnPropDescs$b(i));
const WRAPPER_PADDING = 4
  , sizes$1 = {
    xs: `${rem(3)} ${rem(6)}`,
    sm: `${rem(5)} ${rem(10)}`,
    md: `${rem(7)} ${rem(14)}`,
    lg: `${rem(9)} ${rem(16)}`,
    xl: `${rem(12)} ${rem(20)}`
};
var useStyles$e = createStyles( (o, {fullWidth: i, color: s, radius: a, shouldAnimate: _, transitionDuration: $, transitionTimingFunction: _e, orientation: tt}, {size: nt}) => {
    const rt = tt === "vertical"
      , ot = o.fn.variant({
        variant: "filled",
        color: s
    });
    return {
        label: __spreadProps$b(__spreadValues$l(__spreadValues$l({
            ref: getStylesRef("label")
        }, o.fn.focusStyles()), o.fn.fontStyles()), {
            WebkitTapHighlightColor: "transparent",
            borderRadius: o.fn.radius(a),
            fontWeight: 500,
            fontSize: nt in o.fontSizes ? o.fontSizes[nt] : o.fontSizes.sm,
            cursor: "pointer",
            display: "block",
            textAlign: "center",
            padding: sizes$1[nt in sizes$1 ? nt : "sm"],
            whiteSpace: "nowrap",
            overflow: "hidden",
            textOverflow: "ellipsis",
            userSelect: "none",
            color: o.colorScheme === "dark" ? o.colors.dark[1] : o.colors.gray[7],
            transition: `color ${_ ? 0 : $}ms ${_e || o.transitionTimingFunction}`,
            "&:hover": {
                color: o.colorScheme === "dark" ? o.colors.dark[0] : o.black
            },
            "&[data-disabled]": {
                "&, &:hover": {
                    color: o.colorScheme === "dark" ? o.colors.dark[3] : o.colors.gray[5],
                    cursor: "not-allowed",
                    pointerEvents: "none"
                }
            },
            "&[data-active]": {
                "&, &:hover": {
                    color: s || o.colorScheme === "dark" ? o.white : o.black
                }
            }
        }),
        control: {
            ref: getStylesRef("control"),
            position: "relative",
            boxSizing: "border-box",
            flex: 1,
            zIndex: 2,
            transition: `border-left-color ${_ ? 0 : $}ms ${_e || o.transitionTimingFunction}`,
            "&:not(:first-of-type)": {
                borderStyle: "solid",
                borderWidth: rt ? `${rem(1)} 0 0 0` : `0 0 0 ${rem(1)}`,
                borderColor: o.colorScheme === "dark" ? o.colors.dark[4] : o.colors.gray[3]
            }
        },
        input: {
            height: 0,
            width: 0,
            position: "absolute",
            overflow: "hidden",
            whiteSpace: "nowrap",
            opacity: 0,
            "&:focus": {
                outline: "none",
                [`& + .${getStylesRef("label")}`]: __spreadValues$l({}, o.focusRing === "always" || o.focusRing === "auto" ? o.focusRingStyles.styles(o) : o.focusRingStyles.resetStyles(o)),
                "&:focus:not(:focus-visible)": {
                    [`& + .${getStylesRef("label")}`]: __spreadValues$l({}, o.focusRing === "auto" || o.focusRing === "never" ? o.focusRingStyles.resetStyles(o) : null)
                }
            },
            "&:disabled + label": {
                "&, &:hover": {
                    color: o.colorScheme === "dark" ? o.colors.dark[3] : o.colors.gray[5],
                    cursor: "not-allowed",
                    pointerEvents: "none"
                }
            }
        },
        root: {
            position: "relative",
            display: i || rt ? "flex" : "inline-flex",
            width: rt && !i ? "max-content" : "auto",
            flexDirection: rt ? "column" : "row",
            backgroundColor: o.colorScheme === "dark" ? o.colors.dark[8] : o.colors.gray[1],
            borderRadius: o.fn.radius(a),
            overflow: "hidden",
            padding: WRAPPER_PADDING
        },
        controlActive: {
            borderLeftColor: "transparent !important",
            borderTopColor: "transparent !important",
            [`& + .${getStylesRef("control")}`]: {
                [rt ? "borderTopColor" : "borderLeftColor"]: "transparent !important"
            },
            borderRadius: o.fn.radius(a),
            boxShadow: _ ? s || o.colorScheme === "dark" ? "none" : o.shadows.xs : void 0,
            backgroundColor: _ ? s ? ot.background : o.colorScheme === "dark" ? o.colors.dark[5] : o.white : void 0
        },
        indicator: {
            boxSizing: "border-box",
            borderRadius: o.fn.radius(a),
            position: "absolute",
            zIndex: 1,
            boxShadow: s || o.colorScheme === "dark" ? "none" : o.shadows.xs,
            transition: `transform ${_ ? 0 : $}ms ${o.transitionTimingFunction}, width ${_ ? 0 : $ / 2}ms ${_e || o.transitionTimingFunction}`,
            backgroundColor: s ? ot.background : o.colorScheme === "dark" ? o.colors.dark[5] : o.white
        }
    }
}
);
const useStyles$f = useStyles$e;
var __defProp$k = Object.defineProperty
  , __getOwnPropSymbols$k = Object.getOwnPropertySymbols
  , __hasOwnProp$k = Object.prototype.hasOwnProperty
  , __propIsEnum$k = Object.prototype.propertyIsEnumerable
  , __defNormalProp$k = (o, i, s) => i in o ? __defProp$k(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$k = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$k.call(i, s) && __defNormalProp$k(o, s, i[s]);
    if (__getOwnPropSymbols$k)
        for (var s of __getOwnPropSymbols$k(i))
            __propIsEnum$k.call(i, s) && __defNormalProp$k(o, s, i[s]);
    return o
}
  , __objRest$a = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$k.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$k)
        for (var a of __getOwnPropSymbols$k(o))
            i.indexOf(a) < 0 && __propIsEnum$k.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$8 = {
    disabled: !1,
    size: "sm",
    transitionDuration: 200
}
  , SegmentedControl = reactExports.forwardRef( (o, i) => {
    var s, a, _, $;
    const _e = useComponentDefaultProps("SegmentedControl", defaultProps$8, o)
      , {className: tt, disabled: nt, data: rt, name: ot, value: et, onChange: j, color: it, fullWidth: st, radius: at, size: lt, transitionDuration: ct, transitionTimingFunction: ut, classNames: dt, styles: ft, defaultValue: ht, orientation: pt, unstyled: gt, variant: _t, readOnly: mt} = _e
      , yt = __objRest$a(_e, ["className", "disabled", "data", "name", "value", "onChange", "color", "fullWidth", "radius", "size", "transitionDuration", "transitionTimingFunction", "classNames", "styles", "defaultValue", "orientation", "unstyled", "variant", "readOnly"])
      , bt = useMantineTheme()
      , vt = useReducedMotion()
      , wt = bt.respectReducedMotion ? vt : !1
      , Tt = rt.map(Kt => typeof Kt == "string" ? {
        label: Kt,
        value: Kt
    } : Kt)
      , $t = reactExports.useRef()
      , [Et,Pt] = reactExports.useState(!1)
      , [Rt,At] = useUncontrolled({
        value: et,
        defaultValue: ht,
        finalValue: Array.isArray(Tt) && ($ = (_ = (s = Tt.find(Kt => !Kt.disabled)) == null ? void 0 : s.value) != null ? _ : (a = Tt[0]) == null ? void 0 : a.value) != null ? $ : null,
        onChange: j
    })
      , {classes: Mt, cx: Ut} = useStyles$f({
        fullWidth: st,
        color: it,
        radius: at,
        shouldAnimate: wt || !Et,
        transitionDuration: ct,
        transitionTimingFunction: ut,
        orientation: pt
    }, {
        name: "SegmentedControl",
        classNames: dt,
        styles: ft,
        unstyled: gt,
        variant: _t,
        size: lt
    })
      , [Lt,tn] = reactExports.useState({
        width: 0,
        height: 0,
        translate: [0, 0]
    })
      , Vt = useId(ot)
      , Nt = reactExports.useRef({})
      , [Yt,Xt] = useResizeObserver();
    useIsomorphicEffect( () => {
        $t.current ? Pt(!0) : ($t.current = !0,
        Pt(!1))
    }
    ),
    reactExports.useEffect( () => {
        if (Rt in Nt.current && Yt.current) {
            const Kt = Nt.current[Rt]
              , qt = Kt.getBoundingClientRect()
              , rn = Kt.offsetWidth / qt.width
              , on = qt.width * rn || 0
              , _n = qt.height * rn || 0
              , mn = Xt.width - Kt.parentElement.offsetLeft + WRAPPER_PADDING - on
              , Sn = Kt.parentElement.offsetLeft - WRAPPER_PADDING;
            tn({
                width: on,
                height: _n,
                translate: [bt.dir === "rtl" ? mn : Sn, Kt.parentElement.offsetTop - WRAPPER_PADDING]
            })
        }
    }
    , [Rt, Xt]);
    const jt = Tt.map(Kt => React.createElement("div", {
        className: Ut(Mt.control, {
            [Mt.controlActive]: Rt === Kt.value
        }),
        key: Kt.value
    }, React.createElement("input", {
        className: Mt.input,
        disabled: nt || Kt.disabled,
        type: "radio",
        name: Vt,
        value: Kt.value,
        id: `${Vt}-${Kt.value}`,
        checked: Rt === Kt.value,
        onChange: () => !mt && At(Kt.value)
    }), React.createElement("label", {
        className: Mt.label,
        "data-active": Rt === Kt.value && !(nt || Kt.disabled) || void 0,
        "data-disabled": nt || Kt.disabled || void 0,
        htmlFor: `${Vt}-${Kt.value}`,
        ref: qt => {
            Nt.current[Kt.value] = qt
        }
    }, Kt.label)))
      , Gt = useMergedRef(Yt, i);
    return Tt.length === 0 ? null : React.createElement(Box, __spreadValues$k({
        className: Ut(Mt.root, tt),
        ref: Gt
    }, yt), typeof Rt == "string" && Et && React.createElement(Box, {
        component: "span",
        className: Mt.indicator,
        sx: {
            width: Lt.width,
            height: Lt.height,
            transform: `translate(${Lt.translate[0]}px, ${Lt.translate[1]}px)`
        }
    }), jt)
}
);
SegmentedControl.displayName = "@mantine/core/SegmentedControl";
function filterData({data: o, searchable: i, limit: s, searchValue: a, filter: _, value: $, filterDataOnExactSearchMatch: _e}) {
    if (!i)
        return o;
    const tt = $ != null && o.find(rt => rt.value === $) || null;
    if (tt && !_e && (tt == null ? void 0 : tt.label) === a) {
        if (s) {
            if (s >= o.length)
                return o;
            const rt = o.indexOf(tt)
              , ot = rt + s
              , et = ot - o.length;
            return et > 0 ? o.slice(rt - et) : o.slice(rt, ot)
        }
        return o
    }
    const nt = [];
    for (let rt = 0; rt < o.length && (_(a, o[rt]) && nt.push(o[rt]),
    !(nt.length >= s)); rt += 1)
        ;
    return nt
}
var useStyles$c = createStyles( () => ({
    input: {
        "&:not(:disabled)": {
            cursor: "pointer",
            "&::selection": {
                backgroundColor: "transparent"
            }
        }
    }
}));
const useStyles$d = useStyles$c;
var __defProp$j = Object.defineProperty
  , __defProps$a = Object.defineProperties
  , __getOwnPropDescs$a = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$j = Object.getOwnPropertySymbols
  , __hasOwnProp$j = Object.prototype.hasOwnProperty
  , __propIsEnum$j = Object.prototype.propertyIsEnumerable
  , __defNormalProp$j = (o, i, s) => i in o ? __defProp$j(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$j = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$j.call(i, s) && __defNormalProp$j(o, s, i[s]);
    if (__getOwnPropSymbols$j)
        for (var s of __getOwnPropSymbols$j(i))
            __propIsEnum$j.call(i, s) && __defNormalProp$j(o, s, i[s]);
    return o
}
  , __spreadProps$a = (o, i) => __defProps$a(o, __getOwnPropDescs$a(i))
  , __objRest$9 = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$j.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$j)
        for (var a of __getOwnPropSymbols$j(o))
            i.indexOf(a) < 0 && __propIsEnum$j.call(o, a) && (s[a] = o[a]);
    return s
}
;
function defaultFilter(o, i) {
    return i.label.toLowerCase().trim().includes(o.toLowerCase().trim())
}
function defaultShouldCreate(o, i) {
    return !!o && !i.some(s => s.label.toLowerCase() === o.toLowerCase())
}
const defaultProps$7 = {
    required: !1,
    size: "sm",
    shadow: "sm",
    itemComponent: DefaultItem,
    transitionProps: {
        transition: "fade",
        duration: 0
    },
    initiallyOpened: !1,
    filter: defaultFilter,
    maxDropdownHeight: 220,
    searchable: !1,
    clearable: !1,
    limit: 1 / 0,
    disabled: !1,
    creatable: !1,
    shouldCreate: defaultShouldCreate,
    selectOnBlur: !1,
    switchDirectionOnFlip: !1,
    filterDataOnExactSearchMatch: !1,
    zIndex: getDefaultZIndex("popover"),
    positionDependencies: [],
    dropdownPosition: "flip"
}
  , Select = reactExports.forwardRef( (o, i) => {
    const s = useInputProps("Select", defaultProps$7, o)
      , {inputProps: a, wrapperProps: _, shadow: $, data: _e, value: tt, defaultValue: nt, onChange: rt, itemComponent: ot, onKeyDown: et, onBlur: j, onFocus: it, transitionProps: st, initiallyOpened: at, unstyled: lt, classNames: ct, styles: ut, filter: dt, maxDropdownHeight: ft, searchable: ht, clearable: pt, nothingFound: gt, limit: _t, disabled: mt, onSearchChange: yt, searchValue: bt, rightSection: vt, rightSectionWidth: wt, creatable: Tt, getCreateLabel: $t, shouldCreate: Et, selectOnBlur: Pt, onCreate: Rt, dropdownComponent: At, onDropdownClose: Mt, onDropdownOpen: Ut, withinPortal: Lt, portalProps: tn, switchDirectionOnFlip: Vt, zIndex: Nt, name: Yt, dropdownPosition: Xt, allowDeselect: jt, placeholder: Gt, filterDataOnExactSearchMatch: Kt, form: qt, positionDependencies: rn, readOnly: on, clearButtonProps: _n, hoverOnSearchChange: mn} = s
      , Sn = __objRest$9(s, ["inputProps", "wrapperProps", "shadow", "data", "value", "defaultValue", "onChange", "itemComponent", "onKeyDown", "onBlur", "onFocus", "transitionProps", "initiallyOpened", "unstyled", "classNames", "styles", "filter", "maxDropdownHeight", "searchable", "clearable", "nothingFound", "limit", "disabled", "onSearchChange", "searchValue", "rightSection", "rightSectionWidth", "creatable", "getCreateLabel", "shouldCreate", "selectOnBlur", "onCreate", "dropdownComponent", "onDropdownClose", "onDropdownOpen", "withinPortal", "portalProps", "switchDirectionOnFlip", "zIndex", "name", "dropdownPosition", "allowDeselect", "placeholder", "filterDataOnExactSearchMatch", "form", "positionDependencies", "readOnly", "clearButtonProps", "hoverOnSearchChange"])
      , {classes: bn, cx: In, theme: Nn} = useStyles$d()
      , [cn,$n] = reactExports.useState(at)
      , [gn,dn] = reactExports.useState(-1)
      , Dn = reactExports.useRef()
      , kn = reactExports.useRef({})
      , [An,Fn] = reactExports.useState("column")
      , On = An === "column"
      , {scrollIntoView: jn, targetRef: Vn, scrollableRef: Mn} = useScrollIntoView({
        duration: 0,
        offset: 5,
        cancelable: !1,
        isList: !0
    })
      , fn = jt === void 0 ? pt : jt
      , It = sn => {
        if (cn !== sn) {
            $n(sn);
            const un = sn ? Ut : Mt;
            typeof un == "function" && un()
        }
    }
      , xt = Tt && typeof $t == "function";
    let Ot = null;
    const Dt = _e.map(sn => typeof sn == "string" ? {
        label: sn,
        value: sn
    } : sn)
      , Bt = groupOptions({
        data: Dt
    })
      , [Wt,Zt,an] = useUncontrolled({
        value: tt,
        defaultValue: nt,
        finalValue: null,
        onChange: rt
    })
      , en = Bt.find(sn => sn.value === Wt)
      , [Jt,pn] = useUncontrolled({
        value: bt,
        defaultValue: (en == null ? void 0 : en.label) || "",
        finalValue: void 0,
        onChange: yt
    })
      , vn = sn => {
        pn(sn),
        ht && typeof yt == "function" && yt(sn)
    }
      , hn = () => {
        var sn;
        on || (Zt(null),
        an || vn(""),
        (sn = Dn.current) == null || sn.focus())
    }
    ;
    reactExports.useEffect( () => {
        const sn = Bt.find(un => un.value === Wt);
        sn ? vn(sn.label) : (!xt || !Wt) && vn("")
    }
    , [Wt]),
    reactExports.useEffect( () => {
        en && (!ht || !cn) && vn(en.label)
    }
    , [en == null ? void 0 : en.label]);
    const Ft = sn => {
        if (!on)
            if (fn && (en == null ? void 0 : en.value) === sn.value)
                Zt(null),
                It(!1);
            else {
                if (sn.creatable && typeof Rt == "function") {
                    const un = Rt(sn.value);
                    typeof un < "u" && un !== null && Zt(typeof un == "string" ? un : un.value)
                } else
                    Zt(sn.value);
                an || vn(sn.label),
                dn(-1),
                It(!1),
                Dn.current.focus()
            }
    }
      , Qt = filterData({
        data: Bt,
        searchable: ht,
        limit: _t,
        searchValue: Jt,
        filter: dt,
        filterDataOnExactSearchMatch: Kt,
        value: Wt
    });
    xt && Et(Jt, Qt) && (Ot = $t(Jt),
    Qt.push({
        label: Jt,
        value: Jt,
        creatable: !0
    }));
    const yn = (sn, un, Bn) => {
        let En = sn;
        for (; Bn(En); )
            if (En = un(En),
            !Qt[En].disabled)
                return En;
        return sn
    }
    ;
    useDidUpdate( () => {
        dn(mn && Jt ? 0 : -1)
    }
    , [Jt, mn]);
    const wn = Wt ? Qt.findIndex(sn => sn.value === Wt) : 0
      , Ln = !on && (Qt.length > 0 ? cn : cn && !!gt)
      , Hn = () => {
        dn(sn => {
            var un;
            const Bn = yn(sn, En => En - 1, En => En > 0);
            return Vn.current = kn.current[(un = Qt[Bn]) == null ? void 0 : un.value],
            Ln && jn({
                alignment: On ? "start" : "end"
            }),
            Bn
        }
        )
    }
      , Rn = () => {
        dn(sn => {
            var un;
            const Bn = yn(sn, En => En + 1, En => En < Qt.length - 1);
            return Vn.current = kn.current[(un = Qt[Bn]) == null ? void 0 : un.value],
            Ln && jn({
                alignment: On ? "end" : "start"
            }),
            Bn
        }
        )
    }
      , Cn = () => window.setTimeout( () => {
        var sn;
        Vn.current = kn.current[(sn = Qt[wn]) == null ? void 0 : sn.value],
        jn({
            alignment: On ? "end" : "start"
        })
    }
    , 50);
    useDidUpdate( () => {
        Ln && Cn()
    }
    , [Ln]);
    const zn = sn => {
        switch (typeof et == "function" && et(sn),
        sn.key) {
        case "ArrowUp":
            {
                sn.preventDefault(),
                cn ? On ? Hn() : Rn() : (dn(wn),
                It(!0),
                Cn());
                break
            }
        case "ArrowDown":
            {
                sn.preventDefault(),
                cn ? On ? Rn() : Hn() : (dn(wn),
                It(!0),
                Cn());
                break
            }
        case "Home":
            {
                if (!ht) {
                    sn.preventDefault(),
                    cn || It(!0);
                    const un = Qt.findIndex(Bn => !Bn.disabled);
                    dn(un),
                    Ln && jn({
                        alignment: On ? "end" : "start"
                    })
                }
                break
            }
        case "End":
            {
                if (!ht) {
                    sn.preventDefault(),
                    cn || It(!0);
                    const un = Qt.map(Bn => !!Bn.disabled).lastIndexOf(!1);
                    dn(un),
                    Ln && jn({
                        alignment: On ? "end" : "start"
                    })
                }
                break
            }
        case "Escape":
            {
                sn.preventDefault(),
                It(!1),
                dn(-1);
                break
            }
        case " ":
            {
                ht || (sn.preventDefault(),
                Qt[gn] && cn ? Ft(Qt[gn]) : (It(!0),
                dn(wn),
                Cn()));
                break
            }
        case "Enter":
            ht || sn.preventDefault(),
            Qt[gn] && cn && (sn.preventDefault(),
            Ft(Qt[gn]))
        }
    }
      , qn = sn => {
        typeof j == "function" && j(sn);
        const un = Bt.find(Bn => Bn.value === Wt);
        Pt && Qt[gn] && cn && Ft(Qt[gn]),
        vn((un == null ? void 0 : un.label) || ""),
        It(!1)
    }
      , Qn = sn => {
        typeof it == "function" && it(sn),
        ht && It(!0)
    }
      , er = sn => {
        on || (vn(sn.currentTarget.value),
        pt && sn.currentTarget.value === "" && Zt(null),
        dn(-1),
        It(!0))
    }
      , Tn = () => {
        on || (It(!cn),
        Wt && !cn && dn(wn))
    }
    ;
    return React.createElement(Input.Wrapper, __spreadProps$a(__spreadValues$j({}, _), {
        __staticSelector: "Select"
    }), React.createElement(SelectPopover, {
        opened: Ln,
        transitionProps: st,
        shadow: $,
        withinPortal: Lt,
        portalProps: tn,
        __staticSelector: "Select",
        onDirectionChange: Fn,
        switchDirectionOnFlip: Vt,
        zIndex: Nt,
        dropdownPosition: Xt,
        positionDependencies: [...rn, Jt],
        classNames: ct,
        styles: ut,
        unstyled: lt,
        variant: a.variant
    }, React.createElement(SelectPopover.Target, null, React.createElement("div", {
        role: "combobox",
        "aria-haspopup": "listbox",
        "aria-owns": Ln ? `${a.id}-items` : null,
        "aria-controls": a.id,
        "aria-expanded": Ln,
        onMouseLeave: () => dn(-1),
        tabIndex: -1
    }, React.createElement("input", {
        type: "hidden",
        name: Yt,
        value: Wt || "",
        form: qt,
        disabled: mt
    }), React.createElement(Input, __spreadValues$j(__spreadProps$a(__spreadValues$j(__spreadValues$j({
        autoComplete: "off",
        type: "search"
    }, a), Sn), {
        ref: useMergedRef(i, Dn),
        onKeyDown: zn,
        __staticSelector: "Select",
        value: Jt,
        placeholder: Gt,
        onChange: er,
        "aria-autocomplete": "list",
        "aria-controls": Ln ? `${a.id}-items` : null,
        "aria-activedescendant": gn >= 0 ? `${a.id}-${gn}` : null,
        onMouseDown: Tn,
        onBlur: qn,
        onFocus: Qn,
        readOnly: !ht || on,
        disabled: mt,
        "data-mantine-stop-propagation": Ln,
        name: null,
        classNames: __spreadProps$a(__spreadValues$j({}, ct), {
            input: In({
                [bn.input]: !ht
            }, ct == null ? void 0 : ct.input)
        })
    }), getSelectRightSectionProps({
        theme: Nn,
        rightSection: vt,
        rightSectionWidth: wt,
        styles: ut,
        size: a.size,
        shouldClear: pt && !!en,
        onClear: hn,
        error: _.error,
        clearButtonProps: _n,
        disabled: mt,
        readOnly: on
    }))))), React.createElement(SelectPopover.Dropdown, {
        component: At || SelectScrollArea,
        maxHeight: ft,
        direction: An,
        id: a.id,
        innerRef: Mn,
        __staticSelector: "Select",
        classNames: ct,
        styles: ut
    }, React.createElement(SelectItems, {
        data: Qt,
        hovered: gn,
        classNames: ct,
        styles: ut,
        isItemSelected: sn => sn === Wt,
        uuid: a.id,
        __staticSelector: "Select",
        onItemHover: dn,
        onItemSelect: Ft,
        itemsRefs: kn,
        itemComponent: ot,
        size: a.size,
        nothingFound: gt,
        creatable: xt && !!Ot,
        createLabel: Ot,
        "aria-label": _.label,
        unstyled: lt,
        variant: a.variant
    }))))
}
);
Select.displayName = "@mantine/core/Select";
var useStyles$a = createStyles( (o, {spacing: i, align: s, justify: a}) => ({
    root: {
        display: "flex",
        flexDirection: "column",
        alignItems: s,
        justifyContent: a,
        gap: getSize({
            size: i,
            sizes: o.spacing
        })
    }
}));
const useStyles$b = useStyles$a;
var __defProp$i = Object.defineProperty
  , __getOwnPropSymbols$i = Object.getOwnPropertySymbols
  , __hasOwnProp$i = Object.prototype.hasOwnProperty
  , __propIsEnum$i = Object.prototype.propertyIsEnumerable
  , __defNormalProp$i = (o, i, s) => i in o ? __defProp$i(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$i = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$i.call(i, s) && __defNormalProp$i(o, s, i[s]);
    if (__getOwnPropSymbols$i)
        for (var s of __getOwnPropSymbols$i(i))
            __propIsEnum$i.call(i, s) && __defNormalProp$i(o, s, i[s]);
    return o
}
  , __objRest$8 = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$i.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$i)
        for (var a of __getOwnPropSymbols$i(o))
            i.indexOf(a) < 0 && __propIsEnum$i.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$6 = {
    spacing: "md",
    align: "stretch",
    justify: "flex-start"
}
  , Stack = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("Stack", defaultProps$6, o)
      , {spacing: a, className: _, align: $, justify: _e, unstyled: tt, variant: nt} = s
      , rt = __objRest$8(s, ["spacing", "className", "align", "justify", "unstyled", "variant"])
      , {classes: ot, cx: et} = useStyles$b({
        spacing: a,
        align: $,
        justify: _e
    }, {
        name: "Stack",
        unstyled: tt,
        variant: nt
    });
    return React.createElement(Box, __spreadValues$i({
        className: et(ot.root, _),
        ref: i
    }, rt))
}
);
Stack.displayName = "@mantine/core/Stack";
const SwitchGroupContext = reactExports.createContext(null)
  , SwitchGroupProvider = SwitchGroupContext.Provider
  , useSwitchGroupContext = () => reactExports.useContext(SwitchGroupContext);
var __defProp$h = Object.defineProperty
  , __getOwnPropSymbols$h = Object.getOwnPropertySymbols
  , __hasOwnProp$h = Object.prototype.hasOwnProperty
  , __propIsEnum$h = Object.prototype.propertyIsEnumerable
  , __defNormalProp$h = (o, i, s) => i in o ? __defProp$h(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$h = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$h.call(i, s) && __defNormalProp$h(o, s, i[s]);
    if (__getOwnPropSymbols$h)
        for (var s of __getOwnPropSymbols$h(i))
            __propIsEnum$h.call(i, s) && __defNormalProp$h(o, s, i[s]);
    return o
}
  , __objRest$7 = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$h.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$h)
        for (var a of __getOwnPropSymbols$h(o))
            i.indexOf(a) < 0 && __propIsEnum$h.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$5 = {
    size: "sm"
}
  , SwitchGroup = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("SwitchGroup", defaultProps$5, o)
      , {children: a, value: _, defaultValue: $, onChange: _e, size: tt, wrapperProps: nt} = s
      , rt = __objRest$7(s, ["children", "value", "defaultValue", "onChange", "size", "wrapperProps"])
      , [ot,et] = useUncontrolled({
        value: _,
        defaultValue: $,
        finalValue: [],
        onChange: _e
    })
      , j = it => {
        const st = it.currentTarget.value;
        et(ot.includes(st) ? ot.filter(at => at !== st) : [...ot, st])
    }
    ;
    return React.createElement(SwitchGroupProvider, {
        value: {
            value: ot,
            onChange: j,
            size: tt
        }
    }, React.createElement(Input.Wrapper, __spreadValues$h(__spreadValues$h({
        labelElement: "div",
        size: tt,
        __staticSelector: "SwitchGroup",
        ref: i
    }, nt), rt), a))
}
);
SwitchGroup.displayName = "@mantine/core/SwitchGroup";
var __defProp$g = Object.defineProperty
  , __defProps$9 = Object.defineProperties
  , __getOwnPropDescs$9 = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$g = Object.getOwnPropertySymbols
  , __hasOwnProp$g = Object.prototype.hasOwnProperty
  , __propIsEnum$g = Object.prototype.propertyIsEnumerable
  , __defNormalProp$g = (o, i, s) => i in o ? __defProp$g(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$g = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$g.call(i, s) && __defNormalProp$g(o, s, i[s]);
    if (__getOwnPropSymbols$g)
        for (var s of __getOwnPropSymbols$g(i))
            __propIsEnum$g.call(i, s) && __defNormalProp$g(o, s, i[s]);
    return o
}
  , __spreadProps$9 = (o, i) => __defProps$9(o, __getOwnPropDescs$9(i));
const switchHeight = {
    xs: rem(16),
    sm: rem(20),
    md: rem(24),
    lg: rem(30),
    xl: rem(36)
}
  , switchWidth = {
    xs: rem(32),
    sm: rem(38),
    md: rem(46),
    lg: rem(56),
    xl: rem(72)
}
  , handleSizes = {
    xs: rem(12),
    sm: rem(14),
    md: rem(18),
    lg: rem(22),
    xl: rem(28)
}
  , labelFontSizes = {
    xs: rem(5),
    sm: rem(6),
    md: rem(7),
    lg: rem(9),
    xl: rem(11)
}
  , trackLabelPaddings = {
    xs: rem(4),
    sm: rem(5),
    md: rem(6),
    lg: rem(8),
    xl: rem(10)
};
var useStyles$8 = createStyles( (o, {radius: i, color: s, labelPosition: a, error: _}, {size: $}) => {
    const _e = getSize({
        size: $,
        sizes: handleSizes
    })
      , tt = getSize({
        size: i,
        sizes: o.radius
    })
      , nt = o.fn.variant({
        variant: "filled",
        color: s
    })
      , rt = getSize({
        size: $,
        sizes: switchWidth
    })
      , ot = rem($ === "xs" ? 1 : 2)
      , et = o.fn.variant({
        variant: "filled",
        color: "red"
    }).background;
    return {
        root: {
            position: "relative"
        },
        input: {
            height: 0,
            width: 0,
            overflow: "hidden",
            whiteSpace: "nowrap",
            padding: 0,
            WebkitClipPath: "inset(50%)",
            clipPath: "inset(50%)",
            position: "absolute"
        },
        track: __spreadProps$9(__spreadValues$g({}, o.fn.focusStyles("input:focus + &")), {
            cursor: o.cursorType,
            overflow: "hidden",
            WebkitTapHighlightColor: "transparent",
            position: "relative",
            borderRadius: tt,
            backgroundColor: o.colorScheme === "dark" ? o.colors.dark[6] : o.colors.gray[2],
            border: `${rem(1)} solid ${_ ? et : o.colorScheme === "dark" ? o.colors.dark[4] : o.colors.gray[3]}`,
            height: getSize({
                size: $,
                sizes: switchHeight
            }),
            minWidth: rt,
            margin: 0,
            transitionProperty: "background-color, border-color",
            transitionTimingFunction: o.transitionTimingFunction,
            transitionDuration: "150ms",
            boxSizing: "border-box",
            appearance: "none",
            display: "flex",
            alignItems: "center",
            fontSize: getSize({
                size: $,
                sizes: labelFontSizes
            }),
            fontWeight: 600,
            order: a === "left" ? 2 : 1,
            userSelect: "none",
            zIndex: 0,
            lineHeight: 0,
            color: o.colorScheme === "dark" ? o.colors.dark[1] : o.colors.gray[6],
            transition: `color 150ms ${o.transitionTimingFunction}`,
            "input:checked + &": {
                backgroundColor: nt.background,
                borderColor: nt.background,
                color: o.white,
                transition: `color 150ms ${o.transitionTimingFunction}`
            },
            "input:disabled + &": {
                backgroundColor: o.colorScheme === "dark" ? o.colors.dark[4] : o.colors.gray[2],
                borderColor: o.colorScheme === "dark" ? o.colors.dark[4] : o.colors.gray[2],
                cursor: "not-allowed",
                pointerEvents: "none"
            }
        }),
        thumb: {
            position: "absolute",
            zIndex: 1,
            borderRadius: tt,
            boxSizing: "border-box",
            display: "flex",
            backgroundColor: o.white,
            height: _e,
            width: _e,
            border: `${rem(1)} solid ${o.colorScheme === "dark" ? o.white : o.colors.gray[3]}`,
            left: ot,
            transition: `left 150ms ${o.transitionTimingFunction}`,
            "& > *": {
                margin: "auto"
            },
            "@media (prefers-reduced-motion)": {
                transitionDuration: o.respectReducedMotion ? "0ms" : ""
            },
            "input:checked + * > &": {
                left: `calc(100% - ${_e} - ${ot})`,
                borderColor: o.white
            },
            "input:disabled + * > &": {
                borderColor: o.colorScheme === "dark" ? o.colors.dark[4] : o.colors.gray[2],
                backgroundColor: o.colorScheme === "dark" ? o.colors.dark[3] : o.colors.gray[0]
            }
        },
        trackLabel: {
            height: "100%",
            display: "grid",
            placeContent: "center",
            minWidth: `calc(${rt} - ${_e})`,
            paddingInline: getSize({
                size: $,
                sizes: trackLabelPaddings
            }),
            marginLeft: `calc(${_e} + ${ot})`,
            transition: `margin 150ms ${o.transitionTimingFunction}`,
            "input:checked + * > &": {
                marginLeft: 0,
                marginRight: `calc(${_e} + ${ot})`
            }
        }
    }
}
);
const useStyles$9 = useStyles$8;
var __defProp$f = Object.defineProperty
  , __defProps$8 = Object.defineProperties
  , __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$f = Object.getOwnPropertySymbols
  , __hasOwnProp$f = Object.prototype.hasOwnProperty
  , __propIsEnum$f = Object.prototype.propertyIsEnumerable
  , __defNormalProp$f = (o, i, s) => i in o ? __defProp$f(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$f = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$f.call(i, s) && __defNormalProp$f(o, s, i[s]);
    if (__getOwnPropSymbols$f)
        for (var s of __getOwnPropSymbols$f(i))
            __propIsEnum$f.call(i, s) && __defNormalProp$f(o, s, i[s]);
    return o
}
  , __spreadProps$8 = (o, i) => __defProps$8(o, __getOwnPropDescs$8(i))
  , __objRest$6 = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$f.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$f)
        for (var a of __getOwnPropSymbols$f(o))
            i.indexOf(a) < 0 && __propIsEnum$f.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$4 = {
    offLabel: "",
    onLabel: "",
    size: "sm",
    radius: "xl",
    error: !1
}
  , Switch = reactExports.forwardRef( (o, i) => {
    var s;
    const a = useComponentDefaultProps("Switch", defaultProps$4, o)
      , {className: _, color: $, label: _e, offLabel: tt, onLabel: nt, id: rt, style: ot, size: et, radius: j, wrapperProps: it, children: st, unstyled: at, styles: lt, classNames: ct, thumbIcon: ut, sx: dt, checked: ft, defaultChecked: ht, onChange: pt, labelPosition: gt, description: _t, error: mt, disabled: yt, variant: bt} = a
      , vt = __objRest$6(a, ["className", "color", "label", "offLabel", "onLabel", "id", "style", "size", "radius", "wrapperProps", "children", "unstyled", "styles", "classNames", "thumbIcon", "sx", "checked", "defaultChecked", "onChange", "labelPosition", "description", "error", "disabled", "variant"])
      , wt = useSwitchGroupContext()
      , Tt = (wt == null ? void 0 : wt.size) || et
      , {classes: $t, cx: Et} = useStyles$9({
        color: $,
        radius: j,
        labelPosition: gt,
        error: !!mt
    }, {
        name: "Switch",
        classNames: ct,
        styles: lt,
        unstyled: at,
        size: Tt,
        variant: bt
    })
      , {systemStyles: Pt, rest: Rt} = extractSystemStyles(vt)
      , At = useId(rt)
      , Mt = wt ? {
        checked: wt.value.includes(Rt.value),
        onChange: wt.onChange
    } : {}
      , [Ut,Lt] = useUncontrolled({
        value: (s = Mt.checked) != null ? s : ft,
        defaultValue: ht,
        finalValue: !1
    });
    return React.createElement(InlineInput, __spreadValues$f(__spreadValues$f({
        className: Et(_, $t.root),
        sx: dt,
        style: ot,
        id: At,
        size: (wt == null ? void 0 : wt.size) || et,
        labelPosition: gt,
        label: _e,
        description: _t,
        error: mt,
        disabled: yt,
        __staticSelector: "Switch",
        classNames: ct,
        styles: lt,
        unstyled: at,
        "data-checked": Mt.checked || void 0,
        variant: bt
    }, Pt), it), React.createElement("input", __spreadProps$8(__spreadValues$f({}, Rt), {
        disabled: yt,
        checked: Ut,
        onChange: tn => {
            wt ? Mt.onChange(tn) : pt == null || pt(tn),
            Lt(tn.currentTarget.checked)
        }
        ,
        id: At,
        ref: i,
        type: "checkbox",
        className: $t.input
    })), React.createElement("label", {
        htmlFor: At,
        className: $t.track
    }, React.createElement("div", {
        className: $t.thumb
    }, ut), React.createElement("div", {
        className: $t.trackLabel
    }, Ut ? nt : tt)))
}
);
Switch.displayName = "@mantine/core/Switch";
Switch.Group = SwitchGroup;
var __defProp$e = Object.defineProperty
  , __defProps$7 = Object.defineProperties
  , __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$e = Object.getOwnPropertySymbols
  , __hasOwnProp$e = Object.prototype.hasOwnProperty
  , __propIsEnum$e = Object.prototype.propertyIsEnumerable
  , __defNormalProp$e = (o, i, s) => i in o ? __defProp$e(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$e = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$e.call(i, s) && __defNormalProp$e(o, s, i[s]);
    if (__getOwnPropSymbols$e)
        for (var s of __getOwnPropSymbols$e(i))
            __propIsEnum$e.call(i, s) && __defNormalProp$e(o, s, i[s]);
    return o
}
  , __spreadProps$7 = (o, i) => __defProps$7(o, __getOwnPropDescs$7(i))
  , useStyles$6 = createStyles( (o, {captionSide: i, horizontalSpacing: s, verticalSpacing: a, fontSize: _, withBorder: $, withColumnBorders: _e}) => {
    const tt = `${rem(1)} solid ${o.colorScheme === "dark" ? o.colors.dark[4] : o.colors.gray[3]}`;
    return {
        root: __spreadProps$7(__spreadValues$e({}, o.fn.fontStyles()), {
            width: "100%",
            borderCollapse: "collapse",
            captionSide: i,
            color: o.colorScheme === "dark" ? o.colors.dark[0] : o.black,
            lineHeight: o.lineHeight,
            border: $ ? tt : void 0,
            "& > caption": {
                marginTop: i === "top" ? 0 : o.spacing.xs,
                marginBottom: i === "bottom" ? 0 : o.spacing.xs,
                fontSize: o.fontSizes.sm,
                color: o.colorScheme === "dark" ? o.colors.dark[2] : o.colors.gray[6]
            },
            "& > thead > tr > th, & > tfoot > tr > th, & > tbody > tr > th": {
                textAlign: "left",
                fontWeight: "bold",
                color: o.colorScheme === "dark" ? o.colors.dark[0] : o.colors.gray[7],
                fontSize: getSize({
                    size: _,
                    sizes: o.fontSizes
                }),
                padding: `${getSize({
                    size: a,
                    sizes: o.spacing
                })} ${getSize({
                    size: s,
                    sizes: o.spacing
                })}`
            },
            "& > thead > tr > th": {
                borderBottom: tt
            },
            "& > tfoot > tr > th, & > tbody > tr > th": {
                borderTop: tt
            },
            "& > tbody > tr > td": {
                padding: `${getSize({
                    size: a,
                    sizes: o.spacing
                })} ${getSize({
                    size: s,
                    sizes: o.spacing
                })}`,
                borderTop: tt,
                fontSize: getSize({
                    size: _,
                    sizes: o.fontSizes
                })
            },
            "& > tbody > tr:first-of-type > td, & > tbody > tr:first-of-type > th": {
                borderTop: "none"
            },
            "& > thead > tr > th, & > tbody > tr > td": {
                borderRight: _e ? tt : "none",
                "&:last-of-type": {
                    borderRight: "none",
                    borderLeft: _e ? tt : "none"
                }
            },
            "& > tbody > tr > th": {
                borderRight: _e ? tt : "none"
            },
            "&[data-striped] > tbody > tr:nth-of-type(odd)": {
                backgroundColor: o.colorScheme === "dark" ? o.colors.dark[6] : o.colors.gray[0]
            },
            "&[data-hover] > tbody > tr": o.fn.hover({
                backgroundColor: o.colorScheme === "dark" ? o.colors.dark[5] : o.colors.gray[1]
            })
        })
    }
}
);
const useStyles$7 = useStyles$6;
var __defProp$d = Object.defineProperty
  , __defProps$6 = Object.defineProperties
  , __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$d = Object.getOwnPropertySymbols
  , __hasOwnProp$d = Object.prototype.hasOwnProperty
  , __propIsEnum$d = Object.prototype.propertyIsEnumerable
  , __defNormalProp$d = (o, i, s) => i in o ? __defProp$d(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$d = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$d.call(i, s) && __defNormalProp$d(o, s, i[s]);
    if (__getOwnPropSymbols$d)
        for (var s of __getOwnPropSymbols$d(i))
            __propIsEnum$d.call(i, s) && __defNormalProp$d(o, s, i[s]);
    return o
}
  , __spreadProps$6 = (o, i) => __defProps$6(o, __getOwnPropDescs$6(i))
  , __objRest$5 = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$d.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$d)
        for (var a of __getOwnPropSymbols$d(o))
            i.indexOf(a) < 0 && __propIsEnum$d.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$3 = {
    striped: !1,
    highlightOnHover: !1,
    captionSide: "top",
    horizontalSpacing: "xs",
    fontSize: "sm",
    verticalSpacing: 7,
    withBorder: !1,
    withColumnBorders: !1
}
  , Table = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("Table", defaultProps$3, o)
      , {className: a, children: _, striped: $, highlightOnHover: _e, captionSide: tt, horizontalSpacing: nt, verticalSpacing: rt, fontSize: ot, unstyled: et, withBorder: j, withColumnBorders: it, variant: st} = s
      , at = __objRest$5(s, ["className", "children", "striped", "highlightOnHover", "captionSide", "horizontalSpacing", "verticalSpacing", "fontSize", "unstyled", "withBorder", "withColumnBorders", "variant"])
      , {classes: lt, cx: ct} = useStyles$7({
        captionSide: tt,
        verticalSpacing: rt,
        horizontalSpacing: nt,
        fontSize: ot,
        withBorder: j,
        withColumnBorders: it
    }, {
        unstyled: et,
        name: "Table",
        variant: st
    });
    return React.createElement(Box, __spreadProps$6(__spreadValues$d({}, at), {
        component: "table",
        ref: i,
        className: ct(lt.root, a),
        "data-striped": $ || void 0,
        "data-hover": _e || void 0
    }), _)
}
);
Table.displayName = "@mantine/core/Table";
var __defProp$c = Object.defineProperty
  , __defProps$5 = Object.defineProperties
  , __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$c = Object.getOwnPropertySymbols
  , __hasOwnProp$c = Object.prototype.hasOwnProperty
  , __propIsEnum$c = Object.prototype.propertyIsEnumerable
  , __defNormalProp$c = (o, i, s) => i in o ? __defProp$c(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$c = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$c.call(i, s) && __defNormalProp$c(o, s, i[s]);
    if (__getOwnPropSymbols$c)
        for (var s of __getOwnPropSymbols$c(i))
            __propIsEnum$c.call(i, s) && __defNormalProp$c(o, s, i[s]);
    return o
}
  , __spreadProps$5 = (o, i) => __defProps$5(o, __getOwnPropDescs$5(i));
const sizes = {
    xs: rem(16),
    sm: rem(20),
    md: rem(26),
    lg: rem(32),
    xl: rem(40)
}
  , THEME_ICON_VARIANTS = ["filled", "light", "gradient", "outline", "default"];
function getVariantStyles({theme: o, variant: i, color: s, gradient: a}) {
    if (!THEME_ICON_VARIANTS.includes(i))
        return null;
    const _ = o.fn.variant({
        variant: i,
        color: s || o.primaryColor,
        gradient: a,
        primaryFallback: !1
    });
    return {
        backgroundColor: _.background,
        color: _.color,
        backgroundImage: i === "gradient" ? _.background : void 0,
        border: `${rem(i === "gradient" ? 0 : 1)} solid ${_.border}`
    }
}
var useStyles$4 = createStyles( (o, {color: i, radius: s, gradient: a}, {variant: _, size: $}) => {
    const _e = getSize({
        size: $,
        sizes
    });
    return {
        root: __spreadValues$c(__spreadProps$5(__spreadValues$c({}, o.fn.fontStyles()), {
            display: "inline-flex",
            alignItems: "center",
            justifyContent: "center",
            boxSizing: "border-box",
            width: _e,
            height: _e,
            minWidth: _e,
            minHeight: _e,
            borderRadius: o.fn.radius(s)
        }), getVariantStyles({
            theme: o,
            variant: _,
            gradient: a,
            color: i
        }))
    }
}
);
const useStyles$5 = useStyles$4;
var __defProp$b = Object.defineProperty
  , __getOwnPropSymbols$b = Object.getOwnPropertySymbols
  , __hasOwnProp$b = Object.prototype.hasOwnProperty
  , __propIsEnum$b = Object.prototype.propertyIsEnumerable
  , __defNormalProp$b = (o, i, s) => i in o ? __defProp$b(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$b = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$b.call(i, s) && __defNormalProp$b(o, s, i[s]);
    if (__getOwnPropSymbols$b)
        for (var s of __getOwnPropSymbols$b(i))
            __propIsEnum$b.call(i, s) && __defNormalProp$b(o, s, i[s]);
    return o
}
  , __objRest$4 = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$b.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$b)
        for (var a of __getOwnPropSymbols$b(o))
            i.indexOf(a) < 0 && __propIsEnum$b.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$2 = {
    size: "md",
    variant: "filled"
}
  , ThemeIcon = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("ThemeIcon", defaultProps$2, o)
      , {className: a, size: _, radius: $, variant: _e, color: tt, children: nt, gradient: rt, unstyled: ot} = s
      , et = __objRest$4(s, ["className", "size", "radius", "variant", "color", "children", "gradient", "unstyled"])
      , {classes: j, cx: it} = useStyles$5({
        variant: _e,
        radius: $,
        color: tt,
        gradient: rt
    }, {
        name: "ThemeIcon",
        unstyled: ot,
        variant: _e,
        size: _
    });
    return React.createElement(Box, __spreadValues$b({
        className: it(j.root, a),
        ref: i
    }, et), nt)
}
);
ThemeIcon.displayName = "@mantine/core/ThemeIcon";
var __defProp$a = Object.defineProperty
  , __defProps$4 = Object.defineProperties
  , __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$a = Object.getOwnPropertySymbols
  , __hasOwnProp$a = Object.prototype.hasOwnProperty
  , __propIsEnum$a = Object.prototype.propertyIsEnumerable
  , __defNormalProp$a = (o, i, s) => i in o ? __defProp$a(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$a = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$a.call(i, s) && __defNormalProp$a(o, s, i[s]);
    if (__getOwnPropSymbols$a)
        for (var s of __getOwnPropSymbols$a(i))
            __propIsEnum$a.call(i, s) && __defNormalProp$a(o, s, i[s]);
    return o
}
  , __spreadProps$4 = (o, i) => __defProps$4(o, __getOwnPropDescs$4(i));
function getFontSize(o, i, s) {
    return typeof o < "u" ? o in s.headings.sizes ? s.headings.sizes[o].fontSize : rem(o) : s.headings.sizes[i].fontSize
}
function getLineHeight(o, i, s) {
    return typeof o < "u" && o in s.headings.sizes ? s.headings.sizes[o].lineHeight : s.headings.sizes[i].lineHeight
}
var useStyles$2 = createStyles( (o, {element: i, weight: s, inline: a}, {size: _}) => ({
    root: __spreadProps$4(__spreadValues$a({}, o.fn.fontStyles()), {
        fontFamily: o.headings.fontFamily,
        fontWeight: s || o.headings.sizes[i].fontWeight || o.headings.fontWeight,
        fontSize: getFontSize(_, i, o),
        lineHeight: a ? 1 : getLineHeight(_, i, o),
        margin: 0
    })
}));
const useStyles$3 = useStyles$2;
var __defProp$9 = Object.defineProperty
  , __getOwnPropSymbols$9 = Object.getOwnPropertySymbols
  , __hasOwnProp$9 = Object.prototype.hasOwnProperty
  , __propIsEnum$9 = Object.prototype.propertyIsEnumerable
  , __defNormalProp$9 = (o, i, s) => i in o ? __defProp$9(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$9 = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$9.call(i, s) && __defNormalProp$9(o, s, i[s]);
    if (__getOwnPropSymbols$9)
        for (var s of __getOwnPropSymbols$9(i))
            __propIsEnum$9.call(i, s) && __defNormalProp$9(o, s, i[s]);
    return o
}
  , __objRest$3 = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$9.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$9)
        for (var a of __getOwnPropSymbols$9(o))
            i.indexOf(a) < 0 && __propIsEnum$9.call(o, a) && (s[a] = o[a]);
    return s
}
;
const defaultProps$1 = {
    order: 1
}
  , Title = reactExports.forwardRef( (o, i) => {
    const s = useComponentDefaultProps("Title", defaultProps$1, o)
      , {className: a, order: _, children: $, unstyled: _e, size: tt, weight: nt, inline: rt, variant: ot} = s
      , et = __objRest$3(s, ["className", "order", "children", "unstyled", "size", "weight", "inline", "variant"])
      , {classes: j, cx: it} = useStyles$3({
        element: `h${_}`,
        weight: nt,
        inline: rt
    }, {
        name: "Title",
        unstyled: _e,
        variant: ot,
        size: tt
    });
    return [1, 2, 3, 4, 5, 6].includes(_) ? React.createElement(Text$2, __spreadValues$9({
        variant: ot,
        component: `h${_}`,
        ref: i,
        className: it(j.root, a)
    }, et), $) : null
}
);
Title.displayName = "@mantine/core/Title";
var ort_min = {
    exports: {}
};
/*!
* ONNX Runtime Web v1.15.1
* Copyright (c) Microsoft Corporation. All rights reserved.
* Licensed under the MIT License.
*/
(function(module, exports) {
    (function(o, i) {
        module.exports = i()
    }
    )(self, () => ( () => {
        var __webpack_modules__ = {
            8453: (o, i, s) => {
                s.r(i),
                s.d(i, {
                    InferenceSession: () => it,
                    Tensor: () => et,
                    env: () => _e,
                    registerBackend: () => $
                });
                const a = {}
                  , _ = []
                  , $ = (st, at, lt) => {
                    if (!at || typeof at.init != "function" || typeof at.createSessionHandler != "function")
                        throw new TypeError("not a valid backend");
                    {
                        const ct = a[st];
                        if (ct === void 0)
                            a[st] = {
                                backend: at,
                                priority: lt
                            };
                        else {
                            if (ct.priority > lt)
                                return;
                            if (ct.priority === lt && ct.backend !== at)
                                throw new Error(`cannot register backend "${st}" using priority ${lt}`)
                        }
                        if (lt >= 0) {
                            const ut = _.indexOf(st);
                            ut !== -1 && _.splice(ut, 1);
                            for (let dt = 0; dt < _.length; dt++)
                                if (a[_[dt]].priority <= lt)
                                    return void _.splice(dt, 0, st);
                            _.push(st)
                        }
                    }
                }
                  , _e = new class {
                    constructor() {
                        this.wasm = {},
                        this.webgl = {},
                        this.webgpu = {},
                        this.logLevelInternal = "warning"
                    }
                    set logLevel(st) {
                        if (st !== void 0) {
                            if (typeof st != "string" || ["verbose", "info", "warning", "error", "fatal"].indexOf(st) === -1)
                                throw new Error(`Unsupported logging level: ${st}`);
                            this.logLevelInternal = st
                        }
                    }
                    get logLevel() {
                        return this.logLevelInternal
                    }
                }
                  , tt = new Map([["float32", Float32Array], ["uint8", Uint8Array], ["int8", Int8Array], ["uint16", Uint16Array], ["int16", Int16Array], ["int32", Int32Array], ["bool", Uint8Array], ["float64", Float64Array], ["uint32", Uint32Array]])
                  , nt = new Map([[Float32Array, "float32"], [Uint8Array, "uint8"], [Int8Array, "int8"], [Uint16Array, "uint16"], [Int16Array, "int16"], [Int32Array, "int32"], [Float64Array, "float64"], [Uint32Array, "uint32"]]);
                let rt = !1;
                class ot {
                    constructor(at, lt, ct) {
                        let ut, dt, ft;
                        if (( () => {
                            if (!rt) {
                                rt = !0;
                                const pt = typeof BigInt64Array < "u" && typeof BigInt64Array.from == "function"
                                  , gt = typeof BigUint64Array < "u" && typeof BigUint64Array.from == "function";
                                pt && (tt.set("int64", BigInt64Array),
                                nt.set(BigInt64Array, "int64")),
                                gt && (tt.set("uint64", BigUint64Array),
                                nt.set(BigUint64Array, "uint64"))
                            }
                        }
                        )(),
                        typeof at == "string")
                            if (ut = at,
                            ft = ct,
                            at === "string") {
                                if (!Array.isArray(lt))
                                    throw new TypeError("A string tensor's data must be a string array.");
                                dt = lt
                            } else {
                                const pt = tt.get(at);
                                if (pt === void 0)
                                    throw new TypeError(`Unsupported tensor type: ${at}.`);
                                if (Array.isArray(lt))
                                    dt = pt.from(lt);
                                else {
                                    if (!(lt instanceof pt))
                                        throw new TypeError(`A ${ut} tensor's data must be type of ${pt}`);
                                    dt = lt
                                }
                            }
                        else if (ft = lt,
                        Array.isArray(at)) {
                            if (at.length === 0)
                                throw new TypeError("Tensor type cannot be inferred from an empty array.");
                            const pt = typeof at[0];
                            if (pt === "string")
                                ut = "string",
                                dt = at;
                            else {
                                if (pt !== "boolean")
                                    throw new TypeError(`Invalid element type of data array: ${pt}.`);
                                ut = "bool",
                                dt = Uint8Array.from(at)
                            }
                        } else {
                            const pt = nt.get(at.constructor);
                            if (pt === void 0)
                                throw new TypeError(`Unsupported type for tensor data: ${at.constructor}.`);
                            ut = pt,
                            dt = at
                        }
                        if (ft === void 0)
                            ft = [dt.length];
                        else if (!Array.isArray(ft))
                            throw new TypeError("A tensor's dims must be a number array");
                        const ht = (pt => {
                            let gt = 1;
                            for (let _t = 0; _t < pt.length; _t++) {
                                const mt = pt[_t];
                                if (typeof mt != "number" || !Number.isSafeInteger(mt))
                                    throw new TypeError(`dims[${_t}] must be an integer, got: ${mt}`);
                                if (mt < 0)
                                    throw new RangeError(`dims[${_t}] must be a non-negative integer, got: ${mt}`);
                                gt *= mt
                            }
                            return gt
                        }
                        )(ft);
                        if (ht !== dt.length)
                            throw new Error(`Tensor's size(${ht}) does not match data length(${dt.length}).`);
                        this.dims = ft,
                        this.type = ut,
                        this.data = dt,
                        this.size = ht
                    }
                    static bufferToTensor(at, lt) {
                        if (at === void 0)
                            throw new Error("Image buffer must be defined");
                        if (lt.height === void 0 || lt.width === void 0)
                            throw new Error("Image height and width must be defined");
                        if (lt.tensorLayout === "NHWC")
                            throw new Error("NHWC Tensor layout is not supported yet");
                        const {height: ct, width: ut} = lt
                          , dt = lt.norm ?? {
                            mean: 255,
                            bias: 0
                        };
                        let ft, ht;
                        ft = typeof dt.mean == "number" ? [dt.mean, dt.mean, dt.mean, dt.mean] : [dt.mean[0], dt.mean[1], dt.mean[2], dt.mean[3] ?? 255],
                        ht = typeof dt.bias == "number" ? [dt.bias, dt.bias, dt.bias, dt.bias] : [dt.bias[0], dt.bias[1], dt.bias[2], dt.bias[3] ?? 0];
                        const pt = lt.bitmapFormat !== void 0 ? lt.bitmapFormat : "RGBA"
                          , gt = lt.tensorFormat !== void 0 && lt.tensorFormat !== void 0 ? lt.tensorFormat : "RGB"
                          , _t = ct * ut
                          , mt = gt === "RGBA" ? new Float32Array(4 * _t) : new Float32Array(3 * _t);
                        let yt = 4
                          , bt = 0
                          , vt = 1
                          , wt = 2
                          , Tt = 3
                          , $t = 0
                          , Et = _t
                          , Pt = 2 * _t
                          , Rt = -1;
                        pt === "RGB" && (yt = 3,
                        bt = 0,
                        vt = 1,
                        wt = 2,
                        Tt = -1),
                        gt === "RGBA" ? Rt = 3 * _t : gt === "RBG" ? ($t = 0,
                        Pt = _t,
                        Et = 2 * _t) : gt === "BGR" && (Pt = 0,
                        Et = _t,
                        $t = 2 * _t);
                        for (let At = 0; At < _t; At++,
                        bt += yt,
                        wt += yt,
                        vt += yt,
                        Tt += yt)
                            mt[$t++] = (at[bt] + ht[0]) / ft[0],
                            mt[Et++] = (at[vt] + ht[1]) / ft[1],
                            mt[Pt++] = (at[wt] + ht[2]) / ft[2],
                            Rt !== -1 && Tt !== -1 && (mt[Rt++] = (at[Tt] + ht[3]) / ft[3]);
                        return new ot("float32",mt,gt === "RGBA" ? [1, 4, ct, ut] : [1, 3, ct, ut])
                    }
                    static async fromImage(at, lt) {
                        const ct = typeof HTMLImageElement < "u" && at instanceof HTMLImageElement
                          , ut = typeof ImageData < "u" && at instanceof ImageData
                          , dt = typeof ImageBitmap < "u" && at instanceof ImageBitmap
                          , ft = typeof at == "string";
                        let ht, pt = lt ?? {};
                        if (ct) {
                            const gt = document.createElement("canvas");
                            gt.width = at.width,
                            gt.height = at.height;
                            const _t = gt.getContext("2d");
                            if (_t == null)
                                throw new Error("Can not access image data");
                            {
                                let mt = at.height
                                  , yt = at.width;
                                if (lt !== void 0 && lt.resizedHeight !== void 0 && lt.resizedWidth !== void 0 && (mt = lt.resizedHeight,
                                yt = lt.resizedWidth),
                                lt !== void 0) {
                                    if (pt = lt,
                                    lt.tensorFormat !== void 0)
                                        throw new Error("Image input config format must be RGBA for HTMLImageElement");
                                    if (pt.tensorFormat = "RGBA",
                                    lt.height !== void 0 && lt.height !== mt)
                                        throw new Error("Image input config height doesn't match HTMLImageElement height");
                                    if (pt.height = mt,
                                    lt.width !== void 0 && lt.width !== yt)
                                        throw new Error("Image input config width doesn't match HTMLImageElement width");
                                    pt.width = yt
                                } else
                                    pt.tensorFormat = "RGBA",
                                    pt.height = mt,
                                    pt.width = yt;
                                _t.drawImage(at, 0, 0),
                                ht = _t.getImageData(0, 0, yt, mt).data
                            }
                        } else {
                            if (!ut) {
                                if (dt) {
                                    if (lt === void 0)
                                        throw new Error("Please provide image config with format for Imagebitmap");
                                    if (lt.bitmapFormat !== void 0)
                                        throw new Error("Image input config format must be defined for ImageBitmap");
                                    const gt = document.createElement("canvas").getContext("2d");
                                    if (gt != null) {
                                        const _t = at.height
                                          , mt = at.width;
                                        if (gt.drawImage(at, 0, 0, mt, _t),
                                        ht = gt.getImageData(0, 0, mt, _t).data,
                                        lt !== void 0) {
                                            if (lt.height !== void 0 && lt.height !== _t)
                                                throw new Error("Image input config height doesn't match ImageBitmap height");
                                            if (pt.height = _t,
                                            lt.width !== void 0 && lt.width !== mt)
                                                throw new Error("Image input config width doesn't match ImageBitmap width");
                                            pt.width = mt
                                        } else
                                            pt.height = _t,
                                            pt.width = mt;
                                        return ot.bufferToTensor(ht, pt)
                                    }
                                    throw new Error("Can not access image data")
                                }
                                if (ft)
                                    return new Promise( (gt, _t) => {
                                        const mt = document.createElement("canvas")
                                          , yt = mt.getContext("2d");
                                        if (!at || !yt)
                                            return _t();
                                        const bt = new Image;
                                        bt.crossOrigin = "Anonymous",
                                        bt.src = at,
                                        bt.onload = () => {
                                            mt.width = bt.width,
                                            mt.height = bt.height,
                                            yt.drawImage(bt, 0, 0, mt.width, mt.height);
                                            const vt = yt.getImageData(0, 0, mt.width, mt.height);
                                            if (lt !== void 0) {
                                                if (lt.height !== void 0 && lt.height !== mt.height)
                                                    throw new Error("Image input config height doesn't match height");
                                                if (pt.height = mt.height,
                                                lt.width !== void 0 && lt.width !== mt.width)
                                                    throw new Error("Image input config width doesn't match width");
                                                pt.width = mt.width
                                            } else
                                                pt.height = mt.height,
                                                pt.width = mt.width;
                                            gt(ot.bufferToTensor(vt.data, pt))
                                        }
                                    }
                                    );
                                throw new Error("Input data provided is not supported - aborted tensor creation")
                            }
                            {
                                const gt = "RGBA";
                                let _t, mt;
                                if (lt !== void 0 && lt.resizedWidth !== void 0 && lt.resizedHeight !== void 0 ? (_t = lt.resizedHeight,
                                mt = lt.resizedWidth) : (_t = at.height,
                                mt = at.width),
                                lt !== void 0) {
                                    if (pt = lt,
                                    lt.bitmapFormat !== void 0 && lt.bitmapFormat !== gt)
                                        throw new Error("Image input config format must be RGBA for ImageData");
                                    pt.bitmapFormat = "RGBA"
                                } else
                                    pt.bitmapFormat = "RGBA";
                                if (pt.height = _t,
                                pt.width = mt,
                                lt !== void 0) {
                                    const yt = document.createElement("canvas");
                                    yt.width = mt,
                                    yt.height = _t;
                                    const bt = yt.getContext("2d");
                                    if (bt == null)
                                        throw new Error("Can not access image data");
                                    bt.putImageData(at, 0, 0),
                                    ht = bt.getImageData(0, 0, mt, _t).data
                                } else
                                    ht = at.data
                            }
                        }
                        if (ht !== void 0)
                            return ot.bufferToTensor(ht, pt);
                        throw new Error("Input data provided is not supported - aborted tensor creation")
                    }
                    toDataURL(at) {
                        const lt = document.createElement("canvas");
                        lt.width = this.dims[3],
                        lt.height = this.dims[2];
                        const ct = lt.getContext("2d");
                        if (ct != null) {
                            let ut, dt;
                            (at == null ? void 0 : at.tensorLayout) !== void 0 && at.tensorLayout === "NHWC" ? (ut = this.dims[2],
                            dt = this.dims[3]) : (ut = this.dims[3],
                            dt = this.dims[2]);
                            const ft = (at == null ? void 0 : at.format) !== void 0 ? at.format : "RGB"
                              , ht = at == null ? void 0 : at.norm;
                            let pt, gt;
                            ht === void 0 || ht.mean === void 0 ? pt = [255, 255, 255, 255] : typeof ht.mean == "number" ? pt = [ht.mean, ht.mean, ht.mean, ht.mean] : (pt = [ht.mean[0], ht.mean[1], ht.mean[2], 0],
                            ht.mean[3] !== void 0 && (pt[3] = ht.mean[3])),
                            ht === void 0 || ht.bias === void 0 ? gt = [0, 0, 0, 0] : typeof ht.bias == "number" ? gt = [ht.bias, ht.bias, ht.bias, ht.bias] : (gt = [ht.bias[0], ht.bias[1], ht.bias[2], 0],
                            ht.bias[3] !== void 0 && (gt[3] = ht.bias[3]));
                            const _t = dt * ut;
                            let mt = 0
                              , yt = _t
                              , bt = 2 * _t
                              , vt = -1;
                            ft === "RGBA" ? (mt = 0,
                            yt = _t,
                            bt = 2 * _t,
                            vt = 3 * _t) : ft === "RGB" ? (mt = 0,
                            yt = _t,
                            bt = 2 * _t) : ft === "RBG" && (mt = 0,
                            bt = _t,
                            yt = 2 * _t);
                            for (let wt = 0; wt < dt; wt++)
                                for (let Tt = 0; Tt < ut; Tt++) {
                                    const $t = (this.data[mt++] - gt[0]) * pt[0]
                                      , Et = (this.data[yt++] - gt[1]) * pt[1]
                                      , Pt = (this.data[bt++] - gt[2]) * pt[2]
                                      , Rt = vt === -1 ? 255 : (this.data[vt++] - gt[3]) * pt[3];
                                    ct.fillStyle = "rgba(" + $t + "," + Et + "," + Pt + "," + Rt + ")",
                                    ct.fillRect(Tt, wt, 1, 1)
                                }
                            return lt.toDataURL()
                        }
                        throw new Error("Can not access image data")
                    }
                    toImageData(at) {
                        const lt = document.createElement("canvas").getContext("2d");
                        let ct;
                        if (lt == null)
                            throw new Error("Can not access image data");
                        {
                            let ut, dt, ft;
                            (at == null ? void 0 : at.tensorLayout) !== void 0 && at.tensorLayout === "NHWC" ? (ut = this.dims[2],
                            dt = this.dims[1],
                            ft = this.dims[3]) : (ut = this.dims[3],
                            dt = this.dims[2],
                            ft = this.dims[1]);
                            const ht = at !== void 0 && at.format !== void 0 ? at.format : "RGB"
                              , pt = at == null ? void 0 : at.norm;
                            let gt, _t;
                            pt === void 0 || pt.mean === void 0 ? gt = [255, 255, 255, 255] : typeof pt.mean == "number" ? gt = [pt.mean, pt.mean, pt.mean, pt.mean] : (gt = [pt.mean[0], pt.mean[1], pt.mean[2], 255],
                            pt.mean[3] !== void 0 && (gt[3] = pt.mean[3])),
                            pt === void 0 || pt.bias === void 0 ? _t = [0, 0, 0, 0] : typeof pt.bias == "number" ? _t = [pt.bias, pt.bias, pt.bias, pt.bias] : (_t = [pt.bias[0], pt.bias[1], pt.bias[2], 0],
                            pt.bias[3] !== void 0 && (_t[3] = pt.bias[3]));
                            const mt = dt * ut;
                            if (at !== void 0) {
                                if (at.height !== void 0 && at.height !== dt)
                                    throw new Error("Image output config height doesn't match tensor height");
                                if (at.width !== void 0 && at.width !== ut)
                                    throw new Error("Image output config width doesn't match tensor width");
                                if (at.format !== void 0 && ft === 4 && at.format !== "RGBA" || ft === 3 && at.format !== "RGB" && at.format !== "BGR")
                                    throw new Error("Tensor format doesn't match input tensor dims")
                            }
                            const yt = 4;
                            let bt = 0
                              , vt = 1
                              , wt = 2
                              , Tt = 3
                              , $t = 0
                              , Et = mt
                              , Pt = 2 * mt
                              , Rt = -1;
                            ht === "RGBA" ? ($t = 0,
                            Et = mt,
                            Pt = 2 * mt,
                            Rt = 3 * mt) : ht === "RGB" ? ($t = 0,
                            Et = mt,
                            Pt = 2 * mt) : ht === "RBG" && ($t = 0,
                            Pt = mt,
                            Et = 2 * mt),
                            ct = lt.createImageData(ut, dt);
                            for (let At = 0; At < dt * ut; bt += yt,
                            vt += yt,
                            wt += yt,
                            Tt += yt,
                            At++)
                                ct.data[bt] = (this.data[$t++] - _t[0]) * gt[0],
                                ct.data[vt] = (this.data[Et++] - _t[1]) * gt[1],
                                ct.data[wt] = (this.data[Pt++] - _t[2]) * gt[2],
                                ct.data[Tt] = Rt === -1 ? 255 : (this.data[Rt++] - _t[3]) * gt[3]
                        }
                        return ct
                    }
                    reshape(at) {
                        return new ot(this.type,this.data,at)
                    }
                }
                const et = ot;
                class j {
                    constructor(at) {
                        this.handler = at
                    }
                    async run(at, lt, ct) {
                        const ut = {};
                        let dt = {};
                        if (typeof at != "object" || at === null || at instanceof et || Array.isArray(at))
                            throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
                        let ft = !0;
                        if (typeof lt == "object") {
                            if (lt === null)
                                throw new TypeError("Unexpected argument[1]: cannot be null.");
                            if (lt instanceof et)
                                throw new TypeError("'fetches' cannot be a Tensor");
                            if (Array.isArray(lt)) {
                                if (lt.length === 0)
                                    throw new TypeError("'fetches' cannot be an empty array.");
                                ft = !1;
                                for (const gt of lt) {
                                    if (typeof gt != "string")
                                        throw new TypeError("'fetches' must be a string array or an object.");
                                    if (this.outputNames.indexOf(gt) === -1)
                                        throw new RangeError(`'fetches' contains invalid output name: ${gt}.`);
                                    ut[gt] = null
                                }
                                if (typeof ct == "object" && ct !== null)
                                    dt = ct;
                                else if (ct !== void 0)
                                    throw new TypeError("'options' must be an object.")
                            } else {
                                let gt = !1;
                                const _t = Object.getOwnPropertyNames(lt);
                                for (const mt of this.outputNames)
                                    if (_t.indexOf(mt) !== -1) {
                                        const yt = lt[mt];
                                        (yt === null || yt instanceof et) && (gt = !0,
                                        ft = !1,
                                        ut[mt] = yt)
                                    }
                                if (gt) {
                                    if (typeof ct == "object" && ct !== null)
                                        dt = ct;
                                    else if (ct !== void 0)
                                        throw new TypeError("'options' must be an object.")
                                } else
                                    dt = lt
                            }
                        } else if (lt !== void 0)
                            throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
                        for (const gt of this.inputNames)
                            if (at[gt] === void 0)
                                throw new Error(`input '${gt}' is missing in 'feeds'.`);
                        if (ft)
                            for (const gt of this.outputNames)
                                ut[gt] = null;
                        const ht = await this.handler.run(at, ut, dt)
                          , pt = {};
                        for (const gt in ht)
                            Object.hasOwnProperty.call(ht, gt) && (pt[gt] = new et(ht[gt].type,ht[gt].data,ht[gt].dims));
                        return pt
                    }
                    static async create(at, lt, ct, ut) {
                        let dt, ft = {};
                        if (typeof at == "string") {
                            if (dt = at,
                            typeof lt == "object" && lt !== null)
                                ft = lt;
                            else if (lt !== void 0)
                                throw new TypeError("'options' must be an object.")
                        } else if (at instanceof Uint8Array) {
                            if (dt = at,
                            typeof lt == "object" && lt !== null)
                                ft = lt;
                            else if (lt !== void 0)
                                throw new TypeError("'options' must be an object.")
                        } else {
                            if (!(at instanceof ArrayBuffer || typeof SharedArrayBuffer < "u" && at instanceof SharedArrayBuffer))
                                throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");
                            {
                                const _t = at;
                                let mt = 0
                                  , yt = at.byteLength;
                                if (typeof lt == "object" && lt !== null)
                                    ft = lt;
                                else if (typeof lt == "number") {
                                    if (mt = lt,
                                    !Number.isSafeInteger(mt))
                                        throw new RangeError("'byteOffset' must be an integer.");
                                    if (mt < 0 || mt >= _t.byteLength)
                                        throw new RangeError(`'byteOffset' is out of range [0, ${_t.byteLength}).`);
                                    if (yt = at.byteLength - mt,
                                    typeof ct == "number") {
                                        if (yt = ct,
                                        !Number.isSafeInteger(yt))
                                            throw new RangeError("'byteLength' must be an integer.");
                                        if (yt <= 0 || mt + yt > _t.byteLength)
                                            throw new RangeError(`'byteLength' is out of range (0, ${_t.byteLength - mt}].`);
                                        if (typeof ut == "object" && ut !== null)
                                            ft = ut;
                                        else if (ut !== void 0)
                                            throw new TypeError("'options' must be an object.")
                                    } else if (ct !== void 0)
                                        throw new TypeError("'byteLength' must be a number.")
                                } else if (lt !== void 0)
                                    throw new TypeError("'options' must be an object.");
                                dt = new Uint8Array(_t,mt,yt)
                            }
                        }
                        const ht = (ft.executionProviders || []).map(_t => typeof _t == "string" ? _t : _t.name)
                          , pt = await (async _t => {
                            const mt = _t.length === 0 ? _ : _t
                              , yt = [];
                            for (const bt of mt) {
                                const vt = a[bt];
                                if (vt) {
                                    if (vt.initialized)
                                        return vt.backend;
                                    if (vt.aborted)
                                        continue;
                                    const wt = !!vt.initPromise;
                                    try {
                                        return wt || (vt.initPromise = vt.backend.init()),
                                        await vt.initPromise,
                                        vt.initialized = !0,
                                        vt.backend
                                    } catch (Tt) {
                                        wt || yt.push({
                                            name: bt,
                                            err: Tt
                                        }),
                                        vt.aborted = !0
                                    } finally {
                                        delete vt.initPromise
                                    }
                                }
                            }
                            throw new Error(`no available backend found. ERR: ${yt.map(bt => `[${bt.name}] ${bt.err}`).join(", ")}`)
                        }
                        )(ht)
                          , gt = await pt.createSessionHandler(dt, ft);
                        return new j(gt)
                    }
                    startProfiling() {
                        this.handler.startProfiling()
                    }
                    endProfiling() {
                        this.handler.endProfiling()
                    }
                    get inputNames() {
                        return this.handler.inputNames
                    }
                    get outputNames() {
                        return this.handler.outputNames
                    }
                }
                const it = j
            }
            ,
            5716: (o, i, s) => {
                i.R = void 0;
                const a = s(6027)
                  , _ = s(1723);
                i.R = new class {
                    async init() {}
                    async createSessionHandler($, _e) {
                        const tt = new a.Session(_e);
                        return await tt.loadModel($),
                        new _.OnnxjsSessionHandler(tt)
                    }
                }
            }
            ,
            2818: (o, i, s) => {
                i.c8 = i.rX = void 0;
                const a = s(8453)
                  , _ = s(5381)
                  , $ = s(9544)
                  , _e = s(6640);
                i.rX = () => {
                    if ((typeof a.env.wasm.initTimeout != "number" || a.env.wasm.initTimeout < 0) && (a.env.wasm.initTimeout = 0),
                    typeof a.env.wasm.simd != "boolean" && (a.env.wasm.simd = !0),
                    typeof a.env.wasm.proxy != "boolean" && (a.env.wasm.proxy = !1),
                    typeof a.env.wasm.numThreads != "number" || !Number.isInteger(a.env.wasm.numThreads) || a.env.wasm.numThreads <= 0) {
                        const tt = typeof navigator > "u" ? (0,
                        _.cpus)().length : navigator.hardwareConcurrency;
                        a.env.wasm.numThreads = Math.min(4, Math.ceil((tt || 1) / 2))
                    }
                }
                ,
                i.c8 = new class {
                    async init() {
                        (0,
                        i.rX)(),
                        await (0,
                        $.initWasm)()
                    }
                    async createSessionHandler(tt, nt) {
                        const rt = new _e.OnnxruntimeWebAssemblySessionHandler;
                        return await rt.loadModel(tt, nt),
                        Promise.resolve(rt)
                    }
                }
            }
            ,
            1057: function(o, i, s) {
                var a = this && this.__createBinding || (Object.create ? function(_e, tt, nt, rt) {
                    rt === void 0 && (rt = nt);
                    var ot = Object.getOwnPropertyDescriptor(tt, nt);
                    ot && !("get"in ot ? !tt.__esModule : ot.writable || ot.configurable) || (ot = {
                        enumerable: !0,
                        get: function() {
                            return tt[nt]
                        }
                    }),
                    Object.defineProperty(_e, rt, ot)
                }
                : function(_e, tt, nt, rt) {
                    rt === void 0 && (rt = nt),
                    _e[rt] = tt[nt]
                }
                )
                  , _ = this && this.__exportStar || function(_e, tt) {
                    for (var nt in _e)
                        nt === "default" || Object.prototype.hasOwnProperty.call(tt, nt) || a(tt, _e, nt)
                }
                ;
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                _(s(8453), i);
                const $ = s(8453);
                {
                    const _e = s(5716).R;
                    (0,
                    $.registerBackend)("webgl", _e, -10)
                }
                {
                    const _e = s(2818).c8;
                    (0,
                    $.registerBackend)("cpu", _e, 10),
                    (0,
                    $.registerBackend)("wasm", _e, 10),
                    (0,
                    $.registerBackend)("xnnpack", _e, 9)
                }
            },
            4910: (o, i) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.createAttributeWithCacheKey = void 0;
                class s {
                    constructor(_) {
                        Object.assign(this, _)
                    }
                    get cacheKey() {
                        return this._cacheKey || (this._cacheKey = Object.getOwnPropertyNames(this).sort().map(_ => `${this[_]}`).join(";")),
                        this._cacheKey
                    }
                }
                i.createAttributeWithCacheKey = a => new s(a)
            }
            ,
            6874: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.Attribute = void 0;
                const a = s(1446)
                  , _ = s(1287)
                  , $ = s(9240)
                  , _e = s(7273);
                var tt = _.onnxruntime.experimental.fbs;
                class nt {
                    constructor(ot) {
                        if (this._attributes = new Map,
                        ot != null) {
                            for (const et of ot)
                                et instanceof a.onnx.AttributeProto ? this._attributes.set(et.name, [nt.getValue(et), nt.getType(et)]) : et instanceof tt.Attribute && this._attributes.set(et.name(), [nt.getValue(et), nt.getType(et)]);
                            if (this._attributes.size < ot.length)
                                throw new Error("duplicated attribute names")
                        }
                    }
                    set(ot, et, j) {
                        this._attributes.set(ot, [j, et])
                    }
                    delete(ot) {
                        this._attributes.delete(ot)
                    }
                    getFloat(ot, et) {
                        return this.get(ot, "float", et)
                    }
                    getInt(ot, et) {
                        return this.get(ot, "int", et)
                    }
                    getString(ot, et) {
                        return this.get(ot, "string", et)
                    }
                    getTensor(ot, et) {
                        return this.get(ot, "tensor", et)
                    }
                    getFloats(ot, et) {
                        return this.get(ot, "floats", et)
                    }
                    getInts(ot, et) {
                        return this.get(ot, "ints", et)
                    }
                    getStrings(ot, et) {
                        return this.get(ot, "strings", et)
                    }
                    getTensors(ot, et) {
                        return this.get(ot, "tensors", et)
                    }
                    get(ot, et, j) {
                        const it = this._attributes.get(ot);
                        if (it === void 0) {
                            if (j !== void 0)
                                return j;
                            throw new Error(`required attribute not found: ${ot}`)
                        }
                        if (it[1] !== et)
                            throw new Error(`type mismatch: expected ${et} but got ${it[1]}`);
                        return it[0]
                    }
                    static getType(ot) {
                        const et = ot instanceof a.onnx.AttributeProto ? ot.type : ot.type();
                        switch (et) {
                        case a.onnx.AttributeProto.AttributeType.FLOAT:
                            return "float";
                        case a.onnx.AttributeProto.AttributeType.INT:
                            return "int";
                        case a.onnx.AttributeProto.AttributeType.STRING:
                            return "string";
                        case a.onnx.AttributeProto.AttributeType.TENSOR:
                            return "tensor";
                        case a.onnx.AttributeProto.AttributeType.FLOATS:
                            return "floats";
                        case a.onnx.AttributeProto.AttributeType.INTS:
                            return "ints";
                        case a.onnx.AttributeProto.AttributeType.STRINGS:
                            return "strings";
                        case a.onnx.AttributeProto.AttributeType.TENSORS:
                            return "tensors";
                        default:
                            throw new Error(`attribute type is not supported yet: ${a.onnx.AttributeProto.AttributeType[et]}`)
                        }
                    }
                    static getValue(ot) {
                        const et = ot instanceof a.onnx.AttributeProto ? ot.type : ot.type();
                        if (et === a.onnx.AttributeProto.AttributeType.GRAPH || et === a.onnx.AttributeProto.AttributeType.GRAPHS)
                            throw new Error("graph attribute is not supported yet");
                        const j = this.getValueNoCheck(ot);
                        if (et === a.onnx.AttributeProto.AttributeType.INT && _e.LongUtil.isLong(j))
                            return _e.LongUtil.longToNumber(j);
                        if (et === a.onnx.AttributeProto.AttributeType.INTS) {
                            const it = j
                              , st = new Array(it.length);
                            for (let at = 0; at < it.length; at++) {
                                const lt = it[at];
                                st[at] = _e.LongUtil.longToNumber(lt)
                            }
                            return st
                        }
                        if (et === a.onnx.AttributeProto.AttributeType.TENSOR)
                            return ot instanceof a.onnx.AttributeProto ? $.Tensor.fromProto(j) : $.Tensor.fromOrtTensor(j);
                        if (et === a.onnx.AttributeProto.AttributeType.TENSORS) {
                            if (ot instanceof a.onnx.AttributeProto)
                                return j.map(it => $.Tensor.fromProto(it));
                            if (ot instanceof tt.Attribute)
                                return j.map(it => $.Tensor.fromOrtTensor(it))
                        }
                        if (et === a.onnx.AttributeProto.AttributeType.STRING && ot instanceof a.onnx.AttributeProto) {
                            const it = j;
                            return (0,
                            _e.decodeUtf8String)(it)
                        }
                        return et === a.onnx.AttributeProto.AttributeType.STRINGS && ot instanceof a.onnx.AttributeProto ? j.map(_e.decodeUtf8String) : j
                    }
                    static getValueNoCheck(ot) {
                        return ot instanceof a.onnx.AttributeProto ? this.getValueNoCheckFromOnnxFormat(ot) : this.getValueNoCheckFromOrtFormat(ot)
                    }
                    static getValueNoCheckFromOnnxFormat(ot) {
                        switch (ot.type) {
                        case a.onnx.AttributeProto.AttributeType.FLOAT:
                            return ot.f;
                        case a.onnx.AttributeProto.AttributeType.INT:
                            return ot.i;
                        case a.onnx.AttributeProto.AttributeType.STRING:
                            return ot.s;
                        case a.onnx.AttributeProto.AttributeType.TENSOR:
                            return ot.t;
                        case a.onnx.AttributeProto.AttributeType.GRAPH:
                            return ot.g;
                        case a.onnx.AttributeProto.AttributeType.FLOATS:
                            return ot.floats;
                        case a.onnx.AttributeProto.AttributeType.INTS:
                            return ot.ints;
                        case a.onnx.AttributeProto.AttributeType.STRINGS:
                            return ot.strings;
                        case a.onnx.AttributeProto.AttributeType.TENSORS:
                            return ot.tensors;
                        case a.onnx.AttributeProto.AttributeType.GRAPHS:
                            return ot.graphs;
                        default:
                            throw new Error(`unsupported attribute type: ${a.onnx.AttributeProto.AttributeType[ot.type]}`)
                        }
                    }
                    static getValueNoCheckFromOrtFormat(ot) {
                        switch (ot.type()) {
                        case tt.AttributeType.FLOAT:
                            return ot.f();
                        case tt.AttributeType.INT:
                            return ot.i();
                        case tt.AttributeType.STRING:
                            return ot.s();
                        case tt.AttributeType.TENSOR:
                            return ot.t();
                        case tt.AttributeType.GRAPH:
                            return ot.g();
                        case tt.AttributeType.FLOATS:
                            return ot.floatsArray();
                        case tt.AttributeType.INTS:
                            {
                                const et = [];
                                for (let j = 0; j < ot.intsLength(); j++)
                                    et.push(ot.ints(j));
                                return et
                            }
                        case tt.AttributeType.STRINGS:
                            {
                                const et = [];
                                for (let j = 0; j < ot.stringsLength(); j++)
                                    et.push(ot.strings(j));
                                return et
                            }
                        case tt.AttributeType.TENSORS:
                            {
                                const et = [];
                                for (let j = 0; j < ot.tensorsLength(); j++)
                                    et.push(ot.tensors(j));
                                return et
                            }
                        default:
                            throw new Error(`unsupported attribute type: ${tt.AttributeType[ot.type()]}`)
                        }
                    }
                }
                i.Attribute = nt
            }
            ,
            1975: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.resolveBackend = i.backend = void 0;
                const a = s(4418)
                  , _ = new Map;
                async function $(_e) {
                    const tt = i.backend;
                    if (tt[_e] !== void 0 && function(nt) {
                        const rt = nt;
                        return "initialize"in rt && typeof rt.initialize == "function" && "createSessionHandler"in rt && typeof rt.createSessionHandler == "function" && "dispose"in rt && typeof rt.dispose == "function"
                    }(tt[_e])) {
                        const nt = tt[_e];
                        let rt = nt.initialize();
                        if (typeof rt == "object" && "then"in rt && (rt = await rt),
                        rt)
                            return _.set(_e, nt),
                            nt
                    }
                }
                i.backend = {
                    webgl: new a.WebGLBackend
                },
                i.resolveBackend = async function _e(tt) {
                    if (!tt)
                        return _e(["webgl"]);
                    {
                        const nt = typeof tt == "string" ? [tt] : tt;
                        for (const rt of nt) {
                            const ot = _.get(rt);
                            if (ot)
                                return ot;
                            const et = await $(rt);
                            if (et)
                                return et
                        }
                    }
                    throw new Error("no available backend to use")
                }
            }
            ,
            4418: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.WebGLBackend = void 0;
                const a = s(8453)
                  , _ = s(1315)
                  , $ = s(2171)
                  , _e = s(3389);
                i.WebGLBackend = class {
                    get contextId() {
                        return a.env.webgl.contextId
                    }
                    set contextId(tt) {
                        a.env.webgl.contextId = tt
                    }
                    get matmulMaxBatchSize() {
                        return a.env.webgl.matmulMaxBatchSize
                    }
                    set matmulMaxBatchSize(tt) {
                        a.env.webgl.matmulMaxBatchSize = tt
                    }
                    get textureCacheMode() {
                        return a.env.webgl.textureCacheMode
                    }
                    set textureCacheMode(tt) {
                        a.env.webgl.textureCacheMode = tt
                    }
                    get pack() {
                        return a.env.webgl.pack
                    }
                    set pack(tt) {
                        a.env.webgl.pack = tt
                    }
                    get async() {
                        return a.env.webgl.async
                    }
                    set async(tt) {
                        a.env.webgl.async = tt
                    }
                    initialize() {
                        try {
                            return this.glContext = (0,
                            _e.createWebGLContext)(this.contextId),
                            typeof this.matmulMaxBatchSize != "number" && (this.matmulMaxBatchSize = 16),
                            typeof this.textureCacheMode != "string" && (this.textureCacheMode = "full"),
                            typeof this.pack != "boolean" && (this.pack = !1),
                            typeof this.async != "boolean" && (this.async = !1),
                            _.Logger.setWithEnv(a.env),
                            _.Logger.verbose("WebGLBackend", `Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`),
                            !0
                        } catch (tt) {
                            return _.Logger.warning("WebGLBackend", `Unable to initialize WebGLBackend. ${tt}`),
                            !1
                        }
                    }
                    createSessionHandler(tt) {
                        return new $.WebGLSessionHandler(this,tt)
                    }
                    dispose() {
                        this.glContext.dispose()
                    }
                }
            }
            ,
            6859: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.CoordsGlslLib = void 0;
                const a = s(7273)
                  , _ = s(1997)
                  , $ = s(6757)
                  , _e = s(7618)
                  , tt = s(432);
                class nt extends _.GlslLib {
                    constructor(ot) {
                        super(ot)
                    }
                    getFunctions() {
                        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.offsetToCoords()), this.coordsToOffset()), this.toVec()), this.valueFrom()), this.getCommonUtilFuncs()), this.getInputsSamplingSnippets()), this.getOutputSamplingSnippet())
                    }
                    getCustomTypes() {
                        return {}
                    }
                    offsetToCoords() {
                        return {
                            offsetToCoords: new _.GlslLibRoutine(`
      vec2 offsetToCoords(int offset, int width, int height) {
        int t = offset / width;
        int s = offset - t*width;
        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);
        return coords;
      }
      `)
                        }
                    }
                    coordsToOffset() {
                        return {
                            coordsToOffset: new _.GlslLibRoutine(`
      int coordsToOffset(vec2 coords, int width, int height) {
        float s = coords.s * float(width);
        float t = coords.t * float(height);
        int offset = int(t) * width + int(s);
        return offset;
      }
      `)
                        }
                    }
                    getOutputSamplingSnippet() {
                        const ot = this.context.outputTextureLayout;
                        return ot.isPacked ? this.getPackedOutputSamplingSnippet(ot) : this.getUnpackedOutputSamplingSnippet(ot)
                    }
                    getPackedOutputSamplingSnippet(ot) {
                        const et = ot.unpackedShape
                          , j = [ot.width, ot.height]
                          , it = {}
                          , st = "getOutputCoords";
                        switch (et.length) {
                        case 0:
                            it[st] = this.getOutputScalarCoords();
                            break;
                        case 1:
                            it[st] = this.getOutputPacked1DCoords(et, j);
                            break;
                        case 2:
                            it[st] = this.getOutputPacked2DCoords(et, j);
                            break;
                        case 3:
                            it[st] = this.getOutputPacked3DCoords(et, j);
                            break;
                        default:
                            it[st] = this.getOutputPackedNDCoords(et, j)
                        }
                        const at = `
      void setOutput(vec4 val) {
        ${(0,
                        $.getGlsl)(this.context.glContext.version).output} = val;
      }
    `;
                        return it.floatTextureSetRGBA = new _.GlslLibRoutine(at),
                        it
                    }
                    getUnpackedOutputSamplingSnippet(ot) {
                        const et = ot.unpackedShape
                          , j = [ot.width, ot.height]
                          , it = {}
                          , st = "getOutputCoords";
                        switch (et.length) {
                        case 0:
                            it[st] = this.getOutputScalarCoords();
                            break;
                        case 1:
                            it[st] = this.getOutputUnpacked1DCoords(et, j);
                            break;
                        case 2:
                            it[st] = this.getOutputUnpacked2DCoords(et, j);
                            break;
                        case 3:
                            it[st] = this.getOutputUnpacked3DCoords(et, j);
                            break;
                        case 4:
                            it[st] = this.getOutputUnpacked4DCoords(et, j);
                            break;
                        case 5:
                            it[st] = this.getOutputUnpacked5DCoords(et, j);
                            break;
                        case 6:
                            it[st] = this.getOutputUnpacked6DCoords(et, j);
                            break;
                        default:
                            throw new Error(`Unsupported output dimensionality: ${et.length}`)
                        }
                        const at = `
        void setOutput(float val) {
          ${(0,
                        $.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `;
                        return it.floatTextureSetR = new _.GlslLibRoutine(at),
                        it
                    }
                    getOutputScalarCoords() {
                        return new _.GlslLibRoutine(`
      int getOutputCoords() {
        return 0;
      }
    `)
                    }
                    getOutputPacked1DCoords(ot, et) {
                        const j = et;
                        let it = "";
                        return j[0] === 1 ? (it = `
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${j[1]}.0);
          }
        `,
                        new _.GlslLibRoutine(it)) : j[1] === 1 ? (it = `
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${j[0]}.0);
          }
        `,
                        new _.GlslLibRoutine(it)) : (it = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${j[0]}, ${j[1]}));
          return 2 * (resTexRC.y * ${j[0]} + resTexRC.x);
        }
      `,
                        new _.GlslLibRoutine(it))
                    }
                    getOutputPacked2DCoords(ot, et) {
                        let j = "";
                        if (a.ArrayUtil.arraysEqual(ot, et))
                            return j = `
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${et[0]}, ${et[1]}));
        }
      `,
                            new _.GlslLibRoutine(j);
                        const it = et
                          , st = Math.ceil(ot[1] / 2);
                        return j = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${it[0]}, ${it[1]}));

          int index = resTexRC.y * ${it[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${st}) * 2;
          int c = 2 * (index / ${st});

          return ivec2(r, c);
        }
      `,
                        new _.GlslLibRoutine(j)
                    }
                    getOutputPacked3DCoords(ot, et) {
                        const j = [et[0], et[1]]
                          , it = Math.ceil(ot[2] / 2)
                          , st = it * Math.ceil(ot[1] / 2)
                          , at = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${j[0]}, ${j[1]}));
          int index = resTexRC.y * ${j[0]} + resTexRC.x;

          int b = index / ${st};
          index -= b * ${st};

          // reverse r and c order for packed texture
          int r = imod(index, ${it}) * 2;
          int c = 2 * (index / ${it});

          return ivec3(b, r, c);
        }
      `;
                        return new _.GlslLibRoutine(at)
                    }
                    getOutputPackedNDCoords(ot, et) {
                        const j = [et[0], et[1]]
                          , it = Math.ceil(ot[ot.length - 1] / 2)
                          , st = it * Math.ceil(ot[ot.length - 2] / 2);
                        let at = st
                          , lt = ""
                          , ct = "b, r, c";
                        for (let dt = 2; dt < ot.length - 1; dt++)
                            at *= ot[ot.length - dt - 1],
                            lt = `
      int b${dt} = index / ${at};
      index -= b${dt} * ${at};
    ` + lt,
                            ct = `b${dt}, ` + ct;
                        const ut = `
      ivec${ot.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${j[0]}, ${j[1]}));
        int index = resTexRC.y * ${j[0]} + resTexRC.x;

        ${lt}

        int b = index / ${st};
        index -= b * ${st};

        // reverse r and c order for packed texture
        int r = imod(index, ${it}) * 2;
        int c = 2 * (index / ${it});

        return ivec${ot.length}(${ct});
      }
    `;
                        return new _.GlslLibRoutine(ut)
                    }
                    getOutputUnpacked1DCoords(ot, et) {
                        const j = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${et[0]}, ${et[1]}));
          return resTexRC.y * ${et[0]} + resTexRC.x;
        }
      `;
                        return new _.GlslLibRoutine(j)
                    }
                    getOutputUnpacked2DCoords(ot, et) {
                        const j = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${et[0]}, ${et[1]}));
          int index = resTexRC.y * ${et[0]} + resTexRC.x;
          int r = index / ${ot[1]};
          int c = index - r * ${ot[1]};
          return ivec2(r, c);
        }
      `;
                        return new _.GlslLibRoutine(j)
                    }
                    getOutputUnpacked3DCoords(ot, et) {
                        let j = "";
                        const it = ot.length;
                        let st = null;
                        it < 2 && (st = []),
                        st = new Array(it - 1),
                        st[it - 2] = ot[it - 1];
                        for (let ct = it - 3; ct >= 0; --ct)
                            st[ct] = st[ct + 1] * ot[ct + 1];
                        const at = ["r", "c", "d"]
                          , lt = st.map( (ct, ut) => `int ${at[ut]} = index / ${ct}; ${ut === st.length - 1 ? `int ${at[ut + 1]} = index - ${at[ut]} * ${ct}` : `index -= ${at[ut]} * ${ct}`};`).join("");
                        return j = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${et[0]}, ${et[1]}));
          int index = resTexRC.y * ${et[0]} + resTexRC.x;
          ${lt}
          return ivec3(r, c, d);
        }
      `,
                        new _.GlslLibRoutine(j)
                    }
                    getOutputUnpacked4DCoords(ot, et) {
                        let j = "";
                        const it = ot.length;
                        let st = null;
                        it < 2 && (st = []),
                        st = new Array(it - 1),
                        st[it - 2] = ot[it - 1];
                        for (let ct = it - 3; ct >= 0; --ct)
                            st[ct] = st[ct + 1] * ot[ct + 1];
                        const at = ["r", "c", "d", "d2"]
                          , lt = st.map( (ct, ut) => `int ${at[ut]} = index / ${ct}; ${ut === st.length - 1 ? `int ${at[ut + 1]} = index - ${at[ut]} * ${ct}` : `index -= ${at[ut]} * ${ct}`};`).join("");
                        return j = `
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${et[0]}, ${et[1]}));
          int index = resTexRC.y * ${et[0]} + resTexRC.x;
          ${lt}
          return ivec4(r, c, d, d2);
        }
      `,
                        new _.GlslLibRoutine(j)
                    }
                    getOutputUnpacked5DCoords(ot, et) {
                        let j = "";
                        const it = ot.length;
                        let st = null;
                        it < 2 && (st = []),
                        st = new Array(it - 1),
                        st[it - 2] = ot[it - 1];
                        for (let ct = it - 3; ct >= 0; --ct)
                            st[ct] = st[ct + 1] * ot[ct + 1];
                        const at = ["r", "c", "d", "d2", "d3"]
                          , lt = st.map( (ct, ut) => `int ${at[ut]} = index / ${ct}; ${ut === st.length - 1 ? `int ${at[ut + 1]} = index - ${at[ut]} * ${ct}` : `index -= ${at[ut]} * ${ct}`};`).join("");
                        return j = `
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${et[0]}, ${et[1]}));
          int index = resTexRC.y * ${et[0]} + resTexRC.x;
          ${lt}
          return ivec5(r, c, d, d2, d3);
        }
      `,
                        new _.GlslLibRoutine(j)
                    }
                    getOutputUnpacked6DCoords(ot, et) {
                        let j = "";
                        const it = ot.length;
                        let st = null;
                        it < 2 && (st = []),
                        st = new Array(it - 1),
                        st[it - 2] = ot[it - 1];
                        for (let ct = it - 3; ct >= 0; --ct)
                            st[ct] = st[ct + 1] * ot[ct + 1];
                        const at = ["r", "c", "d", "d2", "d3", "d4"]
                          , lt = st.map( (ct, ut) => `int ${at[ut]} = index / ${ct}; ${ut === st.length - 1 ? `int ${at[ut + 1]} = index - ${at[ut]} * ${ct}` : `index -= ${at[ut]} * ${ct}`};`).join("");
                        return j = `
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${et[0]}, ${et[1]}));
         int index = resTexRC.y * ${et[0]} + resTexRC.x;
         ${lt}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `,
                        new _.GlslLibRoutine(j)
                    }
                    getCommonUtilFuncs() {
                        const ot = {};
                        let et = "uvFromFlat";
                        ot[et] = new _.GlslLibRoutine(`
    vec2 uvFromFlat(int texNumR, int texNumC, int index) {
      int texC = index / texNumR;
      int texR = index - texC * texNumR;
      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to
      //       v.
      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);
    }
    `),
                        et = "packedUVfrom1D",
                        ot[et] = new _.GlslLibRoutine(`
      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
        int texelIndex = index / 2;
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),
                        et = "packedUVfrom2D",
                        ot[et] = new _.GlslLibRoutine(`
      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {
        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = texelIndex / texNumC;
        int texC = texelIndex - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),
                        et = "packedUVfrom3D",
                        ot[et] = new _.GlslLibRoutine(`
      vec2 packedUVfrom3D(int texNumR, int texNumC,
          int texelsInBatch, int texelsInLogicalRow, int b,
          int row, int col) {
        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
        int texR = index / texNumC;
        int texC = index - texR * texNumC;
        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
      }
      `),
                        et = "sampleTexture";
                        const j = (0,
                        $.getGlsl)(this.context.glContext.version);
                        return ot[et] = new _.GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${j.texture2D}(textureSampler, uv).r;
        }`),
                        ot
                    }
                    getInputsSamplingSnippets() {
                        const ot = {}
                          , et = this.context.outputTextureLayout;
                        return this.context.programInfo.inputNames.forEach( (j, it) => {
                            const st = this.context.inputTextureLayouts[it]
                              , at = (0,
                            tt.generateShaderFuncNameFromInputSamplerName)(j);
                            st.isPacked ? ot[at] = this.getPackedSamplerFromInput(at, j, st) : ot[at] = this.getUnpackedSamplerFromInput(at, j, st);
                            const lt = (0,
                            tt.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(j);
                            st.unpackedShape.length <= et.unpackedShape.length && (st.isPacked ? ot[lt] = this.getPackedSamplerAtOutputCoords(lt, st, et, j) : ot[lt] = this.getUnpackedSamplerAtOutputCoords(lt, st, et, j))
                        }
                        ),
                        ot
                    }
                    getPackedSamplerAtOutputCoords(ot, et, j, it) {
                        const st = et.unpackedShape
                          , at = j.unpackedShape
                          , lt = it
                          , ct = (0,
                        tt.generateShaderFuncNameFromInputSamplerName)(lt)
                          , ut = st.length
                          , dt = at.length
                          , ft = a.BroadcastUtil.getBroadcastDims(st, at)
                          , ht = (0,
                        tt.getCoordsDataType)(dt)
                          , pt = dt - ut;
                        let gt;
                        const _t = (0,
                        tt.getGlChannels)();
                        gt = ut === 0 ? "" : dt < 2 && ft.length >= 1 ? "coords = 0;" : ft.map(Tt => `coords.${_t[Tt + pt]} = 0;`).join(`
`);
                        let mt = "";
                        mt = dt < 2 && ut > 0 ? "coords" : st.map( (Tt, $t) => `coords.${_t[$t + pt]}`).join(", ");
                        let yt = "return outputValue;";
                        const bt = a.ShapeUtil.size(st) === 1
                          , vt = a.ShapeUtil.size(at) === 1;
                        if (ut !== 1 || bt || vt) {
                            if (bt && !vt)
                                yt = dt === 1 ? `
          return vec4(outputValue.x, outputValue.x, 0., 0.);
        ` : `
          return vec4(outputValue.x);
        `;
                            else if (ft.length) {
                                const Tt = ut - 2
                                  , $t = ut - 1;
                                ft.indexOf(Tt) > -1 && ft.indexOf($t) > -1 ? yt = "return vec4(outputValue.x);" : ft.indexOf(Tt) > -1 ? yt = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : ft.indexOf($t) > -1 && (yt = "return vec4(outputValue.xx, outputValue.zz);")
                            }
                        } else
                            yt = `
        return vec4(outputValue.xy, outputValue.xy);
      `;
                        const wt = `
      vec4 ${ot}() {
        ${ht} coords = getOutputCoords();
        
        int lastDim = coords.${_t[dt - 1]};
        coords.${_t[dt - 1]} = coords.${_t[dt - 2]};
        coords.${_t[dt - 2]} = lastDim;
      
        ${gt}
        vec4 outputValue = ${ct}(${mt});
        ${yt}
      }
    `;
                        return new _.GlslLibRoutine(wt,["coordinates.getOutputCoords"])
                    }
                    getUnpackedSamplerAtOutputCoords(ot, et, j, it) {
                        const st = [j.width, j.height]
                          , at = [et.width, et.height]
                          , lt = et.unpackedShape.length
                          , ct = j.unpackedShape.length
                          , ut = et.unpackedShape
                          , dt = j.unpackedShape
                          , ft = (0,
                        tt.generateShaderFuncNameFromInputSamplerName)(it);
                        if (lt === ct && a.ArrayUtil.arraysEqual(at, st)) {
                            const vt = `
          float ${ot}() {
            return sampleTexture(${it}, TexCoords);
          }
        `;
                            return new _.GlslLibRoutine(vt,["coordinates.sampleTexture"])
                        }
                        const ht = (0,
                        tt.getCoordsDataType)(ct)
                          , pt = a.BroadcastUtil.getBroadcastDims(ut, dt)
                          , gt = ct - lt;
                        let _t;
                        const mt = (0,
                        tt.getGlChannels)();
                        _t = lt === 0 ? "" : ct < 2 && pt.length >= 1 ? "coords = 0;" : pt.map(vt => `coords.${mt[vt + gt]} = 0;`).join(`
`);
                        let yt = "";
                        yt = ct < 2 && lt > 0 ? "coords" : et.unpackedShape.map( (vt, wt) => `coords.${mt[wt + gt]}`).join(", ");
                        const bt = `
        float ${ot}() {
          ${ht} coords = getOutputCoords();
          ${_t}
          return ${ft}(${yt});
        }
      `;
                        return new _.GlslLibRoutine(bt,["coordinates.getOutputCoords"])
                    }
                    getPackedSamplerFromInput(ot, et, j) {
                        switch (j.unpackedShape.length) {
                        case 0:
                            return this.getPackedSamplerScalar(ot, et);
                        case 1:
                            return this.getPackedSampler1D(ot, et, j);
                        case 2:
                            return this.getPackedSampler2D(ot, et, j);
                        case 3:
                            return this.getPackedSampler3D(ot, et, j);
                        default:
                            return this.getPackedSamplerND(ot, et, j)
                        }
                    }
                    getUnpackedSamplerFromInput(ot, et, j) {
                        const it = j.unpackedShape;
                        switch (it.length) {
                        case 0:
                            return this.getUnpackedSamplerScalar(ot, et, j);
                        case 1:
                            return this.getUnpackedSampler1D(ot, et, j);
                        case 2:
                            return this.getUnpackedSampler2D(ot, et, j);
                        case 3:
                            return this.getUnpackedSampler3D(ot, et, j);
                        case 4:
                            return this.getUnpackedSampler4D(ot, et, j);
                        case 5:
                            return this.getUnpackedSampler5D(ot, et, j);
                        case 6:
                            return this.getUnpackedSampler6D(ot, et, j);
                        default:
                            throw new Error(`Unsupported dimension ${it.length}-D`)
                        }
                    }
                    getPackedSamplerScalar(ot, et) {
                        const j = `
          vec4 ${ot}() {
            return ${(0,
                        $.getGlsl)(this.context.glContext.version).texture2D}(${et}, halfCR);
          }
        `;
                        return new _.GlslLibRoutine(j)
                    }
                    getPackedSampler1D(ot, et, j) {
                        const it = [j.width, j.height]
                          , st = [it[1], it[0]]
                          , at = (0,
                        $.getGlsl)(this.context.glContext.version)
                          , lt = `vec4 ${ot}(int index) {
      vec2 uv = packedUVfrom1D(
      ${st[0]}, ${st[1]}, index);
      return ${at.texture2D}(${et}, uv);
    }`;
                        return new _.GlslLibRoutine(lt,["coordinates.packedUVfrom1D"])
                    }
                    getPackedSampler2D(ot, et, j) {
                        const it = j.unpackedShape
                          , st = [j.width, j.height]
                          , at = (0,
                        $.getGlsl)(this.context.glContext.version)
                          , lt = st[0]
                          , ct = st[1];
                        if (st != null && a.ArrayUtil.arraysEqual(it, st)) {
                            const ht = `vec4 ${ot}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${ct}.0, ${lt}.0);
        return ${at.texture2D}(${et}, uv);
      }`;
                            return new _.GlslLibRoutine(ht)
                        }
                        const ut = st
                          , dt = Math.ceil(it[1] / 2)
                          , ft = `vec4 ${ot}(int row, int col) {
      vec2 uv = packedUVfrom2D(${ut[1]}, ${ut[0]}, ${dt}, row, col);
      return ${at.texture2D}(${et}, uv);
    }`;
                        return new _.GlslLibRoutine(ft,["coordinates.packedUVfrom2D"])
                    }
                    getPackedSampler3D(ot, et, j) {
                        const it = j.unpackedShape
                          , st = [j.width, j.height]
                          , at = [st[0], st[1]]
                          , lt = (0,
                        $.getGlsl)(this.context.glContext.version);
                        if (it[0] === 1) {
                            const ht = it.slice(1)
                              , pt = [1, 2]
                              , gt = (0,
                            tt.squeezeInputShape)(it, ht)
                              , _t = ["b", "row", "col"]
                              , mt = JSON.parse(JSON.stringify(j));
                            mt.unpackedShape = gt;
                            const yt = this.getPackedSamplerFromInput(ot, et, mt)
                              , bt = `${yt.routineBody}
      vec4 ${ot}(int b, int row, int col) {
        return ${ot}(${(0,
                            tt.getSqueezedParams)(_t, pt)});
      } `;
                            return new _.GlslLibRoutine(bt,yt.dependencies)
                        }
                        const ct = at[0]
                          , ut = at[1]
                          , dt = Math.ceil(it[2] / 2)
                          , ft = `vec4 ${ot}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${ut}, ${ct}, ${dt * Math.ceil(it[1] / 2)}, ${dt}, b, row, col);
      return ${lt.texture2D}(${et}, uv);}`;
                        return new _.GlslLibRoutine(ft,["coordinates.packedUVfrom3D"])
                    }
                    getPackedSamplerND(ot, et, j) {
                        const it = j.unpackedShape
                          , st = it.length
                          , at = [j.width, j.height]
                          , lt = (0,
                        $.getGlsl)(this.context.glContext.version)
                          , ct = [at[0], at[1]]
                          , ut = ct[1]
                          , dt = ct[0]
                          , ft = Math.ceil(it[st - 1] / 2);
                        let ht = ft * Math.ceil(it[st - 2] / 2)
                          , pt = "int b, int row, int col"
                          , gt = `b * ${ht} + (row / 2) * ${ft} + (col / 2)`;
                        for (let mt = 2; mt < st - 1; mt++)
                            pt = `int b${mt}, ` + pt,
                            ht *= it[st - mt - 1],
                            gt = `b${mt} * ${ht} + ` + gt;
                        const _t = `vec4 ${ot}(${pt}) {
      int index = ${gt};
      int texR = index / ${dt};
      int texC = index - texR * ${dt};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${dt}, ${ut});
      return ${lt.texture2D}(${et}, uv);
    }`;
                        return new _.GlslLibRoutine(_t)
                    }
                    getUnpackedSamplerScalar(ot, et, j) {
                        const [it,st] = [j.width, j.height];
                        if (it === 1 && st === 1) {
                            const lt = `
          float ${ot}() {
            return sampleTexture(${et}, halfCR);
          }
        `;
                            return new _.GlslLibRoutine(lt,["coordinates.sampleTexture"])
                        }
                        const at = `
        float ${ot}() {
          int offset_${et} = coordsToOffset(TexCoords, ${it}, ${st});
          vec2 uv = uvFromFlat(${it}, ${st}, offset_${et});
          return sampleTexture(${et}, uv);
        }
      `;
                        return new _.GlslLibRoutine(at,["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"])
                    }
                    getUnpackedSampler1D(ot, et, j) {
                        const it = j.width
                          , st = j.height;
                        if (st === 1 && it === 1) {
                            const lt = `
        float ${ot}(int index) {
          return sampleTexture(${et}, halfCR);
        }
      `;
                            return new _.GlslLibRoutine(lt,["coordinates.sampleTexture"])
                        }
                        if (st === 1) {
                            const lt = `
          float ${ot}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${it}.0, 0.5);
            return sampleTexture(${et}, uv);
          }
        `;
                            return new _.GlslLibRoutine(lt,["coordinates.sampleTexture"])
                        }
                        if (it === 1) {
                            const lt = `
          float ${ot}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${st}.0);
            return sampleTexture(${et}, uv);
          }
        `;
                            return new _.GlslLibRoutine(lt,["coordinates.sampleTexture"])
                        }
                        const at = `
        float ${ot}(int index) {
          vec2 uv = uvFromFlat(${it}, ${st}, index);
          return sampleTexture(${et}, uv);
        }
      `;
                        return new _.GlslLibRoutine(at,["coordinates.uvFromFlat", "coordinates.sampleTexture"])
                    }
                    getUnpackedSampler2D(ot, et, j) {
                        const it = j.unpackedShape
                          , st = [j.height, j.width];
                        if (st != null && a.ArrayUtil.arraysEqual(it, st)) {
                            const ht = `
          float ${ot}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${st[1]}.0, ${st[0]}.0);
            return sampleTexture(${et}, uv);
          }
        `;
                            return new _.GlslLibRoutine(ht,["coordinates.sampleTexture"])
                        }
                        const {newShape: at, keptDims: lt} = (0,
                        _e.squeezeShape)(it)
                          , ct = at;
                        if (ct.length < it.length) {
                            const ht = (0,
                            tt.squeezeInputShape)(it, ct)
                              , pt = JSON.parse(JSON.stringify(j));
                            pt.unpackedShape = ht;
                            const gt = ["col", "row"]
                              , _t = `
          ${this.getUnpackedSamplerFromInput(ot, et, pt).routineBody}
          float ${ot}(int row, int col) {
            return ${ot}(${(0,
                            tt.getSqueezedParams)(gt, lt)});
          }
        `;
                            return new _.GlslLibRoutine(_t,["coordinates.sampleTexture"])
                        }
                        const ut = st[1]
                          , dt = st[0];
                        if (dt === 1) {
                            const ht = `
          float ${ot}(int row, int col) {
            int offset_${et} = coordsToOffset(TexCoords, ${ut}, ${dt});
            float index = dot(vec3(row, col, offset_${et}), vec3(${it[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${ut}.0);
            return sampleTexture(${et}, uv);
          }
        `;
                            return new _.GlslLibRoutine(ht,["coordinates.sampleTexture", "coordinates.coordsToOffset"])
                        }
                        if (ut === 1) {
                            const ht = `
          float ${ot}(int row, int col) {
            int offset_${et} = coordsToOffset(TexCoords, ${ut}, ${dt});
            float index = dot(vec3(row, col, offset_${et}), vec3(${it[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${dt}.0, 0.5);
            return sampleTexture(${et}, uv);
          }
        `;
                            return new _.GlslLibRoutine(ht,["coordinates.sampleTexture", "coordinates.coordsToOffset"])
                        }
                        const ft = `
        float ${ot}(int row, int col) {
          int index = col * ${it[1]} + row;
          vec2 uv = uvFromFlat(${ut}, ${dt}, index);
          return sampleTexture(${et}, uv);
        }
      `;
                        return new _.GlslLibRoutine(ft,["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"])
                    }
                    getUnpackedSampler3D(ot, et, j) {
                        const it = j.unpackedShape
                          , st = it[1] * it[2]
                          , at = it[2]
                          , {newShape: lt, keptDims: ct} = (0,
                        _e.squeezeShape)(it)
                          , ut = lt;
                        if (ut.length < it.length) {
                            const ft = (0,
                            tt.squeezeInputShape)(it, ut)
                              , ht = ["batch", "col", "row"]
                              , pt = JSON.parse(JSON.stringify(j));
                            pt.unpackedShape = ft;
                            const gt = this.getUnpackedSamplerFromInput(ot, et, pt)
                              , _t = ct.reverse()
                              , mt = `
          ${gt.routineBody}
          float ${ot}(int batch, int row, int col) {
            return ${ot}(${(0,
                            tt.getSqueezedParams)(ht, _t)});
          }
        `;
                            return new _.GlslLibRoutine(mt,gt.dependencies)
                        }
                        const dt = `
          float ${ot}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${st} + col * ${at} + row;
            vec2 uv = uvFromFlat(${j.width}, ${j.height}, index);
            return sampleTexture(${et}, uv);
          }
      `;
                        return new _.GlslLibRoutine(dt,["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"])
                    }
                    getUnpackedSampler4D(ot, et, j) {
                        const it = j.unpackedShape
                          , st = it[3]
                          , at = it[2] * st
                          , lt = `
        float ${ot}(int row, int col, int depth, int depth2) {
          int index = row * ${it[1] * at} + col * ${at} +
              depth2 * ${st} + depth;
          vec2 uv = uvFromFlat(${j.width}, ${j.height}, index);
          return sampleTexture(${et}, uv);
        }
      `;
                        return new _.GlslLibRoutine(lt,["coordinates.uvFromFlat", "coordinates.sampleTexture"])
                    }
                    getUnpackedSampler5D(ot, et, j) {
                        const it = j.unpackedShape
                          , st = it[4]
                          , at = it[3] * st
                          , lt = it[2] * at
                          , ct = it[1] * lt
                          , {newShape: ut, keptDims: dt} = (0,
                        _e.squeezeShape)(it);
                        if (ut.length < it.length) {
                            const ht = (0,
                            tt.squeezeInputShape)(it, ut)
                              , pt = ["row", "col", "depth", "depth2", "depth3"]
                              , gt = JSON.parse(JSON.stringify(j));
                            gt.unpackedShape = ht;
                            const _t = `
          ${this.getUnpackedSamplerFromInput(ot, et, gt).routineBody}
          float ${ot}(int row, int col, int depth, int depth2, int depth3) {
            return ${ot}(${(0,
                            tt.getSqueezedParams)(pt, dt)});
          }
        `;
                            return new _.GlslLibRoutine(_t,["coordinates.sampleTexture", "coordinates.uvFromFlat"])
                        }
                        const ft = `
        float ${ot}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${ct} + col * ${lt} + depth * ${at} +
          depth3 * ${st} + depth2;
          vec2 uv = uvFromFlat(${j.width}, ${j.height}, index);
          return sampleTexture(${et}, uv);
        }
      `;
                        return new _.GlslLibRoutine(ft,["coordinates.sampleTexture", "coordinates.uvFromFlat"])
                    }
                    getUnpackedSampler6D(ot, et, j) {
                        const it = j.unpackedShape
                          , st = it[5]
                          , at = it[4] * st
                          , lt = it[3] * at
                          , ct = it[2] * lt
                          , ut = it[1] * ct
                          , {newShape: dt, keptDims: ft} = (0,
                        _e.squeezeShape)(it);
                        if (dt.length < it.length) {
                            const pt = (0,
                            tt.squeezeInputShape)(it, dt)
                              , gt = ["row", "col", "depth", "depth2", "depth3", "depth4"]
                              , _t = JSON.parse(JSON.stringify(j));
                            _t.unpackedShape = pt;
                            const mt = `
            ${this.getUnpackedSamplerFromInput(ot, et, _t).routineBody}
            float ${ot}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${ot}(${(0,
                            tt.getSqueezedParams)(gt, ft)});
            }
          `;
                            return new _.GlslLibRoutine(mt,["coordinates.sampleTexture", "coordinates.uvFromFlat"])
                        }
                        const ht = `
          float ${ot}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${ut} + col * ${ct} + depth * ${lt} +
            depth2 * ${at} + depth3 * ${st} + depth4;
            vec2 uv = uvFromFlat(${j.width}, ${j.height}, index);
            return sampleTexture(${et}, uv);
          }
        `;
                        return new _.GlslLibRoutine(ht,["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"])
                    }
                    toVec() {
                        const ot = this.context.outputTextureLayout
                          , et = ot.shape.length
                          , j = ot.strides
                          , it = ot.width
                          , st = ot.height
                          , at = [];
                        for (let ct = 0; ct < et - 1; ++ct)
                            at.push(`
        c[${ct}] = offset / ${j[ct]};`),
                            at.push(`
        offset -= c[${ct}] * ${j[ct]};`);
                        at.push(`
        c[${et - 1}] = offset;`);
                        const lt = `
      void toVec(vec2 texCoords, out int c[${et}]) {
        int offset = coordsToOffset(texCoords, ${it}, ${st});
        ${at.join("")}
      }
      void toVec(int offset, out int c[${et}]) {
        ${at.join("")}
      }
    `;
                        return {
                            toVec: new _.GlslLibRoutine(lt,["coordinates.coordsToOffset"])
                        }
                    }
                    valueFrom() {
                        const ot = {};
                        return this.context.programInfo.inputNames.forEach( (et, j) => {
                            const it = this.context.inputTextureLayouts[j]
                              , st = (it.unpackedShape.length > 0 ? it.unpackedShape : it.shape).length;
                            let at = `_${et}`;
                            ot[at] = new _.GlslLibRoutine(this.getValueFromSingle(et, st, it.width, it.height, !1),[`shapeUtils.indicesToOffset${at}`, "coordinates.offsetToCoords", "fragcolor.getColorAsFloat"]),
                            at += "_T",
                            ot[at] = new _.GlslLibRoutine(this.getValueFromSingle(et, st, it.width, it.height, !0),[`shapeUtils.indicesToOffset${at}`, "coordinates.offsetToCoords", "fragcolor.getColorAsFloat"])
                        }
                        ),
                        ot
                    }
                    getValueFromSingle(ot, et, j, it, st) {
                        let at = `_${ot}`;
                        return st && (at += "_T"),
                        `
        float ${at}(int m[${et}]) {
          int offset = indicesToOffset${at}(m);
          vec2 coords = offsetToCoords(offset, ${j}, ${it});
          float value = getColorAsFloat(${(0,
                        $.getGlsl)(this.context.glContext.version).texture2D}(${ot}, coords));
          return value;
        }
        `
                    }
                    getPackedValueFrom(ot, et, j, it, st) {
                        let at = `_${ot}_Pack`;
                        return st && (at += "_T"),
                        `
        vec4 ${at}(int m[${et}]) {
          int offset = indicesToOffset_${ot}(m);
          vec2 coords = offsetToCoords(offset, ${j}, ${it});
          return ${(0,
                        $.getGlsl)(this.context.glContext.version).texture2D}(${ot}, coords);
        }
        `
                    }
                }
                i.CoordsGlslLib = nt
            }
            ,
            1997: (o, i) => {
                var s;
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.TopologicalSortGlslRoutines = i.GlslLibRoutineNode = i.GlslLibRoutine = i.GlslLib = i.GlslContext = i.FunctionType = void 0,
                (s = i.FunctionType || (i.FunctionType = {}))[s.ValueBased = 0] = "ValueBased",
                s[s.Positional = 1] = "Positional",
                i.GlslContext = class {
                    constructor(a, _, $, _e) {
                        this.glContext = a,
                        this.programInfo = _,
                        this.inputTextureLayouts = $,
                        this.outputTextureLayout = _e
                    }
                }
                ,
                i.GlslLib = class {
                    constructor(a) {
                        this.context = a
                    }
                }
                ,
                i.GlslLibRoutine = class {
                    constructor(a, _) {
                        this.routineBody = a,
                        this.dependencies = _
                    }
                }
                ,
                i.GlslLibRoutineNode = class {
                    constructor(a, _, $) {
                        this.name = a,
                        this.dependencies = $ || [],
                        _ && (this.routineBody = _)
                    }
                    addDependency(a) {
                        a && this.dependencies.push(a)
                    }
                }
                ,
                i.TopologicalSortGlslRoutines = class {
                    static returnOrderedNodes(a) {
                        if (!a || a.length === 0)
                            return [];
                        if (a.length === 1)
                            return a;
                        const _ = new Set
                          , $ = new Set
                          , _e = new Array;
                        return this.createOrderedNodes(a, _, $, _e),
                        _e
                    }
                    static createOrderedNodes(a, _, $, _e) {
                        for (let tt = 0; tt < a.length; ++tt)
                            this.dfsTraverse(a[tt], _, $, _e)
                    }
                    static dfsTraverse(a, _, $, _e) {
                        if (!a || $.has(a.name))
                            return;
                        if (_.has(a.name))
                            throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");
                        _.add(a.name);
                        const tt = a.dependencies;
                        if (tt && tt.length > 0)
                            for (let nt = 0; nt < tt.length; ++nt)
                                this.dfsTraverse(tt[nt], _, $, _e);
                        _e.push(a),
                        $.add(a.name),
                        _.delete(a.name)
                    }
                }
            }
            ,
            1371: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.EncodingGlslLib = void 0;
                const a = s(1997);
                class _ extends a.GlslLib {
                    constructor(_e) {
                        super(_e)
                    }
                    getFunctions() {
                        return Object.assign(Object.assign({}, this.encodeFloat32()), this.decodeFloat32())
                    }
                    getCustomTypes() {
                        return {}
                    }
                    encodeFloat32() {
                        return {
                            encode: new a.GlslLibRoutine(`highp vec4 encode(highp float f) {
        return vec4(f, 0.0, 0.0, 0.0);
      }
        `)
                        }
                    }
                    decodeFloat32() {
                        return {
                            decode: new a.GlslLibRoutine(`highp float decode(highp vec4 rgba) {
        return rgba.r;
      }
        `)
                        }
                    }
                    encodeUint8() {
                        const _e = _.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
                        return {
                            encode: new a.GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${_e}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `)
                        }
                    }
                    decodeUint8() {
                        const _e = _.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
                        return {
                            decode: new a.GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${_e}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `)
                        }
                    }
                    static isLittleEndian() {
                        const _e = new ArrayBuffer(4)
                          , tt = new Uint32Array(_e)
                          , nt = new Uint8Array(_e);
                        if (tt[0] = 3735928559,
                        nt[0] === 239)
                            return !0;
                        if (nt[0] === 222)
                            return !1;
                        throw new Error("unknown endianness")
                    }
                }
                i.EncodingGlslLib = _
            }
            ,
            2691: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.FragColorGlslLib = void 0;
                const a = s(1997)
                  , _ = s(6757);
                class $ extends a.GlslLib {
                    constructor(tt) {
                        super(tt)
                    }
                    getFunctions() {
                        return Object.assign(Object.assign({}, this.setFragColor()), this.getColorAsFloat())
                    }
                    getCustomTypes() {
                        return {}
                    }
                    setFragColor() {
                        const tt = (0,
                        _.getGlsl)(this.context.glContext.version);
                        return {
                            setFragColor: new a.GlslLibRoutine(`
        void setFragColor(float value) {
            ${tt.output} = encode(value);
        }
        `,["encoding.encode"])
                        }
                    }
                    getColorAsFloat() {
                        return {
                            getColorAsFloat: new a.GlslLibRoutine(`
        float getColorAsFloat(vec4 color) {
            return decode(color);
        }
        `,["encoding.decode"])
                        }
                    }
                }
                i.FragColorGlslLib = $
            }
            ,
            3878: (o, i) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.replaceInlines = void 0;
                const s = /@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;
                i.replaceInlines = function(a) {
                    const _ = {};
                    let $;
                    for (; ($ = s.exec(a)) !== null; ) {
                        const _e = $[3].split(",").map(tt => {
                            const nt = tt.trim().split(" ");
                            return nt && nt.length === 2 ? {
                                type: nt[0],
                                name: nt[1]
                            } : null
                        }
                        ).filter(tt => tt !== null);
                        _[$[2]] = {
                            params: _e,
                            body: $[4]
                        }
                    }
                    for (const _e in _) {
                        const tt = "(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__", _e)
                          , nt = new RegExp(tt,"gm");
                        for (; ($ = nt.exec(a)) !== null; ) {
                            const rt = $[1]
                              , ot = $[2]
                              , et = $[3].split(",")
                              , j = rt ? `${rt} ${ot};` : "";
                            let it = _[_e].body
                              , st = "";
                            _[_e].params.forEach( (lt, ct) => {
                                lt && (st += `${lt.type} ${lt.name} = ${et[ct]};
`)
                            }
                            ),
                            it = `${st}
 ${it}`,
                            it = it.replace("return", `${ot} = `);
                            const at = `
      ${j}
      {
        ${it}
      }
      `;
                            a = a.replace($[0], at)
                        }
                    }
                    return a.replace(s, "")
                }
            }
            ,
            8897: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.GlslPreprocessor = void 0;
                const a = s(1997)
                  , _ = s(3878)
                  , $ = s(1248)
                  , _e = s(6757);
                i.GlslPreprocessor = class {
                    constructor(tt, nt, rt, ot) {
                        this.libs = {},
                        this.glslLibRoutineDependencyGraph = {},
                        this.context = new a.GlslContext(tt,nt,rt,ot),
                        Object.keys($.glslRegistry).forEach(j => {
                            const it = new $.glslRegistry[j](this.context);
                            this.libs[j] = it
                        }
                        );
                        const et = this.glslLibRoutineDependencyGraph;
                        for (const j in this.libs) {
                            const it = this.libs[j].getFunctions();
                            for (const st in it) {
                                const at = j + "." + st;
                                let lt;
                                et[at] ? (lt = et[at],
                                lt.routineBody = it[st].routineBody) : (lt = new a.GlslLibRoutineNode(at,it[st].routineBody),
                                et[at] = lt);
                                const ct = it[st].dependencies;
                                if (ct)
                                    for (let ut = 0; ut < ct.length; ++ut)
                                        if (et[ct[ut]])
                                            lt.addDependency(et[ct[ut]]);
                                        else {
                                            const dt = new a.GlslLibRoutineNode(ct[ut]);
                                            et[ct[ut]] = dt,
                                            lt.addDependency(dt)
                                        }
                            }
                        }
                    }
                    preprocess() {
                        const tt = this.context.programInfo;
                        let nt = tt.shaderSource;
                        return this.context.programInfo.hasMain || (nt = `${nt}
      ${(0,
                        _e.getDefaultFragShaderMain)(this.context.glContext.version, this.context.outputTextureLayout.shape.length)}`),
                        nt = (0,
                        _.replaceInlines)(nt),
                        `${(0,
                        _e.getFragShaderPreamble)(this.context.glContext.version)}
    ${this.getUniforms(tt.inputNames, tt.variables)}
    ${this.getImports(nt)}
    ${nt}`
                    }
                    getImports(tt) {
                        const nt = this.selectGlslLibRoutinesToBeIncluded(tt);
                        if (nt.length === 0)
                            return "";
                        let rt = "";
                        for (let ot = 0; ot < nt.length; ++ot) {
                            if (!nt[ot].routineBody)
                                throw new Error(`Missing body for the Glsl Library routine: ${nt[ot].name}`);
                            rt += nt[ot].routineBody + `
`
                        }
                        return rt
                    }
                    selectGlslLibRoutinesToBeIncluded(tt) {
                        const nt = [];
                        return Object.keys(this.glslLibRoutineDependencyGraph).forEach(rt => {
                            const ot = rt.split(".")[1];
                            tt.indexOf(ot) !== -1 && nt.push(this.glslLibRoutineDependencyGraph[rt])
                        }
                        ),
                        a.TopologicalSortGlslRoutines.returnOrderedNodes(nt)
                    }
                    getUniforms(tt, nt) {
                        const rt = [];
                        if (tt)
                            for (const ot of tt)
                                rt.push(`uniform sampler2D ${ot};`);
                        if (nt)
                            for (const ot of nt)
                                rt.push(`uniform ${ot.type} ${ot.name}${ot.arrayLength ? `[${ot.arrayLength}]` : ""};`);
                        return rt.join(`
`)
                    }
                }
            }
            ,
            1248: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.glslRegistry = void 0;
                const a = s(6859)
                  , _ = s(1371)
                  , $ = s(2691)
                  , _e = s(9183)
                  , tt = s(9314);
                i.glslRegistry = {
                    encoding: _.EncodingGlslLib,
                    fragcolor: $.FragColorGlslLib,
                    vec: tt.VecGlslLib,
                    shapeUtils: _e.ShapeUtilsGlslLib,
                    coordinates: a.CoordsGlslLib
                }
            }
            ,
            9183: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.ShapeUtilsGlslLib = void 0;
                const a = s(1997);
                class _ extends a.GlslLib {
                    constructor(_e) {
                        super(_e)
                    }
                    getFunctions() {
                        return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.bcastIndex()), this.bcastMatmulIndex()), this.offsetToIndices()), this.indicesToOffset()), this.incrementIndices())
                    }
                    getCustomTypes() {
                        return {}
                    }
                    bcastIndex() {
                        const _e = this.context.outputTextureLayout.shape.length
                          , tt = {};
                        return this.context.programInfo.inputNames.forEach( (nt, rt) => {
                            const ot = this.context.inputTextureLayouts[rt].unpackedShape;
                            if (ot.length <= _e) {
                                const et = ot.length
                                  , j = _e - et
                                  , it = `bcastIndices_${nt}`;
                                let st = "";
                                for (let lt = 0; lt < et; ++lt)
                                    st += `
          realIndices[${lt}] = int( mod(float(bcastedIndices[${j + lt}]), ${ot[lt]}.0) );
          `;
                                const at = `
        void ${it} (int bcastedIndices[${_e}], out int realIndices[${et}]) {
          ${st}
        }
        `;
                                tt[it] = new a.GlslLibRoutine(at)
                            }
                        }
                        ),
                        tt
                    }
                    bcastMatmulIndex() {
                        const _e = this.context.outputTextureLayout.shape.length
                          , tt = {};
                        return this.context.programInfo.inputNames.forEach( (nt, rt) => {
                            const ot = this.context.inputTextureLayouts[rt].shape;
                            if (!(ot.length < 2 || ot.length > _e)) {
                                const et = ot.length
                                  , j = _e - et
                                  , it = `bcastMatmulIndices_${nt}`;
                                let st = "";
                                for (let lt = 0; lt < et - 2; ++lt)
                                    st += `
          realIndices[${lt}] = int( mod(float(bcastedIndices[${j + lt}]), ${ot[lt]}.0) );
          `;
                                const at = `
        void ${it}(int bcastedIndices[${_e}], out int realIndices[${et}]) {
          ${st}
          realIndices[${et - 1}] = bcastedIndices[${_e - 1}];
          realIndices[${et - 2}] = bcastedIndices[${_e - 2}];
        }
        `;
                                tt[it] = new a.GlslLibRoutine(at)
                            }
                        }
                        ),
                        tt
                    }
                    indicesToOffset() {
                        const _e = {};
                        return this.context.programInfo.inputNames.forEach( (tt, nt) => {
                            const rt = this.context.inputTextureLayouts[nt].shape
                              , ot = this.context.inputTextureLayouts[nt].strides
                              , et = rt.length;
                            let j = `indicesToOffset_${tt}`;
                            _e[j] = new a.GlslLibRoutine(_.indexToOffsetSingle(j, et, ot)),
                            j = `indicesToOffset_${tt}_T`,
                            _e[j] = new a.GlslLibRoutine(_.indexToOffsetSingle(j, et, ot.slice().reverse()))
                        }
                        ),
                        _e
                    }
                    static indexToOffsetSingle(_e, tt, nt) {
                        let rt = "";
                        for (let ot = tt - 1; ot >= 0; --ot)
                            rt += `
        offset += indices[${ot}] * ${nt[ot]};
        `;
                        return `
      int ${_e}(int indices[${tt}]) {
        int offset = 0;
        ${rt}
        return offset;
      }
      `
                    }
                    offsetToIndices() {
                        const _e = {};
                        return this.context.programInfo.inputNames.forEach( (tt, nt) => {
                            const rt = this.context.inputTextureLayouts[nt].shape
                              , ot = this.context.inputTextureLayouts[nt].strides
                              , et = rt.length;
                            let j = `offsetToIndices_${tt}`;
                            _e[j] = new a.GlslLibRoutine(_.offsetToIndicesSingle(j, et, ot)),
                            j = `offsetToIndices_${tt}_T`,
                            _e[j] = new a.GlslLibRoutine(_.offsetToIndicesSingle(j, et, ot.slice().reverse()))
                        }
                        ),
                        _e
                    }
                    static offsetToIndicesSingle(_e, tt, nt) {
                        const rt = [];
                        for (let ot = 0; ot < tt - 1; ++ot)
                            rt.push(`
      indices[${ot}] = offset / ${nt[ot]};`),
                            rt.push(`
        offset -= indices[${ot}] * ${nt[ot]};`);
                        return rt.push(`
      indices[${tt - 1}] = offset;`),
                        `
      void ${_e}(int offset, out int indices[${tt}]) {
        ${rt.join("")}
      }
      `
                    }
                    incrementIndices() {
                        const _e = {};
                        return this.context.programInfo.inputNames.forEach( (tt, nt) => {
                            const rt = this.context.inputTextureLayouts[nt].shape
                              , ot = rt.length
                              , et = `incrementIndices_${tt}`;
                            let j = "";
                            for (let st = 0; st < ot; ++st)
                                j += `
        shape[${st}] = ${rt[st]};`;
                            const it = `
        void ${et}(int axis, out int indices[${ot}]) {
          int shape[${ot}];
          ${j};
          for(int i = ${ot} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;
                            _e[et] = new a.GlslLibRoutine(it)
                        }
                        ),
                        _e
                    }
                }
                i.ShapeUtilsGlslLib = _
            }
            ,
            6757: (o, i) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.getDefaultFragShaderMain = i.getFragShaderPreamble = i.getVertexShaderSource = i.getGlsl = void 0;
                const s = {
                    version: "",
                    attribute: "attribute",
                    varyingVertex: "varying",
                    varyingFrag: "varying",
                    texture2D: "texture2D",
                    output: "gl_FragColor",
                    outputDeclaration: ""
                }
                  , a = {
                    version: "#version 300 es",
                    attribute: "in",
                    varyingVertex: "out",
                    varyingFrag: "in",
                    texture2D: "texture",
                    output: "outputColor",
                    outputDeclaration: "out vec4 outputColor;"
                };
                function _($) {
                    return $ === 1 ? s : a
                }
                i.getGlsl = _,
                i.getVertexShaderSource = function($) {
                    const _e = _($);
                    return `${_e.version}
      precision highp float;
      ${_e.attribute} vec3 position;
      ${_e.attribute} vec2 textureCoord;

      ${_e.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`
                }
                ,
                i.getFragShaderPreamble = function($) {
                    const _e = _($);
                    return `${_e.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${_e.varyingFrag} vec2 TexCoords;
    ${_e.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `
                }
                ,
                i.getDefaultFragShaderMain = function($, _e) {
                    return `
  void main() {
    int indices[${_e}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${_($).output} = result;
  }
  `
                }
            }
            ,
            9314: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.VecGlslLib = void 0;
                const a = s(1997);
                class _ extends a.GlslLib {
                    constructor(_e) {
                        super(_e)
                    }
                    getCustomTypes() {
                        return {}
                    }
                    getFunctions() {
                        return Object.assign(Object.assign(Object.assign(Object.assign({}, this.binaryVecFunctions()), this.copyVec()), this.setVecItem()), this.getVecItem())
                    }
                    binaryVecFunctions() {
                        const _e = this.context.outputTextureLayout.shape.length
                          , tt = {
                            add: "+=",
                            sub: "-=",
                            mul: "*=",
                            div: "/="
                        }
                          , nt = {};
                        for (const rt in tt) {
                            const ot = `${rt}Vec`;
                            let et = "";
                            for (let it = 0; it < _e; ++it)
                                et += `
          dest[${it}] ${tt[rt]} src[${it}];
          `;
                            const j = `
        void ${ot}(int src[${_e}], out int dest[${_e}]) {
          ${et}
        }
        `;
                            nt[ot] = new a.GlslLibRoutine(j)
                        }
                        return nt
                    }
                    copyVec() {
                        const _e = this.context.outputTextureLayout.shape.length;
                        let tt = "";
                        for (let rt = 0; rt < _e; ++rt)
                            tt += `
        dest[${rt}] = src[${rt}];
        `;
                        const nt = `
      void copyVec(int src[${_e}], out int dest[${_e}]) {
        ${tt}
      }
      `;
                        return {
                            copyVec: new a.GlslLibRoutine(nt)
                        }
                    }
                    setVecItem() {
                        const _e = this.context.outputTextureLayout.shape.length;
                        let tt = `
        if(index < 0)
            index =${_e} + index;
        if (index == 0)
            m[0] = value;
        `;
                        for (let rt = 1; rt < _e - 1; ++rt)
                            tt += `
        else if (index == ${rt})
            m[${rt}] = value;
            `;
                        tt += `
        else
            m[${_e - 1}] = value;
        `;
                        const nt = `
      void setVecItem(out int m[${_e}], int index, int value) {
        ${tt}
      }
        `;
                        return {
                            setVecItem: new a.GlslLibRoutine(nt)
                        }
                    }
                    getVecItem() {
                        const _e = this.context.outputTextureLayout.shape.length;
                        let tt = `
        if(index < 0)
            index = ${_e} + index;
        if (index == 0)
            return m[0];
      `;
                        for (let rt = 1; rt < _e - 1; ++rt)
                            tt += `
        else if (index == ${rt})
            return m[${rt}];
      `;
                        tt += `
        else
            return m[${_e - 1}];
        `;
                        const nt = `
      int getVecItem(int m[${_e}], int index) {
        ${tt}
      }
    `;
                        return {
                            getVecItem: new a.GlslLibRoutine(nt)
                        }
                    }
                }
                i.VecGlslLib = _
            }
            ,
            7860: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.WebGLInferenceHandler = void 0;
                const a = s(1315)
                  , _ = s(9240)
                  , $ = s(7273)
                  , _e = s(9)
                  , tt = s(7379)
                  , nt = s(2488)
                  , rt = s(540)
                  , ot = s(3314)
                  , et = s(5639);
                i.WebGLInferenceHandler = class {
                    constructor(j) {
                        this.session = j,
                        this.packedTextureDataCache = new Map,
                        this.unpackedTextureDataCache = new Map
                    }
                    calculateTextureWidthAndHeight(j, it) {
                        return (0,
                        ot.calculateTextureWidthAndHeight)(this.session.layoutStrategy, j, it)
                    }
                    executeProgram(j, it) {
                        if (it.length < j.inputNames.length)
                            throw new Error(`Input size mustn't be less than ${j.inputNames.length}.`);
                        if (j.inputNames.length !== j.inputTypes.length)
                            throw new Error("input names size does not match input types");
                        const st = [];
                        for (let ft = 0; ft < j.inputNames.length; ++ft)
                            st[ft] = this.getOrCreateTextureData(it[ft], j.inputTypes[ft]);
                        const at = ( (ft, ht) => {
                            const pt = ht.map(_t => `${_t.unpackedShape.join(",")};${_t.width}x${_t.height}`).join("_");
                            let gt = ft.name;
                            return ft.cacheHint && (gt += "[" + ft.cacheHint + "]"),
                            gt += ":" + pt,
                            gt
                        }
                        )(j, st);
                        let lt = this.session.programManager.getArtifact(at);
                        const ct = lt ? lt.programInfo : typeof j.get == "function" ? j.get() : j
                          , ut = (0,
                        ot.createTextureLayoutFromTextureType)(this.session.layoutStrategy, ct.output.dims, ct.output.textureType)
                          , dt = this.createTextureData(ut, ct.output.type);
                        return lt || (lt = this.session.programManager.build(ct, st, dt),
                        this.session.programManager.setArtifact(at, lt)),
                        this.runProgram(lt, st, dt),
                        dt
                    }
                    run(j, it) {
                        return this.executeProgram(j, it).tensor
                    }
                    runProgram(j, it, st) {
                        for (let at = 0; at < it.length; ++at)
                            if (!!it[at].isPacked != (j.programInfo.inputTypes[at] === et.TextureType.packed))
                                throw new Error(`input[${at}] property packed inconsistent`);
                        if (!!st.isPacked != (j.programInfo.output.textureType === et.TextureType.packed))
                            throw new Error("output property packed inconsistent");
                        this.session.programManager.run(j, it, st)
                    }
                    getOrCreateTextureData(j, it) {
                        let st = this.getTextureData(j.dataId, it === et.TextureType.packed);
                        if (!st && (st = this.getTextureData(j.dataId, it !== et.TextureType.packed),
                        st))
                            return it === et.TextureType.packed ? this.pack(st) : this.unpack(st);
                        if (!st) {
                            const at = (0,
                            ot.createTextureLayoutFromTextureType)(this.session.layoutStrategy, j.dims, it);
                            if (it === et.TextureType.packedLastDimension) {
                                const ut = j.dims;
                                if (ut.length === 4) {
                                    const dt = [ut[0], Math.ceil(ut[1] * ut[2] * ut[3] / 4)]
                                      , ft = (0,
                                    ot.createTextureLayoutFromTextureType)(this.session.layoutStrategy, dt, it);
                                    let ht = j.numberData;
                                    if (ut[1] * ut[2] * ut[3] % 4 != 0) {
                                        const pt = ut[0]
                                          , gt = ut[1] * ut[2] * ut[3]
                                          , _t = Math.ceil(gt * 1 / 4) * 4;
                                        ht = new Float32Array(pt * _t);
                                        for (let mt = 0; mt < pt; ++mt) {
                                            const yt = mt * gt
                                              , bt = mt * _t + mt % 1 * gt;
                                            ht.set(j.numberData.subarray(yt, yt + gt), bt)
                                        }
                                    }
                                    return this.createTextureData(ft, j.type, ht, j, 1)
                                }
                            }
                            if (it === et.TextureType.packed) {
                                const lt = (0,
                                ot.createTextureLayoutFromShape)(this.session.layoutStrategy, j.dims, 1, [], {
                                    reverseWH: !0
                                })
                                  , ct = this.createTextureData(lt, j.type, j.numberData, j, 1);
                                st = this.pack(ct)
                            } else
                                st = this.createTextureData(at, j.type, j.numberData, j, 1)
                        }
                        return st
                    }
                    createTextureDataFromLayoutBindTensor(j, it, st, at) {
                        return this.createTextureData(j, it, st, at, 1)
                    }
                    createTextureData(j, it, st, at, lt) {
                        a.Logger.verbose("InferenceHandler", `Creating TextureData: layout:[${JSON.stringify(j)}]`);
                        const ct = this.session.textureManager.createTextureFromLayout(it, j, st, lt);
                        return this.createTextureDataFromTexture(j, it, ct, at)
                    }
                    reshapeUnpacked(j, it) {
                        const st = this.getOrCreateTextureData(j, et.TextureType.unpacked)
                          , at = {
                            channels: st.channels,
                            height: st.height,
                            width: st.width,
                            shape: it.length !== 0 ? it : [1],
                            strides: $.ShapeUtil.computeStrides(it),
                            unpackedShape: it
                        };
                        return this.createTextureDataFromTexture(at, j.type, st.texture).tensor
                    }
                    reshapePacked(j, it) {
                        const st = this.getOrCreateTextureData(j, et.TextureType.packed);
                        if ((0,
                        tt.isReshapeCheap)(j.dims, it)) {
                            const dt = {
                                channels: st.channels,
                                height: st.height,
                                width: st.width,
                                shape: it.length !== 0 ? it : [1],
                                strides: $.ShapeUtil.computeStrides(it),
                                unpackedShape: it,
                                isPacked: !0
                            };
                            return this.createTextureDataFromTexture(dt, j.type, st.texture).tensor
                        }
                        const at = (0,
                        tt.processDims3D)(j.dims)
                          , lt = (0,
                        tt.processDims3D)(it)
                          , ct = this.reshapePacked(j, at)
                          , ut = this.run((0,
                        tt.createPackedReshape3DProgramInfoLoader)(this, ct, lt), [ct]);
                        return this.reshapePacked(ut, it)
                    }
                    cast(j, it) {
                        const st = this.getOrCreateTextureData(j, et.TextureType.unpacked);
                        return this.createTextureDataFromTexture(st, it, st.texture).tensor
                    }
                    createTextureDataFromTexture(j, it, st, at, lt) {
                        const ct = Object.assign(Object.assign({}, j), {
                            tensor: at || new _.Tensor(j.unpackedShape,it,ut => this.readTexture(ct),async ut => this.readTextureAsync(ct),void 0,lt),
                            texture: st
                        });
                        return this.setTextureData(ct.tensor.dataId, ct, j.isPacked),
                        ct
                    }
                    getTextureData(j, it=!1) {
                        return this.session.isInitializer(j) ? this.session.getTextureData(j, it) : it ? this.packedTextureDataCache.get(j) : this.unpackedTextureDataCache.get(j)
                    }
                    setTextureData(j, it, st=!1) {
                        this.session.isInitializer(j) ? this.session.setTextureData(j, it, st) : (st ? this.packedTextureDataCache : this.unpackedTextureDataCache).set(j, it)
                    }
                    isTextureLayoutCached(j, it=!1) {
                        return !!this.getTextureData(j.dataId, it)
                    }
                    dispose() {
                        this.session.textureManager.clearActiveTextures(),
                        this.packedTextureDataCache.forEach(j => this.session.textureManager.releaseTexture(j)),
                        this.packedTextureDataCache = new Map,
                        this.unpackedTextureDataCache.forEach(j => this.session.textureManager.releaseTexture(j)),
                        this.unpackedTextureDataCache = new Map
                    }
                    readTexture(j) {
                        return j.isPacked ? this.readTexture(this.unpack(j)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTexture(j, j.tensor.type, j.channels) : this.session.textureManager.readUint8TextureAsFloat((0,
                        nt.encodeAsUint8)(this, j))
                    }
                    async readTextureAsync(j) {
                        return j.isPacked ? this.readTextureAsync(this.unpack(j)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTextureAsync(j, j.tensor.type, j.channels) : this.session.textureManager.readUint8TextureAsFloat((0,
                        nt.encodeAsUint8)(this, j))
                    }
                    pack(j) {
                        return this.executeProgram((0,
                        _e.createPackProgramInfoLoader)(this, j.tensor), [j.tensor])
                    }
                    unpack(j) {
                        return this.executeProgram((0,
                        rt.createUnpackProgramInfoLoader)(this, j.tensor), [j.tensor])
                    }
                }
            }
            ,
            4110: function(o, i, s) {
                var a = this && this.__createBinding || (Object.create ? function(Mt, Ut, Lt, tn) {
                    tn === void 0 && (tn = Lt);
                    var Vt = Object.getOwnPropertyDescriptor(Ut, Lt);
                    Vt && !("get"in Vt ? !Ut.__esModule : Vt.writable || Vt.configurable) || (Vt = {
                        enumerable: !0,
                        get: function() {
                            return Ut[Lt]
                        }
                    }),
                    Object.defineProperty(Mt, tn, Vt)
                }
                : function(Mt, Ut, Lt, tn) {
                    tn === void 0 && (tn = Lt),
                    Mt[tn] = Ut[Lt]
                }
                )
                  , _ = this && this.__setModuleDefault || (Object.create ? function(Mt, Ut) {
                    Object.defineProperty(Mt, "default", {
                        enumerable: !0,
                        value: Ut
                    })
                }
                : function(Mt, Ut) {
                    Mt.default = Ut
                }
                )
                  , $ = this && this.__importStar || function(Mt) {
                    if (Mt && Mt.__esModule)
                        return Mt;
                    var Ut = {};
                    if (Mt != null)
                        for (var Lt in Mt)
                            Lt !== "default" && Object.prototype.hasOwnProperty.call(Mt, Lt) && a(Ut, Mt, Lt);
                    return _(Ut, Mt),
                    Ut
                }
                ;
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.WEBGL_OP_RESOLVE_RULES = void 0;
                const _e = s(8817)
                  , tt = $(s(5194))
                  , nt = s(4752)
                  , rt = s(6668)
                  , ot = s(9754)
                  , et = s(5042)
                  , j = s(6742)
                  , it = s(4125)
                  , st = s(6149)
                  , at = s(5378)
                  , lt = s(6981)
                  , ct = s(7413)
                  , ut = s(7006)
                  , dt = s(8276)
                  , ft = s(5565)
                  , ht = s(2834)
                  , pt = s(1010)
                  , gt = s(8126)
                  , _t = s(2801)
                  , mt = s(565)
                  , yt = s(2444)
                  , bt = s(815)
                  , vt = s(564)
                  , wt = s(5416)
                  , Tt = s(1240)
                  , $t = s(5944)
                  , Et = s(5707)
                  , Pt = $(s(9087))
                  , Rt = s(7862)
                  , At = s(3980);
                i.WEBGL_OP_RESOLVE_RULES = [["Abs", "", "6+", Pt.abs], ["Acos", "", "7+", Pt.acos], ["Add", "", "7+", tt.add], ["And", "", "7+", tt.and], ["Asin", "", "7+", Pt.asin], ["Atan", "", "7+", Pt.atan], ["AveragePool", "", "7+", ht.averagePool, ht.parseAveragePoolAttributes], ["BatchNormalization", "", "7+", _e.batchNormalization, _e.parseBatchNormalizationAttributes], ["Cast", "", "6+", nt.cast, nt.parseCastAttributes], ["Ceil", "", "6+", Pt.ceil], ["Clip", "", "6-10", Pt.clip, Pt.parseClipAttributes], ["Clip", "", "11+", Pt.clipV11], ["Concat", "", "4+", rt.concat, rt.parseConcatAttributes], ["Conv", "", "1+", ot.conv, ot.parseConvAttributes], ["ConvTranspose", "", "1+", et.convTranspose, et.parseConvTransposeAttributes], ["Cos", "", "7+", Pt.cos], ["Div", "", "7+", tt.div], ["Dropout", "", "7+", Pt.identity], ["DepthToSpace", "", "1+", j.depthToSpace, j.parseDepthToSpaceAttributes], ["Equal", "", "7+", tt.equal], ["Elu", "", "6+", Pt.elu, Pt.parseEluAttributes], ["Exp", "", "6+", Pt.exp], ["Flatten", "", "1+", it.flatten, it.parseFlattenAttributes], ["Floor", "", "6+", Pt.floor], ["FusedConv", "com.microsoft", "1+", ot.conv, ot.parseConvAttributes], ["Gather", "", "1+", st.gather, st.parseGatherAttributes], ["Gemm", "", "7-10", at.gemm, at.parseGemmAttributesV7], ["Gemm", "", "11+", at.gemm, at.parseGemmAttributesV11], ["GlobalAveragePool", "", "1+", ht.globalAveragePool, ht.parseGlobalAveragePoolAttributes], ["GlobalMaxPool", "", "1+", ht.globalMaxPool], ["Greater", "", "7+", tt.greater], ["Identity", "", "1+", Pt.identity], ["ImageScaler", "", "1+", lt.imageScaler, lt.parseImageScalerAttributes], ["InstanceNormalization", "", "6+", ct.instanceNormalization, ct.parseInstanceNormalizationAttributes], ["LeakyRelu", "", "6+", Pt.leakyRelu, Pt.parseLeakyReluAttributes], ["Less", "", "7+", tt.less], ["LRN", "", "1+", ut.lrn, ut.parseLrnAttributes], ["Log", "", "6+", Pt.log], ["MatMul", "", "1+", dt.matMul, dt.parseMatMulAttributes], ["MaxPool", "", "1+", ht.maxPool, ht.parseMaxPoolAttributes], ["Mul", "", "7+", tt.mul], ["Neg", "", "6+", Pt.neg], ["Not", "", "1+", Pt.not], ["Or", "", "7+", tt.or], ["Pad", "", "2-10", ft.padV2, ft.parsePadAttributesV2], ["Pad", "", "11+", ft.padV11, ft.parsePadAttributesV11], ["Pow", "", "7+", tt.pow], ["PRelu", "", "7+", tt.pRelu], ["ReduceLogSum", "", "1+", pt.reduceLogSum, pt.parseReduceAttributes], ["ReduceMax", "", "1+", pt.reduceMax, pt.parseReduceAttributes], ["ReduceMean", "", "1+", pt.reduceMean, pt.parseReduceAttributes], ["ReduceMin", "", "1+", pt.reduceMin, pt.parseReduceAttributes], ["ReduceProd", "", "1+", pt.reduceProd, pt.parseReduceAttributes], ["ReduceSum", "", "1-12", pt.reduceSum, pt.parseReduceAttributes], ["ReduceSumSquare", "", "1+", pt.reduceLogSumSquare, pt.parseReduceAttributes], ["Relu", "", "6+", Pt.relu], ["Reshape", "", "5+", gt.reshape], ["Resize", "", "10", _t.resize, _t.parseResizeAttributesV10], ["Resize", "", "11+", _t.resize, _t.parseResizeAttributesV11], ["Shape", "", "1+", mt.shape], ["Sigmoid", "", "6+", Pt.sigmoid], ["Sin", "", "7+", Pt.sin], ["Slice", "", "10+", yt.sliceV10], ["Slice", "", "1-9", yt.slice, yt.parseSliceAttributes], ["Softmax", "", "1-12", bt.softmax, bt.parseSoftmaxAttributes], ["Softmax", "", "13+", bt.softmaxV13, bt.parseSoftmaxAttributesV13], ["Split", "", "2-12", vt.split, vt.parseSplitAttributes], ["Sqrt", "", "6+", Pt.sqrt], ["Squeeze", "", "1-12", wt.squeeze, wt.parseSqueezeAttributes], ["Squeeze", "", "13+", wt.squeezeV13], ["Sub", "", "7+", tt.sub], ["Sum", "", "6+", Tt.sum], ["Tan", "", "7+", Pt.tan], ["Tanh", "", "6+", Pt.tanh], ["Tile", "", "6+", $t.tile], ["Transpose", "", "1+", Et.transpose, Et.parseTransposeAttributes], ["Upsample", "", "7-8", At.upsample, At.parseUpsampleAttributesV7], ["Upsample", "", "9", At.upsample, At.parseUpsampleAttributesV9], ["Unsqueeze", "", "1-12", Rt.unsqueeze, Rt.parseUnsqueezeAttributes], ["Unsqueeze", "", "13+", Rt.unsqueezeV13], ["Xor", "", "7+", tt.xor]]
            },
            8817: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.parseBatchNormalizationAttributes = i.batchNormalization = void 0;
                const a = s(4910)
                  , _ = s(6757)
                  , $ = s(5639)
                  , _e = {
                    name: "BatchNormalization",
                    inputNames: ["A", "Scale", "B", "Mean", "Variance"],
                    inputTypes: [$.TextureType.unpacked, $.TextureType.unpacked, $.TextureType.unpacked, $.TextureType.unpacked, $.TextureType.unpacked]
                };
                i.batchNormalization = (rt, ot, et) => (nt(ot),
                [rt.run(Object.assign(Object.assign({}, _e), {
                    cacheHint: et.cacheKey,
                    get: () => tt(rt, ot, et)
                }), ot)]),
                i.parseBatchNormalizationAttributes = rt => {
                    const ot = rt.attributes.getFloat("epsilon", 1e-5)
                      , et = rt.attributes.getFloat("momentum", .9)
                      , j = rt.attributes.getInt("spatial", 1);
                    return (0,
                    a.createAttributeWithCacheKey)({
                        epsilon: ot,
                        momentum: et,
                        spatial: j
                    })
                }
                ;
                const tt = (rt, ot, et) => {
                    const j = (0,
                    _.getGlsl)(rt.session.backend.glContext.version)
                      , it = ot[0].dims.length
                      , [st,at] = rt.calculateTextureWidthAndHeight(ot[1].dims, $.TextureType.unpacked)
                      , lt = `
  float process(int[${it}] indices) {
    vec2 position = offsetToCoords(indices[1], ${st}, ${at});
    float scale = getColorAsFloat(${j.texture2D}(Scale, position));
    float mean = getColorAsFloat(${j.texture2D}(Mean, position));
    float variance = getColorAsFloat(${j.texture2D}(Variance, position));
    float b = getColorAsFloat(${j.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${et.epsilon})) ) + b;
  }`;
                    return Object.assign(Object.assign({}, _e), {
                        output: {
                            dims: ot[0].dims,
                            type: ot[0].type,
                            textureType: $.TextureType.unpacked
                        },
                        shaderSource: lt
                    })
                }
                  , nt = rt => {
                    if (!rt || rt.length !== 5)
                        throw new Error("BatchNormalization requires 5 inputs.");
                    const ot = rt[0]
                      , et = rt[1]
                      , j = rt[2]
                      , it = rt[3]
                      , st = rt[4];
                    if (ot.dims.length < 3 || et.dims.length !== 1 || j.dims.length !== 1 || it.dims.length !== 1 || st.dims.length !== 1)
                        throw new Error("invalid input shape.");
                    if (et.dims[0] !== ot.dims[1] || j.dims[0] !== ot.dims[1] || it.dims[0] !== ot.dims[1] || st.dims[0] !== ot.dims[1])
                        throw new Error("invalid input shape.");
                    if (ot.type !== "float32" && ot.type !== "float64" || et.type !== "float32" && et.type !== "float64" || j.type !== "float32" && j.type !== "float64" || it.type !== "float32" && it.type !== "float64" || st.type !== "float32" && st.type !== "float64")
                        throw new Error("invalid input tensor types.")
                }
            }
            ,
            5194: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.xor = i.sub = i.pRelu = i.pow = i.or = i.mul = i.less = i.greater = i.equal = i.div = i.and = i.add = i.glslPRelu = i.glslPow = i.glslXor = i.glslOr = i.glslAnd = i.glslLess = i.glslGreater = i.glslEqual = i.glslSub = i.glslMul = i.glslDiv = i.glslAdd = void 0;
                const a = s(7273)
                  , _ = s(1997)
                  , $ = s(6757)
                  , _e = s(5639);
                function tt() {
                    const ht = "add_";
                    return {
                        body: `
  float ${ht}(float a, float b) {
    return a + b;
  }
  vec4 ${ht}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `,
                        name: ht,
                        type: _.FunctionType.ValueBased
                    }
                }
                function nt() {
                    const ht = "div_";
                    return {
                        body: `
  float ${ht}(float a, float b) {
    return a / b;
  }
  vec4 ${ht}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `,
                        name: ht,
                        type: _.FunctionType.ValueBased
                    }
                }
                function rt() {
                    const ht = "mul_";
                    return {
                        body: `
  float ${ht}(float a, float b) {
    return a * b;
  }
  vec4 ${ht}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `,
                        name: ht,
                        type: _.FunctionType.ValueBased
                    }
                }
                function ot() {
                    const ht = "sub_";
                    return {
                        body: `
  float ${ht}(float a, float b) {
    return a - b;
  }
  vec4 ${ht}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `,
                        name: ht,
                        type: _.FunctionType.ValueBased
                    }
                }
                function et() {
                    const ht = "equal_";
                    return {
                        body: `
  float ${ht}(float a, float b) {
    return float(a == b);
  }
  vec4 ${ht}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `,
                        name: ht,
                        type: _.FunctionType.ValueBased
                    }
                }
                function j() {
                    const ht = "greater_";
                    return {
                        body: `
  float ${ht}(float a, float b) {
    return float(a > b);
  }
  vec4 ${ht}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `,
                        name: ht,
                        type: _.FunctionType.ValueBased
                    }
                }
                function it() {
                    const ht = "less_";
                    return {
                        body: `
  float ${ht}(float a, float b) {
    return float(a < b);
  }
  vec4 ${ht}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `,
                        name: ht,
                        type: _.FunctionType.ValueBased
                    }
                }
                function st() {
                    const ht = "and_";
                    return {
                        body: `
  float ${ht}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${ht}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `,
                        name: ht,
                        type: _.FunctionType.ValueBased
                    }
                }
                function at() {
                    const ht = "or_";
                    return {
                        body: `
  float ${ht}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${ht}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `,
                        name: ht,
                        type: _.FunctionType.ValueBased
                    }
                }
                function lt() {
                    const ht = "xor_";
                    return {
                        body: `
  float ${ht}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${ht}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `,
                        name: ht,
                        type: _.FunctionType.ValueBased
                    }
                }
                function ct() {
                    return function(ht) {
                        const pt = `${ht}_`;
                        return {
                            body: `
  float ${pt}(float a, float b) {
    return ${ht}(a, b);
  }
  vec4 ${pt}(vec4 v1, vec4 v2) {
    return ${ht}(v1, v2);
  }
  `,
                            name: pt,
                            type: _.FunctionType.ValueBased
                        }
                    }("pow")
                }
                function ut() {
                    const ht = "prelu_";
                    return {
                        body: `
  float ${ht}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${ht}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `,
                        name: ht,
                        type: _.FunctionType.ValueBased
                    }
                }
                i.glslAdd = tt,
                i.glslDiv = nt,
                i.glslMul = rt,
                i.glslSub = ot,
                i.glslEqual = et,
                i.glslGreater = j,
                i.glslLess = it,
                i.glslAnd = st,
                i.glslOr = at,
                i.glslXor = lt,
                i.glslPow = ct,
                i.glslPRelu = ut;
                const dt = (ht, pt, gt, _t=pt[0].type, mt) => {
                    const yt = ht.session.pack ? _e.TextureType.packed : _e.TextureType.unpacked;
                    return {
                        name: gt.name,
                        inputNames: ["A", "B"],
                        inputTypes: [yt, yt],
                        cacheHint: mt,
                        get: () => ft(ht, pt, gt, _t)
                    }
                }
                  , ft = (ht, pt, gt, _t=pt[0].type) => {
                    const mt = ht.session.pack ? _e.TextureType.packed : _e.TextureType.unpacked
                      , yt = !a.ShapeUtil.areEqual(pt[0].dims, pt[1].dims);
                    let bt = pt[0].dims;
                    const vt = ht.session.pack;
                    if (yt) {
                        const $t = a.BroadcastUtil.calcShape(pt[0].dims, pt[1].dims, !1);
                        if (!$t)
                            throw new Error("Can't perform binary op on the given tensors");
                        bt = $t;
                        const Et = bt.length
                          , Pt = pt[0].dims.length !== 0 ? pt[0].dims.length : 1
                          , Rt = pt[1].dims.length !== 0 ? pt[1].dims.length : 1
                          , At = pt[0].dims.length !== 0 ? "bcastIndices_A(indices, aindices);" : "aindices[0] = 0;"
                          , Mt = pt[1].dims.length !== 0 ? "bcastIndices_B(indices, bindices);" : "bindices[0] = 0;"
                          , Ut = (0,
                        $.getGlsl)(ht.session.backend.glContext.version)
                          , Lt = vt ? `
      ${gt.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${gt.name}(a, b);
        ${Ut.output} = result;
      }` : `
      ${gt.body}
      float process(int indices[${Et}]) {
        int aindices[${Pt}];
        int bindices[${Rt}];
        ${At}
        ${Mt}
        return ${gt.name}(_A(aindices), _B(bindices));
      }`;
                        return {
                            name: gt.name,
                            inputNames: ["A", "B"],
                            inputTypes: [mt, mt],
                            output: {
                                dims: bt,
                                type: _t,
                                textureType: mt
                            },
                            shaderSource: Lt,
                            hasMain: vt
                        }
                    }
                    const wt = (0,
                    $.getGlsl)(ht.session.backend.glContext.version)
                      , Tt = `
    ${gt.body}
    void main() {
      vec4 v1 = ${wt.texture2D}(A, TexCoords);
      vec4 v2 = ${wt.texture2D}(B, TexCoords);
      vec4 result = ${gt.name}(v1, v2);
      ${wt.output} = result;
    }
    `;
                    return {
                        name: gt.name,
                        inputNames: ["A", "B"],
                        inputTypes: [mt, mt],
                        output: {
                            dims: pt[0].dims,
                            type: _t,
                            textureType: mt
                        },
                        shaderSource: Tt,
                        hasMain: !0
                    }
                }
                ;
                i.add = (ht, pt) => [ht.run(dt(ht, pt, tt()), pt)],
                i.and = (ht, pt) => [ht.run(dt(ht, pt, st(), "bool"), pt)],
                i.div = (ht, pt) => [ht.run(dt(ht, pt, nt()), pt)],
                i.equal = (ht, pt) => [ht.run(dt(ht, pt, et(), "bool"), pt)],
                i.greater = (ht, pt) => [ht.run(dt(ht, pt, j(), "bool"), pt)],
                i.less = (ht, pt) => [ht.run(dt(ht, pt, it(), "bool"), pt)],
                i.mul = (ht, pt) => [ht.run(dt(ht, pt, rt()), pt)],
                i.or = (ht, pt) => [ht.run(dt(ht, pt, at(), "bool"), pt)],
                i.pow = (ht, pt) => [ht.run(dt(ht, pt, ct()), pt)],
                i.pRelu = (ht, pt) => [ht.run(dt(ht, pt, ut()), pt)],
                i.sub = (ht, pt) => [ht.run(dt(ht, pt, ot()), pt)],
                i.xor = (ht, pt) => [ht.run(dt(ht, pt, lt(), "bool"), pt)]
            }
            ,
            4752: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.parseCastAttributes = i.cast = void 0;
                const a = s(7273);
                i.cast = ($, _e, tt) => (_(_e),
                [$.cast(_e[0], tt)]),
                i.parseCastAttributes = $ => a.ProtoUtil.tensorDataTypeFromProto($.attributes.getInt("to"));
                const _ = $ => {
                    if (!$ || $.length !== 1)
                        throw new Error("Cast requires 1 input.");
                    if ($[0].type === "string")
                        throw new Error("Invalid input type.")
                }
            }
            ,
            4595: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.createPackedConcatProgramInfoLoader = void 0;
                const a = s(6757)
                  , _ = s(5639)
                  , $ = s(432)
                  , _e = s(5614);
                i.createPackedConcatProgramInfoLoader = (nt, rt, ot) => {
                    const et = (j = rt.length,
                    it = ot.cacheKey,
                    {
                        name: "Concat (packed)",
                        inputNames: Array.from({
                            length: j
                        }, (st, at) => `X${at}`),
                        inputTypes: Array(j).fill(_.TextureType.packed),
                        cacheHint: it
                    });
                    var j, it;
                    return Object.assign(Object.assign({}, et), {
                        get: () => ( (st, at, lt, ct) => {
                            const ut = lt[0].dims.slice();
                            if (ct >= ut.length || ct < -1 * ut.length)
                                throw new Error("axis specified for concat doesn't match input dimensionality");
                            ct < 0 && (ct = ut.length + ct);
                            const dt = ut.slice(0);
                            for (let At = 1; At < lt.length; At++) {
                                const Mt = lt[At].dims.slice();
                                for (let Ut = 0; Ut < ut.length; Ut++)
                                    if (Ut === ct)
                                        dt[ct] += Mt[Ut];
                                    else if (ut[Ut] !== Mt[Ut])
                                        throw new Error("non concat dimensions must match")
                            }
                            const ft = dt.length
                              , ht = (0,
                            _e.getChannels)("coords", ft)
                              , pt = (0,
                            $.getCoordsDataType)(ft)
                              , gt = (0,
                            _e.unpackFromChannel)()
                              , _t = lt.map(At => At.dims)
                              , mt = (0,
                            $.getGlChannels)(ft)
                              , yt = new Array(_t.length - 1);
                            yt[0] = _t[0][ct];
                            for (let At = 1; At < yt.length; At++)
                                yt[At] = yt[At - 1] + _t[At][ct];
                            const bt = mt[ct]
                              , vt = mt.slice(-2)
                              , wt = mt.join();
                            let Tt = `if (${bt} < ${yt[0]}) {
        return getChannel(
            getX0(${wt}), vec2(${vt.join()}));
        }`;
                            for (let At = 1; At < yt.length; At++) {
                                const Mt = yt[At - 1];
                                Tt += `
            if (${bt} < ${yt[At]}  && ${bt} >= ${yt[At - 1]}) {
              return getChannel(
                getX${At}(${tt(mt, bt, Mt)}),
                vec2(${tt(vt, bt, Mt)}));
            }`
                            }
                            const $t = yt.length
                              , Et = yt[yt.length - 1];
                            Tt += `
            return getChannel(
              getX${$t}(${tt(mt, bt, Et)}),
              vec2(${tt(vt, bt, Et)}));`;
                            const Pt = (0,
                            a.getGlsl)(st.session.backend.glContext.version)
                              , Rt = `
          ${gt}
          float getValue(${mt.map(At => "int " + At)}) {
            ${Tt}
          }

          void main() {
            ${pt} coords = getOutputCoords();
            int lastDim = coords.${mt[ft - 1]};
            coords.${mt[ft - 1]} = coords.${mt[ft - 2]};
            coords.${mt[ft - 2]} = lastDim;

            vec4 result = vec4(getValue(${ht}), 0., 0., 0.);

            ${ht[ft - 1]} = ${ht[ft - 1]} + 1;
            if (${ht[ft - 1]} < ${dt[ft - 1]}) {
              result.g = getValue(${ht});
            }

            ${ht[ft - 2]} = ${ht[ft - 2]} + 1;
            if (${ht[ft - 2]} < ${dt[ft - 2]}) {
              result.a = getValue(${ht});
            }

            ${ht[ft - 1]} = ${ht[ft - 1]} - 1;
            if (${ht[ft - 2]} < ${dt[ft - 2]} &&
                ${ht[ft - 1]} < ${dt[ft - 1]}) {
              result.b = getValue(${ht});
            }
            ${Pt.output} = result;
          }
        `;
                            return Object.assign(Object.assign({}, at), {
                                output: {
                                    dims: dt,
                                    type: lt[0].type,
                                    textureType: _.TextureType.packed
                                },
                                shaderSource: Rt,
                                hasMain: !0
                            })
                        }
                        )(nt, et, rt, ot.axis)
                    })
                }
                ;
                const tt = (nt, rt, ot) => {
                    const et = nt.indexOf(rt);
                    return nt.map( (j, it) => it === et ? `${j} - ${ot}` : j).join()
                }
            }
            ,
            6668: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.parseConcatAttributes = i.concat = void 0;
                const a = s(4910)
                  , _ = s(5639)
                  , $ = s(4595);
                i.concat = (j, it, st) => (et(it),
                j.session.pack && it[0].dims.length > 1 ? [j.run((0,
                $.createPackedConcatProgramInfoLoader)(j, it, st), it)] : [j.run(_e(j, it, st), it)]);
                const _e = (j, it, st) => {
                    const at = (lt = it.length,
                    ct = st.cacheKey,
                    {
                        name: "Concat",
                        inputNames: Array.from({
                            length: lt
                        }, (ut, dt) => `X${dt}`),
                        inputTypes: Array(lt).fill(_.TextureType.unpacked),
                        cacheHint: ct
                    });
                    var lt, ct;
                    return Object.assign(Object.assign({}, at), {
                        get: () => ( (ut, dt, ft, ht) => {
                            const pt = ft[0].dims.slice();
                            if (ht >= pt.length || ht < -1 * pt.length)
                                throw new Error("axis specified for concat doesn't match input dimensionality");
                            ht < 0 && (ht = pt.length + ht);
                            const gt = pt.slice(0);
                            for (let wt = 1; wt < ft.length; wt++) {
                                const Tt = ft[wt].dims.slice();
                                for (let $t = 0; $t < pt.length; $t++)
                                    if ($t === ht)
                                        gt[ht] += Tt[$t];
                                    else if (pt[$t] !== Tt[$t])
                                        throw new Error("non concat dimensions must match")
                            }
                            const _t = gt.length
                              , mt = new Array(ft.length);
                            let yt = 0;
                            for (let wt = 0; wt < mt.length; ++wt)
                                yt += ft[wt].dims[ht],
                                mt[wt] = yt;
                            let bt = "";
                            bt = ft.length < 5 ? tt(mt) : nt(mt);
                            const vt = `
        ${rt(ft.length, _t)}
        ${ot(mt)}
        ${bt}
        float process(int indices[${_t}]) {
          int textureIndex = getTextureWhereDataResides (indices[${ht}]);

          if(textureIndex != 0) {
            indices[${ht}] = indices[${ht}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;
                            return Object.assign(Object.assign({}, dt), {
                                output: {
                                    dims: gt,
                                    type: ft[0].type,
                                    textureType: _.TextureType.unpacked
                                },
                                shaderSource: vt
                            })
                        }
                        )(0, at, it, st.axis)
                    })
                }
                  , tt = j => `int getTextureWhereDataResides(int index) {
      ${j.map( (it, st) => `if(index<${it}) {return ${st};}
`).join("")}
    }`
                  , nt = j => tt(j)
                  , rt = (j, it) => {
                    const st = [`float fetchDataFromCorrectTexture(int textureIndex, int indices[${it}]) {`];
                    for (let at = 0; at < j; ++at)
                        at === 0 ? st.push(`	if (textureIndex == ${at}) { return _X${at}(indices); }`) : at === j - 1 ? st.push(`	else { return _X${at}(indices); }`) : st.push(`	else if (textureIndex == ${at}) { return _X${at}(indices); }`);
                    return st.push("	}"),
                    st.join(`
`)
                }
                  , ot = j => {
                    const it = ["int getSizeInConcatAxisValueFromIndex(int index) {"];
                    for (let st = 0; st < j.length; ++st)
                        st === 0 ? it.push(`	if (index == ${st}) { return ${j[st]}; }`) : st === j.length - 1 ? it.push(`	else { return ${j[st]}; }`) : it.push(`	else if (index == ${st}) { return ${j[st]}; }`);
                    return it.push("	}"),
                    it.join(`
`)
                }
                ;
                i.parseConcatAttributes = j => (0,
                a.createAttributeWithCacheKey)({
                    axis: j.attributes.getInt("axis")
                });
                const et = j => {
                    if (!j || j.length < 1)
                        throw new Error("too few inputs");
                    const it = j[0].type
                      , st = j[0].dims.length;
                    if (it === "string")
                        throw new Error("string tensor is not supported yet");
                    for (const at of j) {
                        if (at.type !== it)
                            throw new Error("input tensors should be one type");
                        if (at.dims.length !== st)
                            throw new Error("input tensors should have the same shape")
                    }
                }
            }
            ,
            7825: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.createUnpackedGroupedConvProgramInfoLoader = void 0;
                const a = s(1315)
                  , _ = s(6757)
                  , $ = s(5639)
                  , _e = s(9754)
                  , tt = s(2150);
                i.createUnpackedGroupedConvProgramInfoLoader = (nt, rt, ot) => {
                    const et = (j = rt.length > 2,
                    it = ot.cacheKey,
                    {
                        name: "GroupedConv",
                        inputNames: j ? ["X", "W", "Bias"] : ["X", "W"],
                        inputTypes: j ? [$.TextureType.unpacked, $.TextureType.unpacked, $.TextureType.unpacked] : [$.TextureType.unpacked, $.TextureType.unpacked],
                        cacheHint: it
                    });
                    var j, it;
                    return Object.assign(Object.assign({}, et), {
                        get: () => ( (st, at, lt, ct) => {
                            const ut = at.length > 2 ? "value += getBias(output_channel);" : ""
                              , dt = at[0].dims.slice()
                              , ft = at[1].dims.slice()
                              , ht = ft[0] / ct.group;
                            a.Logger.verbose("GroupedConv", `autpPad:${ct.autoPad}, dilations:${ct.dilations}, group:${ct.group}, kernelShape:${ct.kernelShape}, pads:${ct.pads}, strides:${ct.strides}`);
                            const pt = (0,
                            _e.calculateOutputShape)(dt, ft, ct.dilations, ct.pads, ct.strides)
                              , gt = (0,
                            _.getGlsl)(st.session.backend.glContext.version)
                              , {activationFunction: _t, applyActivation: mt} = (0,
                            tt.getActivationSnippet)(ct)
                              , yt = `
  const ivec2 strides = ivec2(${ct.strides[0]}, ${ct.strides[1]});
  const ivec2 pads = ivec2(${ct.pads[0]}, ${ct.pads[1]});
  ${_t}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${ht};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${ft[1]}; wInChannel++) {
      int input_channel = group_id * ${ft[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${ft[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${ct.dilations[0]};

        if (xHeight < 0 || xHeight >= ${dt[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${ft[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${ct.dilations[1]};
          if (xWidth < 0 || xWidth >= ${dt[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${ut}
    ${mt}
    ${gt.output} = vec4(value, .0, .0, .0);
  }
`;
                            return Object.assign(Object.assign({}, lt), {
                                output: {
                                    dims: pt,
                                    type: at[0].type,
                                    textureType: $.TextureType.unpacked
                                },
                                shaderSource: yt,
                                hasMain: !0
                            })
                        }
                        )(nt, rt, et, ot)
                    })
                }
            }
            ,
            7708: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.conv2DPacked = i.conv2DPackedPointwise = void 0;
                const a = s(9754)
                  , _ = s(5950)
                  , $ = s(5632);
                i.conv2DPackedPointwise = (_e, tt, nt) => {
                    const rt = tt[0].dims
                      , ot = tt[1].dims
                      , et = (0,
                    a.calculateOutputShape)(rt, ot, nt.dilations, nt.pads, nt.strides)
                      , j = _e.reshapePacked(tt[0], [rt[1], rt[2] * rt[3]])
                      , it = _e.reshapePacked(tt[1], [ot[0], ot[1]])
                      , st = tt.length > 2 ? [it, j, tt[2]] : [it, j]
                      , at = _e.run((0,
                    $.createPackedMatmulProgramInfoLoader)(_e, st, nt), st);
                    return _e.reshapePacked(at, et)
                }
                ,
                i.conv2DPacked = (_e, tt, nt) => {
                    const rt = tt[0].dims
                      , ot = tt[1].dims
                      , et = (0,
                    a.calculateOutputShape)(rt, ot, nt.dilations, nt.pads, nt.strides)
                      , j = _e.run((0,
                    _.createPackedIm2ColProgramInfoLoader)(_e, tt[0], tt[1], et, nt), [tt[0]])
                      , it = _e.reshapePacked(tt[1], [ot[0], ot[1] * ot[2] * ot[3]])
                      , st = tt.length === 3 ? [it, j, tt[2]] : [it, j]
                      , at = _e.run((0,
                    $.createPackedMatmulProgramInfoLoader)(_e, st, nt), st);
                    return _e.reshapePacked(at, et)
                }
            }
            ,
            5042: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.parseConvTransposeAttributes = i.convTranspose = void 0;
                const a = s(4910)
                  , _ = s(6757)
                  , $ = s(5639)
                  , _e = s(2150)
                  , tt = (it, st, at, lt, ct, ut) => (it - 1) * st + at + (lt - 1) * ct + 1 - ut
                  , nt = (it, st, at, lt, ct) => {
                    const ut = Math.floor(it / 2);
                    st === "SAME_UPPER" ? (at[lt] = ut,
                    at[ct] = it - ut) : st === "SAME_LOWER" && (at[lt] = it - ut,
                    at[ct] = ut)
                }
                ;
                i.convTranspose = (it, st, at) => (j(st, at),
                rt(it, st, at));
                const rt = (it, st, at) => {
                    const lt = et(at, st);
                    return [ot(it, st, lt)]
                }
                  , ot = (it, st, at) => it.run(( (lt, ct, ut) => {
                    const dt = (ft = ct.length > 2,
                    ht = ut.cacheKey,
                    {
                        name: "ConvTranspose",
                        inputNames: ft ? ["X", "W", "B"] : ["X", "W"],
                        inputTypes: ft ? [$.TextureType.unpacked, $.TextureType.unpacked, $.TextureType.unpacked] : [$.TextureType.unpacked, $.TextureType.unpacked],
                        cacheHint: ht
                    });
                    var ft, ht;
                    return Object.assign(Object.assign({}, dt), {
                        get: () => ( (pt, gt, _t, mt) => {
                            const yt = gt.length > 2 ? "getB(output_channel)" : "0.0"
                              , bt = gt[0].dims
                              , vt = gt[1].dims
                              , wt = vt[1]
                              , Tt = vt[0] / mt.group
                              , $t = [gt[0].dims[0], gt[1].dims[1] * mt.group, ...mt.outputShape]
                              , Et = (0,
                            _.getGlsl)(pt.session.backend.glContext.version)
                              , {activationFunction: Pt, applyActivation: Rt} = (0,
                            _e.getActivationSnippet)(mt)
                              , At = `
  const ivec2 strides = ivec2(${mt.strides[0]}, ${mt.strides[1]});
  const ivec2 pads = ivec2(${mt.pads[0]}, ${mt.pads[1]});
  ${Pt}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${wt};
    int wOutChannel = output_channel - group_id * ${wt};

    float value = ${yt};
    for (int inChannelOffset = 0; inChannelOffset < ${Tt}; inChannelOffset++) {
      int input_channel = group_id * ${Tt} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${vt[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${vt[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${mt.dilations[0]}, wHOff * ${mt.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${bt[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${bt[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${Rt}
    ${Et.output} = vec4(value, .0, .0, .0);
  }
`;
                            return Object.assign(Object.assign({}, _t), {
                                output: {
                                    dims: $t,
                                    type: gt[0].type,
                                    textureType: $.TextureType.unpacked
                                },
                                shaderSource: At,
                                hasMain: !0
                            })
                        }
                        )(lt, ct, dt, ut)
                    })
                }
                )(it, st, at), st)
                  , et = (it, st) => {
                    const at = it.kernelShape.slice();
                    if (it.kernelShape.length === 0)
                        for (let dt = 2; dt < st[1].dims.length; ++dt)
                            at.push(st[1].dims[dt]);
                    const lt = it.pads.slice()
                      , ct = it.outputShape.slice();
                    ( (dt, ft, ht, pt, gt, _t, mt, yt) => {
                        const bt = dt.length - 2
                          , vt = yt.length === 0;
                        for (let wt = 0; wt < bt; ++wt) {
                            const Tt = vt ? dt[wt + 2] * _t[wt] : yt[wt]
                              , $t = tt(dt[wt + 2], _t[wt], gt[wt], ft[wt], ht[wt], Tt);
                            nt($t, pt, gt, wt, wt + bt),
                            vt && yt.push(_t[wt] * (dt[wt + 2] - 1) + mt[wt] + (ft[wt] - 1) * ht[wt] + 1 - gt[wt] - gt[wt + bt])
                        }
                    }
                    )(st[0].dims, at, it.dilations, it.autoPad, lt, it.strides, it.outputPadding, ct);
                    const ut = Object.assign({}, it);
                    return Object.assign(ut, {
                        kernelShape: at,
                        pads: lt,
                        outputShape: ct,
                        cacheKey: it.cacheKey
                    }),
                    ut
                }
                ;
                i.parseConvTransposeAttributes = it => {
                    const st = it.attributes
                      , at = (0,
                    _e.parseInternalActivationAttributes)(st)
                      , lt = st.getString("auto_pad", "NOTSET")
                      , ct = st.getInts("dilations", [1, 1])
                      , ut = st.getInt("group", 1)
                      , dt = st.getInts("kernel_shape", [])
                      , ft = st.getInts("output_padding", [0, 0])
                      , ht = st.getInts("output_shape", [])
                      , pt = st.getInts("pads", [0, 0, 0, 0])
                      , gt = st.getInts("strides", [1, 1]);
                    return (0,
                    a.createAttributeWithCacheKey)(Object.assign({
                        autoPad: lt,
                        dilations: ct,
                        group: ut,
                        kernelShape: dt,
                        outputPadding: ft,
                        outputShape: ht,
                        pads: pt,
                        strides: gt
                    }, at))
                }
                ;
                const j = (it, st) => {
                    if (!it || it.length !== 2 && it.length !== 3)
                        throw new Error("Conv requires 2 or 3 inputs");
                    if (it[0].dims.length !== 4 || it[1].dims.length !== 4)
                        throw new Error("currently only support 2-dimensional conv");
                    if (it[0].dims[1] !== it[1].dims[0])
                        throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
                    const at = it[1].dims[1] * st.group;
                    if (it.length === 3 && (it[2].dims.length !== 1 || it[2].dims[0] !== at))
                        throw new Error("invalid bias");
                    const lt = it[0].dims.length - 2;
                    if (st.dilations.length !== lt)
                        throw new Error(`dilations should be ${lt}D`);
                    if (st.strides.length !== lt)
                        throw new Error(`strides should be ${lt}D`);
                    if (st.pads.length !== 2 * lt)
                        throw new Error(`pads should be ${2 * lt}D`);
                    if (st.outputPadding.length !== lt)
                        throw new Error(`output_padding should be ${lt}D`);
                    if (st.kernelShape.length !== 0 && st.kernelShape.length !== it[1].dims.length - 2)
                        throw new Error("invalid kernel shape");
                    if (st.outputShape.length !== 0 && st.outputShape.length !== it[0].dims.length - 2)
                        throw new Error("invalid output shape");
                    if (it[0].type !== "float32" || it[1].type !== "float32")
                        throw new Error("ConvTranspose input(X,W) should be float tensor");
                    if (it.length === 3 && it[2].type !== "float32")
                        throw new Error("ConvTranspose input(bias) should be float tensor")
                }
            }
            ,
            9754: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.parseConvAttributes = i.conv = i.calculateOutputShape = void 0;
                const a = s(4910)
                  , _ = s(7273)
                  , $ = s(7825)
                  , _e = s(7708)
                  , tt = s(3281)
                  , nt = s(2150)
                  , rt = s(1625)
                  , ot = s(8276);
                i.calculateOutputShape = (lt, ct, ut, dt, ft) => {
                    const ht = lt[0]
                      , pt = lt.slice(2)
                      , gt = pt.length
                      , _t = ct[0]
                      , mt = ct.slice(2).map( (bt, vt) => bt + (bt - 1) * (ut[vt] - 1))
                      , yt = pt.map( (bt, vt) => bt + dt[vt] + dt[vt + gt]).map( (bt, vt) => Math.floor((bt - mt[vt] + ft[vt]) / ft[vt]));
                    return [ht, _t].concat(...yt)
                }
                ,
                i.conv = (lt, ct, ut) => (at(ct, ut),
                et(lt, ct, ut));
                const et = (lt, ct, ut) => {
                    const dt = st(ut, ct)
                      , ft = lt.session.pack
                      , ht = dt.kernelShape[0] === 1 && dt.kernelShape[1] === 1;
                    return dt.group > 1 ? [lt.run((0,
                    $.createUnpackedGroupedConvProgramInfoLoader)(lt, ct, dt), ct)] : ht && ft ? [j(lt, ct, dt)] : ft && ct[0].dims.length === 4 && ct[0].dims[0] === 1 && !ht ? [(0,
                    _e.conv2DPacked)(lt, ct, dt)] : [it(lt, ct, dt)]
                }
                  , j = (lt, ct, ut) => {
                    const dt = ct[0].dims
                      , ft = ct[1].dims
                      , ht = (0,
                    i.calculateOutputShape)(dt, ft, ut.dilations, ut.pads, ut.strides)
                      , pt = lt.reshapeUnpacked(ct[0], [dt[1], dt[2] * dt[3]])
                      , gt = lt.reshapeUnpacked(ct[1], [ft[0], ft[1]])
                      , _t = ct.length > 2 ? [gt, pt, ct[2]] : [gt, pt]
                      , mt = lt.run((0,
                    ot.createMatmulProgramInfoLoader)(_t, ut), _t);
                    return lt.reshapeUnpacked(mt, ht)
                }
                  , it = (lt, ct, ut) => {
                    const dt = ct[0].dims
                      , ft = ct[1].dims
                      , ht = (0,
                    i.calculateOutputShape)(dt, ft, ut.dilations, ut.pads, ut.strides)
                      , pt = lt.run((0,
                    rt.createIm2ColProgramInfoLoader)(lt, ct[0], ct[1], ht, ut), [ct[0]])
                      , gt = ct.length === 3 ? [pt, ct[1], ct[2]] : [pt, ct[1]];
                    return lt.run((0,
                    tt.createDotProductProgramInfoLoader)(lt, ct, ht, ut), gt)
                }
                  , st = (lt, ct) => {
                    const ut = lt.kernelShape.slice();
                    if (lt.kernelShape.length === 0)
                        for (let ht = 2; ht < ct[1].dims.length; ++ht)
                            ut.push(ct[1].dims[ht]);
                    const dt = lt.pads.slice();
                    _.PoolConvUtil.adjustPadsBasedOnAutoPad(ct[0].dims, lt.strides, lt.dilations, ut, dt, lt.autoPad);
                    const ft = Object.assign({}, lt);
                    return Object.assign(ft, {
                        kernelShape: ut,
                        pads: dt,
                        cacheKey: lt.cacheKey
                    }),
                    ft
                }
                ;
                i.parseConvAttributes = lt => {
                    const ct = lt.attributes
                      , ut = (0,
                    nt.parseInternalActivationAttributes)(ct)
                      , dt = ct.getString("auto_pad", "NOTSET")
                      , ft = ct.getInts("dilations", [1, 1])
                      , ht = ct.getInt("group", 1)
                      , pt = ct.getInts("kernel_shape", [])
                      , gt = ct.getInts("pads", [0, 0, 0, 0])
                      , _t = ct.getInts("strides", [1, 1]);
                    return (0,
                    a.createAttributeWithCacheKey)(Object.assign({
                        autoPad: dt,
                        dilations: ft,
                        group: ht,
                        kernelShape: pt,
                        pads: gt,
                        strides: _t
                    }, ut))
                }
                ;
                const at = (lt, ct) => {
                    if (!lt || lt.length !== 2 && lt.length !== 3)
                        throw new Error("Conv requires 2 or 3 inputs");
                    if (lt[0].dims.length !== 4 || lt[1].dims.length !== 4)
                        throw new Error("currently only support 2-dimensional conv");
                    if (lt[0].dims[1] !== lt[1].dims[1] * ct.group)
                        throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
                    if (lt.length === 3 && (lt[2].dims.length !== 1 || lt[1].dims[0] !== lt[2].dims[0]))
                        throw new Error("invalid bias");
                    const ut = lt[0].dims.length - 2;
                    if (ct.dilations.length !== ut)
                        throw new Error(`dilations should be ${ut}D`);
                    if (ct.strides.length !== ut)
                        throw new Error(`strides should be ${ut}D`);
                    if (ct.pads.length !== 2 * ut)
                        throw new Error(`pads should be ${2 * ut}D`);
                    if (ct.kernelShape.length !== 0 && ct.kernelShape.length !== lt[1].dims.length - 2)
                        throw new Error("invalid kernel shape");
                    if (lt[0].type !== "float32" || lt[1].type !== "float32")
                        throw new Error("Conv input(X,W) should be float tensor");
                    if (lt.length === 3 && lt[2].type !== "float32")
                        throw new Error("Conv input(bias) should be float tensor")
                }
            }
            ,
            6742: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.parseDepthToSpaceAttributes = i.depthToSpace = void 0;
                const a = s(5707);
                i.depthToSpace = ($, _e, tt) => {
                    _(_e);
                    const nt = tt.blocksize
                      , rt = nt * nt
                      , ot = tt.mode === "DCR" ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3]
                      , et = tt.mode === "DCR" ? [_e[0].dims[0], nt, nt, _e[0].dims[1] / rt, _e[0].dims[2], _e[0].dims[3]] : [_e[0].dims[0], _e[0].dims[1] / rt, nt, nt, _e[0].dims[2], _e[0].dims[3]]
                      , j = $.reshapeUnpacked(_e[0], et)
                      , it = {
                        perm: ot,
                        cacheKey: `${ot}`
                    }
                      , [st] = (0,
                    a.transpose)($, [j], it)
                      , at = [_e[0].dims[0], _e[0].dims[1] / rt, _e[0].dims[2] * nt, _e[0].dims[3] * nt];
                    return [$.reshapeUnpacked(st, at)]
                }
                ,
                i.parseDepthToSpaceAttributes = $ => {
                    const _e = $.attributes.getInt("blocksize");
                    if (_e < 1)
                        throw new Error(`blocksize must be >= 1, but got : ${_e} for DepthToSpace`);
                    const tt = $.attributes.getString("mode", "DCR");
                    if (tt !== "DCR" && tt !== "CRD")
                        throw new Error(`unrecognized mode: ${tt} for DepthToSpace`);
                    return {
                        mode: tt,
                        blocksize: _e
                    }
                }
                ;
                const _ = $ => {
                    if ($.length !== 1)
                        throw new Error(`DepthToSpace expect 1 inputs, but got ${$.length}`);
                    if ($[0].type === "string" || $[0].dims.length !== 4)
                        throw new TypeError("DepthToSpace input should be a 4-D numeric tensor")
                }
            }
            ,
            3281: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.createDotProductProgramInfoLoader = void 0;
                const a = s(7273)
                  , _ = s(6757)
                  , $ = s(5639)
                  , _e = s(2150)
                  , tt = s(1625);
                i.createDotProductProgramInfoLoader = (nt, rt, ot, et) => {
                    const j = ( (it, st) => ({
                        name: "ConvDotProduct",
                        inputNames: it ? ["Im2Col", "K", "B"] : ["Im2Col", "K"],
                        inputTypes: it ? [$.TextureType.unpacked, $.TextureType.packedLastDimension, $.TextureType.unpacked] : [$.TextureType.unpacked, $.TextureType.packedLastDimension],
                        cacheKey: st.activationCacheKey
                    }))(rt.length > 2, et);
                    return Object.assign(Object.assign({}, j), {
                        get: () => ( (it, st, at, lt, ct) => {
                            const ut = at[0].dims
                              , dt = at[1].dims
                              , ft = [dt[0], Math.ceil(ut[1] * dt[2] * dt[3] / 4)]
                              , ht = (0,
                            tt.calculateIm2ColDims)(ut, dt, lt)
                              , [pt,gt] = it.calculateTextureWidthAndHeight(ft, $.TextureType.packedLastDimension)
                              , _t = a.ShapeUtil.computeStrides(ht)
                              , [mt,yt] = it.calculateTextureWidthAndHeight(ht, $.TextureType.packedLastDimension)
                              , bt = lt.length
                              , vt = at.length < 3 ? "0.0" : "_B(b)"
                              , wt = Math.ceil(ut[1] * dt[2] * dt[3] / 4)
                              , {activationFunction: Tt, applyActivation: $t} = (0,
                            _e.getActivationSnippet)(ct)
                              , Et = (0,
                            _.getGlsl)(it.session.backend.glContext.version)
                              , Pt = `
${Tt}
float process(int indices[${bt}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${_t[0]} + im2col[1] * ${_t[1]} + im2col[2] * ${_t[2]};
  int kernelOffset = indices[1] * ${ft[1]};
  float value = ${vt};
  for (int i = 0; i < ${wt}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${mt}, ${yt});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${pt}, ${gt});
    value += dot(${Et.texture2D}(Im2Col, im2colCoords), ${Et.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${$t}
  return value;
}`;
                            return Object.assign(Object.assign({}, st), {
                                output: {
                                    dims: lt,
                                    type: at[0].type,
                                    textureType: $.TextureType.unpacked
                                },
                                shaderSource: Pt
                            })
                        }
                        )(nt, j, rt, ot, et)
                    })
                }
            }
            ,
            4125: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.parseFlattenAttributes = i.flatten = void 0;
                const a = s(7273);
                i.flatten = ($, _e, tt) => {
                    _(_e, tt);
                    const nt = a.ShapeUtil.flattenShape(_e[0].dims, tt);
                    return [$.reshapeUnpacked(_e[0], nt)]
                }
                ,
                i.parseFlattenAttributes = $ => $.attributes.getInt("axis", 1);
                const _ = ($, _e) => {
                    if (!$ || $.length !== 1)
                        throw new Error("Flatten requires 1 input.");
                    const tt = $[0].dims.length;
                    if (tt === 0)
                        throw new Error("scalar tensor is not supported.");
                    if (_e < -tt || _e > tt)
                        throw new Error("Invalid axis");
                    if ($[0].type === "string")
                        throw new Error("string tensor is not supported.")
                }
            }
            ,
            2150: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.parseInternalActivationAttributes = i.getActivationSnippet = void 0;
                const a = s(7273)
                  , _ = s(9087);
                i.getActivationSnippet = function($) {
                    let _e;
                    switch ($.activation) {
                    case "Relu":
                        _e = (0,
                        _.glslRelu)();
                        break;
                    case "Sigmoid":
                        _e = (0,
                        _.glslSigmoid)();
                        break;
                    case "Clip":
                        _e = (0,
                        _.glslClip)($.clipMin, $.clipMax);
                        break;
                    default:
                        return {
                            activationFunction: "",
                            applyActivation: ""
                        }
                    }
                    const tt = _e.name;
                    return {
                        activationFunction: _e.body,
                        applyActivation: `value = ${tt}_(value);`
                    }
                }
                ,
                i.parseInternalActivationAttributes = $ => {
                    const _e = $.getString("activation", "");
                    if (_e === "Clip") {
                        const [tt,nt] = $.getFloats("activation_params", [a.MIN_CLIP, a.MAX_CLIP]);
                        return {
                            activation: _e,
                            clipMax: nt,
                            clipMin: tt,
                            activationCacheKey: `${_e}:${tt},${nt}`
                        }
                    }
                    return {
                        activation: _e,
                        activationCacheKey: _e
                    }
                }
            }
            ,
            6149: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.parseGatherAttributes = i.gather = void 0;
                const a = s(4910)
                  , _ = s(6145)
                  , $ = s(7273)
                  , _e = s(5639);
                i.gather = (ot, et, j) => (rt(et, j.axis),
                [ot.run(nt(ot, et, j), et)]),
                i.parseGatherAttributes = ot => (0,
                a.createAttributeWithCacheKey)({
                    axis: ot.attributes.getInt("axis", 0)
                });
                const tt = {
                    name: "Gather",
                    inputNames: ["A", "B"],
                    inputTypes: [_e.TextureType.unpacked, _e.TextureType.unpacked]
                }
                  , nt = (ot, et, j) => {
                    const it = Object.assign(Object.assign({}, tt), {
                        cacheHint: j.cacheKey
                    });
                    return Object.assign(Object.assign({}, it), {
                        get: () => ( (st, at, lt, ct) => {
                            const ut = lt[0].dims.slice()
                              , dt = lt[1].dims.slice()
                              , ft = new Array(ut.length + dt.length - 1);
                            ct = $.ShapeUtil.normalizeAxis(ct, ut.length);
                            const ht = [];
                            for (let gt = 0; gt < ft.length; gt++)
                                gt < ct ? (ft[gt] = ut[gt],
                                ht.push(`inputIdx[${gt}] = outputIdx[${gt}];`)) : gt < ct + dt.length ? (ft[gt] = dt[gt - ct],
                                ht.push(`indexDataIdx[${gt - ct}] = outputIdx[${gt}];`)) : (ft[gt] = ut[gt - dt.length + 1],
                                ht.push(`inputIdx[${gt - dt.length + 1}] = outputIdx[${gt}];`));
                            const pt = `
      float process(int outputIdx[${ft.length || 1}]) {
        int inputIdx[${ut.length}];
        int indexDataIdx[${dt.length || 1}];
        indexDataIdx[0] = 0;
        ${ht.join(`
        `)}
        int idx = int(_B(indexDataIdx));
        inputIdx[${ct}] = idx < 0 ? idx + ${ut[ct]} : idx;
        return _A(inputIdx);
      }`;
                            return Object.assign(Object.assign({}, at), {
                                output: {
                                    dims: ft,
                                    type: lt[0].type,
                                    textureType: _e.TextureType.unpacked
                                },
                                shaderSource: pt
                            })
                        }
                        )(0, it, et, j.axis)
                    })
                }
                  , rt = (ot, et) => {
                    if (!ot || ot.length !== 2)
                        throw new Error("Gather requires 2 inputs.");
                    const j = ot[0].dims.length;
                    if (j < 1)
                        throw new Error("Invalid input shape.");
                    if (et < -j || et > j - 1)
                        throw new Error("Invalid axis.");
                    if (_.NUMBER_TYPES.indexOf(ot[0].type) === -1)
                        throw new Error("Invaid input type.");
                    if (ot[1].type !== "int32" && ot[1].type !== "int16")
                        throw new Error("Invaid input type.")
                }
            }
            ,
            5378: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.parseGemmAttributesV11 = i.parseGemmAttributesV7 = i.gemm = void 0;
                const a = s(4910)
                  , _ = s(7273)
                  , $ = s(5639);
                i.gemm = (ot, et, j) => (rt(et, j),
                [ot.run(tt(et, j), et)]);
                const _e = (ot, et) => {
                    const j = ot.attributes.getInt("transA", 0) !== 0
                      , it = ot.attributes.getInt("transB", 0) !== 0
                      , st = ot.attributes.getFloat("alpha", 1)
                      , at = ot.attributes.getFloat("beta", 1);
                    return (0,
                    a.createAttributeWithCacheKey)({
                        transA: j,
                        transB: it,
                        alpha: st,
                        beta: at,
                        isOptionalC: et
                    })
                }
                ;
                i.parseGemmAttributesV7 = ot => _e(ot, !1),
                i.parseGemmAttributesV11 = ot => _e(ot, !0);
                const tt = (ot, et) => {
                    const j = {
                        name: "Gemm",
                        inputNames: ot.length === 3 ? ["A", "B", "C"] : ["A", "B"],
                        inputTypes: ot.length === 3 ? [$.TextureType.unpacked, $.TextureType.unpacked, $.TextureType.unpacked] : [$.TextureType.unpacked, $.TextureType.unpacked],
                        key: et.cacheKey
                    };
                    return Object.assign(Object.assign({}, j), {
                        get: () => nt(j, ot, et)
                    })
                }
                  , nt = (ot, et, j) => {
                    const it = et[0].dims.slice()
                      , st = et[1].dims.slice()
                      , [at,lt] = _.GemmUtil.getShapeOfGemmResult(it, j.transA, st, j.transB, et.length === 3 ? et[2].dims : void 0)
                      , ct = [at, lt];
                    if (!ct)
                        throw new Error("Can't use gemm on the given tensors");
                    let ut = it[it.length - 1]
                      , dt = "";
                    j.transA && (ut = it[0]),
                    j.transA && j.transB ? dt = "value += _A_T(a) * _B_T(b);" : j.transA && !j.transB ? dt = "value += _A_T(a) * _B(b);" : !j.transA && j.transB ? dt = "value += _A(a) * _B_T(b);" : j.transA || j.transB || (dt = "value += _A(a) * _B(b);");
                    const ft = ct.length
                      , ht = `
      float process(int indices[${ft}]) {
          int a[${ft}];
          int b[${ft}];
          ${et.length === 3 ? `int c[${et[2].dims.length}];` : ""}

          copyVec(indices, a);
          copyVec(indices, b);
          ${et.length === 3 ? "bcastIndices_C(indices, c);" : ""}

          float value = 0.0;
          for (int k=0; k<${ut}; ++k) {
              a[${ft - 1}] = k;
              b[${ft - 2}] = k;
              ${dt}
          }

          value = value * alpha;
          ${et.length === 3 ? "value += beta * _C(c);" : ""}
          return value;
      }`;
                    return Object.assign(Object.assign({}, ot), {
                        output: {
                            dims: ct,
                            type: et[0].type,
                            textureType: $.TextureType.unpacked
                        },
                        variables: [{
                            name: "alpha",
                            type: "float",
                            data: j.alpha
                        }, {
                            name: "beta",
                            type: "float",
                            data: j.beta
                        }],
                        shaderSource: ht
                    })
                }
                  , rt = (ot, et) => {
                    if (!ot)
                        throw new Error("Input is missing");
                    if (et.isOptionalC && (ot.length < 2 || ot.length > 3))
                        throw new Error("Invaid input shape.");
                    if (!et.isOptionalC && ot.length !== 3)
                        throw new Error("Gemm requires 3 inputs");
                    if (ot.length === 3 && ot[2].dims.length !== 1 && ot[2].dims.length !== 2)
                        throw new Error("Invalid input shape of C");
                    if (ot[0].type !== "float32" && ot[0].type !== "float64" || ot[1].type !== "float32" && ot[1].type !== "float64" || ot.length === 3 && ot[2].type !== "float32" && ot[2].type !== "float64")
                        throw new Error("Invalid input type.");
                    if (ot[0].type !== ot[1].type || ot.length === 3 && ot[0].type !== ot[2].type)
                        throw new Error("Input types are mismatched")
                }
            }
            ,
            5950: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.createPackedIm2ColProgramInfoLoader = void 0;
                const a = s(6757)
                  , _ = s(5639)
                  , $ = s(5614);
                i.createPackedIm2ColProgramInfoLoader = (_e, tt, nt, rt, ot) => {
                    const et = (j = ot.cacheKey,
                    {
                        name: "Im2Col (packed)",
                        inputNames: ["A"],
                        inputTypes: [_.TextureType.packed],
                        cacheHint: j
                    });
                    var j;
                    return Object.assign(Object.assign({}, et), {
                        get: () => ( (it, st, at, lt, ct, ut) => {
                            const dt = at.dims
                              , ft = lt.dims
                              , ht = ct.length
                              , pt = [ft[1] * ft[2] * ft[3], ct[2] * ct[3]]
                              , gt = ft[2] * ft[3]
                              , _t = (0,
                            $.unpackFromChannel)()
                              , mt = (0,
                            a.getGlsl)(it.session.backend.glContext.version);
                            let yt = "";
                            for (let vt = 0; vt <= 1; vt++)
                                for (let wt = 0; wt <= 1; wt++)
                                    yt += `
            blockIndex = rc.x + ${wt};
            pos = rc.y + ${vt};

            if(blockIndex < ${pt[1]} && pos < ${pt[0]}) {
              offsetY = int(blockIndex / (${ct[ht - 1]})) * ${ut.strides[0]} -
                ${ut.pads[0]};
              d0 = offsetY + ${ut.dilations[0]} * (imod(pos, ${gt}) / ${ft[2]});

              if(d0 < ${dt[2]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${ct[ht - 1]}) * ${ut.strides[1]} -
                  ${ut.pads[1]};
                d1 = offsetX + ${ut.dilations[1]} * imod(imod(pos, ${gt}), ${ft[2]});

                if(d1 < ${dt[3]} && d1 >= 0) {

                  ch = int(float(pos)/ ${gt}.);
                    innerDims = vec2(d0, d1);
                    result[${2 * vt + wt}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;
                            const bt = `
      ${_t}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${yt}
          ${mt.output} = result;
      }
            `;
                            return Object.assign(Object.assign({}, st), {
                                output: {
                                    dims: pt,
                                    type: at.type,
                                    textureType: _.TextureType.packed
                                },
                                shaderSource: bt,
                                hasMain: !0
                            })
                        }
                        )(_e, et, tt, nt, rt, ot)
                    })
                }
            }
            ,
            1625: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.calculateIm2ColDims = i.createIm2ColProgramInfoLoader = void 0;
                const a = s(5639);
                i.createIm2ColProgramInfoLoader = (_, $, _e, tt, nt) => {
                    const rt = (ot = nt.cacheKey,
                    {
                        name: "Im2Col",
                        inputNames: ["X"],
                        inputTypes: [a.TextureType.unpacked],
                        cacheHint: ot
                    });
                    var ot;
                    return Object.assign(Object.assign({}, rt), {
                        get: () => ( (et, j, it, st, at, lt) => {
                            const ct = it.dims
                              , ut = st.dims
                              , dt = at.length
                              , ft = (0,
                            i.calculateIm2ColDims)(ct, ut, at, 4)
                              , ht = `
        const int XC = ${ct[1]};
        const int XH = ${ct[2]};
        const int XW = ${ct[3]};
        const int KH = ${lt.kernelShape[0]};
        const int KW = ${lt.kernelShape[1]};
        const int dilationH = ${lt.dilations[0]};
        const int dilationW = ${lt.dilations[1]};
        const int strideH = ${lt.strides[0]};
        const int strideW = ${lt.strides[1]};
        const int padH = ${lt.pads[0]};
        const int padW = ${lt.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${dt}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${ct.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;
                            return Object.assign(Object.assign({}, j), {
                                output: {
                                    dims: ft,
                                    type: it.type,
                                    textureType: a.TextureType.packedLastDimension
                                },
                                shaderSource: ht
                            })
                        }
                        )(0, rt, $, _e, tt, nt)
                    })
                }
                ,
                i.calculateIm2ColDims = (_, $, _e, tt=4) => [_e[0], _e[2], _e[3], Math.ceil(_[1] * $[2] * $[3] / tt)]
            }
            ,
            6981: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.parseImageScalerAttributes = i.imageScaler = void 0;
                const a = s(4910)
                  , _ = s(5639);
                i.imageScaler = (rt, ot, et) => (nt(ot),
                [rt.run(_e(rt, ot, et), ot)]),
                i.parseImageScalerAttributes = rt => {
                    const ot = rt.attributes.getFloat("scale")
                      , et = rt.attributes.getFloats("bias");
                    return (0,
                    a.createAttributeWithCacheKey)({
                        scale: ot,
                        bias: et
                    })
                }
                ;
                const $ = {
                    name: "ImageScaler",
                    inputNames: ["X"],
                    inputTypes: [_.TextureType.unpacked]
                }
                  , _e = (rt, ot, et) => {
                    const j = Object.assign(Object.assign({}, $), {
                        cacheHint: et.cacheKey
                    });
                    return Object.assign(Object.assign({}, j), {
                        get: () => ( (it, st, at, lt) => {
                            const ct = at[0].dims.slice()
                              , ut = ct.length
                              , dt = `
      ${tt(lt.bias.length)}
      float process(int indices[${ut}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;
                            return Object.assign(Object.assign({}, st), {
                                output: {
                                    dims: ct,
                                    type: at[0].type,
                                    textureType: _.TextureType.unpacked
                                },
                                variables: [{
                                    name: "bias",
                                    type: "float",
                                    arrayLength: lt.bias.length,
                                    data: lt.bias
                                }, {
                                    name: "scale",
                                    type: "float",
                                    data: lt.scale
                                }],
                                shaderSource: dt
                            })
                        }
                        )(0, j, ot, et)
                    })
                }
                  , tt = rt => {
                    const ot = [`float getBias(float bias[${rt}], int channel) {`];
                    for (let et = 0; et < rt; ++et)
                        et === 0 ? ot.push(`	if (channel == ${et}) { return bias[${et}]; }`) : et === rt - 1 ? ot.push(`	else { return bias[${et}]; }`) : ot.push(`	else if (channel == ${et}) { return bias[${et}]; }`);
                    return ot.push("	}"),
                    ot.join(`
`)
                }
                  , nt = rt => {
                    if (!rt || rt.length !== 1)
                        throw new Error("ImageScaler requires 1 input.");
                    if (rt[0].dims.length !== 4)
                        throw new Error("Invalid input shape.");
                    if (rt[0].type !== "float32" && rt[0].type !== "float64")
                        throw new Error("Invalid input type.")
                }
            }
            ,
            7413: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.parseInstanceNormalizationAttributes = i.instanceNormalization = void 0;
                const a = s(6757)
                  , _ = s(5639);
                i.instanceNormalization = (ot, et, j) => {
                    rt(et);
                    const it = ot.run(_e(et[0]), et);
                    return [ot.run(nt(ot, et[0], j, it.dims), [et[0], it, et[1], et[2]])]
                }
                ,
                i.parseInstanceNormalizationAttributes = ot => ot.attributes.getFloat("epsilon", 1e-5);
                const $ = {
                    name: "InstanceNormalization_MeanAndVariance",
                    inputNames: ["X"],
                    inputTypes: [_.TextureType.unpacked]
                }
                  , _e = ot => Object.assign(Object.assign({}, $), {
                    get: () => ( (et, j) => {
                        const it = j.dims.slice()
                          , st = it[1]
                          , at = it[2] * it[3]
                          , lt = [it[0], st]
                          , ct = `
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${it[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${it[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${at});
        temp = 0.0;
        for(int a2=0; a2<${it[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${it[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${at});

        return v;
      }`;
                        return Object.assign(Object.assign({}, et), {
                            output: {
                                dims: lt,
                                type: j.type,
                                textureType: _.TextureType.packedLastDimension
                            },
                            shaderSource: ct
                        })
                    }
                    )($, ot)
                })
                  , tt = {
                    name: "InstanceNormalization_ComputeOutput",
                    inputNames: ["X", "MeanAndVariance", "Scale", "B"],
                    inputTypes: [_.TextureType.unpacked, _.TextureType.packedLastDimension, _.TextureType.unpacked, _.TextureType.unpacked]
                }
                  , nt = (ot, et, j, it) => {
                    const st = Object.assign(Object.assign({}, tt), {
                        cacheHint: `${j}`
                    });
                    return Object.assign(Object.assign({}, st), {
                        get: () => ( (at, lt, ct, ut, dt) => {
                            const ft = (0,
                            a.getGlsl)(at.session.backend.glContext.version)
                              , [ht,pt] = at.calculateTextureWidthAndHeight(dt, _.TextureType.packedLastDimension)
                              , [gt,_t] = [ht / 4, pt]
                              , mt = `
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${gt}, ${_t});
        return ${ft.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;
                            return Object.assign(Object.assign({}, lt), {
                                output: {
                                    dims: ct.dims,
                                    type: ct.type,
                                    textureType: _.TextureType.unpacked
                                },
                                variables: [{
                                    name: "epsilon",
                                    type: "float",
                                    data: ut
                                }],
                                shaderSource: mt
                            })
                        }
                        )(ot, st, et, j, it)
                    })
                }
                  , rt = ot => {
                    if (!ot || ot.length !== 3)
                        throw new Error("InstanceNormalization requires 3 inputs.");
                    const et = ot[0]
                      , j = ot[1]
                      , it = ot[2];
                    if (et.dims.length < 3 || j.dims.length !== 1 || it.dims.length !== 1)
                        throw new Error("Invalid input shape.");
                    if (j.dims[0] !== et.dims[1] || it.dims[0] !== et.dims[1])
                        throw new Error("Input shapes are mismatched.");
                    if (et.type !== "float32" && et.type !== "float64" || j.type !== "float32" && j.type !== "float64" || it.type !== "float32" && it.type !== "float64")
                        throw new Error("Invalid input type.");
                    if (ot[0].dims.length !== 4)
                        throw new Error("Only support 4-D input shape.")
                }
            }
            ,
            7006: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.createLrnProgramInfoLoader = i.parseLrnAttributes = i.lrn = void 0;
                const a = s(4910)
                  , _ = s(5639);
                i.lrn = (nt, rt, ot) => (tt(rt),
                [nt.run(_e(rt, ot), rt)]),
                i.parseLrnAttributes = nt => {
                    const rt = nt.attributes.getFloat("alpha", 1e-4)
                      , ot = nt.attributes.getFloat("beta", .75)
                      , et = nt.attributes.getFloat("bias", 1)
                      , j = nt.attributes.getInt("size");
                    return (0,
                    a.createAttributeWithCacheKey)({
                        alpha: rt,
                        beta: ot,
                        bias: et,
                        size: j
                    })
                }
                ;
                const $ = {
                    name: "LRN",
                    inputNames: ["X"],
                    inputTypes: [_.TextureType.unpacked]
                };
                function _e(nt, rt) {
                    return Object.assign(Object.assign({}, $), {
                        cacheHint: rt.cacheKey,
                        get: () => function(ot, et) {
                            const j = ot[0].dims[1]
                              , it = ot[0].dims.length
                              , st = -Math.floor((et.size - 1) / 2)
                              , at = Math.ceil((et.size - 1) / 2)
                              , lt = `float(${et.alpha}) / float(${et.size})`
                              , ct = `
    float process(int indices[${it}]) {
        int c = indices[1];
        float x = _X(indices);
        float square_sum = 0.0;

        for (int i = ${st}; i <= ${at}; i++) {
          int idx = c + i;
          if (c >= 0 && c < ${j}) {
            indices[1] = idx;
            float j = _X(indices);
            square_sum += j * j;
          }
        }
        return x / pow(float(${et.bias}) + ${lt} * square_sum, float(${et.beta}));
    }`;
                            return Object.assign(Object.assign({}, $), {
                                cacheHint: et.cacheKey,
                                output: {
                                    dims: ot[0].dims,
                                    type: ot[0].type,
                                    textureType: _.TextureType.unpacked
                                },
                                shaderSource: ct
                            })
                        }(nt, rt)
                    })
                }
                i.createLrnProgramInfoLoader = _e;
                const tt = nt => {
                    if (!nt || nt.length !== 1)
                        throw new Error("LRN requires 1 input.");
                    if (nt[0].dims.length !== 4)
                        throw new Error('currently only support LRN for input with "NCHW" format');
                    if (nt[0].type !== "float32")
                        throw new Error("input should be float type")
                }
            }
            ,
            5632: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.createPackedMatmulProgramInfoLoader = void 0;
                const a = s(7273)
                  , _ = s(6757)
                  , $ = s(5639)
                  , _e = s(432)
                  , tt = s(2150)
                  , nt = s(8276);
                i.createPackedMatmulProgramInfoLoader = (rt, ot, et) => {
                    const j = (it = ot.length > 2,
                    st = et.activationCacheKey,
                    {
                        name: "MatMul (packed)",
                        inputNames: it ? ["A", "B", "Bias"] : ["A", "B"],
                        inputTypes: it ? [$.TextureType.packed, $.TextureType.packed, $.TextureType.packed] : [$.TextureType.packed, $.TextureType.packed],
                        cacheHint: st
                    });
                    var it, st;
                    return Object.assign(Object.assign({}, j), {
                        get: () => ( (at, lt, ct, ut) => {
                            const dt = ct.length > 2
                              , ft = dt ? "value += getBiasForMatmul();" : ""
                              , ht = ct[0].dims
                              , pt = ct[1].dims
                              , gt = a.BroadcastUtil.calcShape(ht, pt, !0)
                              , _t = !a.ShapeUtil.areEqual(ct[0].dims, ct[1].dims);
                            if (!gt)
                                throw new Error("Can't use matmul on the given tensors");
                            const mt = ht[ht.length - 1]
                              , yt = Math.ceil(mt / 2)
                              , bt = ht.length
                              , vt = pt.length
                              , wt = (0,
                            _.getGlsl)(at.session.backend.glContext.version)
                              , Tt = (0,
                            _e.getCoordsDataType)(gt.length)
                              , $t = gt.length
                              , Et = (0,
                            _e.getGlChannels)()
                              , {activationFunction: Pt, applyActivation: Rt} = (0,
                            tt.getActivationSnippet)(ut)
                              , At = dt ? `${(0,
                            nt.getBiasForMatmul)(Tt, Et, ct[2].dims, gt, !0)}` : ""
                              , Mt = _t ? `${function(Vt, Nt, Yt, Xt) {
                                letjt = []
                                  , Gt = [];
                                const Kt = Yt[0].dims
                                  , qt = Yt[1].dims
                                  , rn = Kt.length
                                  , on = qt.length
                                  , _n = Xt.length
                                  , mn = _n - rn
                                  , Sn = _n - on;
                                jt = Kt.map( (gn, dn) => `coords.${Nt[dn + mn]}`),
                                jt[rn - 1] = "i*2",
                                jt.join(", "),
                                Gt = qt.map( (gn, dn) => `coords.${Nt[dn + Sn]}`),
                                Gt[on - 2] = "i*2",
                                Gt.join(", ");
                                const bn = a.BroadcastUtil.getBroadcastDims(Kt, Xt)
                                  , In = a.BroadcastUtil.getBroadcastDims(qt, Xt)
                                  , Nn = bn.map(gn => `coords.${Nt[gn + mn]} = 0;`).join(`
`)
                                  , cn = In.map(gn => `coords.${Nt[gn + Sn]} = 0;`).join(`
`)
                                  , $n = `int lastDim = coords.${Nt[_n - 1]};
  coords.${Nt[_n - 1]} = coords.${Nt[_n - 2]};
  coords.${Nt[_n - 2]} = lastDim;`;
                                return `
vec4 getAAtOutCoordsMatmul(int i) {
  ${Vt} coords = getOutputCoords();
  ${$n}
  ${Nn}
  vec4 outputValue = getA(${jt});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${Vt} coords = getOutputCoords();
  ${$n}
  ${cn}
  vec4 outputValue = getB(${Gt});
  return outputValue;
}`
                            }(Tt, Et, ct, gt)}` : ""
                              , Ut = _t ? "getAAtOutCoordsMatmul(i)" : `getA(${function(Vt, Nt) {
                                letYt = "";
                                for (letXt = 0; Xt < Nt - 2; Xt++)
                                    Yt += `rc.${Vt[Xt]}, `;
                                return Yt += `rc.${Vt[Nt - 2]}, i*2`,
                                Yt
                            }(Et, bt)})`
                              , Lt = _t ? "getBAtOutCoordsMatmul(i)" : `getB(${function(Vt, Nt) {
                                letYt = "";
                                for (letXt = 0; Xt < Nt - 2; Xt++)
                                    Yt += `rc.${Vt[Xt]}, `;
                                return Yt += `i*2, rc.${Vt[Nt - 1]}`,
                                Yt
                            }(Et, vt)})`
                              , tn = `
            ${Mt}
            ${At}
            ${Pt}
            void main() {
              ${_t ? "" : `${Tt} rc =
          getOutputCoords(); int lastDim = rc.${Et[$t - 1]}; rc.${Et[$t - 1]} =
          rc.${Et[$t - 2]}; rc.${Et[$t - 2]} = lastDim;
      `}

              vec4 value = vec4(0);
              for (int i = 0; i < ${yt}; i++) {
                vec4 a = ${Ut};
                vec4 b = ${Lt};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${ft}
              ${Rt}
              ${wt.output} = value;
            }`;
                            return Object.assign(Object.assign({}, lt), {
                                output: {
                                    dims: gt,
                                    type: ct[0].type,
                                    textureType: $.TextureType.packed
                                },
                                shaderSource: tn,
                                hasMain: !0
                            })
                        }
                        )(rt, j, ot, et)
                    })
                }
            }
            ,
            8276: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.getBiasForMatmul = i.createMatmulProgramInfoLoader = i.parseMatMulAttributes = i.matMul = void 0;
                const a = s(7273)
                  , _ = s(5639)
                  , $ = s(432)
                  , _e = s(2150)
                  , tt = s(5632);
                i.matMul = (j, it, st) => (ot(it),
                j.session.pack ? [j.run((0,
                tt.createPackedMatmulProgramInfoLoader)(j, it, st), it)] : [j.run(rt(it, st), it)]),
                i.parseMatMulAttributes = j => (0,
                _e.parseInternalActivationAttributes)(j.attributes);
                const nt = (j, it) => ({
                    name: "MatMul",
                    inputNames: j ? ["A", "B", "Bias"] : ["A", "B"],
                    inputTypes: j ? [_.TextureType.unpacked, _.TextureType.unpacked, _.TextureType.unpacked] : [_.TextureType.unpacked, _.TextureType.unpacked],
                    cacheHint: it
                });
                function rt(j, it) {
                    const st = nt(j.length > 2, it.activationCacheKey);
                    return Object.assign(Object.assign({}, st), {
                        get: () => function(at, lt, ct) {
                            const ut = lt[0].dims
                              , dt = lt[1].dims
                              , ft = a.BroadcastUtil.calcShape(ut, dt, !0);
                            if (!ft)
                                throw new Error("Can't use matmul on the given tensors");
                            const ht = (0,
                            $.getCoordsDataType)(ft.length)
                              , pt = (0,
                            $.getGlChannels)()
                              , {activationFunction: gt, applyActivation: _t} = (0,
                            _e.getActivationSnippet)(ct)
                              , mt = lt.length > 2
                              , yt = mt ? "value += getBiasForMatmul();" : ""
                              , bt = mt ? `${et(ht, pt, lt[2].dims, ft, !1)}` : ""
                              , vt = ft.length
                              , wt = ut.length
                              , Tt = dt.length
                              , $t = `
    ${gt}
    ${bt}
    float process(int indices[${vt}]) {
        int a[${wt}];
        int b[${Tt}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${ut[ut.length - 1]}; ++k) {
            a[${wt - 1}] = k;
            b[${Tt - 2}] = k;
            value += _A(a) * _B(b);
        }
        ${yt}
        ${_t}
        return value;
    }`;
                            return Object.assign(Object.assign({}, at), {
                                output: {
                                    dims: ft,
                                    type: lt[0].type,
                                    textureType: _.TextureType.unpacked
                                },
                                shaderSource: $t
                            })
                        }(st, j, it)
                    })
                }
                i.createMatmulProgramInfoLoader = rt;
                const ot = j => {
                    if (!j || j.length !== 2)
                        throw new Error("MatMul requires 2 inputs.");
                    if (j[0].dims[j[0].dims.length - 1] !== j[1].dims[j[1].dims.length - 2])
                        throw new Error("shared dimension does not match.");
                    if (j[0].type !== "float32" && j[0].type !== "float64" || j[1].type !== "float32" && j[1].type !== "float64")
                        throw new Error("inputs should be float type");
                    if (j[0].type !== j[1].type)
                        throw new Error("inputs types should match")
                }
                ;
                function et(j, it, st, at, lt) {
                    let ct = "";
                    const ut = st.length
                      , dt = at.length
                      , ft = dt - ut;
                    ct = dt < 2 && ut > 0 ? "coords" : st.map( (gt, _t) => `coords.${it[_t + ft]}`).join(", ");
                    const ht = a.BroadcastUtil.getBroadcastDims(st, at).map(gt => `coords.${it[gt + ft]} = 0;`).join(`
`);
                    let pt = "vec4(outputValue.xx, outputValue.yy)";
                    return a.ShapeUtil.size(st) === 1 && (pt = "vec4(outputValue.x)"),
                    lt ? `
vec4 getBiasForMatmul() {
  ${j} coords = getOutputCoords();
  ${ht}
  vec4 outputValue = getBias(${ct});
  return ${pt};
}` : `
float getBiasForMatmul() {
  ${j} coords = getOutputCoords();
  ${ht}
  return getBias(coords.x);
}`
                }
                i.getBiasForMatmul = et
            }
            ,
            9: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.createPackProgramInfoLoader = void 0;
                const a = s(6757)
                  , _ = s(5639)
                  , $ = s(432)
                  , _e = s(5614)
                  , tt = {
                    name: "pack",
                    inputNames: ["A"],
                    inputTypes: [_.TextureType.unpackedReversed]
                };
                i.createPackProgramInfoLoader = (nt, rt) => Object.assign(Object.assign({}, tt), {
                    get: () => ( (ot, et) => {
                        const j = (0,
                        a.getGlsl)(ot.session.backend.glContext.version)
                          , it = et.dims
                          , st = it.length
                          , at = et.dims.length
                          , lt = (0,
                        $.getCoordsDataType)(at)
                          , ct = (0,
                        _e.getChannels)("rc", at)
                          , ut = (dt = at,
                        ft = ct,
                        ht = it[it.length - 2],
                        pt = it[it.length - 1],
                        dt === 0 || dt === 1 ? "" : `
    int r = ${ft[dt - 2]};
    int c = ${ft[dt - 1]};
    int rp1 = ${ft[dt - 2]} + 1;
    int cp1 = ${ft[dt - 1]} + 1;
    bool rEdge = rp1 >= ${pt};
    bool cEdge = cp1 >= ${ht};
    `);
                        var dt, ft, ht, pt;
                        let gt;
                        gt = st === 0 ? [1, 1] : st === 1 ? [it[0], 1] : [it[at - 1], it[at - 2]];
                        const _t = function(bt, vt, wt) {
                            if (bt === 0)
                                return "false";
                            if (bt === 1)
                                return `rc > ${vt[0]}`;
                            let Tt = "";
                            for (let $t = bt - 2; $t < bt; $t++)
                                Tt += `${wt[$t]} >= ${vt[$t - bt + 2]}`,
                                $t < bt - 1 && (Tt += "||");
                            return Tt
                        }(at, gt, ct)
                          , mt = function(bt, vt) {
                            const wt = bt.length;
                            if (wt === 0)
                                return "getA(), 0, 0, 0";
                            if (wt === 1)
                                return `getA(rc),
            rc + 1 >= ${bt[0]} ? 0. : getA(rc + 1),
            0, 0`;
                            let Tt = "";
                            if (wt > 2)
                                for (let $t = 0; $t < wt - 2; ++$t)
                                    Tt += `${vt[$t]},`;
                            return `getA(${Tt}r, c),
          rEdge ? 0. : getA(${Tt}rp1, c),
          cEdge ? 0. : getA(${Tt}r, cp1),
          rEdge || cEdge ? 0. : getA(${Tt}rp1, cp1)`
                        }(it, ct)
                          , yt = `
        void main() {
          ${lt} rc = getOutputCoords();

          if(${_t}) {
            ${j.output} = vec4(0);
          } else {
            ${ut}

            ${j.output} = vec4(${mt});
          }
        }
      `;
                        return Object.assign(Object.assign({}, tt), {
                            hasMain: !0,
                            output: {
                                dims: et.dims,
                                type: et.type,
                                textureType: _.TextureType.packed
                            },
                            shaderSource: yt
                        })
                    }
                    )(nt, rt)
                })
            }
            ,
            5614: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.unpackFromChannel = i.getChannels = i.getVecChannels = void 0;
                const a = s(432);
                function _($, _e) {
                    return (0,
                    a.getGlChannels)(_e).map(tt => `${$}.${tt}`)
                }
                i.getVecChannels = _,
                i.getChannels = function($, _e) {
                    return _e === 1 ? [$] : _($, _e)
                }
                ,
                i.unpackFromChannel = function() {
                    return `
    float getChannel(vec4 frag, int dim) {
      int modCoord = imod(dim, 2);
      return modCoord == 0 ? frag.r : frag.g;
    }

    float getChannel(vec4 frag, vec2 innerDims) {
      vec2 modCoord = mod(innerDims, 2.);
      return modCoord.x == 0. ?
        (modCoord.y == 0. ? frag.r : frag.g) :
        (modCoord.y == 0. ? frag.b : frag.a);
    }
  `
                }
            }
            ,
            5565: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.parsePadAttributesV11 = i.padV11 = i.parsePadAttributesV2 = i.padV2 = void 0;
                const a = s(4910)
                  , _ = s(7273)
                  , $ = s(6757)
                  , _e = s(5639)
                  , tt = {
                    name: "Pad",
                    inputNames: ["A"],
                    inputTypes: [_e.TextureType.unpacked]
                };
                i.padV2 = (lt, ct, ut) => (ot(ct),
                [lt.run(Object.assign(Object.assign({}, tt), {
                    cacheHint: ut.cacheKey,
                    get: () => rt(lt, ct[0], ut)
                }), ct)]),
                i.parsePadAttributesV2 = lt => {
                    const ct = lt.attributes.getString("mode", "constant")
                      , ut = lt.attributes.getFloat("value", 0)
                      , dt = lt.attributes.getInts("pads");
                    return (0,
                    a.createAttributeWithCacheKey)({
                        mode: ct,
                        value: ut,
                        pads: dt
                    })
                }
                ,
                i.padV11 = (lt, ct, ut) => {
                    et(ct);
                    const dt = nt(lt, ct, ut);
                    return (0,
                    i.padV2)(lt, [ct[0]], dt)
                }
                ,
                i.parsePadAttributesV11 = lt => lt.attributes.getString("mode", "constant");
                const nt = (lt, ct, ut) => {
                    if (!lt.session.isInitializer(ct[1].dataId) || ct.length >= 3 && !lt.session.isInitializer(ct[2].dataId))
                        throw new Error("dynamic pad attributes are not allowed");
                    const dt = Array.from(ct[1].integerData)
                      , ft = ct.length >= 3 ? ct[2].floatData[0] : 0;
                    return (0,
                    a.createAttributeWithCacheKey)({
                        mode: ut,
                        pads: dt,
                        value: ft
                    })
                }
                  , rt = (lt, ct, ut) => {
                    const dt = _.ShapeUtil.padShape(ct.dims.slice(), ut.pads)
                      , ft = dt.length
                      , ht = `
      ${j(lt, ct, ut)}
      float process(int[${ft}] indices) {
          return padA(indices);
      }`;
                    return {
                        name: "Pad",
                        inputNames: ["A"],
                        inputTypes: [_e.TextureType.unpacked],
                        output: {
                            dims: dt,
                            type: ct.type,
                            textureType: _e.TextureType.unpacked
                        },
                        shaderSource: ht
                    }
                }
                  , ot = lt => {
                    if (!lt || lt.length !== 1)
                        throw new Error("Pad requires 1 input");
                    if (lt[0].type !== "float32" && lt[0].type !== "float64")
                        throw new Error("Invalid input type.")
                }
                  , et = lt => {
                    if (!lt || lt.length !== 2 && lt.length !== 3)
                        throw new Error("Pad requires 2 or 3 inputs");
                    if (lt[1].type !== "int32")
                        throw new Error("Invalid input type.");
                    if (lt.length >= 3 && lt[2].type === "string")
                        throw new Error("Invalid input type.")
                }
                  , j = (lt, ct, ut) => {
                    const dt = (0,
                    $.getGlsl)(lt.session.backend.glContext.version)
                      , [ft,ht] = lt.calculateTextureWidthAndHeight(ct.dims, _e.TextureType.unpacked)
                      , pt = _.ShapeUtil.computeStrides(ct.dims);
                    switch (ut.mode) {
                    case "constant":
                        return it(dt, ct.dims, pt, ft, ht, ut.pads, ut.value);
                    case "reflect":
                        return st(dt, ct.dims, pt, ft, ht, ut.pads);
                    case "edge":
                        return at(dt, ct.dims, pt, ft, ht, ut.pads);
                    default:
                        throw new Error("Invalid mode")
                    }
                }
                  , it = (lt, ct, ut, dt, ft, ht, pt) => {
                    const gt = ct.length;
                    let _t = "";
                    for (let mt = gt - 1; mt >= 0; --mt)
                        _t += `
        k = m[${mt}] - ${ht[mt]};
        if (k < 0)  return constant;
        if (k >= ${ct[mt]}) return constant;
        offset += k * ${ut[mt]};
        `;
                    return `
      float padA(int m[${gt}]) {
        const float constant = float(${pt});
        int offset = 0;
        int k = 0;
        ${_t}
        vec2 coords = offsetToCoords(offset, ${dt}, ${ft});
        float value = getColorAsFloat(${lt.texture2D}(A, coords));
        return value;
      }
      `
                }
                  , st = (lt, ct, ut, dt, ft, ht) => {
                    const pt = ct.length;
                    let gt = "";
                    for (let _t = pt - 1; _t >= 0; --_t)
                        gt += `
        k = m[${_t}] - ${ht[_t]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2 * (ct[_t] - 1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${ct[_t]}) { k = _2n_1 - k; }
        }
        offset += k * ${ut[_t]};
        `;
                    return `
      float padA(int m[${pt}]) {
        int offset = 0;
        int k = 0;
        ${gt}
        vec2 coords = offsetToCoords(offset, ${dt}, ${ft});
        float value = getColorAsFloat(${lt.texture2D}(A, coords));
        return value;
      }
      `
                }
                  , at = (lt, ct, ut, dt, ft, ht) => {
                    const pt = ct.length;
                    let gt = "";
                    for (let _t = pt - 1; _t >= 0; --_t)
                        gt += `
        k = m[${_t}] - ${ht[_t]};
        if (k < 0)  k = 0;
        if (k >= ${ct[_t]}) k = ${ct[_t] - 1};
        offset += k * ${ut[_t]};
      `;
                    return `
      float padA(int m[${pt}]) {
        int offset = 0;
        int k = 0;
        ${gt}
        vec2 coords = offsetToCoords(offset, ${dt}, ${ft});
        float value = getColorAsFloat(${lt.texture2D}(A, coords));
        return value;
      }
      `
                }
            }
            ,
            2834: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.globalMaxPool = i.parseMaxPoolAttributes = i.maxPool = i.parseGlobalAveragePoolAttributes = i.globalAveragePool = i.parseAveragePoolAttributes = i.averagePool = void 0;
                const a = s(4910)
                  , _ = s(7273)
                  , $ = s(5639);
                i.averagePool = (at, lt, ct) => {
                    et(lt);
                    const ut = {
                        name: "AveragePool",
                        inputNames: ["X"],
                        inputTypes: [$.TextureType.unpacked],
                        cacheHint: ct.cacheKey
                    };
                    return [at.run(Object.assign(Object.assign({}, ut), {
                        get: () => _e(lt, ut, !1, ct)
                    }), lt)]
                }
                ,
                i.parseAveragePoolAttributes = at => {
                    const lt = at.attributes.getString("auto_pad", "NOTSET")
                      , ct = at.attributes.getInt("ceil_mode", 0)
                      , ut = at.attributes.getInt("count_include_pad", 0) !== 0
                      , dt = at.attributes.getInts("kernel_shape")
                      , ft = at.attributes.getInts("strides", [])
                      , ht = at.attributes.getInts("pads", []);
                    if (ct !== 0)
                        throw new Error("using ceil() in shape computation is not yet supported for AveragePool");
                    return (0,
                    a.createAttributeWithCacheKey)({
                        autoPad: lt,
                        ceilMode: ct,
                        countIncludePad: ut,
                        kernelShape: dt,
                        strides: ft,
                        pads: ht
                    })
                }
                ;
                const _e = (at, lt, ct, ut) => {
                    const [dt,ft] = nt(at, ut, ct)
                      , ht = _.ShapeUtil.size(dt.kernelShape);
                    let pt = "";
                    dt.countIncludePad ? pt += `value /= float(${ht});` : pt += `value /= float(${ht} - pad);`;
                    const gt = `
        ${j(at[0].dims, dt, "value += _X(x);", pt, "0.0")}
      `;
                    return Object.assign(Object.assign({}, lt), {
                        output: {
                            dims: ft,
                            type: at[0].type,
                            textureType: $.TextureType.unpacked
                        },
                        shaderSource: gt
                    })
                }
                ;
                i.globalAveragePool = (at, lt, ct) => {
                    et(lt);
                    const ut = {
                        name: "GlobalAveragePool",
                        inputNames: ["X"],
                        inputTypes: [$.TextureType.unpacked],
                        cacheHint: `${ct.countIncludePad}`
                    };
                    return [at.run(Object.assign(Object.assign({}, ut), {
                        get: () => _e(lt, ut, !0, ct)
                    }), lt)]
                }
                ,
                i.parseGlobalAveragePoolAttributes = at => {
                    const lt = at.attributes.getInt("count_include_pad", 0) !== 0;
                    return (0,
                    a.createAttributeWithCacheKey)({
                        autoPad: "",
                        ceilMode: 0,
                        countIncludePad: lt,
                        kernelShape: [],
                        strides: [],
                        pads: []
                    })
                }
                ,
                i.maxPool = (at, lt, ct) => {
                    et(lt);
                    const ut = {
                        name: "MaxPool",
                        inputNames: ["X"],
                        inputTypes: [$.TextureType.unpacked],
                        cacheHint: ct.cacheKey
                    };
                    return [at.run(Object.assign(Object.assign({}, ut), {
                        get: () => tt(lt, ut, !1, ct)
                    }), lt)]
                }
                ,
                i.parseMaxPoolAttributes = at => {
                    const lt = at.attributes.getString("auto_pad", "NOTSET")
                      , ct = at.attributes.getInt("ceil_mode", 0)
                      , ut = at.attributes.getInts("kernel_shape")
                      , dt = at.attributes.getInts("strides", [])
                      , ft = at.attributes.getInts("pads", [])
                      , ht = at.attributes.getInt("storage_order", 0)
                      , pt = at.attributes.getInts("dilations", []);
                    if (ht !== 0)
                        throw new Error("column major storage order is not yet supported for MaxPool");
                    if (ct !== 0)
                        throw new Error("using ceil() in shape computation is not yet supported for MaxPool");
                    return (0,
                    a.createAttributeWithCacheKey)({
                        autoPad: lt,
                        ceilMode: ct,
                        countIncludePad: !1,
                        kernelShape: ut,
                        strides: dt,
                        pads: ft,
                        storageOrder: ht,
                        dilations: pt
                    })
                }
                ;
                const tt = (at, lt, ct, ut) => {
                    const [dt,ft] = nt(at, ut, ct)
                      , ht = `
      ${j(at[0].dims, dt, `
      value = max(_X(x), value);
    `, "", "-1e5")}
    `;
                    return Object.assign(Object.assign({}, lt), {
                        output: {
                            dims: ft,
                            type: at[0].type,
                            textureType: $.TextureType.unpacked
                        },
                        shaderSource: ht
                    })
                }
                  , nt = (at, lt, ct) => {
                    const ut = at[0].dims.slice()
                      , dt = Object.hasOwnProperty.call(lt, "dilations")
                      , ft = lt.kernelShape.slice()
                      , ht = lt.strides.slice()
                      , pt = dt ? lt.dilations.slice() : []
                      , gt = lt.pads.slice();
                    _.PoolConvUtil.adjustPoolAttributes(ct, ut, ft, ht, pt, gt);
                    const _t = _.PoolConvUtil.computePoolOutputShape(ct, ut, ht, pt, ft, gt, lt.autoPad)
                      , mt = Object.assign({}, lt);
                    return dt ? Object.assign(mt, {
                        kernelShape: ft,
                        strides: ht,
                        pads: gt,
                        dilations: pt,
                        cacheKey: lt.cacheKey
                    }) : Object.assign(mt, {
                        kernelShape: ft,
                        strides: ht,
                        pads: gt,
                        cacheKey: lt.cacheKey
                    }),
                    [mt, _t]
                }
                  , rt = {
                    autoPad: "",
                    ceilMode: 0,
                    countIncludePad: !1,
                    kernelShape: [],
                    strides: [],
                    pads: [],
                    storageOrder: 0,
                    dilations: [],
                    cacheKey: ""
                }
                  , ot = {
                    name: "GlobalMaxPool",
                    inputNames: ["X"],
                    inputTypes: [$.TextureType.unpacked]
                };
                i.globalMaxPool = (at, lt) => (et(lt),
                [at.run(Object.assign(Object.assign({}, ot), {
                    get: () => tt(lt, ot, !0, rt)
                }), lt)]);
                const et = at => {
                    if (!at || at.length !== 1)
                        throw new Error("Pool ops requires 1 input.");
                    if (at[0].type !== "float32" && at[0].type !== "float64")
                        throw new Error("Invalid input type.")
                }
                  , j = (at, lt, ct, ut, dt) => {
                    const ft = at.length;
                    if (lt.kernelShape.length <= 2) {
                        const ht = lt.kernelShape[lt.kernelShape.length - 1]
                          , pt = lt.strides[lt.strides.length - 1]
                          , gt = lt.pads[lt.pads.length / 2 - 1]
                          , _t = lt.pads[lt.pads.length - 1]
                          , mt = at[ft - 1];
                        let yt = ""
                          , bt = ""
                          , vt = "";
                        if (yt = gt + _t !== 0 ? `
          for (int i = 0; i < ${ht}; i++) {
            x[${ft} - 1] = indices[${ft} - 1] * ${pt} - ${gt} + i;
            if (x[${ft} - 1] < 0 || x[${ft} - 1] >= ${mt}) {
              pad++;
              continue;
            }
            ${ct}
          }` : `
          for (int i = 0; i < ${ht}; i++) {
            x[${ft} - 1] = indices[${ft} - 1] * ${pt} - ${gt} + i;
            ${ct}
          }`,
                        lt.kernelShape.length === 2) {
                            const wt = lt.kernelShape[lt.kernelShape.length - 2]
                              , Tt = lt.strides[lt.strides.length - 2]
                              , $t = lt.pads[lt.pads.length / 2 - 2]
                              , Et = lt.pads[lt.pads.length - 2]
                              , Pt = at[ft - 2];
                            bt = $t + Et !== 0 ? `
            for (int j = 0; j < ${wt}; j++) {
              x[${ft} - 2] = indices[${ft} - 2] * ${Tt} - ${$t} + j;
              if (x[${ft} - 2] < 0 || x[${ft} - 2] >= ${Pt}) {
                pad+= ${ht};
                continue;
              }
          ` : `
            for (int j = 0; j < ${wt}; j++) {
              x[${ft} - 2] = indices[${ft} - 2] * ${Tt} - ${$t} + j;
            `,
                            vt = `
          }
        `
                        }
                        return `
        float process(int indices[${ft}]) {
          int x[${ft}];
          copyVec(indices, x);

          float value = ${dt};
          int pad = 0;
          ${bt}
          ${yt}
          ${vt}
          ${ut}
          return value;
        }
      `
                    }
                    {
                        const ht = _.ShapeUtil.size(lt.kernelShape)
                          , pt = _.ShapeUtil.computeStrides(lt.kernelShape)
                          , gt = pt.length
                          , _t = lt.pads.length
                          , mt = st(gt)
                          , yt = it(at, "inputDims")
                          , bt = it(lt.pads, "pads")
                          , vt = it(pt, "kernelStrides")
                          , wt = it(lt.strides, "strides");
                        let Tt = "";
                        return Tt = lt.pads.reduce( ($t, Et) => $t + Et) ? `
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${ct}
          }` : `
          }
          ${ct}
        `,
                        `
        ${mt}
        float process(int indices[${ft}]) {
          int x[${ft}];
          copyVec(indices, x);
          int offset[${gt}];
          int pads[${_t}];
          int inputDims[${ft}];
          int kernelStrides[${gt}];
          int strides[${gt}];
          ${bt}
          ${yt}
          ${wt}
          ${vt}

          float value = ${dt};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${ht}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${ft} - ${gt}; j < ${ft}; j++) {
              x[j] = indices[j] * strides[j - ${ft} + ${gt}]
                + offset[j - ${ft} + ${gt}] - pads[j - 2];
              ${Tt}
          }
          ${ut}

          return value;
        }
      `
                    }
                }
                  , it = (at, lt) => {
                    let ct = "";
                    for (let ut = 0; ut < at.length; ut++)
                        ct += `
      ${lt}[${ut}] = ${at[ut]};
    `;
                    return ct
                }
                  , st = at => `
  void offsetToIndices(int offset, int[${at}] strides, out int[${at}] indices) {
    if (${at} == 0) {
      return;
    }
    for (int i = 0; i < ${at} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${at} - 1] = offset;
  }`
            }
            ,
            1010: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.reduceLogSumSquare = i.reduceLogSum = i.reduceProd = i.reduceMin = i.reduceMax = i.reduceMean = i.reduceSum = i.parseReduceAttributes = void 0;
                const a = s(4910)
                  , _ = s(6145)
                  , $ = s(7273)
                  , _e = s(5639)
                  , tt = (ot, et, j, it, st) => {
                    rt(et);
                    const at = {
                        name: it,
                        inputNames: ["A"],
                        inputTypes: [_e.TextureType.unpacked]
                    };
                    return [ot.run(Object.assign(Object.assign({}, at), {
                        cacheHint: j.cacheKey,
                        get: () => nt(ot, et, j, it, st, at)
                    }), et)]
                }
                ;
                i.parseReduceAttributes = ot => {
                    const et = ot.attributes.getInts("axes", [])
                      , j = ot.attributes.getInt("keepdims", 1) === 1;
                    return (0,
                    a.createAttributeWithCacheKey)({
                        axes: et,
                        keepDims: j
                    })
                }
                ;
                const nt = (ot, et, j, it, st, at) => {
                    const lt = []
                      , ct = et[0].dims.length || 1
                      , ut = []
                      , dt = $.ShapeUtil.normalizeAxes(j.axes, et[0].dims.length)
                      , ft = st(et, dt);
                    let ht = ft[1];
                    for (let gt = 0; gt < et[0].dims.length; gt++)
                        dt.indexOf(gt) >= 0 || dt.length === 0 ? (j.keepDims && lt.push(1),
                        ht = `
          for(int j${gt} = 0; j${gt} < ${et[0].dims[gt]}; j${gt}++) {
            inputIdx[${gt}] = j${gt};
            ${ht}
          }`) : (ut.push(`inputIdx[${gt}] = outputIdx[${lt.length}];`),
                        lt.push(et[0].dims[gt]));
                    const pt = `
      float process(int outputIdx[${lt.length || 1}]) {
        float value;                 // final result
        int inputIdx[${ct}];      // addressing input data
        ${ut.join(`
`)}
        ${ft[0]}       // init ops for reduce max/min
        ${ht}
        ${ft[2]}       // final computation for reduce mean
        return value;
      }`;
                    return Object.assign(Object.assign({}, at), {
                        output: {
                            dims: lt,
                            type: et[0].type,
                            textureType: _e.TextureType.unpacked
                        },
                        shaderSource: pt
                    })
                }
                  , rt = ot => {
                    if (!ot || ot.length !== 1)
                        throw new Error("Reduce op requires 1 input.");
                    if (_.NUMBER_TYPES.indexOf(ot[0].type) === -1)
                        throw new Error("Invalid input type.")
                }
                ;
                i.reduceSum = (ot, et, j) => tt(ot, et, j, "ReduceSum", () => ["value = 0.0;", "value += _A(inputIdx);", ""]),
                i.reduceMean = (ot, et, j) => tt(ot, et, j, "ReduceMean", (it, st) => {
                    let at = 1;
                    for (let lt = 0; lt < it[0].dims.length; lt++)
                        (st.indexOf(lt) >= 0 || st.length === 0) && (at *= it[0].dims[lt]);
                    return ["value = 0.0;", "value += _A(inputIdx);", `value /= ${at}.;`]
                }
                ),
                i.reduceMax = (ot, et, j) => tt(ot, et, j, "ReduceMax", (it, st) => {
                    const at = [];
                    for (let lt = 0; lt < it[0].dims.length; lt++)
                        (st.indexOf(lt) >= 0 || st.length === 0) && at.push(`inputIdx[${lt}] = 0;`);
                    return [`${at.join(`
`)}
value = _A(inputIdx);`, "value = max(value, _A(inputIdx));", ""]
                }
                ),
                i.reduceMin = (ot, et, j) => tt(ot, et, j, "ReduceMin", (it, st) => {
                    const at = [];
                    for (let lt = 0; lt < it[0].dims.length; lt++)
                        (st.indexOf(lt) >= 0 || st.length === 0) && at.push(`inputIdx[${lt}] = 0;`);
                    return [`${at.join(`
`)}
value = _A(inputIdx);`, "value = min(value, _A(inputIdx));", ""]
                }
                ),
                i.reduceProd = (ot, et, j) => tt(ot, et, j, "ReduceProd", () => ["value = 1.0;", "value *= _A(inputIdx);", ""]),
                i.reduceLogSum = (ot, et, j) => tt(ot, et, j, "ReduceLogSum", () => ["value = 0.0;", "value += _A(inputIdx);", "value = log(value);"]),
                i.reduceLogSumSquare = (ot, et, j) => tt(ot, et, j, "ReduceLogSumSquare", () => ["float t; value = 0.0;", "t = _A(inputIdx); value += t * t;", ""])
            }
            ,
            7379: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.isReshapeCheap = i.processDims3D = i.createPackedReshape3DProgramInfoLoader = void 0;
                const a = s(7273)
                  , _ = s(6757)
                  , $ = s(5639)
                  , _e = s(5614);
                i.createPackedReshape3DProgramInfoLoader = (tt, nt, rt) => {
                    const ot = (et => ({
                        name: "Reshape (packed)",
                        inputTypes: [$.TextureType.packed],
                        inputNames: ["A"],
                        cacheHint: `${et}`
                    }))(rt);
                    return Object.assign(Object.assign({}, ot), {
                        get: () => ( (et, j, it, st) => {
                            const at = j.dims
                              , lt = st;
                            let ct = "";
                            for (let ft = 0; ft < 4; ft++) {
                                let ht = "";
                                switch (ft) {
                                case 0:
                                    ht = "outputCoords = rc;";
                                    break;
                                case 1:
                                    ht = "outputCoords = ivec3(rc.x, rc.y+1, rc.z);";
                                    break;
                                case 2:
                                    ht = "outputCoords = ivec3(rc.x, rc.y, rc.z+1);";
                                    break;
                                case 3:
                                    ht = "outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";
                                    break;
                                default:
                                    throw new Error
                                }
                                ct += `
        ${ht}
        ${ft > 0 ? "if(outputCoords.y < rows && outputCoords.z < cols){" : ""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${ft}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${ft > 0 ? "}" : ""}
      `
                            }
                            const ut = (0,
                            _.getGlsl)(et.session.backend.glContext.version)
                              , dt = `
      ${function(ft) {
                                const ht = a.ShapeUtil.computeStrides(ft)
                                  , pt = ["b", "r", "c"]
                                  , gt = "index";
                                return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${ht.map( (_t, mt) => `int ${pt[mt]} = ${gt} / ${_t}; ${mt === ht.length - 1 ? `int ${pt[mt + 1]} = ${gt} - ${pt[mt]} * ${_t}` : `index -= ${pt[mt]} * ${_t}`};`).join("")}
      return ivec3(b, r, c);
    }
  `
                            }(at)}
      ${function(ft) {
                                const ht = a.ShapeUtil.computeStrides(ft);
                                return `
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${ht[0]} + coords.z * ${ht[1]} + coords.y;
  }
`
                            }(lt)}
      ${(0,
                            _e.unpackFromChannel)()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${lt[2]};
        int cols = ${lt[1]};

        ${ct}
        ${ut.output} = result;
      }
    `;
                            return Object.assign(Object.assign({}, it), {
                                output: {
                                    dims: lt,
                                    type: j.type,
                                    textureType: $.TextureType.packed
                                },
                                shaderSource: dt,
                                hasMain: !0
                            })
                        }
                        )(tt, nt, ot, rt)
                    })
                }
                ,
                i.processDims3D = function(tt) {
                    if (tt.length === 0)
                        return [1, 1, 1];
                    let nt = 1;
                    for (let rt = 0; rt < tt.length - 2; ++rt)
                        nt *= tt[rt];
                    return [nt, tt.length > 1 ? tt[tt.length - 2] : 1, tt[tt.length - 1]]
                }
                ,
                i.isReshapeCheap = function(tt, nt) {
                    let rt = !1;
                    return rt = tt.length === 0 || nt.length === 0 || (tt.length < 2 || nt.length < 2 ? tt[tt.length - 1] === nt[nt.length - 1] : tt[tt.length - 1] === nt[nt.length - 1] && tt[tt.length - 2] === nt[nt.length - 2]),
                    rt
                }
            }
            ,
            8126: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.reshape = void 0;
                const a = s(7273);
                i.reshape = (_, $) => {
                    const _e = a.ShapeUtil.calculateReshapedDims($[0].dims, $[1].integerData);
                    return _.session.pack ? [_.reshapePacked($[0], _e)] : [_.reshapeUnpacked($[0], _e)]
                }
            }
            ,
            2801: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.parseResizeAttributesV11 = i.parseResizeAttributesV10 = i.resize = void 0;
                const a = s(6757)
                  , _ = s(5639)
                  , $ = s(432)
                  , _e = s(5614)
                  , tt = s(3980)
                  , nt = {
                    name: "Resize",
                    inputNames: ["A"],
                    inputTypes: [_.TextureType.packed]
                };
                i.resize = (it, st, at) => ((0,
                tt.validateInputs)(st, at),
                [it.run(Object.assign(Object.assign({}, nt), {
                    cacheHint: at.cacheKey,
                    get: () => rt(it, st, at)
                }), st)]),
                i.parseResizeAttributesV10 = it => (0,
                tt.parseUpsampleAttributes)(it, 10),
                i.parseResizeAttributesV11 = it => (0,
                tt.parseUpsampleAttributes)(it, 11);
                const rt = (it, st, at) => {
                    const lt = (0,
                    a.getGlsl)(it.session.backend.glContext.version)
                      , [ct,ut] = ot(st, at);
                    if (ct.every(Tt => Tt === 1) && at.coordinateTransformMode !== "tf_crop_and_resize")
                        return Object.assign(Object.assign({}, nt), {
                            output: {
                                dims: ut,
                                type: st[0].type,
                                textureType: _.TextureType.packed
                            },
                            hasMain: !0,
                            shaderSource: `void main() {
                    vec4 v = ${lt.texture2D}(X, TexCoords);
                    ${lt.output} = v;
                }`
                        });
                    const dt = ut.length;
                    if (dt < 2)
                        throw new Error(`output dimension should be at least 2, but got ${dt}`);
                    const ft = ut[dt - 2]
                      , ht = ut[dt - 1]
                      , pt = st[0].dims;
                    if (dt !== pt.length)
                        throw new Error(`output dimension should match input ${pt.length}, but got ${dt}`);
                    const gt = pt[dt - 2]
                      , _t = pt[dt - 1]
                      , mt = ct[dt - 2]
                      , yt = ct[dt - 1];
                    let bt = "";
                    if (at.mode !== "linear")
                        throw new Error(`resize (packed) does not support mode: '${at.mode}'`);
                    switch (at.coordinateTransformMode) {
                    case "asymmetric":
                        bt = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return vec4(coords) / scaleWHWH;
                    }
                `;
                        break;
                    case "half_pixel":
                        bt = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;
                    }
                `;
                        break;
                    case "pytorch_half_pixel":
                        bt = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${ht}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${ft}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${ht}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${ft}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;
                        break;
                    case "align_corners":
                        bt = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${ht}.0 - 1.0, ${ft}.0 - 1.0, ${ht}.0 - 1.0,
                            ${ft}.0 - 1.0);
                        vec4 original = vec4(${_t}.0 - 1.0, ${gt}.0 - 1.0, ${_t}.0 - 1.0,
                            ${gt}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;
                        break;
                    default:
                        throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${at.coordinateTransformMode}'`)
                    }
                    const vt = (0,
                    $.getCoordsDataType)(dt)
                      , wt = `
            const vec2 inputWH = vec2(${gt}.0, ${_t}.0);
            const vec4 scaleWHWH = vec4(float(${mt}), float(${yt}), float(${mt}), float(${yt}));
            ${(0,
                    _e.unpackFromChannel)()}
            ${bt}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${vt} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${ft - 1};
                bool hasNextCol = rc.z < ${ht - 1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${lt.output} = vec4(newValue);
            }
        `;
                    return Object.assign(Object.assign({}, nt), {
                        output: {
                            dims: ut,
                            type: st[0].type,
                            textureType: _.TextureType.packed
                        },
                        hasMain: !0,
                        shaderSource: wt
                    })
                }
                  , ot = (it, st) => {
                    const at = it[0].dims;
                    let lt, ct = st.scales;
                    if (ct.length === 0) {
                        const dt = it[st.scalesInputIdx];
                        if (dt && dt.size !== 0) {
                            if (it[st.sizesInputIdx])
                                throw new Error("Only one of scales or sizes must be provided as input.");
                            ct = et(dt, st.mode, st.isResize)
                        } else {
                            const ft = it[st.sizesInputIdx];
                            if (!ft || ft.size === 0)
                                throw new Error("Either scales or sizes MUST be provided as input.");
                            lt = Array.from(ft.integerData),
                            ct = j(lt, at, st.mode, st.isResize)
                        }
                    } else if (it[st.sizesInputIdx])
                        throw new Error("Only one of scales or sizes must be provided as input.");
                    const ut = lt || at.map( (dt, ft) => Math.floor(dt * ct[ft]));
                    return [ct, ut]
                }
                  , et = (it, st, at) => {
                    const lt = Array.from(it.floatData);
                    return (0,
                    tt.scalesValidation)(lt, st, at),
                    lt
                }
                  , j = (it, st, at, lt) => {
                    const ct = st.length
                      , ut = new Array(ct);
                    for (let dt = 0, ft = ct; dt < ft; dt++)
                        if (st[dt] === 0) {
                            if (it[dt] !== 0)
                                throw new Error("Input dim is zero but required output dim is non-zero.");
                            ut[dt] = 1
                        } else
                            ut[dt] = it[dt] / st[dt];
                    return (0,
                    tt.scalesValidation)(ut, at, lt),
                    ut
                }
            }
            ,
            565: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.shape = void 0;
                const a = s(9240);
                i.shape = ($, _e) => (_(_e),
                [new a.Tensor([_e[0].dims.length],"int32",void 0,void 0,new Int32Array(_e[0].dims))]);
                const _ = $ => {
                    if (!$ || $.length !== 1)
                        throw new Error("Shape requires 1 input.")
                }
            }
            ,
            2444: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.sliceV10 = i.parseSliceAttributes = i.slice = void 0;
                const a = s(4910)
                  , _ = s(6145)
                  , $ = s(7273)
                  , _e = s(5639)
                  , tt = {
                    name: "Slice",
                    inputNames: ["A"],
                    inputTypes: [_e.TextureType.unpacked]
                };
                i.slice = (j, it, st) => (rt(it),
                [j.run(Object.assign(Object.assign({}, tt), {
                    cacheHint: st.cacheKey,
                    get: () => nt(j, it[0], st)
                }), it)]),
                i.parseSliceAttributes = j => {
                    const it = j.attributes.getInts("starts")
                      , st = j.attributes.getInts("ends")
                      , at = j.attributes.getInts("axes", []);
                    return (0,
                    a.createAttributeWithCacheKey)({
                        starts: it,
                        ends: st,
                        axes: at
                    })
                }
                ;
                const nt = (j, it, st) => {
                    const at = st.axes.length === 0 ? it.dims.slice(0).map( (pt, gt) => gt) : st.axes
                      , lt = $.ShapeUtil.normalizeAxes(at, it.dims.length)
                      , ct = st.starts.map( (pt, gt) => pt > it.dims[lt[gt]] - 1 ? it.dims[lt[gt]] : $.ShapeUtil.normalizeAxis(pt, it.dims[lt[gt]]))
                      , ut = st.ends.map( (pt, gt) => pt > it.dims[lt[gt]] - 1 ? it.dims[lt[gt]] : $.ShapeUtil.normalizeAxis(pt, it.dims[lt[gt]]))
                      , dt = it.dims.slice()
                      , ft = [];
                    for (let pt = 0; pt < lt.length; pt++)
                        dt[lt[pt]] = ut[pt] - ct[pt],
                        ct[pt] > 0 && ft.push(`outputIdx[${lt[pt]}] += ${ct[pt]};`);
                    const ht = `
      float process(int outputIdx[${dt.length}]) {
        ${ft.join(`
      `)}
        return _A(outputIdx);
      }`;
                    return Object.assign(Object.assign({}, tt), {
                        output: {
                            dims: dt,
                            type: it.type,
                            textureType: _e.TextureType.unpacked
                        },
                        shaderSource: ht
                    })
                }
                  , rt = j => {
                    if (!j || j.length !== 1)
                        throw new Error("Slice requires 1 input.");
                    if (_.NUMBER_TYPES.indexOf(j[0].type) === -1)
                        throw new Error("Invalid input type.")
                }
                ;
                i.sliceV10 = (j, it) => {
                    et(it);
                    const st = ot(j, it);
                    return [j.run(Object.assign(Object.assign({}, tt), {
                        cacheHint: st.cacheKey,
                        get: () => nt(j, it[0], st)
                    }), [it[0]])]
                }
                ;
                const ot = (j, it) => {
                    if (!j.session.isInitializer(it[1].dataId) || !j.session.isInitializer(it[2].dataId) || it.length >= 4 && !j.session.isInitializer(it[3].dataId) || it.length >= 5 && !j.session.isInitializer(it[4].dataId))
                        throw new Error("dynamic slice attributes are not allowed");
                    if (it.length >= 5 && it[4].integerData.some(ct => ct !== 1))
                        throw new Error("currently non-1 steps is not supported for Slice");
                    const st = Array.from(it[1].integerData)
                      , at = Array.from(it[2].integerData)
                      , lt = it.length >= 4 ? Array.from(it[3].integerData) : [];
                    return {
                        starts: st,
                        ends: at,
                        axes: lt,
                        cacheKey: `${lt};${st};${at}`
                    }
                }
                  , et = j => {
                    if (!j || j.length < 3 || j.length > 5)
                        throw new Error("Invalid input number.");
                    if (j[1].type !== "int32" || j[1].dims.length !== 1)
                        throw new Error("Invalid input type.");
                    if (j[2].type !== "int32" || j[2].dims.length !== 1)
                        throw new Error("Invalid input type.");
                    if (j.length >= 4 && (j[3].type !== "int32" || j[3].dims.length !== 1))
                        throw new Error("Invalid input type.");
                    if (j.length >= 5 && (j[4].type !== "int32" || j[4].dims.length !== 1))
                        throw new Error("Invalid input type.")
                }
            }
            ,
            815: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.softmaxV13 = i.parseSoftmaxAttributesV13 = i.parseSoftmaxAttributes = i.softmax = void 0;
                const a = s(4910)
                  , _ = s(7273)
                  , $ = s(6757)
                  , _e = s(5639)
                  , tt = s(5707)
                  , nt = {
                    name: "SoftmaxComputeMax",
                    inputNames: ["A"],
                    inputTypes: [_e.TextureType.unpacked]
                }
                  , rt = {
                    name: "SoftmaxComputeScale",
                    inputNames: ["A", "Max"],
                    inputTypes: [_e.TextureType.unpacked, _e.TextureType.unpacked]
                }
                  , ot = {
                    name: "SoftMax",
                    inputNames: ["A", "Max", "Norm"],
                    inputTypes: [_e.TextureType.unpacked, _e.TextureType.unpacked, _e.TextureType.unpacked]
                };
                i.softmax = (lt, ct, ut) => {
                    at(ct);
                    const dt = ct[0].dims.slice()
                      , ft = _.ShapeUtil.normalizeAxis(ut.axis, dt.length)
                      , ht = _.ShapeUtil.sizeToDimension(dt, ft)
                      , pt = _.ShapeUtil.sizeFromDimension(dt, ft);
                    return et(lt, ct, ut, ht, pt)
                }
                ,
                i.parseSoftmaxAttributes = lt => (0,
                a.createAttributeWithCacheKey)({
                    axis: lt.attributes.getInt("axis", 1)
                }),
                i.parseSoftmaxAttributesV13 = lt => (0,
                a.createAttributeWithCacheKey)({
                    axis: lt.attributes.getInt("axis", -1)
                }),
                i.softmaxV13 = (lt, ct, ut) => {
                    at(ct);
                    const dt = ct[0].dims.slice()
                      , ft = _.ShapeUtil.normalizeAxis(ut.axis, dt.length)
                      , ht = dt.length
                      , pt = ft !== ht - 1
                      , gt = [];
                    let _t, mt = [], yt = [];
                    pt && (mt = Array.from({
                        length: ht
                    }).map( (Tt, $t) => $t),
                    mt[ft] = ht - 1,
                    mt[ht - 1] = ft,
                    mt.map(Tt => gt.push(dt[Tt])),
                    _t = (0,
                    a.createAttributeWithCacheKey)({
                        perm: mt
                    }),
                    yt = (0,
                    tt.transpose)(lt, ct, _t));
                    const bt = pt ? _.ShapeUtil.sizeToDimension(gt, ht - 1) : _.ShapeUtil.sizeToDimension(dt, ht - 1)
                      , vt = pt ? _.ShapeUtil.sizeFromDimension(gt, ht - 1) : _.ShapeUtil.sizeFromDimension(dt, ht - 1)
                      , wt = et(lt, pt ? yt : ct, ut, bt, vt);
                    return pt ? (0,
                    tt.transpose)(lt, wt, _t) : wt
                }
                ;
                const et = (lt, ct, ut, dt, ft) => {
                    const ht = j(lt, ct[0], dt, ft, [dt])
                      , pt = lt.run(Object.assign(Object.assign({}, nt), {
                        cacheHint: ut.cacheKey,
                        get: () => ht
                    }), ct)
                      , gt = it(lt, ct[0], dt, ft, ht.output.dims, [dt])
                      , _t = lt.run(Object.assign(Object.assign({}, rt), {
                        cacheHint: ut.cacheKey,
                        get: () => gt
                    }), [ct[0], pt])
                      , mt = st(lt, ct[0], dt, ft, ht.output.dims, gt.output.dims);
                    return [lt.run(Object.assign(Object.assign({}, ot), {
                        cacheHint: ut.cacheKey,
                        get: () => mt
                    }), [ct[0], pt, _t])]
                }
                  , j = (lt, ct, ut, dt, ft) => {
                    const [ht,pt] = lt.calculateTextureWidthAndHeight(ct.dims, _e.TextureType.unpacked)
                      , gt = ft.length;
                    if (ut < 1 || dt < 1)
                        throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
                    if (ft.length !== 1)
                        throw new Error("Dimensionality of the output should be 1");
                    if (ft[0] !== ut)
                        throw new Error("Shape of the output should be equal to logical row count");
                    const _t = (0,
                    $.getGlsl)(lt.session.backend.glContext.version)
                      , mt = `
      float process(int[${gt}] indices) {
        int logical_row_start_offset = indices[0] * ${dt};

        float max = getColorAsFloat(${_t.texture2D}(A, offsetToCoords(logical_row_start_offset, ${ht},
        ${pt} )));
        for(int i=1; i<${dt}; ++i)
        {
          float current = getColorAsFloat(${_t.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${ht}, ${pt})));
          if(current > max)
          max = current;
        }

        return max;
      }`;
                    return Object.assign(Object.assign({}, nt), {
                        output: {
                            dims: ft,
                            type: ct.type,
                            textureType: _e.TextureType.unpacked
                        },
                        shaderSource: mt
                    })
                }
                  , it = (lt, ct, ut, dt, ft, ht) => {
                    const [pt,gt] = lt.calculateTextureWidthAndHeight(ct.dims, _e.TextureType.unpacked)
                      , _t = ht.length;
                    if (ut < 1 || dt < 1)
                        throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
                    if (ht.length !== 1)
                        throw new Error("Dimensionality of the output should be 1");
                    if (ht[0] !== ut)
                        throw new Error("Shape of the output should be equal to logical row count");
                    if (ft.length !== 1)
                        throw new Error("Dimensionality of the intermediate results should be 1");
                    if (ft[0] !== ut)
                        throw new Error("Shape of the intermediate results should be equal to logical row count");
                    const mt = `
      float process(int[${_t}] indices) {
        int logical_row_start_offset = indices[0] * ${dt};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${dt}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${(0,
                    $.getGlsl)(lt.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${pt}, ${gt}))) - max);
        }

        return norm_factor;
      }`;
                    return Object.assign(Object.assign({}, rt), {
                        output: {
                            dims: ht,
                            type: ct.type,
                            textureType: _e.TextureType.unpacked
                        },
                        shaderSource: mt
                    })
                }
                  , st = (lt, ct, ut, dt, ft, ht) => {
                    const [pt,gt] = lt.calculateTextureWidthAndHeight(ct.dims, _e.TextureType.unpacked)
                      , _t = ct.dims.length;
                    if (ut < 1 || dt < 1)
                        throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
                    if (ft.length !== 1 || ht.length !== 1)
                        throw new Error("Dimensionality of the intermediate results should be 1");
                    if (ft[0] !== ut || ht[0] !== ut)
                        throw new Error("Shape of the intermediate results should be equal to logical row count");
                    const mt = `
      float process(int[${_t}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${pt}, ${gt});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${dt};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;
                    return Object.assign(Object.assign({}, ot), {
                        output: {
                            dims: ct.dims,
                            type: ct.type,
                            textureType: _e.TextureType.unpacked
                        },
                        shaderSource: mt
                    })
                }
                  , at = lt => {
                    if (!lt || lt.length !== 1)
                        throw new Error("Softmax requires 1 input.");
                    if (lt[0].type !== "float32" && lt[0].type !== "float64")
                        throw new Error("Invalid input type")
                }
            }
            ,
            564: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.parseSplitAttributes = i.split = void 0;
                const a = s(4910)
                  , _ = s(7273)
                  , $ = s(5639)
                  , _e = {
                    name: "Split",
                    inputNames: ["A"],
                    inputTypes: [$.TextureType.unpacked]
                };
                i.split = (ot, et, j) => {
                    rt(et);
                    const it = _.ShapeUtil.normalizeAxis(j.axis, et[0].dims.length)
                      , st = tt(ot, et, it, j)
                      , at = [];
                    for (let lt = 0; lt < st; ++lt)
                        at.push(ot.run(Object.assign(Object.assign({}, _e), {
                            cacheHint: `${j.cacheKey};${lt}`,
                            get: () => nt(ot, et[0], j, it, lt)
                        }), et));
                    return at
                }
                ,
                i.parseSplitAttributes = ot => {
                    const et = ot.attributes.getInt("axis", 0)
                      , j = ot.attributes.getInts("split", [])
                      , it = ot.outputs.length;
                    return (0,
                    a.createAttributeWithCacheKey)({
                        axis: et,
                        split: j,
                        numOutputs: it
                    })
                }
                ;
                const tt = (ot, et, j, it) => {
                    const [,st] = _.SplitUtil.splitShape(et[0].dims, j, it.split, it.numOutputs);
                    return st.length
                }
                  , nt = (ot, et, j, it, st) => {
                    const [at,lt] = _.SplitUtil.splitShape(et.dims, it, j.split, j.numOutputs)
                      , ct = lt[st]
                      , ut = at[st]
                      , dt = `
      float process(int indices[${ut.length}]) {
        indices[${it}] += ${ct};
        return _A(indices);
      }
    `;
                    return Object.assign(Object.assign({}, _e), {
                        cacheHint: `${j.cacheKey}:${st}`,
                        output: {
                            dims: ut,
                            type: et.type,
                            textureType: $.TextureType.unpacked
                        },
                        shaderSource: dt
                    })
                }
                  , rt = ot => {
                    if (!ot || ot.length !== 1)
                        throw new Error("Split requires one input.");
                    if (ot[0].type !== "int8" && ot[0].type !== "uint8" && ot[0].type !== "int16" && ot[0].type !== "uint16" && ot[0].type !== "int32" && ot[0].type !== "uint32" && ot[0].type !== "float32" && ot[0].type !== "float64" && ot[0].type !== "bool")
                        throw new Error("Invalid input type.")
                }
            }
            ,
            5416: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.parseSqueezeAttributes = i.squeezeV13 = i.squeeze = void 0;
                const a = s(7273);
                i.squeeze = (_e, tt, nt) => {
                    _(tt);
                    const rt = a.ShapeUtil.squeezeShape(tt[0].dims, nt);
                    return [_e.reshapeUnpacked(tt[0], rt)]
                }
                ,
                i.squeezeV13 = (_e, tt) => ($(tt),
                (0,
                i.squeeze)(_e, [tt[0]], Array.from(tt[1].integerData))),
                i.parseSqueezeAttributes = _e => _e.attributes.getInts("axes");
                const _ = _e => {
                    if (!_e || _e.length !== 1)
                        throw new Error("Squeeze requires 1 input.");
                    if (_e[0].type === "string")
                        throw new Error("invalid input tensor types.")
                }
                  , $ = _e => {
                    if (!_e || _e.length !== 2)
                        throw new Error("Squeeze requires 2 inputs.");
                    if (_e[1].type !== "int32")
                        throw new Error("Invalid input type.")
                }
            }
            ,
            1240: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.sum = void 0;
                const a = s(6757)
                  , _ = s(5639);
                i.sum = (tt, nt) => {
                    _e(nt);
                    const rt = {
                        name: "Sum",
                        inputNames: nt.map( (ot, et) => `X${et}`),
                        inputTypes: new Array(nt.length).fill(_.TextureType.unpacked)
                    };
                    return [tt.run(Object.assign(Object.assign({}, rt), {
                        get: () => $(tt, nt, rt)
                    }), nt)]
                }
                ;
                const $ = (tt, nt, rt) => {
                    const ot = (0,
                    a.getGlsl)(tt.session.backend.glContext.version)
                      , et = nt[0].dims.slice()
                      , j = `
      void main() {
        vec4 result = ${nt.map( (it, st) => `${ot.texture2D}(X${st},TexCoords)`).join(" + ")};
        ${ot.output} = result;
      }
    `;
                    return Object.assign(Object.assign({}, rt), {
                        output: {
                            dims: et,
                            type: nt[0].type,
                            textureType: _.TextureType.unpacked
                        },
                        hasMain: !0,
                        shaderSource: j
                    })
                }
                  , _e = tt => {
                    if (!tt || tt.length === 0)
                        throw new Error("Sum requires inputs.");
                    const nt = tt[0].dims.length;
                    for (let rt = 1; rt < tt.length; rt++) {
                        if (nt !== tt[rt].dims.length)
                            throw new Error("Input shapes are mismatched.");
                        for (let ot = 0; ot < nt; ot++)
                            if (tt[0].dims[ot] !== tt[rt].dims[ot])
                                throw new Error("Input shapes are not matched.")
                    }
                    if (tt[0].type !== "float32" && tt[0].type !== "float64")
                        throw new Error("Invalid input type.");
                    for (let rt = 1; rt < tt.length; rt++)
                        if (tt[0].type !== tt[rt].type)
                            throw new Error("Input types are not matched.")
                }
            }
            ,
            5944: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.tile = void 0;
                const a = s(6145)
                  , _ = s(5639);
                i.tile = (tt, nt) => {
                    _e(nt);
                    const rt = {
                        name: "Tile",
                        inputNames: ["A"],
                        inputTypes: [_.TextureType.unpacked]
                    };
                    return [tt.run(Object.assign(Object.assign({}, rt), {
                        get: () => $(tt, nt, rt)
                    }), nt)]
                }
                ;
                const $ = (tt, nt, rt) => {
                    const ot = nt[0].dims.slice()
                      , et = new Array(ot.length)
                      , j = [];
                    for (let at = 0; at < ot.length; at++)
                        et[at] = ot[at] * nt[1].numberData[at],
                        j.push(`inputIdx[${at}] = int(mod(float(outputIdx[${at}]), ${ot[at]}.));`);
                    const it = et.length
                      , st = `
      float process(int outputIdx[${it}]) {
        int inputIdx[${it}];
        ${j.join(`
`)}
        return _A(inputIdx);
      }
    `;
                    return Object.assign(Object.assign({}, rt), {
                        output: {
                            dims: et,
                            type: nt[0].type,
                            textureType: _.TextureType.unpacked
                        },
                        shaderSource: st
                    })
                }
                  , _e = tt => {
                    if (!tt || tt.length !== 2)
                        throw new Error("Tile requires 2 input.");
                    if (tt[1].dims.length !== 1)
                        throw new Error("The second input shape must 1 dimension.");
                    if (tt[1].dims[0] !== tt[0].dims.length)
                        throw new Error("Invalid input shape.");
                    if (a.NUMBER_TYPES.indexOf(tt[0].type) === -1)
                        throw new Error("Invalid input type.");
                    if (tt[1].type !== "int32" && tt[1].type !== "int16")
                        throw new Error("Invalid repeat type.")
                }
            }
            ,
            5707: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.parseTransposeAttributes = i.transpose = void 0;
                const a = s(4910)
                  , _ = s(7273)
                  , $ = s(5639)
                  , _e = {
                    name: "Transpose",
                    inputNames: ["A"],
                    inputTypes: [$.TextureType.unpacked]
                };
                i.transpose = (j, it, st) => (et(it),
                [j.run(Object.assign(Object.assign({}, _e), {
                    cacheHint: st.cacheKey,
                    get: () => tt(j, it[0], st.perm)
                }), it)]),
                i.parseTransposeAttributes = j => (0,
                a.createAttributeWithCacheKey)({
                    perm: j.attributes.getInts("perm", [])
                });
                const tt = (j, it, st) => {
                    const at = it.dims;
                    st = nt(at, st);
                    const lt = rt(at, st)
                      , ct = at.length
                      , ut = `
      ${ot("perm", st, ct)}
      float process(int indices[${ct}]) {
        int a[${ct}];
        perm(a, indices);
        return _A(a);
      }`;
                    return Object.assign(Object.assign({}, _e), {
                        output: {
                            dims: lt,
                            type: it.type,
                            textureType: $.TextureType.unpacked
                        },
                        shaderSource: ut
                    })
                }
                  , nt = (j, it) => (it && it.length !== j.length && (it = [...j.keys()].reverse()),
                it)
                  , rt = (j, it) => (it = nt(j, it),
                _.ShapeUtil.sortBasedOnPerm(j, it))
                  , ot = (j, it, st) => {
                    const at = [];
                    at.push(`void ${j}(out int a[${st}], int src[${st}]) {`);
                    for (let lt = 0; lt < st; ++lt)
                        at.push(`	a[${it[lt]}]=src[${lt}];`);
                    return at.push("	}"),
                    at.join(`
`)
                }
                  , et = j => {
                    if (!j || j.length !== 1)
                        throw new Error("Transpose requires 1 input.");
                    if (j[0].type !== "float32" && j[0].type !== "float64")
                        throw new Error("input should be float tensor")
                }
            }
            ,
            2488: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.encodeAsUint8 = void 0;
                const a = s(6757)
                  , _ = s(5639);
                i.encodeAsUint8 = ($, _e) => {
                    const tt = _e.shape
                      , nt = (0,
                    a.getGlsl)($.session.backend.glContext.version)
                      , rt = `
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${nt.texture2D}(X,TexCoords).r;
      ${nt.output} = encodeAsUint8(value);
    }`
                      , ot = {
                        name: "Uint8Encode",
                        inputTypes: [_.TextureType.unpacked],
                        inputNames: ["X"],
                        output: {
                            dims: tt,
                            type: _e.tensor.type,
                            textureType: _.TextureType.downloadUint8AsFloat
                        },
                        shaderSource: rt,
                        hasMain: !0
                    };
                    return $.executeProgram(ot, [_e.tensor])
                }
            }
            ,
            9087: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.tanh = i.tan = i.sqrt = i.sin = i.sigmoid = i.relu = i.not = i.neg = i.log = i.parseLeakyReluAttributes = i.leakyRelu = i.identity = i.floor = i.exp = i.parseEluAttributes = i.elu = i.cos = i.ceil = i.clipV11 = i.parseClipAttributes = i.clip = i.atan = i.asin = i.acos = i.abs = i.glslTanh = i.glslTan = i.glslSqrt = i.glslSigmoid = i.glslRelu = i.glslSin = i.glslNot = i.glslNeg = i.glslLog = i.glslLeakyRelu = i.glslIdentity = i.glslClip = i.glslFloor = i.glslExp = i.glslElu = i.glslCos = i.glslCeil = i.glslAtan = i.glslAsin = i.glslAcos = i.glslAbs = void 0;
                const a = s(4910)
                  , _ = s(7273)
                  , $ = s(1997)
                  , _e = s(6757)
                  , tt = s(5639);
                function nt() {
                    return wt("abs")
                }
                function rt() {
                    return wt("acos")
                }
                function ot() {
                    return wt("asin")
                }
                function et() {
                    return wt("atan")
                }
                function j() {
                    return wt("ceil")
                }
                function it() {
                    return wt("cos")
                }
                function st(Et) {
                    const Pt = "elu";
                    return {
                        body: `
  const float alpha = float(${Et});

  float ${Pt}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${Pt}_(vec4 v) {
    return vec4(${Pt}_(v.x), ${Pt}_(v.y), ${Pt}_(v.z), ${Pt}_(v.w));
  }
  `,
                        name: Pt,
                        type: $.FunctionType.ValueBased
                    }
                }
                function at() {
                    return wt("exp")
                }
                function lt() {
                    return wt("floor")
                }
                function ct(Et, Pt) {
                    const Rt = "clip";
                    return {
                        body: `
  const float min = float(${Et});
  const float max = float(${Pt});

  float ${Rt}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${Rt}_(vec4 v) {
    return clamp(v, min, max);
  }
  `,
                        name: Rt,
                        type: $.FunctionType.ValueBased
                    }
                }
                function ut() {
                    const Et = "indentity";
                    return {
                        body: `
  float ${Et}_(float a) {
    return a;
  }
  vec4 ${Et}_(vec4 v) {
    return v;
  }
  `,
                        name: Et,
                        type: $.FunctionType.ValueBased
                    }
                }
                function dt(Et) {
                    const Pt = "leakyRelu";
                    return {
                        body: `
  const float alpha = float(${Et});

  float ${Pt}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${Pt}_(vec4 v) {
    return vec4(${Pt}_(v.x), ${Pt}_(v.y), ${Pt}_(v.z), ${Pt}_(v.w));
  }
  `,
                        name: Pt,
                        type: $.FunctionType.ValueBased
                    }
                }
                function ft() {
                    return wt("log")
                }
                function ht() {
                    const Et = "neg";
                    return {
                        body: `
  float ${Et}_(float a) {
    return -a;
  }
  vec4 ${Et}_(vec4 v) {
    return -v;
  }
  `,
                        name: Et,
                        type: $.FunctionType.ValueBased
                    }
                }
                function pt() {
                    const Et = "not";
                    return {
                        body: `
  float ${Et}_(float a) {
    return float( ! bool(a) );
  }
  bool ${Et}_(bool a) {
    return !a;
  }
  vec4 ${Et}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${Et}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `,
                        name: Et,
                        type: $.FunctionType.ValueBased
                    }
                }
                function gt() {
                    return wt("sin")
                }
                function _t() {
                    const Et = "relu";
                    return {
                        body: `
  float ${Et}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${Et}_(vec4 v) {
    return max( v, 0.0 );
  }
  `,
                        name: Et,
                        type: $.FunctionType.ValueBased
                    }
                }
                function mt() {
                    const Et = "sigmoid";
                    return {
                        body: `
  float ${Et}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${Et}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `,
                        name: Et,
                        type: $.FunctionType.ValueBased
                    }
                }
                function yt() {
                    return wt("sqrt")
                }
                function bt() {
                    return wt("tan")
                }
                function vt() {
                    const Et = "tanh";
                    return {
                        body: `
  float ${Et}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${Et}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `,
                        name: Et,
                        type: $.FunctionType.ValueBased
                    }
                }
                function wt(Et) {
                    return {
                        body: `
  float ${Et}_(float a) {
    return ${Et}(a);
  }
  vec4 ${Et}_(vec4 v) {
    return ${Et}(v);
  }
  `,
                        name: Et,
                        type: $.FunctionType.ValueBased
                    }
                }
                i.glslAbs = nt,
                i.glslAcos = rt,
                i.glslAsin = ot,
                i.glslAtan = et,
                i.glslCeil = j,
                i.glslCos = it,
                i.glslElu = st,
                i.glslExp = at,
                i.glslFloor = lt,
                i.glslClip = ct,
                i.glslIdentity = ut,
                i.glslLeakyRelu = dt,
                i.glslLog = ft,
                i.glslNeg = ht,
                i.glslNot = pt,
                i.glslSin = gt,
                i.glslRelu = _t,
                i.glslSigmoid = mt,
                i.glslSqrt = yt,
                i.glslTan = bt,
                i.glslTanh = vt;
                const Tt = (Et, Pt, Rt, At) => {
                    const Mt = Et.session.pack ? tt.TextureType.packed : tt.TextureType.unpacked
                      , Ut = {
                        name: Rt.name,
                        inputTypes: [Mt],
                        inputNames: ["A"],
                        cacheHint: At
                    };
                    return Object.assign(Object.assign({}, Ut), {
                        get: () => ( (Lt, tn, Vt, Nt) => {
                            const Yt = Lt.session.pack ? tt.TextureType.packed : tt.TextureType.unpacked
                              , Xt = (0,
                            _e.getGlsl)(Lt.session.backend.glContext.version);
                            return Object.assign(Object.assign({}, tn), {
                                output: {
                                    dims: Vt.dims,
                                    type: Vt.type,
                                    textureType: Yt
                                },
                                shaderSource: `
     ${Nt.body}
     void main() {
       vec4 v = ${Xt.texture2D}(A, TexCoords);
       v = ${Nt.name}_(v);
       ${Xt.output} = v;
     }
     `,
                                hasMain: !0
                            })
                        }
                        )(Et, Ut, Pt, Rt)
                    })
                }
                ;
                i.abs = (Et, Pt) => [Et.run(Tt(Et, Pt[0], nt()), Pt)],
                i.acos = (Et, Pt) => [Et.run(Tt(Et, Pt[0], rt()), Pt)],
                i.asin = (Et, Pt) => [Et.run(Tt(Et, Pt[0], ot()), Pt)],
                i.atan = (Et, Pt) => [Et.run(Tt(Et, Pt[0], et()), Pt)],
                i.clip = (Et, Pt, Rt) => [Et.run(Tt(Et, Pt[0], ct(Rt.min, Rt.max), Rt.cacheKey), Pt)],
                i.parseClipAttributes = Et => (0,
                a.createAttributeWithCacheKey)({
                    min: Et.attributes.getFloat("min", _.MIN_CLIP),
                    max: Et.attributes.getFloat("max", _.MAX_CLIP)
                }),
                i.clipV11 = (Et, Pt) => {
                    const Rt = $t(Et, Pt);
                    return (0,
                    i.clip)(Et, [Pt[0]], Rt)
                }
                ;
                const $t = (Et, Pt) => {
                    if (Pt.length >= 3 && (!Et.session.isInitializer(Pt[1].dataId) || !Et.session.isInitializer(Pt[2].dataId)))
                        throw new Error("dynamic clip attributes are not allowed");
                    const Rt = Pt.length >= 3 ? Pt[1].numberData[0] : _.MIN_CLIP
                      , At = Pt.length >= 3 ? Pt[2].numberData[0] : _.MAX_CLIP;
                    return (0,
                    a.createAttributeWithCacheKey)({
                        min: Rt,
                        max: At
                    })
                }
                ;
                i.ceil = (Et, Pt) => [Et.run(Tt(Et, Pt[0], j()), Pt)],
                i.cos = (Et, Pt) => [Et.run(Tt(Et, Pt[0], it()), Pt)],
                i.elu = (Et, Pt, Rt) => [Et.run(Tt(Et, Pt[0], st(Rt.alpha), Rt.cacheKey), Pt)],
                i.parseEluAttributes = Et => (0,
                a.createAttributeWithCacheKey)({
                    alpha: Et.attributes.getFloat("alpha", 1)
                }),
                i.exp = (Et, Pt) => [Et.run(Tt(Et, Pt[0], at()), Pt)],
                i.floor = (Et, Pt) => [Et.run(Tt(Et, Pt[0], lt()), Pt)],
                i.identity = (Et, Pt) => [Et.run(Tt(Et, Pt[0], ut()), Pt)],
                i.leakyRelu = (Et, Pt, Rt) => [Et.run(Tt(Et, Pt[0], dt(Rt.alpha), Rt.cacheKey), Pt)],
                i.parseLeakyReluAttributes = Et => (0,
                a.createAttributeWithCacheKey)({
                    alpha: Et.attributes.getFloat("alpha", .01)
                }),
                i.log = (Et, Pt) => [Et.run(Tt(Et, Pt[0], ft()), Pt)],
                i.neg = (Et, Pt) => [Et.run(Tt(Et, Pt[0], ht()), Pt)],
                i.not = (Et, Pt) => [Et.run(Tt(Et, Pt[0], pt()), Pt)],
                i.relu = (Et, Pt) => [Et.run(Tt(Et, Pt[0], _t()), Pt)],
                i.sigmoid = (Et, Pt) => [Et.run(Tt(Et, Pt[0], mt()), Pt)],
                i.sin = (Et, Pt) => [Et.run(Tt(Et, Pt[0], gt()), Pt)],
                i.sqrt = (Et, Pt) => [Et.run(Tt(Et, Pt[0], yt()), Pt)],
                i.tan = (Et, Pt) => [Et.run(Tt(Et, Pt[0], bt()), Pt)],
                i.tanh = (Et, Pt) => [Et.run(Tt(Et, Pt[0], vt()), Pt)]
            }
            ,
            540: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.createUnpackProgramInfoLoader = i.createUnpackProgramInfo = void 0;
                const a = s(6757)
                  , _ = s(5639)
                  , $ = s(432)
                  , _e = s(5614)
                  , tt = {
                    name: "unpack",
                    inputNames: ["A"],
                    inputTypes: [_.TextureType.packed]
                };
                i.createUnpackProgramInfo = (nt, rt) => {
                    const ot = rt.dims.length
                      , et = (0,
                    _e.getChannels)("rc", ot)
                      , j = et.slice(-2)
                      , it = (0,
                    $.getCoordsDataType)(ot)
                      , st = (0,
                    _e.unpackFromChannel)()
                      , at = rt.dims.length === 0 ? "" : function(ut, dt) {
                        if (ut === 1)
                            return "rc";
                        let ft = "";
                        for (let ht = 0; ht < ut; ht++)
                            ft += dt[ht],
                            ht < ut - 1 && (ft += ",");
                        return ft
                    }(ot, et)
                      , lt = ot <= 1 ? "rc" : `vec2(${j.join(",")})`
                      , ct = `
    ${st}
    void main() {
      ${it} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${at});

       ${(0,
                    a.getGlsl)(nt.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${lt}), 0, 0, 0);
     }
   `;
                    return Object.assign(Object.assign({}, tt), {
                        hasMain: !0,
                        output: {
                            dims: rt.dims,
                            type: rt.type,
                            textureType: _.TextureType.unpacked
                        },
                        shaderSource: ct
                    })
                }
                ,
                i.createUnpackProgramInfoLoader = (nt, rt) => Object.assign(Object.assign({}, tt), {
                    get: () => (0,
                    i.createUnpackProgramInfo)(nt, rt)
                })
            }
            ,
            7862: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.parseUnsqueezeAttributes = i.unsqueezeV13 = i.unsqueeze = void 0;
                const a = s(7273);
                i.unsqueeze = (_e, tt, nt) => {
                    _(tt);
                    const rt = a.ShapeUtil.unsqueezeShape(tt[0].dims, nt);
                    return [_e.reshapeUnpacked(tt[0], rt)]
                }
                ,
                i.unsqueezeV13 = (_e, tt) => ($(tt),
                (0,
                i.unsqueeze)(_e, [tt[0]], Array.from(tt[1].integerData))),
                i.parseUnsqueezeAttributes = _e => _e.attributes.getInts("axes");
                const _ = _e => {
                    if (!_e || _e.length !== 1)
                        throw new Error("Unsqueeze requires 1 input.");
                    if (_e[0].type === "string")
                        throw new Error("invalid input tensor types.")
                }
                  , $ = _e => {
                    if (!_e || _e.length !== 2)
                        throw new Error("Unsqueeze requires 2 inputs.");
                    if (_e[1].type !== "int32")
                        throw new Error("Invalid input type.")
                }
            }
            ,
            3980: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.scalesValidation = i.validateInputs = i.parseUpsampleAttributes = i.parseUpsampleAttributesV9 = i.parseUpsampleAttributesV7 = i.upsample = void 0;
                const a = s(4910)
                  , _ = s(6757)
                  , $ = s(5639)
                  , _e = {
                    name: "Upsample",
                    inputNames: ["X"],
                    inputTypes: [$.TextureType.unpacked]
                };
                i.upsample = (nt, rt, ot) => ((0,
                i.validateInputs)(rt, ot),
                [nt.run(Object.assign(Object.assign({}, _e), {
                    cacheHint: ot.cacheKey,
                    get: () => tt(nt, rt, ot)
                }), rt)]),
                i.parseUpsampleAttributesV7 = nt => (0,
                i.parseUpsampleAttributes)(nt, 7),
                i.parseUpsampleAttributesV9 = nt => (0,
                i.parseUpsampleAttributes)(nt, 9),
                i.parseUpsampleAttributes = (nt, rt) => {
                    const ot = rt >= 10
                      , et = nt.attributes.getString("mode", "nearest");
                    if (et !== "nearest" && et !== "linear" && (rt < 11 || et !== "cubic"))
                        throw new Error(`unrecognized mode: ${et}`);
                    let j = [];
                    rt < 9 && (j = nt.attributes.getFloats("scales"),
                    (0,
                    i.scalesValidation)(j, et, ot));
                    const it = nt.attributes.getFloat("extrapolation_value", 0)
                      , st = rt > 10 ? nt.attributes.getString("coordinate_transformation_mode", "half_pixel") : "asymmetric";
                    if (["asymmetric", "pytorch_half_pixel", "tf_half_pixel_for_nn", "align_corners", "tf_crop_and_resize", "half_pixel"].indexOf(st) === -1)
                        throw new Error(`coordinate_transform_mode '${st}' is not supported`);
                    const at = st === "tf_crop_and_resize"
                      , lt = at
                      , ct = et === "nearest" && rt >= 11 ? nt.attributes.getString("nearest_mode", "round_prefer_floor") : "";
                    if (["round_prefer_floor", "round_prefer_ceil", "floor", "ceil", ""].indexOf(ct) === -1)
                        throw new Error(`nearest_mode '${ct}' is not supported`);
                    const ut = nt.attributes.getFloat("cubic_coeff_a", -.75)
                      , dt = nt.attributes.getInt("exclude_outside", 0) !== 0;
                    if (dt && et !== "cubic")
                        throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");
                    const ft = rt < 11 || et === "nearest" && st === "asymmetric" && ct === "floor";
                    let ht = 0
                      , pt = 0
                      , gt = 0;
                    return rt > 10 ? nt.inputs.length > 2 ? (ht = 1,
                    pt = 2,
                    gt = 3) : (pt = 1,
                    gt = 2) : rt === 9 && (pt = 1),
                    (0,
                    a.createAttributeWithCacheKey)({
                        opset: rt,
                        isResize: ot,
                        mode: et,
                        scales: j,
                        extrapolationValue: it,
                        coordinateTransformMode: st,
                        useExtrapolation: lt,
                        needRoiInput: at,
                        nearestMode: ct,
                        cubicCoefficientA: ut,
                        excludeOutside: dt,
                        useNearest2xOptimization: ft,
                        roiInputIdx: ht,
                        scalesInputIdx: pt,
                        sizesInputIdx: gt
                    })
                }
                ;
                const tt = (nt, rt, ot) => {
                    const et = (0,
                    _.getGlsl)(nt.session.backend.glContext.version)
                      , [j,it] = nt.calculateTextureWidthAndHeight(rt[0].dims, $.TextureType.unpacked)
                      , st = rt[0].dims.map( (gt, _t) => Math.floor(gt * ot.scales[_t]))
                      , [at,lt] = nt.calculateTextureWidthAndHeight(st, $.TextureType.unpacked)
                      , ct = st.length
                      , ut = new Array(ct)
                      , dt = new Array(ct);
                    let ft = `
      int output_pitches[${ct}];
      int input_pitches[${ct}];
      `;
                    for (let gt = ct - 1; gt >= 0; gt--)
                        ut[gt] = gt === ct - 1 ? 1 : ut[gt + 1] * st[gt + 1],
                        dt[gt] = gt === ct - 1 ? 1 : dt[gt + 1] * rt[0].dims[gt + 1],
                        ft += `
        output_pitches[${gt}] = ${ut[gt]};
        input_pitches[${gt}] = ${dt[gt]};
        `;
                    const ht = `
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${j}, ${it});
        float value = getColorAsFloat(${et.texture2D}(X, coords));
        return value;
      }
      `
                      , pt = ot.mode === "nearest" ? `
    ${ht}
    float process(int indices[${ct}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${at}, ${lt});

      ${ft}

      int d, m;
      for (int dim = 0; dim < ${ct}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }` : ct === 4 ? `
    ${ht}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${at}, ${lt});

      ${ft}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${rt[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }` : `
    ${ht}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${at}, ${lt});

      ${ft}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${rt[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;
                    return Object.assign(Object.assign({}, _e), {
                        output: {
                            dims: st,
                            type: rt[0].type,
                            textureType: $.TextureType.unpacked
                        },
                        shaderSource: pt,
                        variables: [{
                            name: "scales",
                            type: "int",
                            arrayLength: ot.scales.length,
                            data: ot.scales.map(gt => Math.ceil(gt))
                        }]
                    })
                }
                ;
                i.validateInputs = (nt, rt) => {
                    if (!nt || rt.opset < 9 && nt.length !== 1 || rt.opset >= 9 && rt.opset < 11 && nt.length !== 2 || rt.opset >= 11 && nt.length < 2)
                        throw new Error("invalid inputs.");
                    if (rt.scales.length > 0 && nt[0].dims.length !== rt.scales.length)
                        throw new Error("Invalid input shape.");
                    if (nt[0].type === "string")
                        throw new Error("Invalid input tensor types.")
                }
                ,
                i.scalesValidation = (nt, rt, ot) => {
                    if (ot) {
                        for (const et of nt)
                            if (et <= 0)
                                throw new Error("Scale value should be greater than 0.")
                    } else
                        for (const et of nt)
                            if (et < 1)
                                throw new Error("Scale value should be greater than or equal to 1.");
                    if (!(rt !== "linear" && rt !== "cubic" || nt.length === 2 || nt.length === 4 && nt[0] === 1 && nt[1] === 1))
                        throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${ot ? "Resize" : "Upsample"} opeartor.`)
                }
            }
            ,
            2757: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.ProgramManager = void 0;
                const a = s(8453)
                  , _ = s(1315)
                  , $ = s(8897)
                  , _e = s(6757);
                i.ProgramManager = class {
                    constructor(tt, nt, rt) {
                        this.profiler = tt,
                        this.glContext = nt,
                        this.textureLayoutStrategy = rt,
                        this.repo = new Map,
                        this.attributesBound = !1
                    }
                    getArtifact(tt) {
                        return this.repo.get(tt)
                    }
                    setArtifact(tt, nt) {
                        this.repo.set(tt, nt)
                    }
                    run(tt, nt, rt) {
                        var ot;
                        this.profiler.event("op", `ProgramManager.run ${(ot = tt.programInfo.name) !== null && ot !== void 0 ? ot : "unknown kernel"}`, () => {
                            var et;
                            const j = this.glContext.gl
                              , it = tt.program;
                            j.useProgram(it);
                            try {
                                this.bindOutput(rt),
                                this.attributesBound || this.bindAttributes(tt.attribLocations),
                                this.bindUniforms(tt.uniformLocations, (et = tt.programInfo.variables) !== null && et !== void 0 ? et : [], nt)
                            } catch (st) {
                                throw _.Logger.error("ProgramManager", tt.programInfo.shaderSource),
                                st
                            }
                            this.profiler.event("backend", "GlContext.draw()", () => {
                                this.glContext.draw()
                            }
                            )
                        }
                        , this.glContext)
                    }
                    dispose() {
                        this.vertexShader && this.glContext.deleteShader(this.vertexShader),
                        this.repo.forEach(tt => this.glContext.deleteProgram(tt.program))
                    }
                    build(tt, nt, rt) {
                        return this.profiler.event("backend", "ProgramManager.build", () => {
                            const ot = new $.GlslPreprocessor(this.glContext,tt,nt,rt)
                              , et = ot.preprocess()
                              , j = this.compile(et);
                            return {
                                programInfo: tt,
                                program: j,
                                uniformLocations: this.getUniformLocations(j, ot.context.programInfo.inputNames, ot.context.programInfo.variables),
                                attribLocations: this.getAttribLocations(j)
                            }
                        }
                        )
                    }
                    compile(tt) {
                        if (!this.vertexShader) {
                            _.Logger.verbose("ProrgramManager", "Compiling and caching Vertex shader for the first time");
                            const ot = (0,
                            _e.getVertexShaderSource)(this.glContext.version);
                            this.vertexShader = this.glContext.compileShader(ot, this.glContext.gl.VERTEX_SHADER)
                        }
                        a.env.debug && _.Logger.verbose("ProrgramManager", `FragShader:
${tt}
`);
                        const nt = this.glContext.compileShader(tt, this.glContext.gl.FRAGMENT_SHADER)
                          , rt = this.glContext.createProgram(this.vertexShader, nt);
                        return this.glContext.deleteShader(nt),
                        rt
                    }
                    bindOutput(tt) {
                        const nt = tt.width
                          , rt = tt.height;
                        _.Logger.verbose("ProrgramManager", `Binding output texture to Framebuffer: w/h=${nt}/${rt}, shape=${tt.shape}, type=${tt.tensor.type}`),
                        this.glContext.attachFramebuffer(tt.texture, nt, rt)
                    }
                    bindAttributes(tt) {
                        const nt = tt.position
                          , rt = tt.textureCoord;
                        this.glContext.setVertexAttributes(nt, rt),
                        this.attributesBound = !0
                    }
                    bindUniforms(tt, nt, rt) {
                        var ot;
                        const et = this.glContext.gl;
                        let j = 0;
                        for (const {name: it, type: st, location: at, arrayLength: lt} of tt) {
                            const ct = (ot = nt.find(ut => ut.name === it)) === null || ot === void 0 ? void 0 : ot.data;
                            if (st !== "sampler2D" && !ct)
                                throw new Error(`variable '${it}' does not have data defined in program info`);
                            switch (st) {
                            case "sampler2D":
                                this.bindTexture(rt[j], at, j),
                                j++;
                                break;
                            case "float":
                                lt ? et.uniform1fv(at, ct) : et.uniform1f(at, ct);
                                break;
                            case "int":
                                lt ? et.uniform1iv(at, ct) : et.uniform1i(at, ct);
                                break;
                            default:
                                throw new Error(`Uniform not implemented: ${st}`)
                            }
                        }
                    }
                    bindTexture(tt, nt, rt) {
                        this.glContext.bindTextureToUniform(tt.texture, rt, nt)
                    }
                    getAttribLocations(tt) {
                        return {
                            position: this.getAttribLocation(tt, "position"),
                            textureCoord: this.getAttribLocation(tt, "textureCoord")
                        }
                    }
                    getUniformLocations(tt, nt, rt) {
                        const ot = [];
                        if (nt)
                            for (const et of nt)
                                ot.push({
                                    name: et,
                                    type: "sampler2D",
                                    location: this.getUniformLocation(tt, et)
                                });
                        if (rt)
                            for (const et of rt)
                                ot.push(Object.assign(Object.assign({}, et), {
                                    location: this.getUniformLocation(tt, et.name)
                                }));
                        return ot
                    }
                    getUniformLocation(tt, nt) {
                        const rt = this.glContext.gl.getUniformLocation(tt, nt);
                        if (rt === null)
                            throw new Error(`Uniform ${nt} not found.`);
                        return rt
                    }
                    getAttribLocation(tt, nt) {
                        return this.glContext.gl.getAttribLocation(tt, nt)
                    }
                }
            }
            ,
            2171: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.WebGLSessionHandler = void 0;
                const a = s(1315)
                  , _ = s(5881)
                  , $ = s(7860)
                  , _e = s(4110)
                  , tt = s(2757)
                  , nt = s(7618)
                  , rt = s(5243);
                i.WebGLSessionHandler = class {
                    constructor(ot, et) {
                        this.backend = ot,
                        this.context = et,
                        this.layoutStrategy = new nt.PreferLogicalStrategy(ot.glContext.maxTextureSize),
                        this.programManager = new tt.ProgramManager(this.context.profiler,ot.glContext,this.layoutStrategy),
                        this.textureManager = new rt.TextureManager(ot.glContext,this.layoutStrategy,this.context.profiler,{
                            reuseTextures: ot.textureCacheMode === "full"
                        }),
                        this.packedTextureDataCache = new Map,
                        this.unpackedTextureDataCache = new Map,
                        this.pack = ot.pack,
                        this.pack2unpackMap = new Map,
                        this.unpack2packMap = new Map
                    }
                    createInferenceHandler() {
                        return new $.WebGLInferenceHandler(this)
                    }
                    onGraphInitialized(ot) {
                        const et = ot.getValues().filter(j => j.from === -1 && j.tensor).map(j => j.tensor.dataId);
                        this.initializers = new Set(et)
                    }
                    isInitializer(ot) {
                        return !!this.initializers && this.initializers.has(ot)
                    }
                    addInitializer(ot) {
                        this.initializers.add(ot)
                    }
                    getTextureData(ot, et) {
                        return et ? this.packedTextureDataCache.get(ot) : this.unpackedTextureDataCache.get(ot)
                    }
                    setTextureData(ot, et, j=!1) {
                        a.Logger.verbose("WebGLSessionHandler", "Storing Texture data in cache"),
                        j ? this.packedTextureDataCache.set(ot, et) : this.unpackedTextureDataCache.set(ot, et)
                    }
                    dispose() {
                        this.programManager.dispose(),
                        this.textureManager.clearActiveTextures(),
                        this.packedTextureDataCache.forEach(ot => this.textureManager.releaseTexture(ot, !0)),
                        this.packedTextureDataCache = new Map,
                        this.unpackedTextureDataCache.forEach(ot => this.textureManager.releaseTexture(ot, !0)),
                        this.unpackedTextureDataCache = new Map
                    }
                    resolve(ot, et, j) {
                        const it = (0,
                        _.resolveOperator)(ot, et, _e.WEBGL_OP_RESOLVE_RULES);
                        return {
                            impl: it.opImpl,
                            context: it.opInit ? it.opInit(ot, j) : ot
                        }
                    }
                }
            }
            ,
            9622: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.Uint8DataEncoder = i.RGBAFloatDataEncoder = i.RedFloat32DataEncoder = void 0;
                const a = s(1315);
                i.RedFloat32DataEncoder = class {
                    constructor(_, $=1) {
                        if ($ === 1)
                            this.internalFormat = _.R32F,
                            this.format = _.RED,
                            this.textureType = _.FLOAT,
                            this.channelSize = $;
                        else {
                            if ($ !== 4)
                                throw new Error(`Invalid number of channels: ${$}`);
                            this.internalFormat = _.RGBA32F,
                            this.format = _.RGBA,
                            this.textureType = _.FLOAT,
                            this.channelSize = $
                        }
                    }
                    encode(_, $) {
                        let _e, tt;
                        return _.constructor !== Float32Array && (a.Logger.warning("Encoder", "data was not of type Float32; creating new Float32Array"),
                        tt = new Float32Array(_)),
                        $ * this.channelSize > _.length ? (a.Logger.warning("Encoder", "Source data too small. Allocating larger array"),
                        tt = _,
                        _e = this.allocate($ * this.channelSize),
                        tt.forEach( (nt, rt) => _e[rt] = nt)) : (tt = _,
                        _e = tt),
                        _e
                    }
                    allocate(_) {
                        return new Float32Array(4 * _)
                    }
                    decode(_, $) {
                        return this.channelSize === 1 ? _.filter( (_e, tt) => tt % 4 == 0).subarray(0, $) : _.subarray(0, $)
                    }
                }
                ,
                i.RGBAFloatDataEncoder = class {
                    constructor(_, $=1, _e) {
                        if ($ !== 1 && $ !== 4)
                            throw new Error(`Invalid number of channels: ${$}`);
                        this.internalFormat = _.RGBA,
                        this.format = _.RGBA,
                        this.channelSize = $,
                        this.textureType = _e || _.FLOAT
                    }
                    encode(_, $) {
                        let _e = _;
                        return this.channelSize === 1 && (a.Logger.verbose("Encoder", "Exploding into a larger array"),
                        _e = this.allocate($),
                        _.forEach( (tt, nt) => _e[4 * nt] = tt)),
                        _e
                    }
                    allocate(_) {
                        return new Float32Array(4 * _)
                    }
                    decode(_, $) {
                        return this.channelSize === 1 ? _.filter( (_e, tt) => tt % 4 == 0).subarray(0, $) : _.subarray(0, $)
                    }
                }
                ,
                i.Uint8DataEncoder = class {
                    constructor(_, $=1) {
                        if (this.channelSize = 4,
                        $ === 1)
                            this.internalFormat = _.ALPHA,
                            this.format = _.ALPHA,
                            this.textureType = _.UNSIGNED_BYTE,
                            this.channelSize = $;
                        else {
                            if ($ !== 4)
                                throw new Error(`Invalid number of channels: ${$}`);
                            this.internalFormat = _.RGBA,
                            this.format = _.RGBA,
                            this.textureType = _.UNSIGNED_BYTE,
                            this.channelSize = $
                        }
                    }
                    encode(_, $) {
                        return new Uint8Array(_.buffer,_.byteOffset,_.byteLength)
                    }
                    allocate(_) {
                        return new Uint8Array(_ * this.channelSize)
                    }
                    decode(_, $) {
                        if (_ instanceof Uint8Array)
                            return _.subarray(0, $);
                        throw new Error(`Invalid array type: ${_.constructor}`)
                    }
                }
            }
            ,
            7618: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.getBatchDim = i.sizeToSquarishShape = i.getRowsCols = i.sizeFromShape = i.isInt = i.parseAxisParam = i.squeezeShape = i.PreferLogicalStrategy = i.AlwaysKeepOriginalSizeStrategy = void 0;
                const a = s(1315)
                  , _ = s(7273);
                function $(ot, et) {
                    const j = []
                      , it = []
                      , st = et != null && Array.isArray(et) && et.length === 0
                      , at = et == null || st ? null : _e(et, ot).sort();
                    let lt = 0;
                    for (let ct = 0; ct < ot.length; ++ct) {
                        if (at != null) {
                            if (at[lt] === ct && ot[ct] !== 1)
                                throw new Error(`Can't squeeze axis ${ct} since its dim '${ot[ct]}' is not 1`);
                            (at[lt] == null || at[lt] > ct) && ot[ct] === 1 && (j.push(ot[ct]),
                            it.push(ct)),
                            at[lt] <= ct && lt++
                        }
                        ot[ct] !== 1 && (j.push(ot[ct]),
                        it.push(ct))
                    }
                    return {
                        newShape: j,
                        keptDims: it
                    }
                }
                function _e(ot, et) {
                    const j = et.length;
                    return ot = ot == null ? et.map( (it, st) => st) : [].concat(ot),
                    (0,
                    _.assert)(ot.every(it => it >= -j && it < j), () => `All values in axis param must be in range [-${j}, ${j}) but got axis ${ot}`),
                    (0,
                    _.assert)(ot.every(tt), () => `All values in axis param must be integers but got axis ${ot}`),
                    ot.map(it => it < 0 ? j + it : it)
                }
                function tt(ot) {
                    return ot % 1 == 0
                }
                function nt(ot) {
                    if (ot.length === 0)
                        return 1;
                    let et = ot[0];
                    for (let j = 1; j < ot.length; j++)
                        et *= ot[j];
                    return et
                }
                function rt(ot) {
                    const et = Math.ceil(Math.sqrt(ot));
                    return [et, Math.ceil(ot / et)]
                }
                i.AlwaysKeepOriginalSizeStrategy = class {
                    constructor(ot) {
                        this.maxTextureSize = ot
                    }
                    computeTextureWH(ot, et) {
                        if (ot.length === 0)
                            return [1, 1];
                        const j = this.maxTextureSize;
                        if (et && et.breakAxis !== void 0) {
                            const at = et.breakAxis >= ot.length ? 1 : ot.slice(et.breakAxis).reduce( (ct, ut) => ct * ut)
                              , lt = et.breakAxis <= 0 ? 1 : ot.slice(0, et.breakAxis).reduce( (ct, ut) => ct * ut);
                            if (!(at > j || lt > j))
                                return [at, lt];
                            a.Logger.verbose("TextureLayout", `Given width/height preferences were unattainable: shape:${ot}, breakAxis:${et.breakAxis}`)
                        }
                        const it = ot.reduce( (at, lt) => at * lt);
                        let st = Math.floor(Math.sqrt(it));
                        for (; st < j && st < it && it % st != 0; st++)
                            ;
                        if (st >= j || it % st != 0)
                            throw new Error(`The given dimensions are outside this GPU's boundaries: ${ot}`);
                        return [st, it / st]
                    }
                }
                ,
                i.PreferLogicalStrategy = class {
                    constructor(ot) {
                        this.maxTextureSize = ot
                    }
                    computeTextureWH(ot, et) {
                        const j = this.computeTexture(ot, et);
                        return et && et.isPacked && (j[0] /= 2,
                        j[1] /= 2),
                        et && et.reverseWH ? [j[1], j[0]] : j
                    }
                    computeTexture(ot, et) {
                        const j = et && et.isPacked;
                        if (ot.length === 0)
                            return j ? [2, 2] : [1, 1];
                        let it = this.maxTextureSize;
                        if (et && et.breakAxis !== void 0) {
                            const lt = et.breakAxis >= ot.length ? 1 : ot.slice(et.breakAxis).reduce( (ut, dt) => ut * dt)
                              , ct = et.breakAxis <= 0 ? 1 : ot.slice(0, et.breakAxis).reduce( (ut, dt) => ut * dt);
                            if (!(lt > it || ct > it))
                                return [lt, ct];
                            a.Logger.verbose("TextureLayout", `Given width/height preferences were unattainable: shape:${ot}, breakAxis:${et.breakAxis}`)
                        }
                        let st = ot.slice(0);
                        j && (it *= 2,
                        st = st.map( (lt, ct) => ct >= st.length - 2 ? st[ct] % 2 == 0 ? st[ct] : st[ct] + 1 : st[ct]),
                        st.length === 1 && (st = [2, st[0]])),
                        st.length !== 2 && (st = $(st).newShape);
                        const at = nt(st);
                        return st.length <= 1 && at <= it ? [1, at] : st.length === 2 && st[0] <= it && st[1] <= it ? st : st.length === 3 && st[0] * st[1] <= it && st[2] <= it ? [st[0] * st[1], st[2]] : st.length === 3 && st[0] <= it && st[1] * st[2] <= it ? [st[0], st[1] * st[2]] : st.length === 4 && st[0] * st[1] * st[2] <= it && st[3] <= it ? [st[0] * st[1] * st[2], st[3]] : st.length === 4 && st[0] <= it && st[1] * st[2] * st[3] <= it ? [st[0], st[1] * st[2] * st[3]] : j ? rt(at / 4).map(lt => 2 * lt) : rt(at)
                    }
                }
                ,
                i.squeezeShape = $,
                i.parseAxisParam = _e,
                i.isInt = tt,
                i.sizeFromShape = nt,
                i.getRowsCols = function(ot) {
                    if (ot.length === 0)
                        throw Error("Cannot get rows and columns of an empty shape array.");
                    return [ot.length > 1 ? ot[ot.length - 2] : 1, ot[ot.length - 1]]
                }
                ,
                i.sizeToSquarishShape = rt,
                i.getBatchDim = function(ot, et=2) {
                    return nt(ot.slice(0, ot.length - et))
                }
            }
            ,
            3314: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.createTextureLayoutFromShape = i.calculateTextureWidthAndHeight = i.createTextureLayoutFromTextureType = void 0;
                const a = s(7273)
                  , _ = s(5639);
                i.createTextureLayoutFromTextureType = ($, _e, tt) => {
                    const nt = tt === _.TextureType.unpacked || tt === _.TextureType.unpackedReversed ? 1 : 4
                      , rt = tt === _.TextureType.packed
                      , ot = tt === _.TextureType.unpackedReversed || tt === _.TextureType.packed
                      , et = tt === _.TextureType.packedLastDimension ? _e.length - 1 : void 0
                      , j = tt === _.TextureType.packedLastDimension ? _e.map( (it, st) => st === _e.length - 1 ? 4 * it : it) : void 0;
                    return (0,
                    i.createTextureLayoutFromShape)($, _e, nt, j, {
                        isPacked: rt,
                        reverseWH: ot,
                        breakAxis: et
                    })
                }
                ,
                i.calculateTextureWidthAndHeight = ($, _e, tt) => {
                    const nt = (0,
                    i.createTextureLayoutFromTextureType)($, _e, tt);
                    return [nt.width, nt.height]
                }
                ,
                i.createTextureLayoutFromShape = ($, _e, tt=1, nt, rt) => {
                    const ot = !(!rt || !rt.isPacked)
                      , [et,j] = $.computeTextureWH(ot && nt || _e, rt)
                      , it = _e.length;
                    let st = _e.slice(0);
                    if (it === 0 && (st = [1]),
                    tt === 1)
                        nt = _e;
                    else if (ot) {
                        if (tt !== 4)
                            throw new Error("a packed texture must be 4-channel");
                        nt = _e,
                        it > 0 && (st[it - 1] = Math.ceil(st[it - 1] / 2)),
                        it > 1 && (st[it - 2] = Math.ceil(st[it - 2] / 2))
                    } else if (!nt)
                        throw new Error("Unpacked shape is needed when using channels > 1");
                    return {
                        width: et,
                        height: j,
                        channels: tt,
                        isPacked: ot,
                        shape: st,
                        strides: a.ShapeUtil.computeStrides(st),
                        unpackedShape: nt,
                        reversedWH: rt && rt.reverseWH
                    }
                }
            }
            ,
            5243: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.TextureManager = void 0;
                const a = s(1315);
                i.TextureManager = class {
                    constructor(_, $, _e, tt) {
                        this.glContext = _,
                        this.layoutStrategy = $,
                        this.profiler = _e,
                        this.config = tt,
                        this.pendingRead = new Map,
                        tt.reuseTextures && (this.inUseTextures = new Map,
                        this.idleTextures = new Map,
                        this.textureLookup = new Map)
                    }
                    createTextureFromLayout(_, $, _e, tt) {
                        const nt = this.toEncoderType(_)
                          , rt = this.glContext.getEncoder(nt, $.channels || 1, tt);
                        if ($.isPacked && tt === 1)
                            throw new Error("not implemented");
                        const ot = $.width
                          , et = $.height;
                        let j, it;
                        if (this.config.reuseTextures) {
                            j = `${ot}x${et}_${rt.format}_${rt.internalFormat}_${rt.textureType}`,
                            it = this.inUseTextures.get(j),
                            it || (it = [],
                            this.inUseTextures.set(j, it));
                            const at = this.idleTextures.get(j);
                            if (at && at.length > 0) {
                                const lt = at.pop();
                                return it.push(lt),
                                tt === 1 && this.glContext.updateTexture(lt, ot, et, rt, this.toTextureData(_, _e)),
                                lt
                            }
                        }
                        a.Logger.verbose("TextureManager", `Creating new texture of size ${$.width}x${$.height}`);
                        const st = this.glContext.allocateTexture(ot, et, rt, this.toTextureData(_, _e));
                        return this.config.reuseTextures && (it.push(st),
                        this.textureLookup.set(st, j)),
                        st
                    }
                    readTexture(_, $, _e) {
                        return _e || (_e = 1),
                        this.profiler.event("backend", "TextureManager.readTexture", () => {
                            const tt = _.shape.reduce( (rt, ot) => rt * ot) * _e
                              , nt = this.glContext.readTexture(_.texture, _.width, _.height, tt, this.toEncoderType($), _e);
                            return this.toTensorData($, nt)
                        }
                        )
                    }
                    async readTextureAsync(_, $, _e) {
                        const tt = _.tensor.dataId;
                        if (_e || (_e = 1),
                        this.pendingRead.has(tt)) {
                            const nt = this.pendingRead.get(tt);
                            return new Promise(rt => nt == null ? void 0 : nt.push(rt))
                        }
                        return this.profiler.event("backend", "TextureManager.readTextureAsync", async () => {
                            this.pendingRead.set(tt, []);
                            const nt = _.shape.reduce( (j, it) => j * it) * _e;
                            await this.glContext.createAndWaitForFence();
                            const rt = this.glContext.readTexture(_.texture, _.width, _.height, nt, this.toEncoderType($), _e)
                              , ot = this.toTensorData($, rt)
                              , et = this.pendingRead.get(tt);
                            return this.pendingRead.delete(tt),
                            et == null || et.forEach(j => j(ot)),
                            ot
                        }
                        )
                    }
                    readUint8TextureAsFloat(_) {
                        return this.profiler.event("backend", "TextureManager.readUint8TextureAsFloat", () => {
                            const $ = _.shape.reduce( (tt, nt) => tt * nt)
                              , _e = this.glContext.readTexture(_.texture, _.width, _.height, 4 * $, "byte", 4);
                            return new Float32Array(_e.buffer,_e.byteOffset,$)
                        }
                        )
                    }
                    releaseTexture(_, $) {
                        let _e;
                        if (this.config.reuseTextures && (_e = this.textureLookup.get(_.texture),
                        _e)) {
                            $ && this.textureLookup.delete(_e);
                            const tt = this.inUseTextures.get(_e);
                            if (tt) {
                                const nt = tt.indexOf(_.texture);
                                if (nt !== -1) {
                                    tt.splice(nt, 1);
                                    let rt = this.idleTextures.get(_e);
                                    rt || (rt = [],
                                    this.idleTextures.set(_e, rt)),
                                    rt.push(_.texture)
                                }
                            }
                        }
                        _e && !$ || (a.Logger.verbose("TextureManager", `Deleting texture of size ${_.width}x${_.height}`),
                        this.glContext.deleteTexture(_.texture))
                    }
                    toTensorData(_, $) {
                        switch (_) {
                        case "int16":
                            return $ instanceof Int16Array ? $ : Int16Array.from($);
                        case "int32":
                            return $ instanceof Int32Array ? $ : Int32Array.from($);
                        case "int8":
                            return $ instanceof Int8Array ? $ : Int8Array.from($);
                        case "uint16":
                            return $ instanceof Uint16Array ? $ : Uint16Array.from($);
                        case "uint32":
                            return $ instanceof Uint32Array ? $ : Uint32Array.from($);
                        case "uint8":
                        case "bool":
                            return $ instanceof Uint8Array ? $ : Uint8Array.from($);
                        case "float32":
                            return $ instanceof Float32Array ? $ : Float32Array.from($);
                        case "float64":
                            return $ instanceof Float64Array ? $ : Float64Array.from($);
                        default:
                            throw new Error(`TensorData type ${_} is not supported`)
                        }
                    }
                    toTextureData(_, $) {
                        if ($)
                            return $ instanceof Float32Array ? $ : new Float32Array($)
                    }
                    toEncoderType(_) {
                        return "float"
                    }
                    clearActiveTextures() {
                        this.glContext.clearActiveTextures()
                    }
                }
            }
            ,
            5639: (o, i) => {
                var s;
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.TextureType = void 0,
                (s = i.TextureType || (i.TextureType = {}))[s.unpacked = 0] = "unpacked",
                s[s.unpackedReversed = 1] = "unpackedReversed",
                s[s.packed = 2] = "packed",
                s[s.downloadUint8AsFloat = 3] = "downloadUint8AsFloat",
                s[s.packedLastDimension = 4] = "packedLastDimension"
            }
            ,
            432: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.getGlChannels = i.getCoordsDataType = i.getSqueezedParams = i.squeezeInputShape = i.generateShaderFuncNameFromInputSamplerNameAtOutCoords = i.generateShaderFuncNameFromInputSamplerName = i.repeatedTry = i.getPackedShape = void 0;
                const a = s(7273);
                i.getPackedShape = function(_) {
                    const $ = _.length;
                    return _.slice(0, $ - 1).concat(_[$ - 1] / 4)
                }
                ,
                i.repeatedTry = async function(_, $=tt => 0, _e) {
                    return new Promise( (tt, nt) => {
                        let rt = 0;
                        const ot = () => {
                            if (_())
                                return void tt();
                            rt++;
                            const et = $(rt);
                            _e != null && rt >= _e ? nt() : setTimeout(ot, et)
                        }
                        ;
                        ot()
                    }
                    )
                }
                ,
                i.generateShaderFuncNameFromInputSamplerName = function(_) {
                    return (0,
                    a.assert)(_ !== void 0 && _.length !== 0, () => "empty string found for sampler name"),
                    "get" + _.charAt(0).toUpperCase() + _.slice(1)
                }
                ,
                i.generateShaderFuncNameFromInputSamplerNameAtOutCoords = function(_) {
                    return (0,
                    a.assert)(_ !== void 0 && _.length !== 0, () => "empty string found for sampler name"),
                    "get" + _.charAt(0).toUpperCase() + _.slice(1) + "AtOutCoords"
                }
                ,
                i.squeezeInputShape = function(_, $) {
                    let _e = JSON.parse(JSON.stringify(_));
                    return _e = $,
                    _e
                }
                ,
                i.getSqueezedParams = function(_, $) {
                    return $.map(_e => _[_e]).join(", ")
                }
                ,
                i.getCoordsDataType = function(_) {
                    if (_ <= 1)
                        return "int";
                    if (_ === 2)
                        return "ivec2";
                    if (_ === 3)
                        return "ivec3";
                    if (_ === 4)
                        return "ivec4";
                    if (_ === 5)
                        return "ivec5";
                    if (_ === 6)
                        return "ivec6";
                    throw Error(`GPU for rank ${_} is not yet supported`)
                }
                ,
                i.getGlChannels = function(_=6) {
                    return ["x", "y", "z", "w", "u", "v"].slice(0, _)
                }
            }
            ,
            3389: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.createNewWebGLContext = i.createWebGLContext = void 0;
                const a = s(1315)
                  , _ = s(3524)
                  , $ = {};
                function _e(tt) {
                    const nt = function() {
                        if (typeof document > "u") {
                            if (typeof OffscreenCanvas > "u")
                                throw new TypeError("failed to create canvas: OffscreenCanvas is not supported");
                            return new OffscreenCanvas(1,1)
                        }
                        const et = document.createElement("canvas");
                        return et.width = 1,
                        et.height = 1,
                        et
                    }();
                    let rt;
                    const ot = {
                        alpha: !1,
                        depth: !1,
                        antialias: !1,
                        stencil: !1,
                        preserveDrawingBuffer: !1,
                        premultipliedAlpha: !1,
                        failIfMajorPerformanceCaveat: !1
                    };
                    if ((!tt || tt === "webgl2") && (rt = nt.getContext("webgl2", ot),
                    rt))
                        try {
                            return new _.WebGLContext(rt,2)
                        } catch (et) {
                            a.Logger.warning("GlContextFactory", `failed to create WebGLContext using contextId 'webgl2'. Error: ${et}`)
                        }
                    if ((!tt || tt === "webgl") && (rt = nt.getContext("webgl", ot) || nt.getContext("experimental-webgl", ot),
                    rt))
                        try {
                            return new _.WebGLContext(rt,1)
                        } catch (et) {
                            a.Logger.warning("GlContextFactory", `failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${et}`)
                        }
                    throw new Error("WebGL is not supported")
                }
                i.createWebGLContext = function tt(nt) {
                    let rt;
                    nt && nt !== "webgl2" || !("webgl2"in $) ? nt && nt !== "webgl" || !("webgl"in $) || (rt = $.webgl) : rt = $.webgl2,
                    rt = rt || _e(nt),
                    nt = nt || rt.version === 1 ? "webgl" : "webgl2";
                    const ot = rt.gl;
                    return $[nt] = rt,
                    ot.isContextLost() ? (delete $[nt],
                    tt(nt)) : (ot.disable(ot.DEPTH_TEST),
                    ot.disable(ot.STENCIL_TEST),
                    ot.disable(ot.BLEND),
                    ot.disable(ot.DITHER),
                    ot.disable(ot.POLYGON_OFFSET_FILL),
                    ot.disable(ot.SAMPLE_COVERAGE),
                    ot.enable(ot.SCISSOR_TEST),
                    ot.enable(ot.CULL_FACE),
                    ot.cullFace(ot.BACK),
                    rt)
                }
                ,
                i.createNewWebGLContext = _e
            }
            ,
            3524: function(o, i, s) {
                var a = this && this.__createBinding || (Object.create ? function(ot, et, j, it) {
                    it === void 0 && (it = j);
                    var st = Object.getOwnPropertyDescriptor(et, j);
                    st && !("get"in st ? !et.__esModule : st.writable || st.configurable) || (st = {
                        enumerable: !0,
                        get: function() {
                            return et[j]
                        }
                    }),
                    Object.defineProperty(ot, it, st)
                }
                : function(ot, et, j, it) {
                    it === void 0 && (it = j),
                    ot[it] = et[j]
                }
                )
                  , _ = this && this.__setModuleDefault || (Object.create ? function(ot, et) {
                    Object.defineProperty(ot, "default", {
                        enumerable: !0,
                        value: et
                    })
                }
                : function(ot, et) {
                    ot.default = et
                }
                )
                  , $ = this && this.__importStar || function(ot) {
                    if (ot && ot.__esModule)
                        return ot;
                    var et = {};
                    if (ot != null)
                        for (var j in ot)
                            j !== "default" && Object.prototype.hasOwnProperty.call(ot, j) && a(et, ot, j);
                    return _(et, ot),
                    et
                }
                ;
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.WebGLContext = i.linearSearchLastTrue = void 0;
                const _e = s(8453)
                  , tt = $(s(9622))
                  , nt = s(432);
                function rt(ot) {
                    let et = 0;
                    for (; et < ot.length && ot[et](); ++et)
                        ;
                    return et - 1
                }
                i.linearSearchLastTrue = rt,
                i.WebGLContext = class {
                    constructor(ot, et) {
                        this.frameBufferBound = !1,
                        this.itemsToPoll = [],
                        this.gl = ot,
                        this.version = et,
                        this.getExtensions(),
                        this.vertexbuffer = this.createVertexbuffer(),
                        this.framebuffer = this.createFramebuffer(),
                        this.queryVitalParameters()
                    }
                    allocateTexture(ot, et, j, it) {
                        const st = this.gl
                          , at = st.createTexture();
                        st.bindTexture(st.TEXTURE_2D, at),
                        st.texParameteri(st.TEXTURE_2D, st.TEXTURE_MIN_FILTER, st.NEAREST),
                        st.texParameteri(st.TEXTURE_2D, st.TEXTURE_MAG_FILTER, st.NEAREST),
                        st.texParameteri(st.TEXTURE_2D, st.TEXTURE_WRAP_S, st.CLAMP_TO_EDGE),
                        st.texParameteri(st.TEXTURE_2D, st.TEXTURE_WRAP_T, st.CLAMP_TO_EDGE);
                        const lt = it ? j.encode(it, ot * et) : null;
                        return st.texImage2D(st.TEXTURE_2D, 0, j.internalFormat, ot, et, 0, j.format, j.textureType, lt),
                        this.checkError(),
                        at
                    }
                    updateTexture(ot, et, j, it, st) {
                        const at = this.gl;
                        at.bindTexture(at.TEXTURE_2D, ot);
                        const lt = it.encode(st, et * j);
                        at.texSubImage2D(at.TEXTURE_2D, 0, 0, 0, et, j, it.format, it.textureType, lt),
                        this.checkError()
                    }
                    attachFramebuffer(ot, et, j) {
                        const it = this.gl;
                        it.bindTexture(it.TEXTURE_2D, ot),
                        it.bindFramebuffer(it.FRAMEBUFFER, this.framebuffer),
                        it.framebufferTexture2D(it.FRAMEBUFFER, it.COLOR_ATTACHMENT0, it.TEXTURE_2D, ot, 0),
                        this.checkError(),
                        it.viewport(0, 0, et, j),
                        it.scissor(0, 0, et, j)
                    }
                    readTexture(ot, et, j, it, st, at) {
                        const lt = this.gl;
                        at || (at = 1),
                        this.frameBufferBound || this.attachFramebuffer(ot, et, j);
                        const ct = this.getEncoder(st, at)
                          , ut = ct.allocate(et * j);
                        return lt.bindTexture(lt.TEXTURE_2D, ot),
                        lt.framebufferTexture2D(lt.FRAMEBUFFER, lt.COLOR_ATTACHMENT0, lt.TEXTURE_2D, ot, 0),
                        lt.readPixels(0, 0, et, j, lt.RGBA, ct.textureType, ut),
                        this.checkError(),
                        ct.decode(ut, it)
                    }
                    isFramebufferReady() {
                        return !0
                    }
                    getActiveTexture() {
                        const ot = this.gl;
                        return "TEXTURE" + (ot.getParameter(this.gl.ACTIVE_TEXTURE) - ot.TEXTURE0)
                    }
                    getTextureBinding() {
                        return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D)
                    }
                    getFramebufferBinding() {
                        return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING)
                    }
                    setVertexAttributes(ot, et) {
                        const j = this.gl;
                        j.vertexAttribPointer(ot, 3, j.FLOAT, !1, 20, 0),
                        j.enableVertexAttribArray(ot),
                        et !== -1 && (j.vertexAttribPointer(et, 2, j.FLOAT, !1, 20, 12),
                        j.enableVertexAttribArray(et)),
                        this.checkError()
                    }
                    createProgram(ot, et) {
                        const j = this.gl
                          , it = j.createProgram();
                        return j.attachShader(it, ot),
                        j.attachShader(it, et),
                        j.linkProgram(it),
                        it
                    }
                    compileShader(ot, et) {
                        const j = this.gl
                          , it = j.createShader(et);
                        if (!it)
                            throw new Error(`createShader() returned null with type ${et}`);
                        if (j.shaderSource(it, ot),
                        j.compileShader(it),
                        j.getShaderParameter(it, j.COMPILE_STATUS) === !1)
                            throw new Error(`Failed to compile shader: ${j.getShaderInfoLog(it)}
Shader source:
${ot}`);
                        return it
                    }
                    deleteShader(ot) {
                        this.gl.deleteShader(ot)
                    }
                    bindTextureToUniform(ot, et, j) {
                        const it = this.gl;
                        it.activeTexture(it.TEXTURE0 + et),
                        this.checkError(),
                        it.bindTexture(it.TEXTURE_2D, ot),
                        this.checkError(),
                        it.uniform1i(j, et),
                        this.checkError()
                    }
                    draw() {
                        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4),
                        this.checkError()
                    }
                    checkError() {
                        if (_e.env.debug) {
                            const ot = this.gl
                              , et = ot.getError();
                            let j = "";
                            switch (et) {
                            case ot.NO_ERROR:
                                return;
                            case ot.INVALID_ENUM:
                                j = "INVALID_ENUM";
                                break;
                            case ot.INVALID_VALUE:
                                j = "INVALID_VALUE";
                                break;
                            case ot.INVALID_OPERATION:
                                j = "INVALID_OPERATION";
                                break;
                            case ot.INVALID_FRAMEBUFFER_OPERATION:
                                j = "INVALID_FRAMEBUFFER_OPERATION";
                                break;
                            case ot.OUT_OF_MEMORY:
                                j = "OUT_OF_MEMORY";
                                break;
                            case ot.CONTEXT_LOST_WEBGL:
                                j = "CONTEXT_LOST_WEBGL";
                                break;
                            default:
                                j = `Unknown WebGL Error: ${et.toString(16)}`
                            }
                            throw new Error(j)
                        }
                    }
                    deleteTexture(ot) {
                        this.gl.deleteTexture(ot)
                    }
                    deleteProgram(ot) {
                        this.gl.deleteProgram(ot)
                    }
                    getEncoder(ot, et, j=0) {
                        if (this.version === 2)
                            return new tt.RedFloat32DataEncoder(this.gl,et);
                        switch (ot) {
                        case "float":
                            return j === 1 || this.isRenderFloat32Supported ? new tt.RGBAFloatDataEncoder(this.gl,et) : new tt.RGBAFloatDataEncoder(this.gl,et,this.textureHalfFloatExtension.HALF_FLOAT_OES);
                        case "int":
                            throw new Error("not implemented");
                        case "byte":
                            return new tt.Uint8DataEncoder(this.gl,et);
                        default:
                            throw new Error(`Invalid dataType: ${ot}`)
                        }
                    }
                    clearActiveTextures() {
                        const ot = this.gl;
                        for (let et = 0; et < this.maxTextureImageUnits; ++et)
                            ot.activeTexture(ot.TEXTURE0 + et),
                            ot.bindTexture(ot.TEXTURE_2D, null)
                    }
                    dispose() {
                        if (this.disposed)
                            return;
                        const ot = this.gl;
                        ot.bindFramebuffer(ot.FRAMEBUFFER, null),
                        ot.deleteFramebuffer(this.framebuffer),
                        ot.bindBuffer(ot.ARRAY_BUFFER, null),
                        ot.deleteBuffer(this.vertexbuffer),
                        ot.bindBuffer(ot.ELEMENT_ARRAY_BUFFER, null),
                        ot.finish(),
                        this.disposed = !0
                    }
                    createDefaultGeometry() {
                        return new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0])
                    }
                    createVertexbuffer() {
                        const ot = this.gl
                          , et = ot.createBuffer();
                        if (!et)
                            throw new Error("createBuffer() returned null");
                        const j = this.createDefaultGeometry();
                        return ot.bindBuffer(ot.ARRAY_BUFFER, et),
                        ot.bufferData(ot.ARRAY_BUFFER, j, ot.STATIC_DRAW),
                        this.checkError(),
                        et
                    }
                    createFramebuffer() {
                        const ot = this.gl.createFramebuffer();
                        if (!ot)
                            throw new Error("createFramebuffer returned null");
                        return ot
                    }
                    queryVitalParameters() {
                        const ot = this.gl;
                        if (this.isFloatTextureAttachableToFrameBuffer = this.checkFloatTextureAttachableToFrameBuffer(),
                        this.isRenderFloat32Supported = this.checkRenderFloat32(),
                        this.isFloat32DownloadSupported = this.checkFloat32Download(),
                        this.version === 1 && !this.textureHalfFloatExtension && !this.isRenderFloat32Supported)
                            throw new Error("both float32 and float16 TextureType are not supported");
                        this.isBlendSupported = !this.isRenderFloat32Supported || this.checkFloat32Blend(),
                        this.maxTextureSize = ot.getParameter(ot.MAX_TEXTURE_SIZE),
                        this.maxTextureImageUnits = ot.getParameter(ot.MAX_TEXTURE_IMAGE_UNITS),
                        this.version
                    }
                    getExtensions() {
                        this.version === 2 ? (this.colorBufferFloatExtension = this.gl.getExtension("EXT_color_buffer_float"),
                        this.disjointTimerQueryWebgl2Extension = this.gl.getExtension("EXT_disjoint_timer_query_webgl2")) : (this.textureFloatExtension = this.gl.getExtension("OES_texture_float"),
                        this.textureHalfFloatExtension = this.gl.getExtension("OES_texture_half_float"))
                    }
                    checkFloatTextureAttachableToFrameBuffer() {
                        const ot = this.gl
                          , et = ot.createTexture();
                        ot.bindTexture(ot.TEXTURE_2D, et);
                        const j = this.version === 2 ? ot.RGBA32F : ot.RGBA;
                        ot.texImage2D(ot.TEXTURE_2D, 0, j, 1, 1, 0, ot.RGBA, ot.FLOAT, null);
                        const it = ot.createFramebuffer();
                        ot.bindFramebuffer(ot.FRAMEBUFFER, it),
                        ot.framebufferTexture2D(ot.FRAMEBUFFER, ot.COLOR_ATTACHMENT0, ot.TEXTURE_2D, et, 0);
                        const st = ot.checkFramebufferStatus(ot.FRAMEBUFFER) === ot.FRAMEBUFFER_COMPLETE;
                        return ot.bindTexture(ot.TEXTURE_2D, null),
                        ot.bindFramebuffer(ot.FRAMEBUFFER, null),
                        ot.deleteTexture(et),
                        ot.deleteFramebuffer(it),
                        st
                    }
                    checkRenderFloat32() {
                        if (this.version === 2) {
                            if (!this.colorBufferFloatExtension)
                                return !1
                        } else if (!this.textureFloatExtension)
                            return !1;
                        return this.isFloatTextureAttachableToFrameBuffer
                    }
                    checkFloat32Download() {
                        if (this.version === 2) {
                            if (!this.colorBufferFloatExtension)
                                return !1
                        } else if (!this.textureFloatExtension || !this.gl.getExtension("WEBGL_color_buffer_float"))
                            return !1;
                        return this.isFloatTextureAttachableToFrameBuffer
                    }
                    checkFloat32Blend() {
                        const ot = this.gl;
                        let et, j, it, st, at;
                        try {
                            et = ot.createTexture(),
                            j = ot.createFramebuffer(),
                            ot.bindTexture(ot.TEXTURE_2D, et);
                            const lt = this.version === 2 ? ot.RGBA32F : ot.RGBA;
                            return ot.texImage2D(ot.TEXTURE_2D, 0, lt, 1, 1, 0, ot.RGBA, ot.FLOAT, null),
                            ot.bindFramebuffer(ot.FRAMEBUFFER, j),
                            ot.framebufferTexture2D(ot.FRAMEBUFFER, ot.COLOR_ATTACHMENT0, ot.TEXTURE_2D, et, 0),
                            ot.enable(ot.BLEND),
                            it = ot.createShader(ot.VERTEX_SHADER),
                            !!it && (ot.shaderSource(it, "void main(){}"),
                            ot.compileShader(it),
                            st = ot.createShader(ot.FRAGMENT_SHADER),
                            !!st && (ot.shaderSource(st, "precision highp float;void main(){gl_FragColor=vec4(0.5);}"),
                            ot.compileShader(st),
                            at = ot.createProgram(),
                            !!at && (ot.attachShader(at, it),
                            ot.attachShader(at, st),
                            ot.linkProgram(at),
                            ot.useProgram(at),
                            ot.drawArrays(ot.POINTS, 0, 1),
                            ot.getError() === ot.NO_ERROR)))
                        } finally {
                            ot.disable(ot.BLEND),
                            at && ot.deleteProgram(at),
                            it && ot.deleteShader(it),
                            st && ot.deleteShader(st),
                            j && (ot.bindFramebuffer(ot.FRAMEBUFFER, null),
                            ot.deleteFramebuffer(j)),
                            et && (ot.bindTexture(ot.TEXTURE_2D, null),
                            ot.deleteTexture(et))
                        }
                    }
                    beginTimer() {
                        if (this.version === 2 && this.disjointTimerQueryWebgl2Extension) {
                            const ot = this.gl
                              , et = this.disjointTimerQueryWebgl2Extension
                              , j = ot.createQuery();
                            return ot.beginQuery(et.TIME_ELAPSED_EXT, j),
                            j
                        }
                        throw new Error("WebGL1 profiling currently not supported.")
                    }
                    endTimer() {
                        if (this.version !== 2 || !this.disjointTimerQueryWebgl2Extension)
                            throw new Error("WebGL1 profiling currently not supported");
                        {
                            const ot = this.gl
                              , et = this.disjointTimerQueryWebgl2Extension;
                            ot.endQuery(et.TIME_ELAPSED_EXT)
                        }
                    }
                    isTimerResultAvailable(ot) {
                        let et = !1
                          , j = !1;
                        if (this.version !== 2 || !this.disjointTimerQueryWebgl2Extension)
                            throw new Error("WebGL1 profiling currently not supported");
                        {
                            const it = this.gl
                              , st = this.disjointTimerQueryWebgl2Extension;
                            et = it.getQueryParameter(ot, it.QUERY_RESULT_AVAILABLE),
                            j = it.getParameter(st.GPU_DISJOINT_EXT)
                        }
                        return et && !j
                    }
                    getTimerResult(ot) {
                        let et = 0;
                        if (this.version !== 2)
                            throw new Error("WebGL1 profiling currently not supported");
                        {
                            const j = this.gl;
                            et = j.getQueryParameter(ot, j.QUERY_RESULT),
                            j.deleteQuery(ot)
                        }
                        return et / 1e6
                    }
                    async waitForQueryAndGetTime(ot) {
                        return await (0,
                        nt.repeatedTry)( () => this.isTimerResultAvailable(ot)),
                        this.getTimerResult(ot)
                    }
                    async createAndWaitForFence() {
                        const ot = this.createFence(this.gl);
                        return this.pollFence(ot)
                    }
                    createFence(ot) {
                        let et;
                        const j = ot
                          , it = j.fenceSync(j.SYNC_GPU_COMMANDS_COMPLETE, 0);
                        return ot.flush(),
                        et = it === null ? () => !0 : () => {
                            const st = j.clientWaitSync(it, 0, 0);
                            return st === j.ALREADY_SIGNALED || st === j.CONDITION_SATISFIED
                        }
                        ,
                        {
                            query: it,
                            isFencePassed: et
                        }
                    }
                    async pollFence(ot) {
                        return new Promise(et => {
                            this.addItemToPoll( () => ot.isFencePassed(), () => et())
                        }
                        )
                    }
                    pollItems() {
                        const ot = rt(this.itemsToPoll.map(et => et.isDoneFn));
                        for (let et = 0; et <= ot; ++et) {
                            const {resolveFn: j} = this.itemsToPoll[et];
                            j()
                        }
                        this.itemsToPoll = this.itemsToPoll.slice(ot + 1)
                    }
                    async addItemToPoll(ot, et) {
                        this.itemsToPoll.push({
                            isDoneFn: ot,
                            resolveFn: et
                        }),
                        this.itemsToPoll.length > 1 || await (0,
                        nt.repeatedTry)( () => (this.pollItems(),
                        this.itemsToPoll.length === 0))
                    }
                }
            },
            6496: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.ExecutionPlan = void 0;
                const a = s(1315);
                class _ {
                    constructor(_e, tt) {
                        this.op = _e,
                        this.node = tt
                    }
                }
                i.ExecutionPlan = class {
                    constructor($, _e, tt) {
                        this.graph = $,
                        this.profiler = tt,
                        this.initialize(_e)
                    }
                    initialize($) {
                        this.profiler.event("session", "ExecutionPlan.initialize", () => {
                            const _e = this.graph.getNodes();
                            if (_e.length !== $.length)
                                throw new Error("The size of nodes and OPs do not match.");
                            this._ops = $.map( (tt, nt) => new _(tt,_e[nt])),
                            this.reset(),
                            this._starter = [],
                            this._ops.forEach( (tt, nt) => {
                                let rt = !0;
                                for (const ot of tt.node.inputs)
                                    if (!this._values[ot] && this.graph.getInputIndices().indexOf(ot) === -1) {
                                        rt = !1;
                                        break
                                    }
                                rt && this._starter.push(nt)
                            }
                            )
                        }
                        )
                    }
                    reset() {
                        this._values = this.graph.getValues().map($ => $.tensor)
                    }
                    async execute($, _e) {
                        return this.profiler.event("session", "ExecutionPlan.execute", async () => {
                            this.reset();
                            const tt = $.createInferenceHandler()
                              , nt = this.graph.getInputIndices();
                            if (_e.length !== nt.length)
                                throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${_e.length} expected: ${nt.length}`);
                            _e.forEach( (st, at) => {
                                const lt = nt[at];
                                this._values[lt] = st
                            }
                            );
                            const rt = this._starter.slice(0)
                              , ot = this.graph.getValues()
                              , et = this.graph.getNodes();
                            let j = 0;
                            for (; j < rt.length; ) {
                                const st = rt[j++]
                                  , at = this._ops[st]
                                  , lt = at.node.inputs.map(ft => this._values[ft]);
                                if (lt.indexOf(void 0) !== -1)
                                    throw new Error(`unresolved input detected: op: ${at.node}`);
                                const ct = lt;
                                a.Logger.verbose("ExecPlan", `Runing op:${at.node.name} (${ct.map( (ft, ht) => `'${at.node.inputs[ht]}': ${ft.type}[${ft.dims.join(",")}]`).join(", ")})`);
                                const ut = await this.profiler.event("node", at.node.name, async () => at.op.impl(tt, ct, at.op.context));
                                if (ut.length !== at.node.outputs.length)
                                    throw new Error("the size of output does not match model definition.");
                                ut.forEach( (ft, ht) => {
                                    const pt = at.node.outputs[ht];
                                    if (this._values[pt])
                                        throw new Error(`output [${pt}] already has value: op:${at.node.name}`);
                                    this._values[pt] = ft
                                }
                                );
                                const dt = new Set;
                                ut.forEach( (ft, ht) => {
                                    const pt = at.node.outputs[ht];
                                    for (const gt of ot[pt].to) {
                                        const _t = et[gt];
                                        let mt = !0;
                                        for (const yt of _t.inputs)
                                            if (!this._values[yt]) {
                                                mt = !1;
                                                break
                                            }
                                        mt && dt.add(gt)
                                    }
                                }
                                ),
                                rt.push(...dt)
                            }
                            const it = [];
                            for (let st = 0; st < this.graph.getOutputIndices().length; st++) {
                                const at = this.graph.getOutputIndices()[st]
                                  , lt = this._values[at];
                                if (lt === void 0)
                                    throw new Error(`required output [${at}] does not have value`);
                                at === 0 ? await lt.getData() : lt.data,
                                it.push(lt)
                            }
                            return a.Logger.verbose("ExecPlan", "disposing of inferenceHandler"),
                            tt.dispose(),
                            it
                        }
                        )
                    }
                }
            }
            ,
            4662: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.Graph = void 0;
                const a = s(1446)
                  , _ = s(6874)
                  , $ = s(1287)
                  , _e = s(9240)
                  , tt = s(7273);
                var nt = $.onnxruntime.experimental.fbs;
                i.Graph = {
                    from: (j, it) => new et(j,it)
                };
                class rt {
                    constructor(it) {
                        this._from = void 0,
                        this._to = [],
                        this.tensor = void 0,
                        this.type = void 0,
                        it && (this.type = tt.ProtoUtil.tensorValueTypeFromProto(it.type.tensorType))
                    }
                    get from() {
                        return this._from
                    }
                    get to() {
                        return this._to
                    }
                }
                class ot {
                    constructor(it, st) {
                        it instanceof a.onnx.NodeProto ? (this.name = it.name,
                        this.opType = it.opType,
                        this.attributes = new _.Attribute(it.attribute)) : it instanceof nt.Node && (this.name = st ?? it.name(),
                        this.opType = it.opType(),
                        this.attributes = new _.Attribute(tt.ProtoUtil.tensorAttributesFromORTFormat(it))),
                        this.inputs = [],
                        this.outputs = [],
                        this.executeNode = !0
                    }
                }
                class et {
                    constructor(it, st) {
                        if (!it)
                            throw new TypeError("graph is empty");
                        this.buildGraph(it),
                        this.transformGraph(st),
                        this.checkIsAcyclic()
                    }
                    getInputIndices() {
                        return this._allInputIndices
                    }
                    getInputNames() {
                        return this._allInputNames
                    }
                    getOutputIndices() {
                        return this._allOutputIndices
                    }
                    getOutputNames() {
                        return this._allOutputNames
                    }
                    getValues() {
                        return this._allData
                    }
                    getNodes() {
                        return this._nodes
                    }
                    buildGraph(it) {
                        if (it instanceof a.onnx.GraphProto)
                            this.buildGraphFromOnnxFormat(it);
                        else {
                            if (!(it instanceof nt.Graph))
                                throw new TypeError("Graph type is not supported.");
                            this.buildGraphFromOrtFormat(it)
                        }
                    }
                    buildGraphFromOnnxFormat(it) {
                        const st = new Map;
                        this._allData = [],
                        this._allInputIndices = [],
                        this._allInputNames = [],
                        this._allOutputIndices = [],
                        this._allOutputNames = [],
                        this._nodes = [];
                        const at = new Map;
                        if (!it.input)
                            throw new Error("missing information in graph: input");
                        const lt = [];
                        for (const ct of it.input) {
                            if (st.has(ct.name))
                                throw new Error(`duplicated input name: ${ct.name}`);
                            const ut = this._allData.push(new rt(ct)) - 1;
                            st.set(ct.name, ut),
                            lt.push(ct.name)
                        }
                        if (!it.initializer)
                            throw new Error("missing information in graph: initializer");
                        for (const ct of it.initializer) {
                            let ut = st.get(ct.name);
                            if (ut === void 0) {
                                const dt = new rt;
                                dt.type = {
                                    shape: {
                                        dims: tt.ProtoUtil.tensorDimsFromProto(ct.dims)
                                    },
                                    tensorType: tt.ProtoUtil.tensorDataTypeFromProto(ct.dataType)
                                },
                                ut = this._allData.push(dt) - 1,
                                st.set(ct.name, ut)
                            }
                            this._allData[ut]._from = -1,
                            this._allData[ut].tensor = _e.Tensor.fromProto(ct)
                        }
                        for (let ct = 0; ct < this._allData.length; ct++)
                            this._allData[ct].tensor || (this._allInputIndices.push(ct),
                            this._allInputNames.push(lt[ct]));
                        if (!it.output)
                            throw new Error("missing information in graph: output");
                        for (const ct of it.output) {
                            if (st.has(ct.name))
                                throw new Error(`duplicated output name: ${ct.name}`);
                            const ut = this._allData.push(new rt(ct)) - 1;
                            st.set(ct.name, ut),
                            this._allOutputIndices.push(ut),
                            this._allOutputNames.push(ct.name)
                        }
                        if (!it.node)
                            throw new Error("missing information in graph: node");
                        for (const ct of it.node) {
                            if (!ct.name)
                                for (let dt = 0; ; dt++) {
                                    const ft = `unnamed_${ct.opType}_${dt}`;
                                    if (!at.has(ft)) {
                                        ct.name = ft;
                                        break
                                    }
                                }
                            if (at.has(ct.name))
                                throw new Error(`duplicated node name: ${ct.name}`);
                            const ut = this._nodes.push(new ot(ct)) - 1;
                            at.set(ct.name, ut)
                        }
                        for (let ct = 0; ct < this._nodes.length; ct++) {
                            const ut = this._nodes[ct]
                              , dt = it.node[ct];
                            if (!dt.output)
                                throw new Error(`missing output for node: ${dt.name}`);
                            for (const ft of dt.output) {
                                let ht = st.get(ft);
                                if (ht === void 0 && (ht = this._allData.push(new rt) - 1,
                                st.set(ft, ht)),
                                ut.outputs.push(ht),
                                this._allData[ht]._from !== void 0)
                                    throw new Error(`multiple nodes output to one data value: ${ht}`);
                                if (this._allData[ht]._from = ct,
                                dt.opType === "Constant") {
                                    if (!dt.attribute || dt.attribute.length !== 1 || !dt.attribute[0].t)
                                        throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
                                    if (!dt.output || dt.output.length !== 1)
                                        throw new Error("missing output or incorrect number of outputs for this Constant operator");
                                    ut.outputs.pop(),
                                    ut.executeNode = !1,
                                    this._allData[ht]._from = -1,
                                    this._allData[ht].tensor = _e.Tensor.fromProto(dt.attribute[0].t)
                                }
                            }
                        }
                        for (let ct = 0; ct < this._nodes.length; ct++) {
                            const ut = this._nodes[ct]
                              , dt = it.node[ct];
                            if (!dt.input)
                                throw new Error(`missing input for node: ${dt.name}`);
                            for (const ft of dt.input) {
                                const ht = st.get(ft);
                                if (ht === void 0) {
                                    if (ft === "" && dt.input.length === 3 && dt.opType === "Resize")
                                        continue;
                                    throw new Error(`unrecognized input '${ft}' for node: ${dt.name}`)
                                }
                                ut.inputs.push(ht),
                                this._allData[ht]._to.push(ct)
                            }
                        }
                        return !0
                    }
                    buildGraphFromOrtFormat(it) {
                        var st, at, lt;
                        const ct = new Map;
                        this._allData = [],
                        this._allInputIndices = [],
                        this._allInputNames = [],
                        this._allOutputIndices = [],
                        this._allOutputNames = [],
                        this._nodes = [];
                        const ut = new Map
                          , dt = [];
                        for (let ft = 0; ft < it.inputsLength(); ft++) {
                            const ht = it.inputs(ft);
                            if (ct.has(ht))
                                throw new Error(`duplicated input name: ${ht}`);
                            for (let pt = 0; pt < it.nodeArgsLength(); pt++)
                                if (((st = it.nodeArgs(pt)) === null || st === void 0 ? void 0 : st.name()) === ht) {
                                    const gt = new rt;
                                    if (((lt = (at = it.nodeArgs(pt)) === null || at === void 0 ? void 0 : at.type()) === null || lt === void 0 ? void 0 : lt.valueType()) !== nt.TypeInfoValue.tensor_type)
                                        throw new Error("Unexpected value type for the nodeArg.");
                                    const _t = it.nodeArgs(pt).type().value(new nt.TensorTypeAndShape)
                                      , mt = tt.ProtoUtil.tensorDataTypeFromProto(_t.elemType())
                                      , yt = _t.shape()
                                      , bt = [];
                                    for (let wt = 0; wt < yt.dimLength(); wt++)
                                        bt.push(tt.LongUtil.longToNumber(yt.dim(wt).value().dimValue()));
                                    gt.type = {
                                        shape: {
                                            dims: bt
                                        },
                                        tensorType: mt
                                    };
                                    const vt = this._allData.push(gt) - 1;
                                    ct.set(ht, vt),
                                    dt.push(ht)
                                }
                        }
                        for (let ft = 0; ft < it.initializersLength(); ft++) {
                            const ht = it.initializers(ft);
                            let pt = ct.get(ht.name());
                            if (pt === void 0) {
                                const gt = new rt
                                  , _t = tt.ProtoUtil.tensorDimsFromORTFormat(ht)
                                  , mt = tt.ProtoUtil.tensorDataTypeFromProto(ht.dataType());
                                gt.type = {
                                    shape: {
                                        dims: _t
                                    },
                                    tensorType: mt
                                },
                                pt = this._allData.push(gt) - 1,
                                ct.set(ht.name(), pt)
                            }
                            this._allData[pt]._from = -1,
                            this._allData[pt].tensor = _e.Tensor.fromOrtTensor(ht)
                        }
                        for (let ft = 0; ft < this._allData.length; ft++)
                            this._allData[ft].tensor || (this._allInputIndices.push(ft),
                            this._allInputNames.push(dt[ft]));
                        for (let ft = 0; ft < it.outputsLength(); ft++) {
                            const ht = it.outputs(ft);
                            if (ct.has(ht))
                                throw new Error(`duplicated output name: ${ht}`);
                            const pt = this._allData.push(new rt) - 1;
                            ct.set(ht, pt),
                            this._allOutputIndices.push(pt),
                            this._allOutputNames.push(ht)
                        }
                        if (!it.nodes)
                            throw new Error("missing information in graph: node");
                        for (let ft = 0; ft < it.nodesLength(); ft++) {
                            const ht = it.nodes(ft);
                            let pt = ht.name();
                            if (!pt)
                                for (let _t = 0; pt = `unnamed_${ht.opType()}_${_t}`,
                                ut.has(pt); _t++)
                                    ;
                            if (ut.has(pt))
                                throw new Error(`duplicated node name: ${pt}`);
                            const gt = this._nodes.push(new ot(ht,pt)) - 1;
                            ut.set(pt, gt)
                        }
                        for (let ft = 0; ft < this._nodes.length; ft++) {
                            const ht = this._nodes[ft]
                              , pt = it.nodes(ft);
                            if (pt == null)
                                throw new Error(`No node exists at index ${ft}`);
                            if ((pt == null ? void 0 : pt.outputsLength()) === 0)
                                throw new Error(`missing output for node: ${pt.name}`);
                            for (let gt = 0; gt < (pt == null ? void 0 : pt.outputsLength()); gt++) {
                                const _t = pt == null ? void 0 : pt.outputs(gt);
                                let mt = ct.get(_t);
                                if (mt === void 0 && (mt = this._allData.push(new rt) - 1,
                                ct.set(_t, mt)),
                                ht.outputs.push(mt),
                                this._allData[mt]._from !== void 0)
                                    throw new Error(`multiple nodes output to one data value: ${mt}`);
                                if (this._allData[mt]._from = ft,
                                pt.opType() === "Constant") {
                                    if (pt.attributesLength() !== 1 || !pt.attributes(0).t())
                                        throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
                                    if (pt.outputsLength() !== 1)
                                        throw new Error("missing output or incorrect number of outputs for this Constant operator");
                                    ht.outputs.pop(),
                                    ht.executeNode = !1,
                                    this._allData[mt]._from = -1,
                                    this._allData[mt].tensor = _e.Tensor.fromOrtTensor(pt.attributes(0).t())
                                }
                            }
                        }
                        for (let ft = 0; ft < this._nodes.length; ft++) {
                            const ht = this._nodes[ft]
                              , pt = it.nodes(ft);
                            if (pt.inputsLength() === 0)
                                throw new Error(`missing input for node: ${pt.name}`);
                            for (let gt = 0; gt < pt.inputsLength(); gt++) {
                                const _t = pt.inputs(gt)
                                  , mt = ct.get(_t);
                                if (mt === void 0)
                                    throw new Error(`unrecognized input '${_t}' for node: ${pt.name()}`);
                                ht.inputs.push(mt),
                                this._allData[mt]._to.push(ft)
                            }
                        }
                    }
                    checkIsAcyclic() {
                        const it = new Set;
                        this._allInputIndices.forEach(lt => {
                            this._allData[lt]._to.forEach(ct => {
                                it.add(ct)
                            }
                            )
                        }
                        );
                        const st = Array.from(it)
                          , at = new Array(this._nodes.length).fill("white");
                        for (; st.length > 0; ) {
                            const lt = st.pop();
                            at[lt] === "gray" ? at[lt] = "black" : (st.push(lt),
                            at[lt] = "gray",
                            this._nodes[lt].outputs.forEach(ct => {
                                const ut = this._allData[ct];
                                if (ut.tensor !== void 0)
                                    throw new Error("node outputs should not be initialized");
                                if (ut._from !== lt)
                                    throw new Error("from property of the Value object doesn't match index of Node being processed");
                                ut._to.forEach(dt => {
                                    if (at[dt] === "gray")
                                        throw new Error("model graph is cyclic");
                                    at[dt] === "white" && st.push(dt)
                                }
                                )
                            }
                            ))
                        }
                    }
                    transformGraph(it) {
                        this.removeAllIdentityNodes(),
                        this.removeAllDropoutNodes(),
                        this.fuseConvActivationNodes(),
                        it && it.transformGraph(this),
                        this.finalizeGraph()
                    }
                    finalizeGraph() {
                        let it = 0;
                        const st = new Array(this._nodes.length,0);
                        let at = 0;
                        for (let lt = 0; lt < this._nodes.length; lt++)
                            st[lt] = at,
                            this._nodes[lt].executeNode ? (at !== lt && (this._nodes[at] = this._nodes[lt]),
                            at++) : this._nodes[lt].outputs.forEach(ct => {
                                this._allData[ct]._from = -2
                            }
                            );
                        this._nodes.splice(at, this._nodes.length - at);
                        for (let lt = 0; lt < this._allData.length; lt++) {
                            const ct = this._allData[lt];
                            ct._from !== void 0 && ct._from !== -1 && ct._from !== -2 && (ct._from = st[ct._from]);
                            for (let ut = 0; ut < ct._to.length; ut++) {
                                if (!(ct._to[ut] >= 0))
                                    throw new Error("Trying to update a removed node");
                                ct._to[ut] = st[ct._to[ut]]
                            }
                        }
                        it = 0;
                        for (let lt = 0; lt < this._allData.length; lt++)
                            if (this._allData[lt].from !== -2 || this._allOutputIndices.indexOf(lt + it) !== -1) {
                                if (it > 0) {
                                    let ct = -1;
                                    this._allData[lt].from !== void 0 && this._allData[lt].from !== -1 ? (ct = this._nodes[this._allData[lt].from].outputs.indexOf(lt + it),
                                    ct !== -1 && (this._nodes[this._allData[lt].from].outputs[ct] = lt)) : (ct = this._allInputIndices.indexOf(lt + it),
                                    ct !== -1 && (this._allInputIndices[ct] = lt)),
                                    this._allData[lt].to.forEach(ut => {
                                        ct = this._nodes[ut].inputs.indexOf(lt + it),
                                        ct !== -1 && (this._nodes[ut].inputs[ct] = lt)
                                    }
                                    ),
                                    this._allData[lt].to.length === 0 && (ct = this._allOutputIndices.indexOf(lt + it),
                                    ct !== -1 && (this._allOutputIndices[ct] = lt))
                                }
                            } else
                                it++,
                                this._allData.splice(lt, 1),
                                lt--
                    }
                    deleteNode(it) {
                        const st = this._nodes[it];
                        if (st.outputs.length > 1) {
                            for (let dt = 1; dt < st.outputs.length; dt++)
                                if (this._allData[st.outputs[dt]].to.length > 0)
                                    throw new Error("Node deletion with more than one output connected to other nodes is not supported. ")
                        }
                        st.executeNode = !1;
                        const at = st.inputs[0]
                          , lt = st.outputs[0]
                          , ct = this._allData[lt].to;
                        for (let dt = 0; dt < st.inputs.length; dt++) {
                            const ft = this._allData[st.inputs[dt]].to.indexOf(it);
                            if (ft === -1)
                                throw new Error("The Value object doesn't have the current Node in it's 'to' property ");
                            this._allData[st.inputs[dt]].to.splice(ft, 1)
                        }
                        this._allData[lt]._to = [];
                        const ut = this._allOutputIndices.indexOf(lt);
                        if (ut !== -1 && (this._allOutputIndices[ut] = at),
                        ct && ct.length > 0)
                            for (const dt of ct) {
                                const ft = this._nodes[dt].inputs.indexOf(lt);
                                if (ft === -1)
                                    throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");
                                this._nodes[dt].inputs[ft] = at,
                                this._allData[at].to.push(dt)
                            }
                    }
                    removeAllDropoutNodes() {
                        let it = 0;
                        for (const st of this._nodes) {
                            if (st.opType === "Dropout") {
                                if (st.inputs.length !== 1)
                                    throw new Error("Dropout nodes should only contain one input. ");
                                if (st.outputs.length !== 1 && st.outputs.length !== 2)
                                    throw new Error("Dropout nodes should contain either 1 or 2 output(s)");
                                if (st.outputs.length === 2 && this._allData[st.outputs[1]]._to.length !== 0)
                                    throw new Error("Dropout nodes's second output should not be referenced by other nodes");
                                this.deleteNode(it)
                            }
                            it++
                        }
                    }
                    removeAllIdentityNodes() {
                        let it = 0;
                        for (const st of this._nodes)
                            st.opType === "Identity" && this.deleteNode(it),
                            it++
                    }
                    isActivation(it) {
                        switch (it.opType) {
                        case "Relu":
                        case "Sigmoid":
                        case "Clip":
                            return !0;
                        default:
                            return !1
                        }
                    }
                    fuseConvActivationNodes() {
                        for (const it of this._nodes)
                            if (it.opType === "Conv") {
                                const st = this._allData[it.outputs[0]]._to;
                                if (st.length === 1 && this.isActivation(this._nodes[st[0]])) {
                                    const at = this._nodes[st[0]];
                                    if (at.opType === "Clip")
                                        if (at.inputs.length === 1)
                                            try {
                                                it.attributes.set("activation_params", "floats", [at.attributes.getFloat("min"), at.attributes.getFloat("max")])
                                            } catch {
                                                it.attributes.set("activation_params", "floats", [tt.MIN_CLIP, tt.MAX_CLIP])
                                            }
                                        else {
                                            if (!(at.inputs.length >= 3 && this._allData[at.inputs[1]].tensor !== void 0 && this._allData[at.inputs[2]].tensor !== void 0))
                                                continue;
                                            it.attributes.set("activation_params", "floats", [this._allData[at.inputs[1]].tensor.floatData[0], this._allData[at.inputs[2]].tensor.floatData[0]])
                                        }
                                    it.attributes.set("activation", "string", at.opType),
                                    this.deleteNode(st[0])
                                }
                            }
                    }
                }
            }
            ,
            1315: (o, i) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.now = i.Profiler = i.Logger = void 0;
                const s = {
                    verbose: 1e3,
                    info: 2e3,
                    warning: 4e3,
                    error: 5e3,
                    fatal: 6e3
                }
                  , a = {
                    none: new class {
                        log(ot, et, j) {}
                    }
                    ,
                    console: new class {
                        log(ot, et, j) {
                            console.log(`${this.color(ot)} ${j ? "\x1B[35m" + j + "\x1B[0m " : ""}${et}`)
                        }
                        color(ot) {
                            switch (ot) {
                            case "verbose":
                                return "\x1B[34;40mv\x1B[0m";
                            case "info":
                                return "\x1B[32mi\x1B[0m";
                            case "warning":
                                return "\x1B[30;43mw\x1B[0m";
                            case "error":
                                return "\x1B[31;40me\x1B[0m";
                            case "fatal":
                                return "\x1B[101mf\x1B[0m";
                            default:
                                throw new Error(`unsupported severity: ${ot}`)
                            }
                        }
                    }
                }
                  , _ = {
                    provider: "console",
                    minimalSeverity: "warning",
                    logDateTime: !0,
                    logSourceLocation: !1
                };
                let $ = {
                    "": _
                };
                function _e(ot, et, j, it) {
                    if (et === void 0)
                        return st = ot,
                        {
                            verbose: _e.verbose.bind(null, st),
                            info: _e.info.bind(null, st),
                            warning: _e.warning.bind(null, st),
                            error: _e.error.bind(null, st),
                            fatal: _e.fatal.bind(null, st)
                        };
                    if (j === void 0)
                        tt(ot, et);
                    else if (typeof j == "number" && it === void 0)
                        tt(ot, et);
                    else if (typeof j == "string" && it === void 0)
                        tt(ot, j, 0, et);
                    else {
                        if (typeof j != "string" || typeof it != "number")
                            throw new TypeError("input is valid");
                        tt(ot, j, 0, et)
                    }
                    var st
                }
                function tt(ot, et, j, it) {
                    const st = $[it || ""] || $[""];
                    s[ot] < s[st.minimalSeverity] || (st.logDateTime && (et = `${new Date().toISOString()}|${et}`),
                    st.logSourceLocation,
                    a[st.provider].log(ot, et, it))
                }
                (function(ot) {
                    function et(it) {
                        $ = {},
                        j("", it || {})
                    }
                    function j(it, st) {
                        if (it === "*")
                            et(st);
                        else {
                            const at = $[it] || _;
                            $[it] = {
                                provider: st.provider || at.provider,
                                minimalSeverity: st.minimalSeverity || at.minimalSeverity,
                                logDateTime: st.logDateTime === void 0 ? at.logDateTime : st.logDateTime,
                                logSourceLocation: st.logSourceLocation === void 0 ? at.logSourceLocation : st.logSourceLocation
                            }
                        }
                    }
                    ot.verbose = function(it, st) {
                        ot("verbose", it, st)
                    }
                    ,
                    ot.info = function(it, st) {
                        ot("info", it, st)
                    }
                    ,
                    ot.warning = function(it, st) {
                        ot("warning", it, st)
                    }
                    ,
                    ot.error = function(it, st) {
                        ot("error", it, st)
                    }
                    ,
                    ot.fatal = function(it, st) {
                        ot("fatal", it, st)
                    }
                    ,
                    ot.reset = et,
                    ot.set = j,
                    ot.setWithEnv = function(it) {
                        const st = {};
                        it.logLevel && (st.minimalSeverity = it.logLevel),
                        j("", st)
                    }
                }
                )(_e || (_e = {})),
                i.Logger = _e;
                class nt {
                    constructor(et, j, it, st, at, lt) {
                        this.category = et,
                        this.name = j,
                        this.startTime = it,
                        this.endCallback = st,
                        this.timer = at,
                        this.ctx = lt
                    }
                    async end() {
                        return this.endCallback(this)
                    }
                    async checkTimer() {
                        if (this.ctx === void 0 || this.timer === void 0)
                            throw new Error("No webgl timer found");
                        return this.ctx.endTimer(),
                        this.ctx.waitForQueryAndGetTime(this.timer)
                    }
                }
                class rt {
                    constructor(et, j, it, st) {
                        this.category = et,
                        this.name = j,
                        this.startTime = it,
                        this.endTime = st
                    }
                }
                i.Profiler = class {
                    static create(ot) {
                        return ot === void 0 ? new this : new this(ot.maxNumberEvents,ot.flushBatchSize,ot.flushIntervalInMilliseconds)
                    }
                    constructor(ot, et, j) {
                        this._started = !1,
                        this._flushPointer = 0,
                        this._started = !1,
                        this._maxNumberEvents = ot === void 0 ? 1e4 : ot,
                        this._flushBatchSize = et === void 0 ? 10 : et,
                        this._flushIntervalInMilliseconds = j === void 0 ? 5e3 : j
                    }
                    start() {
                        this._started = !0,
                        this._timingEvents = [],
                        this._flushTime = (0,
                        i.now)(),
                        this._flushPointer = 0
                    }
                    stop() {
                        for (this._started = !1; this._flushPointer < this._timingEvents.length; this._flushPointer++)
                            this.logOneEvent(this._timingEvents[this._flushPointer])
                    }
                    event(ot, et, j, it) {
                        const st = this._started ? this.begin(ot, et, it) : void 0;
                        let at = !1;
                        const lt = j();
                        if (lt && typeof lt.then == "function")
                            return at = !0,
                            new Promise( (ct, ut) => {
                                lt.then(async dt => {
                                    st && await st.end(),
                                    ct(dt)
                                }
                                , async dt => {
                                    st && await st.end(),
                                    ut(dt)
                                }
                                )
                            }
                            );
                        if (!at && st) {
                            const ct = st.end();
                            if (ct && typeof ct.then == "function")
                                return new Promise( (ut, dt) => {
                                    ct.then( () => {
                                        ut(lt)
                                    }
                                    , ft => {
                                        dt(ft)
                                    }
                                    )
                                }
                                )
                        }
                        return lt
                    }
                    begin(ot, et, j) {
                        if (!this._started)
                            throw new Error("profiler is not started yet");
                        if (j === void 0) {
                            const it = (0,
                            i.now)();
                            return this.flush(it),
                            new nt(ot,et,it,st => this.endSync(st))
                        }
                        {
                            const it = j.beginTimer();
                            return new nt(ot,et,0,async st => this.end(st),it,j)
                        }
                    }
                    async end(ot) {
                        const et = await ot.checkTimer();
                        this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new rt(ot.category,ot.name,ot.startTime,et)),
                        this.flush(et))
                    }
                    endSync(ot) {
                        const et = (0,
                        i.now)();
                        this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new rt(ot.category,ot.name,ot.startTime,et)),
                        this.flush(et))
                    }
                    logOneEvent(ot) {
                        i.Logger.verbose(`Profiler.${ot.category}`, `${(ot.endTime - ot.startTime).toFixed(2)}ms on event '${ot.name}' at ${ot.endTime.toFixed(2)}`)
                    }
                    flush(ot) {
                        if (this._timingEvents.length - this._flushPointer >= this._flushBatchSize || ot - this._flushTime >= this._flushIntervalInMilliseconds) {
                            for (const et = this._flushPointer; this._flushPointer < et + this._flushBatchSize && this._flushPointer < this._timingEvents.length; this._flushPointer++)
                                this.logOneEvent(this._timingEvents[this._flushPointer]);
                            this._flushTime = (0,
                            i.now)()
                        }
                    }
                    get started() {
                        return this._started
                    }
                }
                ,
                i.now = typeof performance < "u" && performance.now ? () => performance.now() : Date.now
            }
            ,
            1745: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.Model = void 0;
                const a = s(5686)
                  , _ = s(1446)
                  , $ = s(4662)
                  , _e = s(1287)
                  , tt = s(7273);
                var nt = _e.onnxruntime.experimental.fbs;
                i.Model = class {
                    constructor() {}
                    load(rt, ot, et) {
                        if (!et)
                            try {
                                return void this.loadFromOnnxFormat(rt, ot)
                            } catch (j) {
                                if (et !== void 0)
                                    throw j
                            }
                        this.loadFromOrtFormat(rt, ot)
                    }
                    loadFromOnnxFormat(rt, ot) {
                        const et = _.onnx.ModelProto.decode(rt);
                        if (tt.LongUtil.longToNumber(et.irVersion) < 3)
                            throw new Error("only support ONNX model with IR_VERSION>=3");
                        this._opsets = et.opsetImport.map(j => ({
                            domain: j.domain,
                            version: tt.LongUtil.longToNumber(j.version)
                        })),
                        this._graph = $.Graph.from(et.graph, ot)
                    }
                    loadFromOrtFormat(rt, ot) {
                        const et = new a.flatbuffers.ByteBuffer(rt)
                          , j = nt.InferenceSession.getRootAsInferenceSession(et).model();
                        if (tt.LongUtil.longToNumber(j.irVersion()) < 3)
                            throw new Error("only support ONNX model with IR_VERSION>=3");
                        this._opsets = [];
                        for (let it = 0; it < j.opsetImportLength(); it++) {
                            const st = j.opsetImport(it);
                            this._opsets.push({
                                domain: st == null ? void 0 : st.domain(),
                                version: tt.LongUtil.longToNumber(st.version())
                            })
                        }
                        this._graph = $.Graph.from(j.graph(), ot)
                    }
                    get graph() {
                        return this._graph
                    }
                    get opsets() {
                        return this._opsets
                    }
                }
            }
            ,
            6145: (o, i) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.FLOAT_TYPES = i.INT_TYPES = i.NUMBER_TYPES = void 0,
                i.NUMBER_TYPES = ["float32", "float64", "int32", "int16", "int8", "uint16", "uint32", "uint8"],
                i.INT_TYPES = ["int32", "int16", "int8", "uint16", "uint32", "uint8"],
                i.FLOAT_TYPES = ["float32", "float64"]
            }
            ,
            5881: (o, i) => {
                function s(a, _) {
                    if (_.endsWith("+")) {
                        const $ = Number.parseInt(_.substring(0, _.length - 1), 10);
                        return !isNaN($) && $ <= a
                    }
                    if (_.split("-").length === 2) {
                        const $ = _.split("-")
                          , _e = Number.parseInt($[0], 10)
                          , tt = Number.parseInt($[1], 10);
                        return !isNaN(_e) && !isNaN(tt) && _e <= a && a <= tt
                    }
                    return Number.parseInt(_, 10) === a
                }
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.resolveOperator = void 0,
                i.resolveOperator = function(a, _, $) {
                    for (const _e of $) {
                        const tt = _e[0]
                          , nt = _e[1]
                          , rt = _e[2]
                          , ot = _e[3]
                          , et = _e[4];
                        if (a.opType === tt) {
                            for (const j of _)
                                if ((j.domain === nt || j.domain === "ai.onnx" && nt === "") && s(j.version, rt))
                                    return {
                                        opImpl: ot,
                                        opInit: et
                                    }
                        }
                    }
                    throw new TypeError(`cannot resolve operator '${a.opType}' with opsets: ${_.map(_e => `${_e.domain || "ai.onnx"} v${_e.version}`).join(", ")}`)
                }
            }
            ,
            1287: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.onnxruntime = void 0;
                const a = s(5686);
                var _, $;
                _ = i.onnxruntime || (i.onnxruntime = {}),
                function(_e) {
                    (function(tt) {
                        tt[tt.UNDEFINED = 0] = "UNDEFINED",
                        tt[tt.FLOAT = 1] = "FLOAT",
                        tt[tt.INT = 2] = "INT",
                        tt[tt.STRING = 3] = "STRING",
                        tt[tt.TENSOR = 4] = "TENSOR",
                        tt[tt.GRAPH = 5] = "GRAPH",
                        tt[tt.FLOATS = 6] = "FLOATS",
                        tt[tt.INTS = 7] = "INTS",
                        tt[tt.STRINGS = 8] = "STRINGS",
                        tt[tt.TENSORS = 9] = "TENSORS",
                        tt[tt.GRAPHS = 10] = "GRAPHS",
                        tt[tt.SPARSE_TENSOR = 11] = "SPARSE_TENSOR",
                        tt[tt.SPARSE_TENSORS = 12] = "SPARSE_TENSORS"
                    }
                    )(_e.AttributeType || (_e.AttributeType = {}))
                }(($ = _.experimental || (_.experimental = {})).fbs || ($.fbs = {})),
                function(_e) {
                    (function(tt) {
                        (function(nt) {
                            (function(rt) {
                                rt[rt.UNKNOWN = 0] = "UNKNOWN",
                                rt[rt.VALUE = 1] = "VALUE",
                                rt[rt.PARAM = 2] = "PARAM"
                            }
                            )(nt.DimensionValueType || (nt.DimensionValueType = {}))
                        }
                        )(tt.fbs || (tt.fbs = {}))
                    }
                    )(_e.experimental || (_e.experimental = {}))
                }(i.onnxruntime || (i.onnxruntime = {})),
                function(_e) {
                    (function(tt) {
                        (function(nt) {
                            (function(rt) {
                                rt[rt.UNDEFINED = 0] = "UNDEFINED",
                                rt[rt.FLOAT = 1] = "FLOAT",
                                rt[rt.UINT8 = 2] = "UINT8",
                                rt[rt.INT8 = 3] = "INT8",
                                rt[rt.UINT16 = 4] = "UINT16",
                                rt[rt.INT16 = 5] = "INT16",
                                rt[rt.INT32 = 6] = "INT32",
                                rt[rt.INT64 = 7] = "INT64",
                                rt[rt.STRING = 8] = "STRING",
                                rt[rt.BOOL = 9] = "BOOL",
                                rt[rt.FLOAT16 = 10] = "FLOAT16",
                                rt[rt.DOUBLE = 11] = "DOUBLE",
                                rt[rt.UINT32 = 12] = "UINT32",
                                rt[rt.UINT64 = 13] = "UINT64",
                                rt[rt.COMPLEX64 = 14] = "COMPLEX64",
                                rt[rt.COMPLEX128 = 15] = "COMPLEX128",
                                rt[rt.BFLOAT16 = 16] = "BFLOAT16"
                            }
                            )(nt.TensorDataType || (nt.TensorDataType = {}))
                        }
                        )(tt.fbs || (tt.fbs = {}))
                    }
                    )(_e.experimental || (_e.experimental = {}))
                }(i.onnxruntime || (i.onnxruntime = {})),
                function(_e) {
                    (function(tt) {
                        (function(nt) {
                            (function(rt) {
                                rt[rt.Primitive = 0] = "Primitive",
                                rt[rt.Fused = 1] = "Fused"
                            }
                            )(nt.NodeType || (nt.NodeType = {}))
                        }
                        )(tt.fbs || (tt.fbs = {}))
                    }
                    )(_e.experimental || (_e.experimental = {}))
                }(i.onnxruntime || (i.onnxruntime = {})),
                function(_e) {
                    (function(tt) {
                        (function(nt) {
                            (function(rt) {
                                rt[rt.NONE = 0] = "NONE",
                                rt[rt.tensor_type = 1] = "tensor_type",
                                rt[rt.sequence_type = 2] = "sequence_type",
                                rt[rt.map_type = 3] = "map_type"
                            }
                            )(nt.TypeInfoValue || (nt.TypeInfoValue = {}))
                        }
                        )(tt.fbs || (tt.fbs = {}))
                    }
                    )(_e.experimental || (_e.experimental = {}))
                }(i.onnxruntime || (i.onnxruntime = {})),
                function(_e) {
                    (function(tt) {
                        (function(nt) {
                            class rt {
                                constructor() {
                                    this.bb = null,
                                    this.bb_pos = 0
                                }
                                __init(et, j) {
                                    return this.bb_pos = et,
                                    this.bb = j,
                                    this
                                }
                                static getRootAsShape(et, j) {
                                    return (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                static getSizePrefixedRootAsShape(et, j) {
                                    return et.setPosition(et.position() + a.flatbuffers.SIZE_PREFIX_LENGTH),
                                    (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                dim(et, j) {
                                    let it = this.bb.__offset(this.bb_pos, 4);
                                    return it ? (j || new _e.experimental.fbs.Dimension).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + it) + 4 * et), this.bb) : null
                                }
                                dimLength() {
                                    let et = this.bb.__offset(this.bb_pos, 4);
                                    return et ? this.bb.__vector_len(this.bb_pos + et) : 0
                                }
                                static startShape(et) {
                                    et.startObject(1)
                                }
                                static addDim(et, j) {
                                    et.addFieldOffset(0, j, 0)
                                }
                                static createDimVector(et, j) {
                                    et.startVector(4, j.length, 4);
                                    for (let it = j.length - 1; it >= 0; it--)
                                        et.addOffset(j[it]);
                                    return et.endVector()
                                }
                                static startDimVector(et, j) {
                                    et.startVector(4, j, 4)
                                }
                                static endShape(et) {
                                    return et.endObject()
                                }
                                static createShape(et, j) {
                                    return rt.startShape(et),
                                    rt.addDim(et, j),
                                    rt.endShape(et)
                                }
                            }
                            nt.Shape = rt
                        }
                        )(tt.fbs || (tt.fbs = {}))
                    }
                    )(_e.experimental || (_e.experimental = {}))
                }(i.onnxruntime || (i.onnxruntime = {})),
                function(_e) {
                    (function(tt) {
                        (function(nt) {
                            class rt {
                                constructor() {
                                    this.bb = null,
                                    this.bb_pos = 0
                                }
                                __init(et, j) {
                                    return this.bb_pos = et,
                                    this.bb = j,
                                    this
                                }
                                static getRootAsDimension(et, j) {
                                    return (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                static getSizePrefixedRootAsDimension(et, j) {
                                    return et.setPosition(et.position() + a.flatbuffers.SIZE_PREFIX_LENGTH),
                                    (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                value(et) {
                                    let j = this.bb.__offset(this.bb_pos, 4);
                                    return j ? (et || new _e.experimental.fbs.DimensionValue).__init(this.bb.__indirect(this.bb_pos + j), this.bb) : null
                                }
                                denotation(et) {
                                    let j = this.bb.__offset(this.bb_pos, 6);
                                    return j ? this.bb.__string(this.bb_pos + j, et) : null
                                }
                                static startDimension(et) {
                                    et.startObject(2)
                                }
                                static addValue(et, j) {
                                    et.addFieldOffset(0, j, 0)
                                }
                                static addDenotation(et, j) {
                                    et.addFieldOffset(1, j, 0)
                                }
                                static endDimension(et) {
                                    return et.endObject()
                                }
                                static createDimension(et, j, it) {
                                    return rt.startDimension(et),
                                    rt.addValue(et, j),
                                    rt.addDenotation(et, it),
                                    rt.endDimension(et)
                                }
                            }
                            nt.Dimension = rt
                        }
                        )(tt.fbs || (tt.fbs = {}))
                    }
                    )(_e.experimental || (_e.experimental = {}))
                }(i.onnxruntime || (i.onnxruntime = {})),
                function(_e) {
                    (function(tt) {
                        (function(nt) {
                            class rt {
                                constructor() {
                                    this.bb = null,
                                    this.bb_pos = 0
                                }
                                __init(et, j) {
                                    return this.bb_pos = et,
                                    this.bb = j,
                                    this
                                }
                                static getRootAsDimensionValue(et, j) {
                                    return (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                static getSizePrefixedRootAsDimensionValue(et, j) {
                                    return et.setPosition(et.position() + a.flatbuffers.SIZE_PREFIX_LENGTH),
                                    (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                dimType() {
                                    let et = this.bb.__offset(this.bb_pos, 4);
                                    return et ? this.bb.readInt8(this.bb_pos + et) : _e.experimental.fbs.DimensionValueType.UNKNOWN
                                }
                                dimValue() {
                                    let et = this.bb.__offset(this.bb_pos, 6);
                                    return et ? this.bb.readInt64(this.bb_pos + et) : this.bb.createLong(0, 0)
                                }
                                dimParam(et) {
                                    let j = this.bb.__offset(this.bb_pos, 8);
                                    return j ? this.bb.__string(this.bb_pos + j, et) : null
                                }
                                static startDimensionValue(et) {
                                    et.startObject(3)
                                }
                                static addDimType(et, j) {
                                    et.addFieldInt8(0, j, _e.experimental.fbs.DimensionValueType.UNKNOWN)
                                }
                                static addDimValue(et, j) {
                                    et.addFieldInt64(1, j, et.createLong(0, 0))
                                }
                                static addDimParam(et, j) {
                                    et.addFieldOffset(2, j, 0)
                                }
                                static endDimensionValue(et) {
                                    return et.endObject()
                                }
                                static createDimensionValue(et, j, it, st) {
                                    return rt.startDimensionValue(et),
                                    rt.addDimType(et, j),
                                    rt.addDimValue(et, it),
                                    rt.addDimParam(et, st),
                                    rt.endDimensionValue(et)
                                }
                            }
                            nt.DimensionValue = rt
                        }
                        )(tt.fbs || (tt.fbs = {}))
                    }
                    )(_e.experimental || (_e.experimental = {}))
                }(i.onnxruntime || (i.onnxruntime = {})),
                function(_e) {
                    (function(tt) {
                        (function(nt) {
                            class rt {
                                constructor() {
                                    this.bb = null,
                                    this.bb_pos = 0
                                }
                                __init(et, j) {
                                    return this.bb_pos = et,
                                    this.bb = j,
                                    this
                                }
                                static getRootAsTensorTypeAndShape(et, j) {
                                    return (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                static getSizePrefixedRootAsTensorTypeAndShape(et, j) {
                                    return et.setPosition(et.position() + a.flatbuffers.SIZE_PREFIX_LENGTH),
                                    (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                elemType() {
                                    let et = this.bb.__offset(this.bb_pos, 4);
                                    return et ? this.bb.readInt32(this.bb_pos + et) : _e.experimental.fbs.TensorDataType.UNDEFINED
                                }
                                shape(et) {
                                    let j = this.bb.__offset(this.bb_pos, 6);
                                    return j ? (et || new _e.experimental.fbs.Shape).__init(this.bb.__indirect(this.bb_pos + j), this.bb) : null
                                }
                                static startTensorTypeAndShape(et) {
                                    et.startObject(2)
                                }
                                static addElemType(et, j) {
                                    et.addFieldInt32(0, j, _e.experimental.fbs.TensorDataType.UNDEFINED)
                                }
                                static addShape(et, j) {
                                    et.addFieldOffset(1, j, 0)
                                }
                                static endTensorTypeAndShape(et) {
                                    return et.endObject()
                                }
                                static createTensorTypeAndShape(et, j, it) {
                                    return rt.startTensorTypeAndShape(et),
                                    rt.addElemType(et, j),
                                    rt.addShape(et, it),
                                    rt.endTensorTypeAndShape(et)
                                }
                            }
                            nt.TensorTypeAndShape = rt
                        }
                        )(tt.fbs || (tt.fbs = {}))
                    }
                    )(_e.experimental || (_e.experimental = {}))
                }(i.onnxruntime || (i.onnxruntime = {})),
                function(_e) {
                    (function(tt) {
                        (function(nt) {
                            class rt {
                                constructor() {
                                    this.bb = null,
                                    this.bb_pos = 0
                                }
                                __init(et, j) {
                                    return this.bb_pos = et,
                                    this.bb = j,
                                    this
                                }
                                static getRootAsMapType(et, j) {
                                    return (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                static getSizePrefixedRootAsMapType(et, j) {
                                    return et.setPosition(et.position() + a.flatbuffers.SIZE_PREFIX_LENGTH),
                                    (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                keyType() {
                                    let et = this.bb.__offset(this.bb_pos, 4);
                                    return et ? this.bb.readInt32(this.bb_pos + et) : _e.experimental.fbs.TensorDataType.UNDEFINED
                                }
                                valueType(et) {
                                    let j = this.bb.__offset(this.bb_pos, 6);
                                    return j ? (et || new _e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos + j), this.bb) : null
                                }
                                static startMapType(et) {
                                    et.startObject(2)
                                }
                                static addKeyType(et, j) {
                                    et.addFieldInt32(0, j, _e.experimental.fbs.TensorDataType.UNDEFINED)
                                }
                                static addValueType(et, j) {
                                    et.addFieldOffset(1, j, 0)
                                }
                                static endMapType(et) {
                                    return et.endObject()
                                }
                                static createMapType(et, j, it) {
                                    return rt.startMapType(et),
                                    rt.addKeyType(et, j),
                                    rt.addValueType(et, it),
                                    rt.endMapType(et)
                                }
                            }
                            nt.MapType = rt
                        }
                        )(tt.fbs || (tt.fbs = {}))
                    }
                    )(_e.experimental || (_e.experimental = {}))
                }(i.onnxruntime || (i.onnxruntime = {})),
                function(_e) {
                    (function(tt) {
                        (function(nt) {
                            class rt {
                                constructor() {
                                    this.bb = null,
                                    this.bb_pos = 0
                                }
                                __init(et, j) {
                                    return this.bb_pos = et,
                                    this.bb = j,
                                    this
                                }
                                static getRootAsSequenceType(et, j) {
                                    return (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                static getSizePrefixedRootAsSequenceType(et, j) {
                                    return et.setPosition(et.position() + a.flatbuffers.SIZE_PREFIX_LENGTH),
                                    (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                elemType(et) {
                                    let j = this.bb.__offset(this.bb_pos, 4);
                                    return j ? (et || new _e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos + j), this.bb) : null
                                }
                                static startSequenceType(et) {
                                    et.startObject(1)
                                }
                                static addElemType(et, j) {
                                    et.addFieldOffset(0, j, 0)
                                }
                                static endSequenceType(et) {
                                    return et.endObject()
                                }
                                static createSequenceType(et, j) {
                                    return rt.startSequenceType(et),
                                    rt.addElemType(et, j),
                                    rt.endSequenceType(et)
                                }
                            }
                            nt.SequenceType = rt
                        }
                        )(tt.fbs || (tt.fbs = {}))
                    }
                    )(_e.experimental || (_e.experimental = {}))
                }(i.onnxruntime || (i.onnxruntime = {})),
                function(_e) {
                    (function(tt) {
                        (tt.fbs || (tt.fbs = {})).EdgeEnd = class {
                            constructor() {
                                this.bb = null,
                                this.bb_pos = 0
                            }
                            __init(nt, rt) {
                                return this.bb_pos = nt,
                                this.bb = rt,
                                this
                            }
                            nodeIndex() {
                                return this.bb.readUint32(this.bb_pos)
                            }
                            srcArgIndex() {
                                return this.bb.readInt32(this.bb_pos + 4)
                            }
                            dstArgIndex() {
                                return this.bb.readInt32(this.bb_pos + 8)
                            }
                            static createEdgeEnd(nt, rt, ot, et) {
                                return nt.prep(4, 12),
                                nt.writeInt32(et),
                                nt.writeInt32(ot),
                                nt.writeInt32(rt),
                                nt.offset()
                            }
                        }
                    }
                    )(_e.experimental || (_e.experimental = {}))
                }(i.onnxruntime || (i.onnxruntime = {})),
                function(_e) {
                    (function(tt) {
                        (function(nt) {
                            class rt {
                                constructor() {
                                    this.bb = null,
                                    this.bb_pos = 0
                                }
                                __init(et, j) {
                                    return this.bb_pos = et,
                                    this.bb = j,
                                    this
                                }
                                static getRootAsNodeEdge(et, j) {
                                    return (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                static getSizePrefixedRootAsNodeEdge(et, j) {
                                    return et.setPosition(et.position() + a.flatbuffers.SIZE_PREFIX_LENGTH),
                                    (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                nodeIndex() {
                                    let et = this.bb.__offset(this.bb_pos, 4);
                                    return et ? this.bb.readUint32(this.bb_pos + et) : 0
                                }
                                inputEdges(et, j) {
                                    let it = this.bb.__offset(this.bb_pos, 6);
                                    return it ? (j || new _e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos + it) + 12 * et, this.bb) : null
                                }
                                inputEdgesLength() {
                                    let et = this.bb.__offset(this.bb_pos, 6);
                                    return et ? this.bb.__vector_len(this.bb_pos + et) : 0
                                }
                                outputEdges(et, j) {
                                    let it = this.bb.__offset(this.bb_pos, 8);
                                    return it ? (j || new _e.experimental.fbs.EdgeEnd).__init(this.bb.__vector(this.bb_pos + it) + 12 * et, this.bb) : null
                                }
                                outputEdgesLength() {
                                    let et = this.bb.__offset(this.bb_pos, 8);
                                    return et ? this.bb.__vector_len(this.bb_pos + et) : 0
                                }
                                static startNodeEdge(et) {
                                    et.startObject(3)
                                }
                                static addNodeIndex(et, j) {
                                    et.addFieldInt32(0, j, 0)
                                }
                                static addInputEdges(et, j) {
                                    et.addFieldOffset(1, j, 0)
                                }
                                static startInputEdgesVector(et, j) {
                                    et.startVector(12, j, 4)
                                }
                                static addOutputEdges(et, j) {
                                    et.addFieldOffset(2, j, 0)
                                }
                                static startOutputEdgesVector(et, j) {
                                    et.startVector(12, j, 4)
                                }
                                static endNodeEdge(et) {
                                    return et.endObject()
                                }
                                static createNodeEdge(et, j, it, st) {
                                    return rt.startNodeEdge(et),
                                    rt.addNodeIndex(et, j),
                                    rt.addInputEdges(et, it),
                                    rt.addOutputEdges(et, st),
                                    rt.endNodeEdge(et)
                                }
                            }
                            nt.NodeEdge = rt
                        }
                        )(tt.fbs || (tt.fbs = {}))
                    }
                    )(_e.experimental || (_e.experimental = {}))
                }(i.onnxruntime || (i.onnxruntime = {})),
                function(_e) {
                    (function(tt) {
                        (function(nt) {
                            class rt {
                                constructor() {
                                    this.bb = null,
                                    this.bb_pos = 0
                                }
                                __init(et, j) {
                                    return this.bb_pos = et,
                                    this.bb = j,
                                    this
                                }
                                static getRootAsNode(et, j) {
                                    return (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                static getSizePrefixedRootAsNode(et, j) {
                                    return et.setPosition(et.position() + a.flatbuffers.SIZE_PREFIX_LENGTH),
                                    (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                name(et) {
                                    let j = this.bb.__offset(this.bb_pos, 4);
                                    return j ? this.bb.__string(this.bb_pos + j, et) : null
                                }
                                docString(et) {
                                    let j = this.bb.__offset(this.bb_pos, 6);
                                    return j ? this.bb.__string(this.bb_pos + j, et) : null
                                }
                                domain(et) {
                                    let j = this.bb.__offset(this.bb_pos, 8);
                                    return j ? this.bb.__string(this.bb_pos + j, et) : null
                                }
                                sinceVersion() {
                                    let et = this.bb.__offset(this.bb_pos, 10);
                                    return et ? this.bb.readInt32(this.bb_pos + et) : 0
                                }
                                index() {
                                    let et = this.bb.__offset(this.bb_pos, 12);
                                    return et ? this.bb.readUint32(this.bb_pos + et) : 0
                                }
                                opType(et) {
                                    let j = this.bb.__offset(this.bb_pos, 14);
                                    return j ? this.bb.__string(this.bb_pos + j, et) : null
                                }
                                type() {
                                    let et = this.bb.__offset(this.bb_pos, 16);
                                    return et ? this.bb.readInt32(this.bb_pos + et) : _e.experimental.fbs.NodeType.Primitive
                                }
                                executionProviderType(et) {
                                    let j = this.bb.__offset(this.bb_pos, 18);
                                    return j ? this.bb.__string(this.bb_pos + j, et) : null
                                }
                                inputs(et, j) {
                                    let it = this.bb.__offset(this.bb_pos, 20);
                                    return it ? this.bb.__string(this.bb.__vector(this.bb_pos + it) + 4 * et, j) : null
                                }
                                inputsLength() {
                                    let et = this.bb.__offset(this.bb_pos, 20);
                                    return et ? this.bb.__vector_len(this.bb_pos + et) : 0
                                }
                                outputs(et, j) {
                                    let it = this.bb.__offset(this.bb_pos, 22);
                                    return it ? this.bb.__string(this.bb.__vector(this.bb_pos + it) + 4 * et, j) : null
                                }
                                outputsLength() {
                                    let et = this.bb.__offset(this.bb_pos, 22);
                                    return et ? this.bb.__vector_len(this.bb_pos + et) : 0
                                }
                                attributes(et, j) {
                                    let it = this.bb.__offset(this.bb_pos, 24);
                                    return it ? (j || new _e.experimental.fbs.Attribute).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + it) + 4 * et), this.bb) : null
                                }
                                attributesLength() {
                                    let et = this.bb.__offset(this.bb_pos, 24);
                                    return et ? this.bb.__vector_len(this.bb_pos + et) : 0
                                }
                                inputArgCounts(et) {
                                    let j = this.bb.__offset(this.bb_pos, 26);
                                    return j ? this.bb.readInt32(this.bb.__vector(this.bb_pos + j) + 4 * et) : 0
                                }
                                inputArgCountsLength() {
                                    let et = this.bb.__offset(this.bb_pos, 26);
                                    return et ? this.bb.__vector_len(this.bb_pos + et) : 0
                                }
                                inputArgCountsArray() {
                                    let et = this.bb.__offset(this.bb_pos, 26);
                                    return et ? new Int32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + et),this.bb.__vector_len(this.bb_pos + et)) : null
                                }
                                implicitInputs(et, j) {
                                    let it = this.bb.__offset(this.bb_pos, 28);
                                    return it ? this.bb.__string(this.bb.__vector(this.bb_pos + it) + 4 * et, j) : null
                                }
                                implicitInputsLength() {
                                    let et = this.bb.__offset(this.bb_pos, 28);
                                    return et ? this.bb.__vector_len(this.bb_pos + et) : 0
                                }
                                static startNode(et) {
                                    et.startObject(13)
                                }
                                static addName(et, j) {
                                    et.addFieldOffset(0, j, 0)
                                }
                                static addDocString(et, j) {
                                    et.addFieldOffset(1, j, 0)
                                }
                                static addDomain(et, j) {
                                    et.addFieldOffset(2, j, 0)
                                }
                                static addSinceVersion(et, j) {
                                    et.addFieldInt32(3, j, 0)
                                }
                                static addIndex(et, j) {
                                    et.addFieldInt32(4, j, 0)
                                }
                                static addOpType(et, j) {
                                    et.addFieldOffset(5, j, 0)
                                }
                                static addType(et, j) {
                                    et.addFieldInt32(6, j, _e.experimental.fbs.NodeType.Primitive)
                                }
                                static addExecutionProviderType(et, j) {
                                    et.addFieldOffset(7, j, 0)
                                }
                                static addInputs(et, j) {
                                    et.addFieldOffset(8, j, 0)
                                }
                                static createInputsVector(et, j) {
                                    et.startVector(4, j.length, 4);
                                    for (let it = j.length - 1; it >= 0; it--)
                                        et.addOffset(j[it]);
                                    return et.endVector()
                                }
                                static startInputsVector(et, j) {
                                    et.startVector(4, j, 4)
                                }
                                static addOutputs(et, j) {
                                    et.addFieldOffset(9, j, 0)
                                }
                                static createOutputsVector(et, j) {
                                    et.startVector(4, j.length, 4);
                                    for (let it = j.length - 1; it >= 0; it--)
                                        et.addOffset(j[it]);
                                    return et.endVector()
                                }
                                static startOutputsVector(et, j) {
                                    et.startVector(4, j, 4)
                                }
                                static addAttributes(et, j) {
                                    et.addFieldOffset(10, j, 0)
                                }
                                static createAttributesVector(et, j) {
                                    et.startVector(4, j.length, 4);
                                    for (let it = j.length - 1; it >= 0; it--)
                                        et.addOffset(j[it]);
                                    return et.endVector()
                                }
                                static startAttributesVector(et, j) {
                                    et.startVector(4, j, 4)
                                }
                                static addInputArgCounts(et, j) {
                                    et.addFieldOffset(11, j, 0)
                                }
                                static createInputArgCountsVector(et, j) {
                                    et.startVector(4, j.length, 4);
                                    for (let it = j.length - 1; it >= 0; it--)
                                        et.addInt32(j[it]);
                                    return et.endVector()
                                }
                                static startInputArgCountsVector(et, j) {
                                    et.startVector(4, j, 4)
                                }
                                static addImplicitInputs(et, j) {
                                    et.addFieldOffset(12, j, 0)
                                }
                                static createImplicitInputsVector(et, j) {
                                    et.startVector(4, j.length, 4);
                                    for (let it = j.length - 1; it >= 0; it--)
                                        et.addOffset(j[it]);
                                    return et.endVector()
                                }
                                static startImplicitInputsVector(et, j) {
                                    et.startVector(4, j, 4)
                                }
                                static endNode(et) {
                                    return et.endObject()
                                }
                                static createNode(et, j, it, st, at, lt, ct, ut, dt, ft, ht, pt, gt, _t) {
                                    return rt.startNode(et),
                                    rt.addName(et, j),
                                    rt.addDocString(et, it),
                                    rt.addDomain(et, st),
                                    rt.addSinceVersion(et, at),
                                    rt.addIndex(et, lt),
                                    rt.addOpType(et, ct),
                                    rt.addType(et, ut),
                                    rt.addExecutionProviderType(et, dt),
                                    rt.addInputs(et, ft),
                                    rt.addOutputs(et, ht),
                                    rt.addAttributes(et, pt),
                                    rt.addInputArgCounts(et, gt),
                                    rt.addImplicitInputs(et, _t),
                                    rt.endNode(et)
                                }
                            }
                            nt.Node = rt
                        }
                        )(tt.fbs || (tt.fbs = {}))
                    }
                    )(_e.experimental || (_e.experimental = {}))
                }(i.onnxruntime || (i.onnxruntime = {})),
                function(_e) {
                    (function(tt) {
                        (function(nt) {
                            class rt {
                                constructor() {
                                    this.bb = null,
                                    this.bb_pos = 0
                                }
                                __init(et, j) {
                                    return this.bb_pos = et,
                                    this.bb = j,
                                    this
                                }
                                static getRootAsValueInfo(et, j) {
                                    return (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                static getSizePrefixedRootAsValueInfo(et, j) {
                                    return et.setPosition(et.position() + a.flatbuffers.SIZE_PREFIX_LENGTH),
                                    (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                name(et) {
                                    let j = this.bb.__offset(this.bb_pos, 4);
                                    return j ? this.bb.__string(this.bb_pos + j, et) : null
                                }
                                docString(et) {
                                    let j = this.bb.__offset(this.bb_pos, 6);
                                    return j ? this.bb.__string(this.bb_pos + j, et) : null
                                }
                                type(et) {
                                    let j = this.bb.__offset(this.bb_pos, 8);
                                    return j ? (et || new _e.experimental.fbs.TypeInfo).__init(this.bb.__indirect(this.bb_pos + j), this.bb) : null
                                }
                                static startValueInfo(et) {
                                    et.startObject(3)
                                }
                                static addName(et, j) {
                                    et.addFieldOffset(0, j, 0)
                                }
                                static addDocString(et, j) {
                                    et.addFieldOffset(1, j, 0)
                                }
                                static addType(et, j) {
                                    et.addFieldOffset(2, j, 0)
                                }
                                static endValueInfo(et) {
                                    return et.endObject()
                                }
                                static createValueInfo(et, j, it, st) {
                                    return rt.startValueInfo(et),
                                    rt.addName(et, j),
                                    rt.addDocString(et, it),
                                    rt.addType(et, st),
                                    rt.endValueInfo(et)
                                }
                            }
                            nt.ValueInfo = rt
                        }
                        )(tt.fbs || (tt.fbs = {}))
                    }
                    )(_e.experimental || (_e.experimental = {}))
                }(i.onnxruntime || (i.onnxruntime = {})),
                function(_e) {
                    (function(tt) {
                        (function(nt) {
                            class rt {
                                constructor() {
                                    this.bb = null,
                                    this.bb_pos = 0
                                }
                                __init(et, j) {
                                    return this.bb_pos = et,
                                    this.bb = j,
                                    this
                                }
                                static getRootAsTypeInfo(et, j) {
                                    return (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                static getSizePrefixedRootAsTypeInfo(et, j) {
                                    return et.setPosition(et.position() + a.flatbuffers.SIZE_PREFIX_LENGTH),
                                    (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                denotation(et) {
                                    let j = this.bb.__offset(this.bb_pos, 4);
                                    return j ? this.bb.__string(this.bb_pos + j, et) : null
                                }
                                valueType() {
                                    let et = this.bb.__offset(this.bb_pos, 6);
                                    return et ? this.bb.readUint8(this.bb_pos + et) : _e.experimental.fbs.TypeInfoValue.NONE
                                }
                                value(et) {
                                    let j = this.bb.__offset(this.bb_pos, 8);
                                    return j ? this.bb.__union(et, this.bb_pos + j) : null
                                }
                                static startTypeInfo(et) {
                                    et.startObject(3)
                                }
                                static addDenotation(et, j) {
                                    et.addFieldOffset(0, j, 0)
                                }
                                static addValueType(et, j) {
                                    et.addFieldInt8(1, j, _e.experimental.fbs.TypeInfoValue.NONE)
                                }
                                static addValue(et, j) {
                                    et.addFieldOffset(2, j, 0)
                                }
                                static endTypeInfo(et) {
                                    return et.endObject()
                                }
                                static createTypeInfo(et, j, it, st) {
                                    return rt.startTypeInfo(et),
                                    rt.addDenotation(et, j),
                                    rt.addValueType(et, it),
                                    rt.addValue(et, st),
                                    rt.endTypeInfo(et)
                                }
                            }
                            nt.TypeInfo = rt
                        }
                        )(tt.fbs || (tt.fbs = {}))
                    }
                    )(_e.experimental || (_e.experimental = {}))
                }(i.onnxruntime || (i.onnxruntime = {})),
                function(_e) {
                    (function(tt) {
                        (function(nt) {
                            class rt {
                                constructor() {
                                    this.bb = null,
                                    this.bb_pos = 0
                                }
                                __init(et, j) {
                                    return this.bb_pos = et,
                                    this.bb = j,
                                    this
                                }
                                static getRootAsOperatorSetId(et, j) {
                                    return (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                static getSizePrefixedRootAsOperatorSetId(et, j) {
                                    return et.setPosition(et.position() + a.flatbuffers.SIZE_PREFIX_LENGTH),
                                    (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                domain(et) {
                                    let j = this.bb.__offset(this.bb_pos, 4);
                                    return j ? this.bb.__string(this.bb_pos + j, et) : null
                                }
                                version() {
                                    let et = this.bb.__offset(this.bb_pos, 6);
                                    return et ? this.bb.readInt64(this.bb_pos + et) : this.bb.createLong(0, 0)
                                }
                                static startOperatorSetId(et) {
                                    et.startObject(2)
                                }
                                static addDomain(et, j) {
                                    et.addFieldOffset(0, j, 0)
                                }
                                static addVersion(et, j) {
                                    et.addFieldInt64(1, j, et.createLong(0, 0))
                                }
                                static endOperatorSetId(et) {
                                    return et.endObject()
                                }
                                static createOperatorSetId(et, j, it) {
                                    return rt.startOperatorSetId(et),
                                    rt.addDomain(et, j),
                                    rt.addVersion(et, it),
                                    rt.endOperatorSetId(et)
                                }
                            }
                            nt.OperatorSetId = rt
                        }
                        )(tt.fbs || (tt.fbs = {}))
                    }
                    )(_e.experimental || (_e.experimental = {}))
                }(i.onnxruntime || (i.onnxruntime = {})),
                function(_e) {
                    (function(tt) {
                        (function(nt) {
                            class rt {
                                constructor() {
                                    this.bb = null,
                                    this.bb_pos = 0
                                }
                                __init(et, j) {
                                    return this.bb_pos = et,
                                    this.bb = j,
                                    this
                                }
                                static getRootAsTensor(et, j) {
                                    return (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                static getSizePrefixedRootAsTensor(et, j) {
                                    return et.setPosition(et.position() + a.flatbuffers.SIZE_PREFIX_LENGTH),
                                    (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                name(et) {
                                    let j = this.bb.__offset(this.bb_pos, 4);
                                    return j ? this.bb.__string(this.bb_pos + j, et) : null
                                }
                                docString(et) {
                                    let j = this.bb.__offset(this.bb_pos, 6);
                                    return j ? this.bb.__string(this.bb_pos + j, et) : null
                                }
                                dims(et) {
                                    let j = this.bb.__offset(this.bb_pos, 8);
                                    return j ? this.bb.readInt64(this.bb.__vector(this.bb_pos + j) + 8 * et) : this.bb.createLong(0, 0)
                                }
                                dimsLength() {
                                    let et = this.bb.__offset(this.bb_pos, 8);
                                    return et ? this.bb.__vector_len(this.bb_pos + et) : 0
                                }
                                dataType() {
                                    let et = this.bb.__offset(this.bb_pos, 10);
                                    return et ? this.bb.readInt32(this.bb_pos + et) : _e.experimental.fbs.TensorDataType.UNDEFINED
                                }
                                rawData(et) {
                                    let j = this.bb.__offset(this.bb_pos, 12);
                                    return j ? this.bb.readUint8(this.bb.__vector(this.bb_pos + j) + et) : 0
                                }
                                rawDataLength() {
                                    let et = this.bb.__offset(this.bb_pos, 12);
                                    return et ? this.bb.__vector_len(this.bb_pos + et) : 0
                                }
                                rawDataArray() {
                                    let et = this.bb.__offset(this.bb_pos, 12);
                                    return et ? new Uint8Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + et),this.bb.__vector_len(this.bb_pos + et)) : null
                                }
                                stringData(et, j) {
                                    let it = this.bb.__offset(this.bb_pos, 14);
                                    return it ? this.bb.__string(this.bb.__vector(this.bb_pos + it) + 4 * et, j) : null
                                }
                                stringDataLength() {
                                    let et = this.bb.__offset(this.bb_pos, 14);
                                    return et ? this.bb.__vector_len(this.bb_pos + et) : 0
                                }
                                static startTensor(et) {
                                    et.startObject(6)
                                }
                                static addName(et, j) {
                                    et.addFieldOffset(0, j, 0)
                                }
                                static addDocString(et, j) {
                                    et.addFieldOffset(1, j, 0)
                                }
                                static addDims(et, j) {
                                    et.addFieldOffset(2, j, 0)
                                }
                                static createDimsVector(et, j) {
                                    et.startVector(8, j.length, 8);
                                    for (let it = j.length - 1; it >= 0; it--)
                                        et.addInt64(j[it]);
                                    return et.endVector()
                                }
                                static startDimsVector(et, j) {
                                    et.startVector(8, j, 8)
                                }
                                static addDataType(et, j) {
                                    et.addFieldInt32(3, j, _e.experimental.fbs.TensorDataType.UNDEFINED)
                                }
                                static addRawData(et, j) {
                                    et.addFieldOffset(4, j, 0)
                                }
                                static createRawDataVector(et, j) {
                                    et.startVector(1, j.length, 1);
                                    for (let it = j.length - 1; it >= 0; it--)
                                        et.addInt8(j[it]);
                                    return et.endVector()
                                }
                                static startRawDataVector(et, j) {
                                    et.startVector(1, j, 1)
                                }
                                static addStringData(et, j) {
                                    et.addFieldOffset(5, j, 0)
                                }
                                static createStringDataVector(et, j) {
                                    et.startVector(4, j.length, 4);
                                    for (let it = j.length - 1; it >= 0; it--)
                                        et.addOffset(j[it]);
                                    return et.endVector()
                                }
                                static startStringDataVector(et, j) {
                                    et.startVector(4, j, 4)
                                }
                                static endTensor(et) {
                                    return et.endObject()
                                }
                                static createTensor(et, j, it, st, at, lt, ct) {
                                    return rt.startTensor(et),
                                    rt.addName(et, j),
                                    rt.addDocString(et, it),
                                    rt.addDims(et, st),
                                    rt.addDataType(et, at),
                                    rt.addRawData(et, lt),
                                    rt.addStringData(et, ct),
                                    rt.endTensor(et)
                                }
                            }
                            nt.Tensor = rt
                        }
                        )(tt.fbs || (tt.fbs = {}))
                    }
                    )(_e.experimental || (_e.experimental = {}))
                }(i.onnxruntime || (i.onnxruntime = {})),
                function(_e) {
                    (function(tt) {
                        (function(nt) {
                            class rt {
                                constructor() {
                                    this.bb = null,
                                    this.bb_pos = 0
                                }
                                __init(et, j) {
                                    return this.bb_pos = et,
                                    this.bb = j,
                                    this
                                }
                                static getRootAsSparseTensor(et, j) {
                                    return (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                static getSizePrefixedRootAsSparseTensor(et, j) {
                                    return et.setPosition(et.position() + a.flatbuffers.SIZE_PREFIX_LENGTH),
                                    (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                values(et) {
                                    let j = this.bb.__offset(this.bb_pos, 4);
                                    return j ? (et || new _e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos + j), this.bb) : null
                                }
                                indices(et) {
                                    let j = this.bb.__offset(this.bb_pos, 6);
                                    return j ? (et || new _e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos + j), this.bb) : null
                                }
                                dims(et) {
                                    let j = this.bb.__offset(this.bb_pos, 8);
                                    return j ? this.bb.readInt64(this.bb.__vector(this.bb_pos + j) + 8 * et) : this.bb.createLong(0, 0)
                                }
                                dimsLength() {
                                    let et = this.bb.__offset(this.bb_pos, 8);
                                    return et ? this.bb.__vector_len(this.bb_pos + et) : 0
                                }
                                static startSparseTensor(et) {
                                    et.startObject(3)
                                }
                                static addValues(et, j) {
                                    et.addFieldOffset(0, j, 0)
                                }
                                static addIndices(et, j) {
                                    et.addFieldOffset(1, j, 0)
                                }
                                static addDims(et, j) {
                                    et.addFieldOffset(2, j, 0)
                                }
                                static createDimsVector(et, j) {
                                    et.startVector(8, j.length, 8);
                                    for (let it = j.length - 1; it >= 0; it--)
                                        et.addInt64(j[it]);
                                    return et.endVector()
                                }
                                static startDimsVector(et, j) {
                                    et.startVector(8, j, 8)
                                }
                                static endSparseTensor(et) {
                                    return et.endObject()
                                }
                                static createSparseTensor(et, j, it, st) {
                                    return rt.startSparseTensor(et),
                                    rt.addValues(et, j),
                                    rt.addIndices(et, it),
                                    rt.addDims(et, st),
                                    rt.endSparseTensor(et)
                                }
                            }
                            nt.SparseTensor = rt
                        }
                        )(tt.fbs || (tt.fbs = {}))
                    }
                    )(_e.experimental || (_e.experimental = {}))
                }(i.onnxruntime || (i.onnxruntime = {})),
                function(_e) {
                    (function(tt) {
                        (function(nt) {
                            class rt {
                                constructor() {
                                    this.bb = null,
                                    this.bb_pos = 0
                                }
                                __init(et, j) {
                                    return this.bb_pos = et,
                                    this.bb = j,
                                    this
                                }
                                static getRootAsAttribute(et, j) {
                                    return (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                static getSizePrefixedRootAsAttribute(et, j) {
                                    return et.setPosition(et.position() + a.flatbuffers.SIZE_PREFIX_LENGTH),
                                    (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                name(et) {
                                    let j = this.bb.__offset(this.bb_pos, 4);
                                    return j ? this.bb.__string(this.bb_pos + j, et) : null
                                }
                                docString(et) {
                                    let j = this.bb.__offset(this.bb_pos, 6);
                                    return j ? this.bb.__string(this.bb_pos + j, et) : null
                                }
                                type() {
                                    let et = this.bb.__offset(this.bb_pos, 8);
                                    return et ? this.bb.readInt32(this.bb_pos + et) : _e.experimental.fbs.AttributeType.UNDEFINED
                                }
                                f() {
                                    let et = this.bb.__offset(this.bb_pos, 10);
                                    return et ? this.bb.readFloat32(this.bb_pos + et) : 0
                                }
                                i() {
                                    let et = this.bb.__offset(this.bb_pos, 12);
                                    return et ? this.bb.readInt64(this.bb_pos + et) : this.bb.createLong(0, 0)
                                }
                                s(et) {
                                    let j = this.bb.__offset(this.bb_pos, 14);
                                    return j ? this.bb.__string(this.bb_pos + j, et) : null
                                }
                                t(et) {
                                    let j = this.bb.__offset(this.bb_pos, 16);
                                    return j ? (et || new _e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb_pos + j), this.bb) : null
                                }
                                g(et) {
                                    let j = this.bb.__offset(this.bb_pos, 18);
                                    return j ? (et || new _e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos + j), this.bb) : null
                                }
                                floats(et) {
                                    let j = this.bb.__offset(this.bb_pos, 20);
                                    return j ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + j) + 4 * et) : 0
                                }
                                floatsLength() {
                                    let et = this.bb.__offset(this.bb_pos, 20);
                                    return et ? this.bb.__vector_len(this.bb_pos + et) : 0
                                }
                                floatsArray() {
                                    let et = this.bb.__offset(this.bb_pos, 20);
                                    return et ? new Float32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + et),this.bb.__vector_len(this.bb_pos + et)) : null
                                }
                                ints(et) {
                                    let j = this.bb.__offset(this.bb_pos, 22);
                                    return j ? this.bb.readInt64(this.bb.__vector(this.bb_pos + j) + 8 * et) : this.bb.createLong(0, 0)
                                }
                                intsLength() {
                                    let et = this.bb.__offset(this.bb_pos, 22);
                                    return et ? this.bb.__vector_len(this.bb_pos + et) : 0
                                }
                                strings(et, j) {
                                    let it = this.bb.__offset(this.bb_pos, 24);
                                    return it ? this.bb.__string(this.bb.__vector(this.bb_pos + it) + 4 * et, j) : null
                                }
                                stringsLength() {
                                    let et = this.bb.__offset(this.bb_pos, 24);
                                    return et ? this.bb.__vector_len(this.bb_pos + et) : 0
                                }
                                tensors(et, j) {
                                    let it = this.bb.__offset(this.bb_pos, 26);
                                    return it ? (j || new _e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + it) + 4 * et), this.bb) : null
                                }
                                tensorsLength() {
                                    let et = this.bb.__offset(this.bb_pos, 26);
                                    return et ? this.bb.__vector_len(this.bb_pos + et) : 0
                                }
                                graphs(et, j) {
                                    let it = this.bb.__offset(this.bb_pos, 28);
                                    return it ? (j || new _e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + it) + 4 * et), this.bb) : null
                                }
                                graphsLength() {
                                    let et = this.bb.__offset(this.bb_pos, 28);
                                    return et ? this.bb.__vector_len(this.bb_pos + et) : 0
                                }
                                static startAttribute(et) {
                                    et.startObject(13)
                                }
                                static addName(et, j) {
                                    et.addFieldOffset(0, j, 0)
                                }
                                static addDocString(et, j) {
                                    et.addFieldOffset(1, j, 0)
                                }
                                static addType(et, j) {
                                    et.addFieldInt32(2, j, _e.experimental.fbs.AttributeType.UNDEFINED)
                                }
                                static addF(et, j) {
                                    et.addFieldFloat32(3, j, 0)
                                }
                                static addI(et, j) {
                                    et.addFieldInt64(4, j, et.createLong(0, 0))
                                }
                                static addS(et, j) {
                                    et.addFieldOffset(5, j, 0)
                                }
                                static addT(et, j) {
                                    et.addFieldOffset(6, j, 0)
                                }
                                static addG(et, j) {
                                    et.addFieldOffset(7, j, 0)
                                }
                                static addFloats(et, j) {
                                    et.addFieldOffset(8, j, 0)
                                }
                                static createFloatsVector(et, j) {
                                    et.startVector(4, j.length, 4);
                                    for (let it = j.length - 1; it >= 0; it--)
                                        et.addFloat32(j[it]);
                                    return et.endVector()
                                }
                                static startFloatsVector(et, j) {
                                    et.startVector(4, j, 4)
                                }
                                static addInts(et, j) {
                                    et.addFieldOffset(9, j, 0)
                                }
                                static createIntsVector(et, j) {
                                    et.startVector(8, j.length, 8);
                                    for (let it = j.length - 1; it >= 0; it--)
                                        et.addInt64(j[it]);
                                    return et.endVector()
                                }
                                static startIntsVector(et, j) {
                                    et.startVector(8, j, 8)
                                }
                                static addStrings(et, j) {
                                    et.addFieldOffset(10, j, 0)
                                }
                                static createStringsVector(et, j) {
                                    et.startVector(4, j.length, 4);
                                    for (let it = j.length - 1; it >= 0; it--)
                                        et.addOffset(j[it]);
                                    return et.endVector()
                                }
                                static startStringsVector(et, j) {
                                    et.startVector(4, j, 4)
                                }
                                static addTensors(et, j) {
                                    et.addFieldOffset(11, j, 0)
                                }
                                static createTensorsVector(et, j) {
                                    et.startVector(4, j.length, 4);
                                    for (let it = j.length - 1; it >= 0; it--)
                                        et.addOffset(j[it]);
                                    return et.endVector()
                                }
                                static startTensorsVector(et, j) {
                                    et.startVector(4, j, 4)
                                }
                                static addGraphs(et, j) {
                                    et.addFieldOffset(12, j, 0)
                                }
                                static createGraphsVector(et, j) {
                                    et.startVector(4, j.length, 4);
                                    for (let it = j.length - 1; it >= 0; it--)
                                        et.addOffset(j[it]);
                                    return et.endVector()
                                }
                                static startGraphsVector(et, j) {
                                    et.startVector(4, j, 4)
                                }
                                static endAttribute(et) {
                                    return et.endObject()
                                }
                                static createAttribute(et, j, it, st, at, lt, ct, ut, dt, ft, ht, pt, gt, _t) {
                                    return rt.startAttribute(et),
                                    rt.addName(et, j),
                                    rt.addDocString(et, it),
                                    rt.addType(et, st),
                                    rt.addF(et, at),
                                    rt.addI(et, lt),
                                    rt.addS(et, ct),
                                    rt.addT(et, ut),
                                    rt.addG(et, dt),
                                    rt.addFloats(et, ft),
                                    rt.addInts(et, ht),
                                    rt.addStrings(et, pt),
                                    rt.addTensors(et, gt),
                                    rt.addGraphs(et, _t),
                                    rt.endAttribute(et)
                                }
                            }
                            nt.Attribute = rt
                        }
                        )(tt.fbs || (tt.fbs = {}))
                    }
                    )(_e.experimental || (_e.experimental = {}))
                }(i.onnxruntime || (i.onnxruntime = {})),
                function(_e) {
                    (function(tt) {
                        (function(nt) {
                            class rt {
                                constructor() {
                                    this.bb = null,
                                    this.bb_pos = 0
                                }
                                __init(et, j) {
                                    return this.bb_pos = et,
                                    this.bb = j,
                                    this
                                }
                                static getRootAsGraph(et, j) {
                                    return (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                static getSizePrefixedRootAsGraph(et, j) {
                                    return et.setPosition(et.position() + a.flatbuffers.SIZE_PREFIX_LENGTH),
                                    (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                initializers(et, j) {
                                    let it = this.bb.__offset(this.bb_pos, 4);
                                    return it ? (j || new _e.experimental.fbs.Tensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + it) + 4 * et), this.bb) : null
                                }
                                initializersLength() {
                                    let et = this.bb.__offset(this.bb_pos, 4);
                                    return et ? this.bb.__vector_len(this.bb_pos + et) : 0
                                }
                                nodeArgs(et, j) {
                                    let it = this.bb.__offset(this.bb_pos, 6);
                                    return it ? (j || new _e.experimental.fbs.ValueInfo).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + it) + 4 * et), this.bb) : null
                                }
                                nodeArgsLength() {
                                    let et = this.bb.__offset(this.bb_pos, 6);
                                    return et ? this.bb.__vector_len(this.bb_pos + et) : 0
                                }
                                nodes(et, j) {
                                    let it = this.bb.__offset(this.bb_pos, 8);
                                    return it ? (j || new _e.experimental.fbs.Node).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + it) + 4 * et), this.bb) : null
                                }
                                nodesLength() {
                                    let et = this.bb.__offset(this.bb_pos, 8);
                                    return et ? this.bb.__vector_len(this.bb_pos + et) : 0
                                }
                                maxNodeIndex() {
                                    let et = this.bb.__offset(this.bb_pos, 10);
                                    return et ? this.bb.readUint32(this.bb_pos + et) : 0
                                }
                                nodeEdges(et, j) {
                                    let it = this.bb.__offset(this.bb_pos, 12);
                                    return it ? (j || new _e.experimental.fbs.NodeEdge).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + it) + 4 * et), this.bb) : null
                                }
                                nodeEdgesLength() {
                                    let et = this.bb.__offset(this.bb_pos, 12);
                                    return et ? this.bb.__vector_len(this.bb_pos + et) : 0
                                }
                                inputs(et, j) {
                                    let it = this.bb.__offset(this.bb_pos, 14);
                                    return it ? this.bb.__string(this.bb.__vector(this.bb_pos + it) + 4 * et, j) : null
                                }
                                inputsLength() {
                                    let et = this.bb.__offset(this.bb_pos, 14);
                                    return et ? this.bb.__vector_len(this.bb_pos + et) : 0
                                }
                                outputs(et, j) {
                                    let it = this.bb.__offset(this.bb_pos, 16);
                                    return it ? this.bb.__string(this.bb.__vector(this.bb_pos + it) + 4 * et, j) : null
                                }
                                outputsLength() {
                                    let et = this.bb.__offset(this.bb_pos, 16);
                                    return et ? this.bb.__vector_len(this.bb_pos + et) : 0
                                }
                                sparseInitializers(et, j) {
                                    let it = this.bb.__offset(this.bb_pos, 18);
                                    return it ? (j || new _e.experimental.fbs.SparseTensor).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + it) + 4 * et), this.bb) : null
                                }
                                sparseInitializersLength() {
                                    let et = this.bb.__offset(this.bb_pos, 18);
                                    return et ? this.bb.__vector_len(this.bb_pos + et) : 0
                                }
                                static startGraph(et) {
                                    et.startObject(8)
                                }
                                static addInitializers(et, j) {
                                    et.addFieldOffset(0, j, 0)
                                }
                                static createInitializersVector(et, j) {
                                    et.startVector(4, j.length, 4);
                                    for (let it = j.length - 1; it >= 0; it--)
                                        et.addOffset(j[it]);
                                    return et.endVector()
                                }
                                static startInitializersVector(et, j) {
                                    et.startVector(4, j, 4)
                                }
                                static addNodeArgs(et, j) {
                                    et.addFieldOffset(1, j, 0)
                                }
                                static createNodeArgsVector(et, j) {
                                    et.startVector(4, j.length, 4);
                                    for (let it = j.length - 1; it >= 0; it--)
                                        et.addOffset(j[it]);
                                    return et.endVector()
                                }
                                static startNodeArgsVector(et, j) {
                                    et.startVector(4, j, 4)
                                }
                                static addNodes(et, j) {
                                    et.addFieldOffset(2, j, 0)
                                }
                                static createNodesVector(et, j) {
                                    et.startVector(4, j.length, 4);
                                    for (let it = j.length - 1; it >= 0; it--)
                                        et.addOffset(j[it]);
                                    return et.endVector()
                                }
                                static startNodesVector(et, j) {
                                    et.startVector(4, j, 4)
                                }
                                static addMaxNodeIndex(et, j) {
                                    et.addFieldInt32(3, j, 0)
                                }
                                static addNodeEdges(et, j) {
                                    et.addFieldOffset(4, j, 0)
                                }
                                static createNodeEdgesVector(et, j) {
                                    et.startVector(4, j.length, 4);
                                    for (let it = j.length - 1; it >= 0; it--)
                                        et.addOffset(j[it]);
                                    return et.endVector()
                                }
                                static startNodeEdgesVector(et, j) {
                                    et.startVector(4, j, 4)
                                }
                                static addInputs(et, j) {
                                    et.addFieldOffset(5, j, 0)
                                }
                                static createInputsVector(et, j) {
                                    et.startVector(4, j.length, 4);
                                    for (let it = j.length - 1; it >= 0; it--)
                                        et.addOffset(j[it]);
                                    return et.endVector()
                                }
                                static startInputsVector(et, j) {
                                    et.startVector(4, j, 4)
                                }
                                static addOutputs(et, j) {
                                    et.addFieldOffset(6, j, 0)
                                }
                                static createOutputsVector(et, j) {
                                    et.startVector(4, j.length, 4);
                                    for (let it = j.length - 1; it >= 0; it--)
                                        et.addOffset(j[it]);
                                    return et.endVector()
                                }
                                static startOutputsVector(et, j) {
                                    et.startVector(4, j, 4)
                                }
                                static addSparseInitializers(et, j) {
                                    et.addFieldOffset(7, j, 0)
                                }
                                static createSparseInitializersVector(et, j) {
                                    et.startVector(4, j.length, 4);
                                    for (let it = j.length - 1; it >= 0; it--)
                                        et.addOffset(j[it]);
                                    return et.endVector()
                                }
                                static startSparseInitializersVector(et, j) {
                                    et.startVector(4, j, 4)
                                }
                                static endGraph(et) {
                                    return et.endObject()
                                }
                                static createGraph(et, j, it, st, at, lt, ct, ut, dt) {
                                    return rt.startGraph(et),
                                    rt.addInitializers(et, j),
                                    rt.addNodeArgs(et, it),
                                    rt.addNodes(et, st),
                                    rt.addMaxNodeIndex(et, at),
                                    rt.addNodeEdges(et, lt),
                                    rt.addInputs(et, ct),
                                    rt.addOutputs(et, ut),
                                    rt.addSparseInitializers(et, dt),
                                    rt.endGraph(et)
                                }
                            }
                            nt.Graph = rt
                        }
                        )(tt.fbs || (tt.fbs = {}))
                    }
                    )(_e.experimental || (_e.experimental = {}))
                }(i.onnxruntime || (i.onnxruntime = {})),
                function(_e) {
                    (function(tt) {
                        (function(nt) {
                            class rt {
                                constructor() {
                                    this.bb = null,
                                    this.bb_pos = 0
                                }
                                __init(et, j) {
                                    return this.bb_pos = et,
                                    this.bb = j,
                                    this
                                }
                                static getRootAsModel(et, j) {
                                    return (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                static getSizePrefixedRootAsModel(et, j) {
                                    return et.setPosition(et.position() + a.flatbuffers.SIZE_PREFIX_LENGTH),
                                    (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                irVersion() {
                                    let et = this.bb.__offset(this.bb_pos, 4);
                                    return et ? this.bb.readInt64(this.bb_pos + et) : this.bb.createLong(0, 0)
                                }
                                opsetImport(et, j) {
                                    let it = this.bb.__offset(this.bb_pos, 6);
                                    return it ? (j || new _e.experimental.fbs.OperatorSetId).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + it) + 4 * et), this.bb) : null
                                }
                                opsetImportLength() {
                                    let et = this.bb.__offset(this.bb_pos, 6);
                                    return et ? this.bb.__vector_len(this.bb_pos + et) : 0
                                }
                                producerName(et) {
                                    let j = this.bb.__offset(this.bb_pos, 8);
                                    return j ? this.bb.__string(this.bb_pos + j, et) : null
                                }
                                producerVersion(et) {
                                    let j = this.bb.__offset(this.bb_pos, 10);
                                    return j ? this.bb.__string(this.bb_pos + j, et) : null
                                }
                                domain(et) {
                                    let j = this.bb.__offset(this.bb_pos, 12);
                                    return j ? this.bb.__string(this.bb_pos + j, et) : null
                                }
                                modelVersion() {
                                    let et = this.bb.__offset(this.bb_pos, 14);
                                    return et ? this.bb.readInt64(this.bb_pos + et) : this.bb.createLong(0, 0)
                                }
                                docString(et) {
                                    let j = this.bb.__offset(this.bb_pos, 16);
                                    return j ? this.bb.__string(this.bb_pos + j, et) : null
                                }
                                graph(et) {
                                    let j = this.bb.__offset(this.bb_pos, 18);
                                    return j ? (et || new _e.experimental.fbs.Graph).__init(this.bb.__indirect(this.bb_pos + j), this.bb) : null
                                }
                                graphDocString(et) {
                                    let j = this.bb.__offset(this.bb_pos, 20);
                                    return j ? this.bb.__string(this.bb_pos + j, et) : null
                                }
                                static startModel(et) {
                                    et.startObject(9)
                                }
                                static addIrVersion(et, j) {
                                    et.addFieldInt64(0, j, et.createLong(0, 0))
                                }
                                static addOpsetImport(et, j) {
                                    et.addFieldOffset(1, j, 0)
                                }
                                static createOpsetImportVector(et, j) {
                                    et.startVector(4, j.length, 4);
                                    for (let it = j.length - 1; it >= 0; it--)
                                        et.addOffset(j[it]);
                                    return et.endVector()
                                }
                                static startOpsetImportVector(et, j) {
                                    et.startVector(4, j, 4)
                                }
                                static addProducerName(et, j) {
                                    et.addFieldOffset(2, j, 0)
                                }
                                static addProducerVersion(et, j) {
                                    et.addFieldOffset(3, j, 0)
                                }
                                static addDomain(et, j) {
                                    et.addFieldOffset(4, j, 0)
                                }
                                static addModelVersion(et, j) {
                                    et.addFieldInt64(5, j, et.createLong(0, 0))
                                }
                                static addDocString(et, j) {
                                    et.addFieldOffset(6, j, 0)
                                }
                                static addGraph(et, j) {
                                    et.addFieldOffset(7, j, 0)
                                }
                                static addGraphDocString(et, j) {
                                    et.addFieldOffset(8, j, 0)
                                }
                                static endModel(et) {
                                    return et.endObject()
                                }
                                static createModel(et, j, it, st, at, lt, ct, ut, dt, ft) {
                                    return rt.startModel(et),
                                    rt.addIrVersion(et, j),
                                    rt.addOpsetImport(et, it),
                                    rt.addProducerName(et, st),
                                    rt.addProducerVersion(et, at),
                                    rt.addDomain(et, lt),
                                    rt.addModelVersion(et, ct),
                                    rt.addDocString(et, ut),
                                    rt.addGraph(et, dt),
                                    rt.addGraphDocString(et, ft),
                                    rt.endModel(et)
                                }
                            }
                            nt.Model = rt
                        }
                        )(tt.fbs || (tt.fbs = {}))
                    }
                    )(_e.experimental || (_e.experimental = {}))
                }(i.onnxruntime || (i.onnxruntime = {})),
                function(_e) {
                    (function(tt) {
                        (function(nt) {
                            class rt {
                                constructor() {
                                    this.bb = null,
                                    this.bb_pos = 0
                                }
                                __init(et, j) {
                                    return this.bb_pos = et,
                                    this.bb = j,
                                    this
                                }
                                static getRootAsKernelCreateInfos(et, j) {
                                    return (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                static getSizePrefixedRootAsKernelCreateInfos(et, j) {
                                    return et.setPosition(et.position() + a.flatbuffers.SIZE_PREFIX_LENGTH),
                                    (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                nodeIndices(et) {
                                    let j = this.bb.__offset(this.bb_pos, 4);
                                    return j ? this.bb.readUint32(this.bb.__vector(this.bb_pos + j) + 4 * et) : 0
                                }
                                nodeIndicesLength() {
                                    let et = this.bb.__offset(this.bb_pos, 4);
                                    return et ? this.bb.__vector_len(this.bb_pos + et) : 0
                                }
                                nodeIndicesArray() {
                                    let et = this.bb.__offset(this.bb_pos, 4);
                                    return et ? new Uint32Array(this.bb.bytes().buffer,this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + et),this.bb.__vector_len(this.bb_pos + et)) : null
                                }
                                kernelDefHashes(et) {
                                    let j = this.bb.__offset(this.bb_pos, 6);
                                    return j ? this.bb.readUint64(this.bb.__vector(this.bb_pos + j) + 8 * et) : this.bb.createLong(0, 0)
                                }
                                kernelDefHashesLength() {
                                    let et = this.bb.__offset(this.bb_pos, 6);
                                    return et ? this.bb.__vector_len(this.bb_pos + et) : 0
                                }
                                static startKernelCreateInfos(et) {
                                    et.startObject(2)
                                }
                                static addNodeIndices(et, j) {
                                    et.addFieldOffset(0, j, 0)
                                }
                                static createNodeIndicesVector(et, j) {
                                    et.startVector(4, j.length, 4);
                                    for (let it = j.length - 1; it >= 0; it--)
                                        et.addInt32(j[it]);
                                    return et.endVector()
                                }
                                static startNodeIndicesVector(et, j) {
                                    et.startVector(4, j, 4)
                                }
                                static addKernelDefHashes(et, j) {
                                    et.addFieldOffset(1, j, 0)
                                }
                                static createKernelDefHashesVector(et, j) {
                                    et.startVector(8, j.length, 8);
                                    for (let it = j.length - 1; it >= 0; it--)
                                        et.addInt64(j[it]);
                                    return et.endVector()
                                }
                                static startKernelDefHashesVector(et, j) {
                                    et.startVector(8, j, 8)
                                }
                                static endKernelCreateInfos(et) {
                                    return et.endObject()
                                }
                                static createKernelCreateInfos(et, j, it) {
                                    return rt.startKernelCreateInfos(et),
                                    rt.addNodeIndices(et, j),
                                    rt.addKernelDefHashes(et, it),
                                    rt.endKernelCreateInfos(et)
                                }
                            }
                            nt.KernelCreateInfos = rt
                        }
                        )(tt.fbs || (tt.fbs = {}))
                    }
                    )(_e.experimental || (_e.experimental = {}))
                }(i.onnxruntime || (i.onnxruntime = {})),
                function(_e) {
                    (function(tt) {
                        (function(nt) {
                            class rt {
                                constructor() {
                                    this.bb = null,
                                    this.bb_pos = 0
                                }
                                __init(et, j) {
                                    return this.bb_pos = et,
                                    this.bb = j,
                                    this
                                }
                                static getRootAsSubGraphSessionState(et, j) {
                                    return (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                static getSizePrefixedRootAsSubGraphSessionState(et, j) {
                                    return et.setPosition(et.position() + a.flatbuffers.SIZE_PREFIX_LENGTH),
                                    (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                graphId(et) {
                                    let j = this.bb.__offset(this.bb_pos, 4);
                                    return j ? this.bb.__string(this.bb_pos + j, et) : null
                                }
                                sessionState(et) {
                                    let j = this.bb.__offset(this.bb_pos, 6);
                                    return j ? (et || new _e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos + j), this.bb) : null
                                }
                                static startSubGraphSessionState(et) {
                                    et.startObject(2)
                                }
                                static addGraphId(et, j) {
                                    et.addFieldOffset(0, j, 0)
                                }
                                static addSessionState(et, j) {
                                    et.addFieldOffset(1, j, 0)
                                }
                                static endSubGraphSessionState(et) {
                                    let j = et.endObject();
                                    return et.requiredField(j, 4),
                                    j
                                }
                                static createSubGraphSessionState(et, j, it) {
                                    return rt.startSubGraphSessionState(et),
                                    rt.addGraphId(et, j),
                                    rt.addSessionState(et, it),
                                    rt.endSubGraphSessionState(et)
                                }
                            }
                            nt.SubGraphSessionState = rt
                        }
                        )(tt.fbs || (tt.fbs = {}))
                    }
                    )(_e.experimental || (_e.experimental = {}))
                }(i.onnxruntime || (i.onnxruntime = {})),
                function(_e) {
                    (function(tt) {
                        (function(nt) {
                            class rt {
                                constructor() {
                                    this.bb = null,
                                    this.bb_pos = 0
                                }
                                __init(et, j) {
                                    return this.bb_pos = et,
                                    this.bb = j,
                                    this
                                }
                                static getRootAsSessionState(et, j) {
                                    return (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                static getSizePrefixedRootAsSessionState(et, j) {
                                    return et.setPosition(et.position() + a.flatbuffers.SIZE_PREFIX_LENGTH),
                                    (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                kernels(et) {
                                    let j = this.bb.__offset(this.bb_pos, 4);
                                    return j ? (et || new _e.experimental.fbs.KernelCreateInfos).__init(this.bb.__indirect(this.bb_pos + j), this.bb) : null
                                }
                                subGraphSessionStates(et, j) {
                                    let it = this.bb.__offset(this.bb_pos, 6);
                                    return it ? (j || new _e.experimental.fbs.SubGraphSessionState).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + it) + 4 * et), this.bb) : null
                                }
                                subGraphSessionStatesLength() {
                                    let et = this.bb.__offset(this.bb_pos, 6);
                                    return et ? this.bb.__vector_len(this.bb_pos + et) : 0
                                }
                                static startSessionState(et) {
                                    et.startObject(2)
                                }
                                static addKernels(et, j) {
                                    et.addFieldOffset(0, j, 0)
                                }
                                static addSubGraphSessionStates(et, j) {
                                    et.addFieldOffset(1, j, 0)
                                }
                                static createSubGraphSessionStatesVector(et, j) {
                                    et.startVector(4, j.length, 4);
                                    for (let it = j.length - 1; it >= 0; it--)
                                        et.addOffset(j[it]);
                                    return et.endVector()
                                }
                                static startSubGraphSessionStatesVector(et, j) {
                                    et.startVector(4, j, 4)
                                }
                                static endSessionState(et) {
                                    return et.endObject()
                                }
                                static createSessionState(et, j, it) {
                                    return rt.startSessionState(et),
                                    rt.addKernels(et, j),
                                    rt.addSubGraphSessionStates(et, it),
                                    rt.endSessionState(et)
                                }
                            }
                            nt.SessionState = rt
                        }
                        )(tt.fbs || (tt.fbs = {}))
                    }
                    )(_e.experimental || (_e.experimental = {}))
                }(i.onnxruntime || (i.onnxruntime = {})),
                function(_e) {
                    (function(tt) {
                        (function(nt) {
                            class rt {
                                constructor() {
                                    this.bb = null,
                                    this.bb_pos = 0
                                }
                                __init(et, j) {
                                    return this.bb_pos = et,
                                    this.bb = j,
                                    this
                                }
                                static getRootAsInferenceSession(et, j) {
                                    return (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                static getSizePrefixedRootAsInferenceSession(et, j) {
                                    return et.setPosition(et.position() + a.flatbuffers.SIZE_PREFIX_LENGTH),
                                    (j || new rt).__init(et.readInt32(et.position()) + et.position(), et)
                                }
                                static bufferHasIdentifier(et) {
                                    return et.__has_identifier("ORTM")
                                }
                                ortVersion(et) {
                                    let j = this.bb.__offset(this.bb_pos, 4);
                                    return j ? this.bb.__string(this.bb_pos + j, et) : null
                                }
                                model(et) {
                                    let j = this.bb.__offset(this.bb_pos, 6);
                                    return j ? (et || new _e.experimental.fbs.Model).__init(this.bb.__indirect(this.bb_pos + j), this.bb) : null
                                }
                                sessionState(et) {
                                    let j = this.bb.__offset(this.bb_pos, 8);
                                    return j ? (et || new _e.experimental.fbs.SessionState).__init(this.bb.__indirect(this.bb_pos + j), this.bb) : null
                                }
                                static startInferenceSession(et) {
                                    et.startObject(3)
                                }
                                static addOrtVersion(et, j) {
                                    et.addFieldOffset(0, j, 0)
                                }
                                static addModel(et, j) {
                                    et.addFieldOffset(1, j, 0)
                                }
                                static addSessionState(et, j) {
                                    et.addFieldOffset(2, j, 0)
                                }
                                static endInferenceSession(et) {
                                    return et.endObject()
                                }
                                static finishInferenceSessionBuffer(et, j) {
                                    et.finish(j, "ORTM")
                                }
                                static finishSizePrefixedInferenceSessionBuffer(et, j) {
                                    et.finish(j, "ORTM", !0)
                                }
                                static createInferenceSession(et, j, it, st) {
                                    return rt.startInferenceSession(et),
                                    rt.addOrtVersion(et, j),
                                    rt.addModel(et, it),
                                    rt.addSessionState(et, st),
                                    rt.endInferenceSession(et)
                                }
                            }
                            nt.InferenceSession = rt
                        }
                        )(tt.fbs || (tt.fbs = {}))
                    }
                    )(_e.experimental || (_e.experimental = {}))
                }(i.onnxruntime || (i.onnxruntime = {}))
            }
            ,
            1723: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.OnnxjsSessionHandler = void 0;
                const a = s(8453)
                  , _ = s(9240);
                i.OnnxjsSessionHandler = class {
                    constructor($) {
                        this.session = $,
                        this.inputNames = this.session.inputNames,
                        this.outputNames = this.session.outputNames
                    }
                    async dispose() {}
                    async run($, _e, tt) {
                        const nt = new Map;
                        for (const et in $)
                            if (Object.hasOwnProperty.call($, et)) {
                                const j = $[et];
                                nt.set(et, new _.Tensor(j.dims,j.type,void 0,void 0,j.data))
                            }
                        const rt = await this.session.run(nt)
                          , ot = {};
                        return rt.forEach( (et, j) => {
                            ot[j] = new a.Tensor(et.type,et.data,et.dims)
                        }
                        ),
                        ot
                    }
                    startProfiling() {
                        this.session.startProfiling()
                    }
                    endProfiling() {
                        this.session.endProfiling()
                    }
                }
            }
            ,
            6027: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.Session = void 0;
                const a = s(7067)
                  , _ = s(1296)
                  , $ = s(1975)
                  , _e = s(6496)
                  , tt = s(1315)
                  , nt = s(1745);
                i.Session = class {
                    constructor(rt={}) {
                        this._initialized = !1,
                        this.backendHint = rt.backendHint,
                        this.profiler = tt.Profiler.create(rt.profiler),
                        this.context = {
                            profiler: this.profiler,
                            graphInputTypes: [],
                            graphInputDims: []
                        }
                    }
                    get inputNames() {
                        return this._model.graph.getInputNames()
                    }
                    get outputNames() {
                        return this._model.graph.getOutputNames()
                    }
                    startProfiling() {
                        this.profiler.start()
                    }
                    endProfiling() {
                        this.profiler.stop()
                    }
                    async loadModel(rt, ot, et) {
                        await this.profiler.event("session", "Session.loadModel", async () => {
                            const j = await (0,
                            $.resolveBackend)(this.backendHint);
                            if (this.sessionHandler = j.createSessionHandler(this.context),
                            this._model = new nt.Model,
                            typeof rt == "string") {
                                const it = rt.endsWith(".ort");
                                if (typeof fetch > "u") {
                                    const st = await (0,
                                    _.promisify)(a.readFile)(rt);
                                    this.initialize(st, it)
                                } else {
                                    const st = await fetch(rt)
                                      , at = await st.arrayBuffer();
                                    this.initialize(new Uint8Array(at), it)
                                }
                            } else if (ArrayBuffer.isView(rt))
                                this.initialize(rt);
                            else {
                                const it = new Uint8Array(rt,ot || 0,et || rt.byteLength);
                                this.initialize(it)
                            }
                        }
                        )
                    }
                    initialize(rt, ot) {
                        if (this._initialized)
                            throw new Error("already initialized");
                        this.profiler.event("session", "Session.initialize", () => {
                            const et = this.sessionHandler.transformGraph ? this.sessionHandler : void 0;
                            this._model.load(rt, et, ot),
                            this.sessionHandler.onGraphInitialized && this.sessionHandler.onGraphInitialized(this._model.graph),
                            this.initializeOps(this._model.graph),
                            this._executionPlan = new _e.ExecutionPlan(this._model.graph,this._ops,this.profiler)
                        }
                        ),
                        this._initialized = !0
                    }
                    async run(rt) {
                        if (!this._initialized)
                            throw new Error("session not initialized yet");
                        return this.profiler.event("session", "Session.run", async () => {
                            const ot = this.normalizeAndValidateInputs(rt)
                              , et = await this._executionPlan.execute(this.sessionHandler, ot);
                            return this.createOutput(et)
                        }
                        )
                    }
                    normalizeAndValidateInputs(rt) {
                        const ot = this._model.graph.getInputNames();
                        if (Array.isArray(rt)) {
                            if (rt.length !== ot.length)
                                throw new Error(`incorrect input array length: expected ${ot.length} but got ${rt.length}`)
                        } else {
                            if (rt.size !== ot.length)
                                throw new Error(`incorrect input map size: expected ${ot.length} but got ${rt.size}`);
                            const et = new Array(rt.size);
                            let j = 0;
                            for (let it = 0; it < ot.length; ++it) {
                                const st = rt.get(ot[it]);
                                if (!st)
                                    throw new Error(`missing input tensor for: '${name}'`);
                                et[j++] = st
                            }
                            rt = et
                        }
                        if (this.context.graphInputTypes && this.context.graphInputTypes.length !== 0 && this.context.graphInputDims && this.context.graphInputDims.length !== 0)
                            this.validateInputTensorDims(this.context.graphInputDims, rt, !1);
                        else {
                            const et = this._model.graph.getInputIndices()
                              , j = this._model.graph.getValues()
                              , it = new Array(et.length);
                            for (let st = 0; st < et.length; ++st) {
                                const at = j[et[st]];
                                it[st] = at.type.shape.dims,
                                this.context.graphInputTypes.push(at.type.tensorType),
                                this.context.graphInputDims.push(rt[st].dims)
                            }
                            this.validateInputTensorDims(it, rt, !0)
                        }
                        return this.validateInputTensorTypes(this.context.graphInputTypes, rt),
                        rt
                    }
                    validateInputTensorTypes(rt, ot) {
                        for (let et = 0; et < ot.length; et++) {
                            const j = rt[et]
                              , it = ot[et].type;
                            if (j !== it)
                                throw new Error(`input tensor[${et}] check failed: expected type '${j}' but got ${it}`)
                        }
                    }
                    validateInputTensorDims(rt, ot, et) {
                        for (let j = 0; j < ot.length; j++) {
                            const it = rt[j]
                              , st = ot[j].dims;
                            if (!this.compareTensorDims(it, st, et))
                                throw new Error(`input tensor[${j}] check failed: expected shape '[${it.join(",")}]' but got [${st.join(",")}]`)
                        }
                    }
                    compareTensorDims(rt, ot, et) {
                        if (rt.length !== ot.length)
                            return !1;
                        for (let j = 0; j < rt.length; ++j)
                            if (rt[j] !== ot[j] && (!et || rt[j] !== 0))
                                return !1;
                        return !0
                    }
                    createOutput(rt) {
                        const ot = this._model.graph.getOutputNames();
                        if (rt.length !== ot.length)
                            throw new Error("expected number of outputs do not match number of generated outputs");
                        const et = new Map;
                        for (let j = 0; j < ot.length; ++j)
                            et.set(ot[j], rt[j]);
                        return et
                    }
                    initializeOps(rt) {
                        const ot = rt.getNodes();
                        this._ops = new Array(ot.length);
                        for (let et = 0; et < ot.length; et++)
                            this._ops[et] = this.sessionHandler.resolve(ot[et], this._model.opsets, rt)
                    }
                }
            }
            ,
            9240: function(o, i, s) {
                var a = this && this.__importDefault || function(at) {
                    return at && at.__esModule ? at : {
                        default: at
                    }
                }
                ;
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.Tensor = void 0;
                const _ = s(3442)
                  , $ = a(s(3720))
                  , _e = s(1446)
                  , tt = s(1287)
                  , nt = s(7273);
                var rt = tt.onnxruntime.experimental.fbs;
                class ot {
                    get data() {
                        if (this.cache === void 0) {
                            const lt = this.dataProvider(this.dataId);
                            if (lt.length !== this.size)
                                throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");
                            this.cache = lt
                        }
                        return this.cache
                    }
                    get stringData() {
                        if (this.type !== "string")
                            throw new TypeError("data type is not string");
                        return this.data
                    }
                    get integerData() {
                        switch (this.type) {
                        case "uint8":
                        case "int8":
                        case "uint16":
                        case "int16":
                        case "int32":
                        case "uint32":
                        case "bool":
                            return this.data;
                        default:
                            throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)")
                        }
                    }
                    get floatData() {
                        switch (this.type) {
                        case "float32":
                        case "float64":
                            return this.data;
                        default:
                            throw new TypeError("data type is not float (float32, float64)")
                        }
                    }
                    get numberData() {
                        if (this.type !== "string")
                            return this.data;
                        throw new TypeError("type cannot be non-number (string)")
                    }
                    get(lt) {
                        return this.data[nt.ShapeUtil.indicesToOffset(lt, this.strides)]
                    }
                    set(lt, ct) {
                        this.data[nt.ShapeUtil.indicesToOffset(lt, this.strides)] = ct
                    }
                    async getData() {
                        return this.cache === void 0 && (this.cache = await this.asyncDataProvider(this.dataId)),
                        this.cache
                    }
                    get strides() {
                        return this._strides || (this._strides = nt.ShapeUtil.computeStrides(this.dims)),
                        this._strides
                    }
                    constructor(lt, ct, ut, dt, ft, ht=_.Guid.create()) {
                        this.dims = lt,
                        this.type = ct,
                        this.dataProvider = ut,
                        this.asyncDataProvider = dt,
                        this.cache = ft,
                        this.dataId = ht,
                        this.size = nt.ShapeUtil.validateDimsAndCalcSize(lt);
                        const pt = this.size
                          , gt = ut === void 0 && dt === void 0 && ft === void 0;
                        if (ft !== void 0 && ft.length !== pt)
                            throw new RangeError("Input dims doesn't match data length.");
                        if (ct === "string") {
                            if (!(ft === void 0 || Array.isArray(ft) && ft.every(_t => typeof _t == "string")))
                                throw new TypeError("cache should be a string array");
                            gt && (this.cache = new Array(pt))
                        } else {
                            if (ft !== void 0) {
                                const _t = j(ct);
                                if (!(ft instanceof _t))
                                    throw new TypeError(`cache should be type ${_t.name}`)
                            }
                            if (gt) {
                                const _t = new ArrayBuffer(pt * function(mt) {
                                    switch (mt) {
                                    case "bool":
                                    case "int8":
                                    case "uint8":
                                        return 1;
                                    case "int16":
                                    case "uint16":
                                        return 2;
                                    case "int32":
                                    case "uint32":
                                    case "float32":
                                        return 4;
                                    case "float64":
                                        return 8;
                                    default:
                                        throw new Error(`cannot calculate sizeof() on type ${mt}`)
                                    }
                                }(ct));
                                this.cache = function(mt, yt) {
                                    return new (j(yt))(mt)
                                }(_t, ct)
                            }
                        }
                    }
                    static fromProto(lt) {
                        if (!lt)
                            throw new Error("cannot construct Value from an empty tensor");
                        const ct = nt.ProtoUtil.tensorDataTypeFromProto(lt.dataType)
                          , ut = nt.ProtoUtil.tensorDimsFromProto(lt.dims)
                          , dt = new ot(ut,ct);
                        if (ct === "string")
                            lt.stringData.forEach( (ft, ht) => {
                                dt.data[ht] = (0,
                                nt.decodeUtf8String)(ft)
                            }
                            );
                        else if (lt.rawData && typeof lt.rawData.byteLength == "number" && lt.rawData.byteLength > 0) {
                            const ft = dt.data
                              , ht = new DataView(lt.rawData.buffer,lt.rawData.byteOffset,lt.rawData.byteLength)
                              , pt = et(lt.dataType)
                              , gt = lt.rawData.byteLength / pt;
                            if (lt.rawData.byteLength % pt != 0)
                                throw new Error("invalid buffer length");
                            if (ft.length !== gt)
                                throw new Error("buffer length mismatch");
                            for (let _t = 0; _t < gt; _t++) {
                                const mt = st(ht, lt.dataType, _t * pt);
                                ft[_t] = mt
                            }
                        } else {
                            let ft;
                            switch (lt.dataType) {
                            case _e.onnx.TensorProto.DataType.FLOAT:
                                ft = lt.floatData;
                                break;
                            case _e.onnx.TensorProto.DataType.INT32:
                            case _e.onnx.TensorProto.DataType.INT16:
                            case _e.onnx.TensorProto.DataType.UINT16:
                            case _e.onnx.TensorProto.DataType.INT8:
                            case _e.onnx.TensorProto.DataType.UINT8:
                            case _e.onnx.TensorProto.DataType.BOOL:
                                ft = lt.int32Data;
                                break;
                            case _e.onnx.TensorProto.DataType.INT64:
                                ft = lt.int64Data;
                                break;
                            case _e.onnx.TensorProto.DataType.DOUBLE:
                                ft = lt.doubleData;
                                break;
                            case _e.onnx.TensorProto.DataType.UINT32:
                            case _e.onnx.TensorProto.DataType.UINT64:
                                ft = lt.uint64Data;
                                break;
                            default:
                                throw new Error("unspecific error")
                            }
                            if (ft == null)
                                throw new Error("failed to populate data from a tensorproto value");
                            const ht = dt.data;
                            if (ht.length !== ft.length)
                                throw new Error("array length mismatch");
                            for (let pt = 0; pt < ft.length; pt++) {
                                const gt = ft[pt];
                                $.default.isLong(gt) ? ht[pt] = it(gt, lt.dataType) : ht[pt] = gt
                            }
                        }
                        return dt
                    }
                    static fromData(lt, ct, ut) {
                        return new ot(ct,ut,void 0,void 0,lt)
                    }
                    static fromOrtTensor(lt) {
                        if (!lt)
                            throw new Error("cannot construct Value from an empty tensor");
                        const ct = nt.ProtoUtil.tensorDimsFromORTFormat(lt)
                          , ut = nt.ProtoUtil.tensorDataTypeFromProto(lt.dataType())
                          , dt = new ot(ct,ut);
                        if (ut === "string")
                            for (let ft = 0; ft < lt.stringDataLength(); ft++)
                                dt.data[ft] = lt.stringData(ft);
                        else if (lt.rawDataArray() && typeof lt.rawDataLength() == "number" && lt.rawDataLength() > 0) {
                            const ft = dt.data
                              , ht = new DataView(lt.rawDataArray().buffer,lt.rawDataArray().byteOffset,lt.rawDataLength())
                              , pt = et(lt.dataType())
                              , gt = lt.rawDataLength() / pt;
                            if (lt.rawDataLength() % pt != 0)
                                throw new Error("invalid buffer length");
                            if (ft.length !== gt)
                                throw new Error("buffer length mismatch");
                            for (let _t = 0; _t < gt; _t++) {
                                const mt = st(ht, lt.dataType(), _t * pt);
                                ft[_t] = mt
                            }
                        }
                        return dt
                    }
                }
                function et(at) {
                    switch (at) {
                    case _e.onnx.TensorProto.DataType.UINT8:
                    case _e.onnx.TensorProto.DataType.INT8:
                    case _e.onnx.TensorProto.DataType.BOOL:
                        return 1;
                    case _e.onnx.TensorProto.DataType.UINT16:
                    case _e.onnx.TensorProto.DataType.INT16:
                        return 2;
                    case _e.onnx.TensorProto.DataType.FLOAT:
                    case _e.onnx.TensorProto.DataType.INT32:
                    case _e.onnx.TensorProto.DataType.UINT32:
                        return 4;
                    case _e.onnx.TensorProto.DataType.INT64:
                    case _e.onnx.TensorProto.DataType.DOUBLE:
                    case _e.onnx.TensorProto.DataType.UINT64:
                        return 8;
                    default:
                        throw new Error(`cannot calculate sizeof() on type ${_e.onnx.TensorProto.DataType[at]}`)
                    }
                }
                function j(at) {
                    switch (at) {
                    case "bool":
                    case "uint8":
                        return Uint8Array;
                    case "int8":
                        return Int8Array;
                    case "int16":
                        return Int16Array;
                    case "uint16":
                        return Uint16Array;
                    case "int32":
                        return Int32Array;
                    case "uint32":
                        return Uint32Array;
                    case "float32":
                        return Float32Array;
                    case "float64":
                        return Float64Array;
                    default:
                        throw new Error("unspecified error")
                    }
                }
                function it(at, lt) {
                    if (lt === _e.onnx.TensorProto.DataType.INT64 || lt === rt.TensorDataType.INT64) {
                        if (at.greaterThanOrEqual(2147483648) || at.lessThan(-2147483648))
                            throw new TypeError("int64 is not supported")
                    } else {
                        if (lt !== _e.onnx.TensorProto.DataType.UINT32 && lt !== rt.TensorDataType.UINT32 && lt !== _e.onnx.TensorProto.DataType.UINT64 && lt !== rt.TensorDataType.UINT64)
                            throw new TypeError(`not a LONG type: ${_e.onnx.TensorProto.DataType[lt]}`);
                        if (at.greaterThanOrEqual(4294967296) || at.lessThan(0))
                            throw new TypeError("uint64 is not supported")
                    }
                    return at.toNumber()
                }
                function st(at, lt, ct) {
                    switch (lt) {
                    case _e.onnx.TensorProto.DataType.BOOL:
                    case _e.onnx.TensorProto.DataType.UINT8:
                        return at.getUint8(ct);
                    case _e.onnx.TensorProto.DataType.INT8:
                        return at.getInt8(ct);
                    case _e.onnx.TensorProto.DataType.UINT16:
                        return at.getUint16(ct, !0);
                    case _e.onnx.TensorProto.DataType.INT16:
                        return at.getInt16(ct, !0);
                    case _e.onnx.TensorProto.DataType.FLOAT:
                        return at.getFloat32(ct, !0);
                    case _e.onnx.TensorProto.DataType.INT32:
                        return at.getInt32(ct, !0);
                    case _e.onnx.TensorProto.DataType.UINT32:
                        return at.getUint32(ct, !0);
                    case _e.onnx.TensorProto.DataType.INT64:
                        return it($.default.fromBits(at.getUint32(ct, !0), at.getUint32(ct + 4, !0), !1), lt);
                    case _e.onnx.TensorProto.DataType.DOUBLE:
                        return at.getFloat64(ct, !0);
                    case _e.onnx.TensorProto.DataType.UINT64:
                        return it($.default.fromBits(at.getUint32(ct, !0), at.getUint32(ct + 4, !0), !0), lt);
                    default:
                        throw new Error(`cannot read from DataView for type ${_e.onnx.TensorProto.DataType[lt]}`)
                    }
                }
                i.Tensor = ot
            },
            7273: function(o, i, s) {
                var a = this && this.__importDefault || function(lt) {
                    return lt && lt.__esModule ? lt : {
                        default: lt
                    }
                }
                ;
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.decodeUtf8String = i.MAX_CLIP = i.MIN_CLIP = i.PoolConvUtil = i.ReduceUtil = i.SplitUtil = i.MathUtil = i.ShapeUtil = i.LongUtil = i.ProtoUtil = i.GemmUtil = i.arrayCopyHelper = i.BroadcastUtil = i.MatMulUtil = i.ArrayUtil = i.assert = i.checkInputsShape = void 0;
                const _ = s(5686)
                  , $ = a(s(3720))
                  , _e = s(1446)
                  , tt = s(9240);
                i.checkInputsShape = function(lt, ...ct) {
                    if (!lt || lt.length !== ct.length)
                        return !1;
                    for (let ut = 0; ut < lt.length; ut++)
                        if (!lt[ut].dims || lt[ut].dims.length !== ct[ut])
                            return !1;
                    return !0
                }
                ,
                i.assert = function(lt, ct) {
                    if (!lt)
                        throw new Error(typeof ct == "string" ? ct : ct())
                }
                ,
                i.ArrayUtil = class {
                    static arraysEqual(lt, ct) {
                        if (lt.length !== ct.length)
                            return !1;
                        for (let ut = 0; ut < lt.length; ut++)
                            if (lt[ut] !== ct[ut])
                                return !1;
                        return !0
                    }
                }
                ;
                class nt {
                    static preprocessInputShapes(ct, ut) {
                        return [ct.length === 1 ? [1, ct[0]] : ct, ut.length === 1 ? [ut[0], 1] : ut]
                    }
                    static postprocessOutputShape(ct, ut, dt) {
                        ut === 1 && ct.splice(ct.length - 2, 1),
                        dt === 1 && ct.pop()
                    }
                    static calcMatMulShape(ct, ut) {
                        return ct[1] !== ut[0] ? void 0 : [ct[0], ut[1]]
                    }
                }
                i.MatMulUtil = nt;
                class rt {
                    static calcShape(ct, ut, dt=!1) {
                        const ft = ct.length
                          , ht = ut.length;
                        if (ft === 0)
                            return ut;
                        if (ht === 0)
                            return ct;
                        const pt = Math.max(ct.length, ut.length)
                          , gt = new Array(pt);
                        if (dt) {
                            if (ft < 2 || ht < 2)
                                return;
                            const _t = nt.calcMatMulShape([ct[ft - 2], ct[ft - 1]], [ut[ht - 2], ut[ht - 1]]);
                            if (_t === void 0)
                                return;
                            [gt[pt - 2],gt[pt - 1]] = _t
                        }
                        for (let _t = dt ? 3 : 1; _t <= pt; _t++) {
                            const mt = ft - _t < 0 ? 1 : ct[ft - _t]
                              , yt = ht - _t < 0 ? 1 : ut[ht - _t];
                            if (mt !== yt && mt > 1 && yt > 1)
                                return;
                            gt[pt - _t] = Math.max(mt, yt)
                        }
                        return gt
                    }
                    static index(ct, ut) {
                        const dt = new Array(ut.length);
                        return rt.fillIndex(ct, ut, dt),
                        dt
                    }
                    static fillIndex(ct, ut, dt) {
                        const ft = ct.length - ut.length;
                        for (let ht = 0; ht < ut.length; ht++)
                            dt[ht] = ct[ft + ht] % ut[ht]
                    }
                    static calc(ct, ut, dt, ft, ht) {
                        const pt = rt.calcShape(ct.dims, ut.dims);
                        if (pt) {
                            if (ft && !j.areEqual(pt, ct.dims))
                                return;
                            const gt = j.size(pt)
                              , _t = ft ? ct : new tt.Tensor(pt,ht || ct.type);
                            if (pt.length === 0)
                                _t.set([], dt(ct.get([]), ut.get([])));
                            else {
                                const mt = new Array(pt.length)
                                  , yt = new Array(ct.dims.length)
                                  , bt = new Array(ut.dims.length);
                                let vt, wt = 0, Tt = 0, $t = !1, Et = !1;
                                ct.dims.length === 0 && (wt = ct.get([]),
                                $t = !0),
                                ut.dims.length === 0 && (Tt = ut.get([]),
                                Et = !0);
                                for (let Pt = 0; Pt < gt; Pt++) {
                                    vt = Pt;
                                    for (let Rt = pt.length - 1; Rt >= 0; Rt--)
                                        mt[Rt] = vt % pt[Rt],
                                        vt = Math.floor(vt / pt[Rt]);
                                    $t || (rt.fillIndex(mt, ct.dims, yt),
                                    wt = ct.get(yt)),
                                    Et || (rt.fillIndex(mt, ut.dims, bt),
                                    Tt = ut.get(bt)),
                                    _t.set(mt, dt(wt, Tt))
                                }
                            }
                            return _t
                        }
                    }
                    static isValidBroadcast(ct, ut) {
                        const dt = ct.length
                          , ft = ut.length;
                        if (dt > ft)
                            return !1;
                        for (let ht = 1; ht <= dt; ht++)
                            if (ct[dt - ht] !== 1 && ct[dt - ht] !== ut[ft - ht])
                                return !1;
                        return !0
                    }
                    static getBroadcastDims(ct, ut) {
                        const dt = ct.length
                          , ft = [];
                        for (let ht = 0; ht < dt; ht++) {
                            const pt = dt - 1 - ht
                              , gt = ct[pt] || 1;
                            (ut[ut.length - 1 - ht] || 1) > 1 && gt === 1 && ft.unshift(pt)
                        }
                        return ft
                    }
                }
                i.BroadcastUtil = rt,
                i.arrayCopyHelper = function(lt, ct, ut, dt, ft) {
                    if (dt < 0 || dt >= ct.length)
                        throw new Error("sourceIndex out of bounds");
                    if (ut < 0 || ut >= lt.length)
                        throw new Error("targetIndex out of bounds");
                    if (dt + ft > ct.length)
                        throw new Error("source indices to be copied are outside bounds");
                    if (ut + ft > lt.length)
                        throw new Error("target array is too small to hold result");
                    for (let ht = 0; ht < ft; ht++)
                        lt[ut + ht] = ct[dt + ht]
                }
                ,
                i.GemmUtil = class {
                    static getShapeOfGemmResult(lt, ct, ut, dt, ft) {
                        if (lt.length !== 2 || ut.length !== 2)
                            throw new Error("shape need to be of size 2");
                        let ht, pt, gt;
                        ct ? (ht = lt[1],
                        pt = lt[0]) : (ht = lt[0],
                        pt = lt[1]);
                        let _t = -1;
                        if (dt ? (gt = ut[0],
                        _t = 1) : (gt = ut[1],
                        _t = 0),
                        ut[_t] !== pt)
                            throw new Error("dimension mismatch");
                        if (ht <= 0 || gt <= 0 || pt <= 0)
                            throw new Error("invalid shape specified");
                        if (ft && !rt.isValidBroadcast(ft, [ht, gt]))
                            throw new Error("gemm: invalid bias shape for broadcast");
                        return [ht, gt, pt]
                    }
                }
                ;
                class ot {
                    static tensorDataTypeFromProto(ct) {
                        switch (ct) {
                        case _e.onnx.TensorProto.DataType.INT8:
                            return "int8";
                        case _e.onnx.TensorProto.DataType.UINT8:
                            return "uint8";
                        case _e.onnx.TensorProto.DataType.BOOL:
                            return "bool";
                        case _e.onnx.TensorProto.DataType.INT16:
                            return "int16";
                        case _e.onnx.TensorProto.DataType.UINT16:
                            return "uint16";
                        case _e.onnx.TensorProto.DataType.INT32:
                            return "int32";
                        case _e.onnx.TensorProto.DataType.UINT32:
                            return "uint32";
                        case _e.onnx.TensorProto.DataType.FLOAT:
                            return "float32";
                        case _e.onnx.TensorProto.DataType.DOUBLE:
                            return "float64";
                        case _e.onnx.TensorProto.DataType.STRING:
                            return "string";
                        case _e.onnx.TensorProto.DataType.INT64:
                            return "int32";
                        case _e.onnx.TensorProto.DataType.UINT64:
                            return "uint32";
                        default:
                            throw new Error(`unsupported data type: ${_e.onnx.TensorProto.DataType[ct]}`)
                        }
                    }
                    static tensorDataTypeStringToEnum(ct) {
                        switch (ct) {
                        case "int8":
                            return _e.onnx.TensorProto.DataType.INT8;
                        case "uint8":
                            return _e.onnx.TensorProto.DataType.UINT8;
                        case "bool":
                            return _e.onnx.TensorProto.DataType.BOOL;
                        case "int16":
                            return _e.onnx.TensorProto.DataType.INT16;
                        case "uint16":
                            return _e.onnx.TensorProto.DataType.UINT16;
                        case "int32":
                            return _e.onnx.TensorProto.DataType.INT32;
                        case "uint32":
                            return _e.onnx.TensorProto.DataType.UINT32;
                        case "float32":
                            return _e.onnx.TensorProto.DataType.FLOAT;
                        case "float64":
                            return _e.onnx.TensorProto.DataType.DOUBLE;
                        case "string":
                            return _e.onnx.TensorProto.DataType.STRING;
                        case "int64":
                            return _e.onnx.TensorProto.DataType.INT64;
                        case "uint64":
                            return _e.onnx.TensorProto.DataType.UINT64;
                        default:
                            throw new Error(`unsupported data type: ${ct}`)
                        }
                    }
                    static tensorDimsFromProto(ct) {
                        return ct.map(ut => $.default.isLong(ut) ? ut.toNumber() : ut)
                    }
                    static tensorValueTypeFromProto(ct) {
                        return {
                            tensorType: ot.tensorDataTypeFromProto(ct.elemType),
                            shape: {
                                dims: ot.tensorDimsFromProto(ct.shape.dim.map(ut => ut.dimValue))
                            }
                        }
                    }
                    static tensorDimsFromORTFormat(ct) {
                        const ut = [];
                        for (let dt = 0; dt < ct.dimsLength(); dt++)
                            ut.push(et.longToNumber(ct.dims(dt)));
                        return ut
                    }
                    static tensorAttributesFromORTFormat(ct) {
                        const ut = [];
                        for (let dt = 0; dt < ct.attributesLength(); dt++)
                            ut.push(ct.attributes(dt));
                        return ut
                    }
                }
                i.ProtoUtil = ot;
                class et {
                    static longToNumber(ct, ut) {
                        return $.default.isLong(ct) ? ct.toNumber() : ct instanceof _.flatbuffers.Long ? $.default.fromValue({
                            low: ct.low,
                            high: ct.high,
                            unsigned: ut != null && ut
                        }).toNumber() : ct
                    }
                    static isLong(ct) {
                        return $.default.isLong(ct) || ct instanceof _.flatbuffers.Long
                    }
                }
                i.LongUtil = et;
                class j {
                    static size(ct) {
                        return j.getSizeFromDimensionRange(ct, 0, ct.length)
                    }
                    static sizeFromDimension(ct, ut) {
                        if (ut < 0 || ut > ct.length)
                            throw new Error(`invalid dimension of ${ut} for sizeFromDimension as Tensor has ${ct.length} dimensions.`);
                        return j.getSizeFromDimensionRange(ct, ut, ct.length)
                    }
                    static sizeToDimension(ct, ut) {
                        if (ut < 0 || ut > ct.length)
                            throw new Error(`invalid dimension of ${ut} for sizeToDimension as Tensor has ${ct.length} dimensions.`);
                        return j.getSizeFromDimensionRange(ct, 0, ut)
                    }
                    static getSizeFromDimensionRange(ct, ut, dt) {
                        let ft = 1;
                        for (let ht = ut; ht < dt; ht++) {
                            if (ct[ht] <= 0)
                                throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");
                            ft *= ct[ht]
                        }
                        return ft
                    }
                    static computeStrides(ct) {
                        const ut = ct.length;
                        if (ut === 0)
                            return [];
                        if (ut === 1)
                            return [1];
                        const dt = new Array(ut);
                        dt[ut - 1] = 1,
                        dt[ut - 2] = ct[ut - 1];
                        for (let ft = ut - 3; ft >= 0; --ft)
                            dt[ft] = dt[ft + 1] * ct[ft + 1];
                        return dt
                    }
                    static transpose(ct) {
                        return ct.slice().reverse()
                    }
                    static indicesToOffset(ct, ut, dt) {
                        dt === void 0 && (dt = ct.length);
                        let ft = 0;
                        for (let ht = 0; ht < dt; ++ht)
                            ft += ut[ht] * ct[ht];
                        return ft
                    }
                    static offsetToIndices(ct, ut) {
                        const dt = ut.length;
                        if (dt === 0)
                            return [];
                        if (dt === 1)
                            return [ct * ut[0]];
                        const ft = new Array(ut.length);
                        for (let ht = 0; ht < ft.length - 1; ++ht)
                            ft[ht] = Math.floor(ct / ut[ht]),
                            ct -= ft[ht] * ut[ht];
                        return ft[ft.length - 1] = ct,
                        ft
                    }
                    static normalizeAxis(ct, ut) {
                        if (ct < -ut && ct >= ut)
                            throw new Error("unsupported axis for this operation.");
                        return ct < 0 ? ct + ut : ct
                    }
                    static normalizeAxes(ct, ut) {
                        return ct.map(dt => this.normalizeAxis(dt, ut))
                    }
                    static incrementIndex(ct, ut, dt) {
                        if (ut.length === 0 || ct.length === 0)
                            throw new Error("Index incrementing unsupported for scalar Tensor");
                        if (dt === void 0)
                            dt = ut.length;
                        else if (dt <= 0 || dt > ut.length)
                            throw new Error("Incorrect axis to increment on");
                        for (let ft = dt - 1; ft >= 0 && (ct[ft]++,
                        !(ct[ft] < ut[ft])); --ft)
                            ct[ft] = 0
                    }
                    static calculateReshapedDims(ct, ut) {
                        if (ut.length === 0) {
                            if (ct.length === 0 || j.size(ct) === 1)
                                return [];
                            throw new Error("cannot reshape to a scalar Tensor")
                        }
                        const dt = ut.length
                          , ft = new Array(dt);
                        let ht = -1
                          , pt = 1;
                        for (let _t = 0; _t < dt; _t++) {
                            if (ut[_t] < -1)
                                throw new Error("a dimension in shape hints cannot be less than -1");
                            if (ut[_t] === -1) {
                                if (ht !== -1)
                                    throw new Error("at most one dimension in shape hints can be -1");
                                ht = _t
                            } else {
                                if (ut[_t] === 0) {
                                    if (_t >= ct.length)
                                        throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");
                                    ft[_t] = ct[_t]
                                } else
                                    ft[_t] = ut[_t];
                                pt *= ft[_t]
                            }
                        }
                        const gt = j.size(ct);
                        if (ht !== -1) {
                            if (gt % pt != 0)
                                throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${ct}] Output shape: [${ut}]`);
                            ft[ht] = gt / pt
                        } else if (pt !== gt)
                            throw new Error("reshapedDims and originalDims don't have matching sizes");
                        return ft
                    }
                    static sortBasedOnPerm(ct, ut) {
                        return ut ? ut.map(dt => ct[dt]) : ct.slice().reverse()
                    }
                    static padShape(ct, ut) {
                        const dt = ct.length;
                        return ct.map( (ft, ht) => ft + ut[ht] + ut[ht + dt])
                    }
                    static areEqual(ct, ut) {
                        return ct.length === ut.length && ct.every( (dt, ft) => dt === ut[ft])
                    }
                    static validateDimsAndCalcSize(ct) {
                        if (ct.length > 6)
                            throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");
                        let ut = 1;
                        for (const dt of ct) {
                            if (!Number.isInteger(dt))
                                throw new TypeError(`Invalid shape: ${dt} is not an integer`);
                            if (dt < 0 || dt > 2147483647)
                                throw new TypeError(`Invalid shape: length ${dt} is not allowed`);
                            ut *= dt
                        }
                        return ut
                    }
                    static flattenShape(ct, ut) {
                        ut < 0 && (ut += ct.length);
                        const dt = ct.reduce( (ht, pt) => ht * pt, 1)
                          , ft = ct.slice(ut).reduce( (ht, pt) => ht * pt, 1);
                        return [dt / ft, ft]
                    }
                    static squeezeShape(ct, ut) {
                        const dt = new Array;
                        ut = j.normalizeAxes(ut, ct.length);
                        for (let ft = 0; ft < ct.length; ft++) {
                            const ht = ut.indexOf(ft) >= 0;
                            if (ht && ct[ft] !== 1)
                                throw new Error("squeeze an axis of size different than 1");
                            (ut.length === 0 && ct[ft] > 1 || ut.length > 0 && !ht) && dt.push(ct[ft])
                        }
                        return dt
                    }
                    static unsqueezeShape(ct, ut) {
                        const dt = new Array(ct.length + ut.length);
                        dt.fill(0);
                        for (let ht = 0; ht < ut.length; ht++) {
                            const pt = j.normalizeAxis(ut[ht], dt.length);
                            if (pt >= dt.length)
                                throw new Error("'axes' has an out of range axis");
                            if (dt[pt] !== 0)
                                throw new Error("'axes' has a duplicate axis");
                            dt[pt] = 1
                        }
                        let ft = 0;
                        for (let ht = 0; ht < dt.length; ht++)
                            dt[ht] === 0 && (dt[ht] = ct[ft++]);
                        if (ft !== ct.length)
                            throw new Error("the unsqueezed dimension could not be established");
                        return dt
                    }
                }
                i.ShapeUtil = j,
                i.MathUtil = class {
                    static sqr(lt, ct, ut, dt, ft) {
                        if (dt < 0 || dt >= ct.length)
                            throw new Error("sourceIndex out of bounds");
                        if (ut < 0 || ut >= lt.length)
                            throw new Error("targetIndex out of bounds");
                        if (dt + ft > ct.length)
                            throw new Error("source indices to be copied are outside bounds");
                        if (ut + ft > lt.length)
                            throw new Error("target array is too small to hold result");
                        for (let ht = 0; ht < ft; ht++)
                            lt[ut + ht] += Math.pow(ct[dt + ht], 2)
                    }
                    static axpy(lt, ct, ut, dt, ft, ht) {
                        if (dt < 0 || dt >= ct.length)
                            throw new Error("sourceIndex out of bounds");
                        if (ut < 0 || ut >= lt.length)
                            throw new Error("targetIndex out of bounds");
                        if (dt + ft > ct.length)
                            throw new Error("source indices to be copied are outside bounds");
                        if (ut + ft > lt.length)
                            throw new Error("target array is too small to hold result");
                        for (let pt = 0; pt < ft; pt++)
                            lt[ut + pt] += ht * ct[dt + pt]
                    }
                    static powx(lt, ct, ut, dt, ft, ht) {
                        if (dt < 0 || dt >= ct.length)
                            throw new Error("sourceIndex out of bounds");
                        if (ut < 0 || ut >= lt.length)
                            throw new Error("targetIndex out of bounds");
                        if (dt + ft > ct.length)
                            throw new Error("source indices to be copied are outside bounds");
                        if (ut + ft > lt.length)
                            throw new Error("target array is too small to hold result");
                        for (let pt = 0; pt < ft; pt++)
                            lt[ut + pt] = Math.pow(ct[dt + pt], ht)
                    }
                    static mul(lt, ct, ut, dt, ft) {
                        if (dt < 0 || dt >= ct.length)
                            throw new Error("sourceIndex out of bounds");
                        if (ut < 0 || ut >= lt.length)
                            throw new Error("targetIndex out of bounds");
                        if (dt + ft > ct.length)
                            throw new Error("source indices to be copied are outside bounds");
                        if (ut + ft > lt.length)
                            throw new Error("target array is too small to hold result");
                        for (let ht = 0; ht < ft; ht++)
                            lt[ut + ht] = ct[dt + ht] * lt[ut + ht]
                    }
                }
                ;
                class it {
                    static splitShape(ct, ut, dt, ft) {
                        if (dt.length === 0) {
                            if (!ft)
                                throw new Error("need to know number of outputs when the 'split' attribute is not specified");
                            it.determineSplit(ct[ut], ft, dt)
                        }
                        const ht = []
                          , pt = [0];
                        for (let gt = 0; gt < dt.length; ++gt) {
                            gt !== 0 && pt.push(pt[gt - 1] + dt[gt - 1]);
                            const _t = ct.slice();
                            _t[ut] = dt[gt],
                            ht.push(_t)
                        }
                        return [ht, pt]
                    }
                    static determineSplit(ct, ut, dt) {
                        if (ct % ut != 0)
                            throw new Error("cannot split tensor to equal sized parts");
                        for (let ft = 0; ft < ut; ++ft)
                            dt.push(ct / ut)
                    }
                }
                i.SplitUtil = it;
                class st {
                    static calcReduce(ct, ut, dt, ft, ht) {
                        const pt = ct.dims.slice(0);
                        ut.length === 0 && pt.forEach( (wt, Tt) => ut.push(Tt));
                        const gt = st.calcReduceShape(pt, ut, !0)
                          , _t = j.size(gt)
                          , mt = new tt.Tensor(gt,ct.type)
                          , yt = j.computeStrides(gt)
                          , bt = j.computeStrides(pt)
                          , vt = new Array(pt.length);
                        for (let wt = 0; wt < _t; wt++) {
                            const Tt = j.offsetToIndices(wt, yt);
                            rt.fillIndex(Tt, pt, vt),
                            mt.set(Tt, st.calcReduceByAxis(ct.numberData, ut, pt, 0, j.indicesToOffset(vt, bt), ft, ht))
                        }
                        return dt ? mt : new tt.Tensor(st.calcReduceShape(pt, ut, dt),mt.type,void 0,void 0,mt.data,mt.dataId)
                    }
                    static calcReduceByAxis(ct, ut, dt, ft, ht, pt, gt) {
                        let _t = 0;
                        if (ft >= ut.length)
                            return pt(ct[ht]);
                        const mt = ut[ft]
                          , yt = mt >= dt.length ? 1 : j.size(dt.slice(mt + 1));
                        for (let bt = 0; bt < dt[mt]; bt++)
                            _t = bt === 0 ? st.calcReduceByAxis(ct, ut, dt, ft + 1, ht, pt, gt) : gt(_t, st.calcReduceByAxis(ct, ut, dt, ft + 1, ht, pt, gt)),
                            ht += yt;
                        return _t
                    }
                    static calcReduceShape(ct, ut, dt) {
                        const ft = ct.slice();
                        for (let ht = 0; ht < ut.length; ht++)
                            ft[ut[ht]] = dt ? 1 : 0;
                        return ft.filter(ht => ht !== 0)
                    }
                }
                i.ReduceUtil = st;
                class at {
                    static adjustPoolAttributes(ct, ut, dt, ft, ht, pt) {
                        if (!ct && dt.length !== ut.length - 2)
                            throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");
                        if (ct)
                            for (let gt = 0; gt < ut.length - 2; gt++)
                                gt >= dt.length ? dt.push(ut[gt + 2]) : dt[gt] = ut[gt + 2];
                        for (let gt = 0; gt < dt.length; gt++)
                            if (gt < ft.length) {
                                if (ft[gt] < 0)
                                    throw new Error("strides should be greater than or equal to 1")
                            } else
                                ft.push(1);
                        for (let gt = 0; gt < dt.length; gt++)
                            if (gt < ht.length) {
                                if (ht[gt] < 0)
                                    throw new Error("dilations should be greater than or equal to 1")
                            } else
                                ht.push(1);
                        for (let gt = 0; gt < 2 * dt.length; gt++)
                            if (gt < pt.length) {
                                if (pt[gt] < 0)
                                    throw new Error("pad should be greater than or equal to 1")
                            } else
                                pt.push(0);
                        for (let gt = 0; gt < dt.length; gt++) {
                            if (dt[gt] <= 0)
                                throw new Error("kernel shapes need to be greater than 0");
                            if (pt[gt] >= dt[gt] || pt[gt + dt.length] >= dt[gt])
                                throw new Error("pads should be smaller than kernel")
                        }
                    }
                    static adjustPadsBasedOnAutoPad(ct, ut, dt, ft, ht, pt) {
                        if (pt) {
                            if (ht.length !== 2 * (ct.length - 2))
                                throw new Error("length of pads should be twice the length of data dimensions");
                            if (ut.length !== ct.length - 2)
                                throw new Error("length of strides should be the length of data dimensions");
                            if (ft.length !== ct.length - 2)
                                throw new Error("length of kernel shapes should be the length of data dimensions");
                            for (let gt = 0; gt < ct.length - 2; gt++)
                                at.adjustPadAndReturnShape(ct[gt + 2], ut[gt], dt[gt], ft[gt], ht, gt, gt + ct.length - 2, pt)
                        }
                    }
                    static computePoolOutputShape(ct, ut, dt, ft, ht, pt, gt) {
                        if (ut.length <= 0)
                            throw new Error("input shape must be of size greater than 0");
                        const _t = [ut[0], ut[1]];
                        return at.computeShapeHelper(ct, ut, _t, dt, ft, ht, pt, gt),
                        _t
                    }
                    static computeConvOutputShape(ct, ut, dt, ft, ht, pt, gt) {
                        if (ct.length <= 0 || ut.length <= 0)
                            throw new Error("invalid input tensor dims or invalid filter tensor dims");
                        const _t = [ct[0], ut[0]];
                        return at.computeShapeHelper(!1, ct, _t, dt, ft, ht, pt, gt),
                        _t
                    }
                    static computeShapeHelper(ct, ut, dt, ft, ht, pt, gt, _t) {
                        if (ct)
                            for (let mt = 0; mt < ut.length - 2; mt++)
                                dt.push(1);
                        else
                            for (let mt = 0; mt < ut.length - 2; mt++)
                                dt.push(at.adjustPadAndReturnShape(ut[mt + 2], ft[mt], ht[mt], pt[mt], gt, mt, mt + ut.length - 2, _t))
                    }
                    static adjustPadAndReturnShape(ct, ut, dt, ft, ht, pt, gt, _t) {
                        const mt = dt * (ft - 1) + 1;
                        if (!_t || _t === "NOTSET")
                            return Math.floor((ct + ht[pt] + ht[gt] - mt) / ut + 1);
                        switch (_t) {
                        case "VALID":
                            return ht[pt] = 0,
                            ht[gt] = 0,
                            Math.floor((ct - mt) / ut + 1);
                        case "SAME_LOWER":
                        case "SAME_UPPER":
                            if (dt !== 1)
                                throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");
                            {
                                const yt = ((ct + ut - 1) / ut - 1) * ut + ft - ct;
                                return ht[pt] = Math.floor(_t === "SAME_LOWER" ? (yt + 1) / 2 : yt / 2),
                                ht[gt] = yt - ht[pt],
                                Math.floor((ct + yt - ft) / ut + 1)
                            }
                        default:
                            throw new Error("Unsupported AutoPad type")
                        }
                    }
                }
                i.PoolConvUtil = at,
                i.MIN_CLIP = -34028234663852886e22,
                i.MAX_CLIP = 34028234663852886e22,
                i.decodeUtf8String = function(lt) {
                    return new TextDecoder().decode(lt)
                }
            },
            3838: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.WebGpuBackend = void 0;
                const a = s(8453)
                  , _ = s(4955)
                  , $ = s(7771)
                  , _e = s(8510)
                  , tt = s(8305);
                i.WebGpuBackend = class {
                    constructor() {
                        this.currentKernelId = null,
                        this.commandEncoder = null,
                        this.computePassEncoder = null,
                        this.pendingDispatchNumber = 0,
                        this.profilingEnabled = !1
                    }
                    get currentKernelCustomData() {
                        if (this.currentKernelId === null)
                            throw new Error("currentKernelCustomData(): currentKernelId is null. (should not happen)");
                        let nt = this.kernelCustomData.get(this.currentKernelId);
                        return nt || (nt = {},
                        this.kernelCustomData.set(this.currentKernelId, nt)),
                        nt
                    }
                    async initialize() {
                        if (!navigator.gpu)
                            throw new Error("WebGpuBackend: WebGPU is not available.");
                        const nt = await navigator.gpu.requestAdapter();
                        if (!nt)
                            throw new Error("WebGpuBackend: Failed to get GPU adapter.");
                        const rt = {
                            requiredLimits: {
                                maxComputeWorkgroupStorageSize: nt.limits.maxComputeWorkgroupStorageSize,
                                maxComputeWorkgroupsPerDimension: nt.limits.maxComputeWorkgroupsPerDimension,
                                maxStorageBufferBindingSize: nt.limits.maxStorageBufferBindingSize
                            }
                        };
                        nt.features.has("timestamp-query-inside-passes") && a.env.webgpu.profilingMode === "default" && (this.profilingEnabled = !0,
                        rt.requiredFeatures = ["timestamp-query-inside-passes"]),
                        this.device = await nt.requestDevice(rt),
                        this.gpuDataManager = (0,
                        $.createGpuDataManager)(this),
                        this.programManager = new tt.ProgramManager(this),
                        this.kernels = new Map,
                        this.kernelPersistentData = new Map,
                        this.kernelCustomData = new Map,
                        this.device.onuncapturederror = ot => {
                            ot.error instanceof GPUValidationError && console.error(`An uncaught WebGPU validation error was raised: ${ot.error.message}`)
                        }
                        ,
                        this.profilingEnabled && (this.profilingQuerySet = this.device.createQuerySet({
                            type: "timestamp",
                            count: 2
                        }))
                    }
                    dispose() {}
                    getCommandEncoder() {
                        return this.commandEncoder || (this.commandEncoder = this.device.createCommandEncoder()),
                        this.commandEncoder
                    }
                    getComputePassEncoder() {
                        return this.computePassEncoder || (this.computePassEncoder = this.getCommandEncoder().beginComputePass()),
                        this.computePassEncoder
                    }
                    endComputePass() {
                        this.computePassEncoder && (this.computePassEncoder.end(),
                        this.computePassEncoder = null)
                    }
                    flush() {
                        this.endComputePass(),
                        this.device.queue.submit([this.getCommandEncoder().finish()]),
                        this.gpuDataManager.refreshPendingBuffers(),
                        this.commandEncoder = null,
                        this.pendingDispatchNumber = 0
                    }
                    run(nt, rt, ot, et, j) {
                        if (rt.length !== nt.inputTypes.length)
                            throw new Error(`Input size must be equal to ${nt.inputTypes.length}.`);
                        const it = [];
                        for (let ht = 0; ht < rt.length; ++ht) {
                            const pt = this.gpuDataManager.get(rt[ht].data);
                            if (!pt)
                                throw new Error(`no GPU data for input: ${rt[ht].data}`);
                            it[ht] = pt
                        }
                        const st = ( (ht, pt, gt) => {
                            const _t = pt.map(bt => `${bt.join(",")}`).join("_")
                              , mt = gt.join("_");
                            let yt = ht.name;
                            return ht.cacheHint && (yt += "[" + ht.cacheHint + "]"),
                            yt += ":" + _t + ";" + mt,
                            yt
                        }
                        )(nt, rt.map(ht => ht.dims), it.map(ht => ht.type));
                        let at = this.programManager.getArtifact(st);
                        const lt = at ? at.programInfo : typeof nt.get == "function" ? nt.get() : nt
                          , ct = ot.length === 0 ? lt.outputs.map( (ht, pt) => pt) : ot;
                        if (ct.length !== lt.outputs.length)
                            throw new Error(`Output size ${ct.length} must be equal to ${lt.outputs.length}.`);
                        const ut = []
                          , dt = [];
                        for (let ht = 0; ht < lt.outputs.length; ++ht) {
                            if (!Number.isInteger(ct[ht]) || ct[ht] < -2 || ct[ht] >= lt.outputs.length)
                                throw new Error(`Invalid output index: ${ct[ht]}`);
                            const pt = ct[ht] === -1
                              , gt = ct[ht] === -2
                              , _t = pt || gt ? j(lt.outputs[ht].dataType, lt.outputs[ht].dims) : et(ct[ht], lt.outputs[ht].dataType, lt.outputs[ht].dims)
                              , mt = this.gpuDataManager.get(_t.data);
                            if (!mt)
                                throw new Error(`no GPU data for output: ${_t.data}`);
                            if (pt && this.temporaryData.push(mt),
                            gt) {
                                let yt = this.kernelPersistentData.get(this.currentKernelId);
                                yt || (yt = [],
                                this.kernelPersistentData.set(this.currentKernelId, yt)),
                                yt.push(mt)
                            }
                            ut.push(_t),
                            dt.push(mt)
                        }
                        const ft = this.programManager.normalizeDispatchGroupSize(lt.dispatchGroup(rt));
                        return at || (at = this.programManager.build(lt, ft),
                        this.programManager.setArtifact(st, at)),
                        (0,
                        _.LOG_DEBUG)("info", () => `[ProgramManager] run "${lt.name}" (key=${st}) with ${ft[0]}x${ft[1]}x${ft[2]}`),
                        this.programManager.run(at, it, dt, ft),
                        ut
                    }
                    upload(nt, rt) {
                        this.gpuDataManager.upload(nt, rt)
                    }
                    memcpy(nt, rt) {
                        this.gpuDataManager.memcpy(nt, rt)
                    }
                    async download(nt, rt) {
                        const ot = await this.gpuDataManager.download(nt);
                        rt().set(new Uint8Array(ot))
                    }
                    alloc(nt) {
                        return this.gpuDataManager.create(nt).id
                    }
                    free(nt) {
                        return this.gpuDataManager.release(nt)
                    }
                    createKernel(nt, rt, ot) {
                        const et = _e.WEBGPU_OP_RESOLVE_RULES.get(nt);
                        if (!et)
                            throw new Error(`kernel not implemented: ${nt}`);
                        this.kernels.set(rt, [nt, et[0], [et[1], ot]])
                    }
                    releaseKernel(nt) {
                        const rt = this.kernelPersistentData.get(nt);
                        if (rt) {
                            for (const ot of rt)
                                this.gpuDataManager.release(ot.id);
                            this.kernelPersistentData.delete(nt)
                        }
                        this.kernelCustomData.delete(nt),
                        this.kernels.delete(nt)
                    }
                    computeKernel(nt, rt) {
                        const ot = this.kernels.get(nt);
                        if (!ot)
                            throw new Error(`kernel not created: ${nt}`);
                        const [et,j,it] = ot;
                        if (this.currentKernelId !== null)
                            throw new Error(`kernel "${et}" is not allowed to be called recursively`);
                        this.currentKernelId = nt,
                        it[0] && (it[1] = it[0](it[1]),
                        it[0] = void 0),
                        (0,
                        _.LOG_DEBUG)("info", () => `[WebGPU] Start to run kernel "${et}"...`),
                        this.temporaryData = [];
                        try {
                            return j(rt, it[1]),
                            0
                        } catch (st) {
                            return (0,
                            _.LOG_DEBUG)("warning", `[WebGPU] Kernel "${et}" failed. Error: ${st}`),
                            1
                        } finally {
                            for (const st of this.temporaryData)
                                this.gpuDataManager.release(st.id);
                            this.temporaryData = [],
                            this.currentKernelId = null
                        }
                    }
                }
            }
            ,
            7675: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.init = void 0;
                const a = s(7917)
                  , _ = s(3838)
                  , $ = s(4955)
                  , _e = s(6952);
                class tt {
                    constructor(ot, et, j, it) {
                        this.module = ot,
                        this.dataType = et,
                        this.data = j,
                        this.dims = it
                    }
                    getFloat32Array() {
                        return new Float32Array(this.module.HEAP8.buffer,this.data,_e.ShapeUtil.size(this.dims))
                    }
                    reshape(ot) {
                        if (_e.ShapeUtil.size(ot) !== _e.ShapeUtil.size(this.dims))
                            throw new Error("Invalid new shape");
                        return new tt(this.module,this.dataType,this.data,ot)
                    }
                }
                class nt {
                    get customData() {
                        return this.backend.currentKernelCustomData
                    }
                    constructor(ot, et, j) {
                        this.module = ot,
                        this.backend = et;
                        const it = ot.HEAPU32;
                        let st = j >> 2;
                        this.opKernelContext = it[st++];
                        const at = it[st++]
                          , lt = [];
                        for (let ct = 0; ct < at; ct++) {
                            const ut = it[st++]
                              , dt = it[st++]
                              , ft = it[st++]
                              , ht = [];
                            for (let pt = 0; pt < ft; pt++)
                                ht.push(it[st++]);
                            lt.push(new tt(ot,ut,dt,ht))
                        }
                        this.inputs = lt
                    }
                    compute(ot, et) {
                        var j, it, st;
                        const at = (it = (j = et == null ? void 0 : et.inputs) === null || j === void 0 ? void 0 : j.map(ct => typeof ct == "number" ? this.inputs[ct] : ct)) !== null && it !== void 0 ? it : this.inputs
                          , lt = (st = et == null ? void 0 : et.outputs) !== null && st !== void 0 ? st : [];
                        return this.backend.run(ot, at, lt, (ct, ut, dt) => new tt(this.module,ut,this.output(ct, dt),dt), (ct, ut) => {
                            const dt = (0,
                            a.getTensorElementSize)(ct);
                            if (!dt)
                                throw new Error(`Unsupported data type: ${ct}`);
                            const ft = dt * _e.ShapeUtil.size(ut);
                            return new tt(this.module,ct,this.backend.gpuDataManager.create(ft).id,ut)
                        }
                        )
                    }
                    output(ot, et) {
                        const j = this.module.stackSave();
                        try {
                            const it = this.module.stackAlloc(4 * (1 + et.length));
                            let st = it >> 2;
                            this.module.HEAPU32[st++] = et.length;
                            for (let at = 0; at < et.length; at++)
                                this.module.HEAPU32[st++] = et[at];
                            return this.module._JsepOutput(this.opKernelContext, ot, it)
                        } finally {
                            this.module.stackRestore(j)
                        }
                    }
                }
                i.init = async rt => {
                    const ot = rt.jsepInit;
                    if (ot && navigator.gpu) {
                        const et = new _.WebGpuBackend;
                        await et.initialize(),
                        ot({
                            backend: et
                        }, j => et.alloc(j), j => et.free(j), (j, it, st, at=!1) => {
                            if (at)
                                (0,
                                $.LOG_DEBUG)("verbose", () => `[WebGPU] jsepCopyGpuToGpu: src=${j}, dst=${it}, size=${st}`),
                                et.memcpy(j, it);
                            else {
                                (0,
                                $.LOG_DEBUG)("verbose", () => `[WebGPU] jsepCopyCpuToGpu: dataOffset=${j}, gpuDataId=${it}, size=${st}`);
                                const lt = rt.HEAPU8.subarray(j, j + st);
                                et.upload(it, lt)
                            }
                        }
                        , async (j, it, st) => {
                            (0,
                            $.LOG_DEBUG)("verbose", () => `[WebGPU] jsepCopyGpuToCpu: gpuDataId=${j}, dataOffset=${it}, size=${st}`),
                            await et.download(j, () => rt.HEAPU8.subarray(it, it + st))
                        }
                        , (j, it, st) => et.createKernel(j, it, st), j => et.releaseKernel(j), (j, it) => {
                            (0,
                            $.LOG_DEBUG)("verbose", () => `[WebGPU] jsepRun: kernel=${j}, contextDataOffset=${it}`);
                            const st = new nt(rt,et,it);
                            return et.computeKernel(j, st)
                        }
                        )
                    }
                }
            }
            ,
            4955: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.LOG_DEBUG = i.LOG = void 0;
                const a = s(8453)
                  , _ = s(7917)
                  , $ = ["V", "I", "W", "E", "F"];
                i.LOG = (_e, tt) => {
                    const nt = (0,
                    _.logLevelStringToEnum)(_e);
                    var rt, ot;
                    nt >= (0,
                    _.logLevelStringToEnum)(a.env.logLevel) && (rt = nt,
                    ot = typeof tt == "function" ? tt() : tt,
                    console.log(`[${$[rt]},${new Date().toISOString()}]${ot}`))
                }
                ,
                i.LOG_DEBUG = (..._e) => {
                    a.env.debug && (0,
                    i.LOG)(..._e)
                }
            }
            ,
            6952: (o, i) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.MAX_CLIP = i.MIN_CLIP = i.GemmUtil = i.PoolConvUtil = i.ShapeUtil = i.BroadcastUtil = i.MatMulUtil = void 0;
                class s {
                    static calcMatMulShape(tt, nt) {
                        return tt[1] !== nt[0] ? void 0 : [tt[0], nt[1]]
                    }
                }
                i.MatMulUtil = s;
                class a {
                    static calcShape(tt, nt, rt=!1) {
                        const ot = tt.length
                          , et = nt.length;
                        if (ot === 0)
                            return nt;
                        if (et === 0)
                            return tt;
                        const j = Math.max(tt.length, nt.length)
                          , it = new Array(j);
                        if (rt) {
                            if (ot < 2 || et < 2)
                                return;
                            const st = s.calcMatMulShape([tt[ot - 2], tt[ot - 1]], [nt[et - 2], nt[et - 1]]);
                            if (st === void 0)
                                return;
                            [it[j - 2],it[j - 1]] = st
                        }
                        for (let st = rt ? 3 : 1; st <= j; st++) {
                            const at = ot - st < 0 ? 1 : tt[ot - st]
                              , lt = et - st < 0 ? 1 : nt[et - st];
                            if (at !== lt && at > 1 && lt > 1)
                                return;
                            it[j - st] = Math.max(at, lt)
                        }
                        return it
                    }
                    static isValidBroadcast(tt, nt) {
                        const rt = tt.length
                          , ot = nt.length;
                        if (rt > ot)
                            return !1;
                        for (let et = 1; et <= rt; et++)
                            if (tt[rt - et] !== 1 && tt[rt - et] !== nt[ot - et])
                                return !1;
                        return !0
                    }
                }
                i.BroadcastUtil = a;
                class _ {
                    static size(tt) {
                        return _.getSizeFromDimensionRange(tt, 0, tt.length)
                    }
                    static sizeFromDimension(tt, nt) {
                        if (nt < 0 || nt > tt.length)
                            throw new Error(`invalid dimension of ${nt} for sizeFromDimension as Tensor has ${tt.length} dimensions.`);
                        return _.getSizeFromDimensionRange(tt, nt, tt.length)
                    }
                    static sizeToDimension(tt, nt) {
                        if (nt < 0 || nt > tt.length)
                            throw new Error(`invalid dimension of ${nt} for sizeToDimension as Tensor has ${tt.length} dimensions.`);
                        return _.getSizeFromDimensionRange(tt, 0, nt)
                    }
                    static getSizeFromDimensionRange(tt, nt, rt) {
                        let ot = 1;
                        for (let et = nt; et < rt; et++) {
                            if (tt[et] <= 0)
                                throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");
                            ot *= tt[et]
                        }
                        return ot
                    }
                    static computeStrides(tt) {
                        const nt = tt.length;
                        if (nt === 0)
                            return [];
                        if (nt === 1)
                            return [1];
                        const rt = new Array(nt);
                        rt[nt - 1] = 1,
                        rt[nt - 2] = tt[nt - 1];
                        for (let ot = nt - 3; ot >= 0; --ot)
                            rt[ot] = rt[ot + 1] * tt[ot + 1];
                        return rt
                    }
                    static normalizeAxis(tt, nt) {
                        if (tt < -nt && tt >= nt)
                            throw new Error("unsupported axis for this operation.");
                        return tt < 0 ? tt + nt : tt
                    }
                    static normalizeAxes(tt, nt) {
                        return tt.map(rt => this.normalizeAxis(rt, nt ?? tt.length))
                    }
                    static sortBasedOnPerm(tt, nt) {
                        return nt ? nt.map(rt => tt[rt]) : tt.slice().reverse()
                    }
                    static padShape(tt, nt) {
                        const rt = tt.length;
                        return tt.map( (ot, et) => ot + nt[et] + nt[et + rt])
                    }
                    static areEqual(tt, nt) {
                        return tt.length === nt.length && tt.every( (rt, ot) => rt === nt[ot])
                    }
                }
                i.ShapeUtil = _;
                class $ {
                    static adjustPoolAttributes(tt, nt, rt, ot, et, j) {
                        if (!tt && rt.length !== nt.length - 2)
                            throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");
                        if (tt)
                            for (let it = 0; it < nt.length - 2; it++)
                                it >= rt.length ? rt.push(nt[it + 2]) : rt[it] = nt[it + 2];
                        for (let it = 0; it < rt.length; it++)
                            if (it < ot.length) {
                                if (ot[it] < 0)
                                    throw new Error("strides should be greater than or equal to 1")
                            } else
                                ot.push(1);
                        for (let it = 0; it < rt.length; it++)
                            if (it < et.length) {
                                if (et[it] < 0)
                                    throw new Error("dilations should be greater than or equal to 1")
                            } else
                                et.push(1);
                        for (let it = 0; it < 2 * rt.length; it++)
                            if (it < j.length) {
                                if (j[it] < 0)
                                    throw new Error("pad should be greater than or equal to 1")
                            } else
                                j.push(0);
                        for (let it = 0; it < rt.length; it++) {
                            if (rt[it] <= 0)
                                throw new Error("kernel shapes need to be greater than 0");
                            if (j[it] >= rt[it] || j[it + rt.length] >= rt[it])
                                throw new Error("pads should be smaller than kernel")
                        }
                    }
                    static adjustPadsBasedOnAutoPad(tt, nt, rt, ot, et, j, it) {
                        if (it) {
                            if (et.length !== 2 * (tt.length - 2))
                                throw new Error("length of pads should be twice the length of data dimensions");
                            if (nt.length !== tt.length - 2)
                                throw new Error("length of strides should be the length of data dimensions");
                            if (ot.length !== tt.length - 2)
                                throw new Error("length of kernel shapes should be the length of data dimensions");
                            for (let st = 0; st < tt.length - 2; st++)
                                $.adjustPadAndReturnShape(tt[st + (j ? 1 : 2)], nt[st], rt[st], ot[st], et, st, st + tt.length - 2, it)
                        }
                    }
                    static computePoolOutputShape(tt, nt, rt, ot, et, j, it) {
                        if (nt.length <= 0)
                            throw new Error("input shape must be of size greater than 0");
                        const st = [nt[0], nt[1]];
                        return $.computeShapeHelper(tt, nt, st, rt, ot, et, j, it),
                        st
                    }
                    static computeConvOutputShape(tt, nt, rt, ot, et, j, it) {
                        if (tt.length <= 0 || nt.length <= 0)
                            throw new Error("invalid input tensor dims or invalid filter tensor dims");
                        const st = [tt[0], nt[0]];
                        return $.computeShapeHelper(!1, tt, st, rt, ot, et, j, it),
                        st
                    }
                    static computeShapeHelper(tt, nt, rt, ot, et, j, it, st) {
                        if (tt)
                            for (let at = 0; at < nt.length - 2; at++)
                                rt.push(1);
                        else
                            for (let at = 0; at < nt.length - 2; at++)
                                rt.push($.adjustPadAndReturnShape(nt[at + 2], ot[at], et[at], j[at], it, at, at + nt.length - 2, st))
                    }
                    static adjustPadAndReturnShape(tt, nt, rt, ot, et, j, it, st) {
                        const at = rt * (ot - 1) + 1;
                        if (!st || st === "NOTSET")
                            return Math.floor((tt + et[j] + et[it] - at) / nt + 1);
                        switch (st) {
                        case "VALID":
                            return et[j] = 0,
                            et[it] = 0,
                            Math.floor((tt - at) / nt + 1);
                        case "SAME_LOWER":
                        case "SAME_UPPER":
                            if (rt !== 1)
                                throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");
                            {
                                const lt = ((tt + nt - 1) / nt - 1) * nt + ot - tt;
                                return et[j] = Math.floor(st === "SAME_LOWER" ? (lt + 1) / 2 : lt / 2),
                                et[it] = lt - et[j],
                                Math.floor((tt + lt - ot) / nt + 1)
                            }
                        default:
                            throw new Error("Unsupported AutoPad type")
                        }
                    }
                }
                i.PoolConvUtil = $,
                i.GemmUtil = class {
                    static getShapeOfGemmResult(_e, tt, nt, rt, ot) {
                        if (_e.length !== 2 || nt.length !== 2)
                            throw new Error("shape need to be of size 2");
                        let et, j, it;
                        tt ? (et = _e[1],
                        j = _e[0]) : (et = _e[0],
                        j = _e[1]);
                        let st = -1;
                        if (rt ? (it = nt[0],
                        st = 1) : (it = nt[1],
                        st = 0),
                        nt[st] !== j)
                            throw new Error("dimension mismatch");
                        if (et <= 0 || it <= 0 || j <= 0)
                            throw new Error("invalid shape specified");
                        if (ot && !a.isValidBroadcast(ot, [et, it]))
                            throw new Error("gemm: invalid bias shape for broadcast");
                        return [et, it, j]
                    }
                }
                ,
                i.MIN_CLIP = -34028234663852886e22,
                i.MAX_CLIP = 34028234663852886e22
            }
            ,
            387: (o, i) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.createAttributeWithCacheKey = void 0;
                class s {
                    constructor(_) {
                        Object.assign(this, _)
                    }
                    get cacheKey() {
                        return this._cacheKey || (this._cacheKey = Object.getOwnPropertyNames(this).sort().map(_ => `${this[_]}`).join(";")),
                        this._cacheKey
                    }
                }
                i.createAttributeWithCacheKey = a => new s(a)
            }
            ,
            7771: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.createGpuDataManager = void 0;
                const a = s(4955)
                  , _ = s(1163)
                  , $ = nt => 16 * Math.ceil(nt / 16);
                let _e = 0;
                class tt {
                    constructor(rt) {
                        this.backend = rt,
                        this.storageCache = new Map,
                        this.downloadCache = new Map,
                        this.buffersForUploadingPending = [],
                        this.buffersPending = []
                    }
                    upload(rt, ot) {
                        const et = ot.buffer
                          , j = ot.byteOffset
                          , it = ot.byteLength
                          , st = $(it)
                          , at = this.storageCache.get(rt);
                        if (!at)
                            throw new Error("gpu data for uploading does not exist");
                        if (at.originalSize !== it)
                            throw new Error(`inconsistent data size. gpu data size=${at.originalSize}, data size=${it}`);
                        const lt = this.backend.device.createBuffer({
                            mappedAtCreation: !0,
                            size: st,
                            usage: GPUBufferUsage.MAP_WRITE | GPUBufferUsage.COPY_SRC
                        })
                          , ct = lt.getMappedRange();
                        new Uint8Array(ct).set(new Uint8Array(et,j,it)),
                        lt.unmap();
                        const ut = this.backend.getCommandEncoder();
                        this.backend.endComputePass(),
                        ut.copyBufferToBuffer(lt, 0, at.gpuData.buffer, 0, st),
                        (0,
                        a.LOG_DEBUG)("verbose", () => `[WebGPU] GpuDataManager.upload(id=${rt})`),
                        this.buffersForUploadingPending.push(lt)
                    }
                    memcpy(rt, ot) {
                        const et = this.storageCache.get(rt);
                        if (!et)
                            throw new Error("source gpu data for memcpy does not exist");
                        const j = this.storageCache.get(ot);
                        if (!j)
                            throw new Error("destination gpu data for memcpy does not exist");
                        if (et.originalSize !== j.originalSize)
                            throw new Error("inconsistent source and destination gpu data size");
                        const it = $(et.originalSize);
                        this.backend.getCommandEncoder().copyBufferToBuffer(et.gpuData.buffer, 0, j.gpuData.buffer, 0, it)
                    }
                    create(rt, ot=GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST) {
                        const et = $(rt)
                          , j = this.backend.device.createBuffer({
                            size: et,
                            usage: ot
                        })
                          , it = {
                            id: _e++,
                            type: _.GpuDataType.default,
                            buffer: j
                        };
                        return this.storageCache.set(it.id, {
                            gpuData: it,
                            originalSize: rt
                        }),
                        (0,
                        a.LOG_DEBUG)("verbose", () => `[WebGPU] GpuDataManager.create(size=${rt}) => id=${it.id}`),
                        it
                    }
                    get(rt) {
                        var ot;
                        return (ot = this.storageCache.get(rt)) === null || ot === void 0 ? void 0 : ot.gpuData
                    }
                    release(rt) {
                        const ot = this.storageCache.get(rt);
                        if (!ot)
                            throw new Error("releasing data does not exist");
                        return (0,
                        a.LOG_DEBUG)("verbose", () => `[WebGPU] GpuDataManager.release(id=${rt}), gpuDataId=${ot.gpuData.id}`),
                        this.storageCache.delete(rt),
                        this.buffersPending.push(ot.gpuData.buffer),
                        this.downloadCache.get(rt) && this.downloadCache.delete(rt),
                        ot.originalSize
                    }
                    async download(rt) {
                        const ot = this.downloadCache.get(rt);
                        if (ot)
                            return ot.data;
                        const et = this.storageCache.get(rt);
                        if (!et)
                            throw new Error("data does not exist");
                        const j = this.backend.getCommandEncoder();
                        this.backend.endComputePass();
                        const it = this.backend.device.createBuffer({
                            size: et.originalSize,
                            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
                        });
                        j.copyBufferToBuffer(et.gpuData.buffer, 0, it, 0, et.originalSize),
                        this.backend.flush();
                        const st = new Promise(at => {
                            it.mapAsync(GPUMapMode.READ).then( () => {
                                const lt = it.getMappedRange().slice(0);
                                it.destroy(),
                                at(lt)
                            }
                            )
                        }
                        );
                        return this.downloadCache.set(rt, {
                            data: st
                        }),
                        st
                    }
                    refreshPendingBuffers() {
                        for (const rt of this.buffersForUploadingPending)
                            rt.destroy();
                        for (const rt of this.buffersPending)
                            rt.destroy()
                    }
                }
                i.createGpuDataManager = (...nt) => new tt(...nt)
            }
            ,
            8510: function(o, i, s) {
                var a = this && this.__createBinding || (Object.create ? function(it, st, at, lt) {
                    lt === void 0 && (lt = at);
                    var ct = Object.getOwnPropertyDescriptor(st, at);
                    ct && !("get"in ct ? !st.__esModule : ct.writable || ct.configurable) || (ct = {
                        enumerable: !0,
                        get: function() {
                            return st[at]
                        }
                    }),
                    Object.defineProperty(it, lt, ct)
                }
                : function(it, st, at, lt) {
                    lt === void 0 && (lt = at),
                    it[lt] = st[at]
                }
                )
                  , _ = this && this.__setModuleDefault || (Object.create ? function(it, st) {
                    Object.defineProperty(it, "default", {
                        enumerable: !0,
                        value: st
                    })
                }
                : function(it, st) {
                    it.default = st
                }
                )
                  , $ = this && this.__importStar || function(it) {
                    if (it && it.__esModule)
                        return it;
                    var st = {};
                    if (it != null)
                        for (var at in it)
                            at !== "default" && Object.prototype.hasOwnProperty.call(it, at) && a(st, it, at);
                    return _(st, it),
                    st
                }
                ;
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.WEBGPU_OP_RESOLVE_RULES = void 0;
                const _e = $(s(504))
                  , tt = s(9770)
                  , nt = s(4271)
                  , rt = s(1522)
                  , ot = $(s(5262))
                  , et = s(2625)
                  , j = $(s(9302));
                i.WEBGPU_OP_RESOLVE_RULES = new Map([["Abs", [j.abs]], ["Acos", [j.acos]], ["Acosh", [j.acosh]], ["Add", [_e.add]], ["Asin", [j.asin]], ["Asinh", [j.asinh]], ["Atan", [j.atan]], ["Atanh", [j.atanh]], ["AveragePool", [ot.averagePool, ot.parseAveragePoolAttributes]], ["Ceil", [j.ceil]], ["ClipV10", [j.clipV10]], ["Clip", [j.clip]], ["Conv", [tt.conv, tt.parseConvAttributes]], ["Cos", [j.cos]], ["Cosh", [j.cosh]], ["Div", [_e.div]], ["Elu", [j.elu, j.parseAlphaAttributes]], ["Erf", [j.erf]], ["Exp", [j.exp]], ["Floor", [j.floor]], ["Gemm", [nt.gemm, nt.parseGemmAttributes]], ["GlobalAveragePool", [ot.globalAveragePool, ot.parseGlobalAveragePoolAttributes]], ["GlobalMaxPool", [ot.globalMaxPool, ot.parseGlobalMaxPoolAttributes]], ["LeakyRelu", [j.leakyRelu, j.parseAlphaAttributes]], ["MatMul", [rt.matMul]], ["MaxPool", [ot.maxPool, ot.parseMaxPoolAttributes]], ["Mul", [_e.mul]], ["Neg", [j.neg]], ["Pow", [_e.pow]], ["Reciprocal", [j.reciprocal]], ["Relu", [j.relu]], ["Sigmoid", [j.sigmoid]], ["Sin", [j.sin]], ["Sinh", [j.sinh]], ["Sqrt", [j.sqrt]], ["Sub", [_e.sub]], ["Tan", [j.tan]], ["Tanh", [j.tanh]], ["ThresholdedRelu", [j.thresholdedRelu, j.parseAlphaAttributes]], ["Transpose", [et.transpose, et.parseTransposeAttributes]]])
            },
            1427: (o, i) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.biasActivationSnippet = i.activationFnSnippet = i.typeSnippet = void 0,
                i.typeSnippet = s => {
                    switch (s) {
                    case 1:
                        return "f32";
                    case 2:
                        return "vec2<f32>";
                    case 3:
                        return "vec3<f32>";
                    case 4:
                        return "vec4<f32>";
                    default:
                        throw new Error(`${s}-component is not supported.`)
                    }
                }
                ,
                i.activationFnSnippet = (s, a=!1, _=!1, $=3) => "",
                i.biasActivationSnippet = (s, a) => `
      ${s ? "value = value + getBiasByOutputCoords(coords);" : ""}
      ${a ? "value = activation(value, coords);" : ""}
      `
            }
            ,
            9456: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.createConv2DMatMulProgramInfo = void 0;
                const a = s(4955)
                  , _ = s(6952)
                  , $ = s(1163)
                  , _e = s(1427)
                  , tt = s(4085)
                  , nt = s(158);
                i.createConv2DMatMulProgramInfo = (rt, ot, et, j, it, st, at, lt, ct) => {
                    const ut = et.format === "NHWC"
                      , dt = ut ? rt[0].dims[3] : rt[0].dims[1]
                      , ft = j[0]
                      , ht = ut ? j[2] : j[3]
                      , pt = ut ? j[1] : j[2]
                      , gt = ut ? j[3] : j[1]
                      , _t = ((dt % 4 == 0 || dt % 3 == 0) && ut || ht % 4 == 0 && !ut) && gt % 4 == 0
                      , mt = ut ? gt : ht * pt
                      , yt = ut ? ht * pt : gt
                      , bt = _t ? [8, 8, 1] : [mt <= 4 ? 4 : 16, mt > 4 && yt <= 4 ? 4 : 16, 1]
                      , vt = _t ? [4, 4, 1] : [mt <= 4 ? 1 : 2, mt > 4 && yt <= 4 ? 1 : 2, 1]
                      , wt = [Math.ceil(mt / bt[0] / vt[0]), Math.ceil(yt / bt[1] / vt[1]), Math.ceil(ft / bt[2] / vt[1])];
                    (0,
                    a.LOG_DEBUG)("verbose", () => `[conv2d_mm_webgpu] dispatch = ${wt}`);
                    const Tt = _t ? ut && dt % 4 != 0 ? 3 : 4 : vt[0]
                      , $t = bt[1] * vt[1]
                      , Et = bt[0] * vt[0]
                      , Pt = Math.max(bt[0] * Tt, bt[1])
                      , Rt = it % $t == 0
                      , At = st % Et == 0
                      , Mt = at % Pt == 0
                      , Ut = _t ? [Tt, 4, 4] : [1, 1, 1]
                      , Lt = [`@group(0) @binding(0) var<storage, read> x: array<${_t && Tt === 4 ? "vec4<f32>" : "f32"}>;`, `@group(0) @binding(1) var<storage, read> w: array<${_t ? "vec4<f32>" : "f32"}>;`];
                    let tn = `
      fn setOutputAtIndex(flatIndex : i32, value : ${_t ? "vec4<f32>" : "f32"}) {
        result[flatIndex] = ${_t ? "vec4<f32>" : "f32"}(value);
      }
      fn setOutputAtCoords(d0 : i32, d1 : i32, d2 : i32, d3 : i32, value : ${_t ? "vec4<f32>" : "f32"}) {
        let flatIndex = getOutputIndexFromCoords(vec4<i32>(d0, d1, d2, d3));
        setOutputAtIndex(flatIndex ${_t ? "/ 4" : ""}, value);
      }`;
                    return lt && (Lt.push(`@group(0) @binding(2) var<storage, read> bias: array<${_t ? "vec4<f32>" : "f32"}>;`),
                    tn += `
        fn getBiasByOutputCoords(coords : vec4<i32>) -> ${_t ? "vec4<f32>" : "f32"} {
          return bias[coords.${ut ? "w" : "y"}${_t ? "/ 4" : ""}];
        }`),
                    Object.assign(Object.assign({}, ot), {
                        outputs: [{
                            dims: j,
                            dataType: rt[0].dataType,
                            gpuDataType: $.GpuDataType.default
                        }],
                        dispatchGroup: () => ({
                            x: wt[0],
                            y: wt[1],
                            z: wt[2]
                        }),
                        getShaderSource: () => `
        ${tt.utilFunctions}
        //struct Uniforms { xShape : vec4<i32>, wShape : vec4<i32>, outShape : vec4<i32>,
        //  outShapeStrides: vec3<i32>, filterDims : vec2<i32>, pad : vec2<i32>, stride : vec2<i32>,
        //  dilation : vec2<i32>, dimAOuter : i32, dimBOuter : i32, dimInner : i32 };
        ${Lt.join("")}
        @group(0) @binding(${Lt.length}) var<storage, read_write> result: array<${_t ? "vec4<f32>" : "f32"}>;
        //@group(0) @binding(${Lt.length + 1}) var<uniform> uniforms: Uniforms;

        const xShape : vec4<i32> = vec4<i32>(${rt[0].dims.join(",")});
        const wShape : vec4<i32> = vec4<i32>(${rt[1].dims.join(",")});
        const outShape : vec4<i32> = vec4<i32>(${j.join(",")});
        const outShapeStrides : vec3<i32> = vec3<i32>(${_.ShapeUtil.computeStrides(j).slice(0, 3).join(",")});
        const filterDims : vec2<i32> = vec2<i32>(${et.kernelShape[0]}, ${et.kernelShape[1]});
        const pad : vec2<i32> = vec2<i32>(${et.pads[0]}, ${et.pads[1]});
        const stride : vec2<i32> = vec2<i32>(${et.strides[0]}, ${et.strides[1]});
        const dilation : vec2<i32> = vec2<i32>(${et.dilations[0]}, ${et.dilations[1]});
        const dimAOuter : i32 = ${it};
        const dimBOuter : i32 = ${st};
        const dimInner : i32 = ${at};
        ${tn}
        ${( (Vt, Nt, Yt, Xt, jt=!1, Gt, Kt=!1, qt=4, rn=4, on=4) => {
                            const _n = Vt ? `
    let coord = vec4<i32>(batch, xRow, xCol, xCh);
    ` : `
    let coord = vec4<i32>(batch, xCh, xRow, xCol);
    `
                              , mn = Vt ? `
    let coords = vec4<i32>(
      batch,
      row / outWidth,
      row % outWidth,
      col);
    ` : `
    let coords = vec4<i32>(
      batch,
      row,
      col / outWidth,
      col % outWidth);
    `
                              , Sn = Vt ? "xShape[1]" : "xShape[2]"
                              , bn = Vt ? "xShape[2]" : "xShape[3]"
                              , In = Vt ? "row" : "col"
                              , Nn = Vt ? "col" : "row"
                              , cn = `
    let inChannels = wShape[2];
    let outWidth = ${Vt ? "outShape[2]" : "outShape[3]"};
    let outRow = ${In} / outWidth;
    let outCol = ${In} % outWidth;

    let WRow = ${Nn} / (filterDims[1] * inChannels);
    let WCol = ${Nn} / inChannels % filterDims[1];
    let xRow = outRow * stride[0] + dilation[0] * WRow - pad[0];
    let xCol = outCol * stride[1] + dilation[1] * WCol - pad[1];
    let xCh = ${Nn} % inChannels;
    var resData = ${(0,
                            _e.typeSnippet)(qt)}(0.0);
    // The bounds checking is always needed since we use it to pad zero for
    // the 'same' padding type.
    if (xRow >= 0 && xRow < ${Sn} && xCol >= 0 && xCol < ${bn}) {
      ${_n}
      let xIndex = getIndexFromCoords4D(coord, xShape);
      ${(An => {
                                switch (An) {
                                case 1:
                                    return "resData = x[xIndex];";
                                case 3:
                                    return "resData = vec3<f32>(x[xIndex], x[xIndex + 1], x[xIndex + 2]);";
                                case 4:
                                    return "resData = x[xIndex / 4];";
                                default:
                                    throw new Error(`innerElementSize ${An} is not supported.`)
                                }
                            }
                            )(qt)}
    }
    return resData;`
                              , $n = Vt ? Nt && Xt ? `
    let col = colIn * ${qt};
    ${cn}` : `
    let col = colIn * ${qt};
    if (row < dimAOuter && col < dimInner) {
      ${cn}
    }
    return ${(0,
                            _e.typeSnippet)(qt)}(0.0);` : Xt && Yt ? `
    let col = colIn * ${qt};
    ${cn}` : `
    let col = colIn * ${qt};
    if (row < dimInner && col < dimBOuter) {
      ${cn}
    }
    return ${(0,
                            _e.typeSnippet)(qt)}(0.0);`
                              , gn = `${(An => {
                                switch (An) {
                                case 1:
                                    return "return w[row * wShape[3] + colIn];";
                                case 4:
                                    return "return w[row * wShape[3] / 4 + colIn];";
                                default:
                                    throw new Error(`innerElementSize ${An} is not supported.`)
                                }
                            }
                            )(rn)}`
                              , dn = (0,
                            _e.typeSnippet)(on)
                              , Dn = Vt ? (0,
                            _e.typeSnippet)(qt) : (0,
                            _e.typeSnippet)(rn)
                              , kn = Vt ? (0,
                            _e.typeSnippet)(rn) : (0,
                            _e.typeSnippet)(qt);
                            return `
    ${(0,
                            _e.activationFnSnippet)(Gt, Kt, on === 4, 4)}
    fn mm_readA(batch: i32, row : i32, colIn : i32) -> ${Dn} {
      ${Vt ? $n : gn}
    }

    fn mm_readB(batch: i32, row : i32, colIn : i32) -> ${kn} {
      ${Vt ? gn : $n}
    }

    fn mm_write(batch: i32, row : i32, colIn : i32, valueIn : ${dn}) {
      let col = colIn * ${on};
      if (row < dimAOuter && col < dimBOuter)
      {
      var value = valueIn;
      let outWidth = ${Vt ? "outShape[2]" : "outShape[3]"};
      ${mn}
      ${(0,
                            _e.biasActivationSnippet)(jt, Gt)}
      setOutputAtCoords(coords[0], coords[1], coords[2], coords[3], value);
      }
    }`
                        }
                        )(ut, Rt, At, Mt, lt, void 0, !1, Ut[0], Ut[1], Ut[2])}
            ${_t ? (0,
                        nt.makeMatMulPackedVec4Source)(vt, bt, !ut, Pt) : (0,
                        nt.makeMatMulPackedSource)(vt, bt, !ut, Pt, !1, void 0, ct)}`
                    })
                }
            }
            ,
            4085: (o, i) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.utilFunctions = void 0,
                i.utilFunctions = `
fn getIndexFromCoords4D(coords : vec4<i32>, shape : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
      shape.y * shape.z * shape.w, shape.z * shape.w, shape.w, 1));
}
fn getOutputIndexFromCoords(coords : vec4<i32>) -> i32 {
  return dot(coords, vec4<i32>(
    outShapeStrides.x, outShapeStrides.y, outShapeStrides.z, 1));
}
`
            }
            ,
            158: (o, i) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.makeMatMulPackedSource = i.makeMatMulPackedVec4Source = void 0,
                i.makeMatMulPackedVec4Source = (a, _, $=!1, _e=32, tt=!1, nt=32, rt=!1) => {
                    const ot = _[1] * a[1]
                      , et = _[0] * a[0]
                      , j = $ ? ot : _e
                      , it = $ ? _e : ot
                      , st = j / _[0]
                      , at = _e / _[1];
                    if ((!$ || st !== 4 || a[1] !== 4) && ($ || st !== 3 && st !== 4) || j % _[0] != 0 || _e % _[1] != 0 || a[0] !== 4)
                        throw new Error(`If transposeA ${$} is true, innerElementSize ${st} and workPerThread[1] ${a[1]} must be 4.
      Otherwise, innerElementSize ${st} must be 3 or 4.
  tileAWidth ${j} must be divisible by workgroupSize[0]${_[0]}. tileInner ${_e} must be divisible by workgroupSize[1] ${_[1]}. colPerThread ${a[0]} must be 4.`);
                    return `
var<workgroup> mm_Asub : array<array<vec${st}<f32>, ${j / st}>, ${it}>;
var<workgroup> mm_Bsub : array<array<vec4<f32>, ${et / a[0]}>, ${_e}>;

const rowPerThread = ${a[1]};
const colPerThread = ${a[0]};
const innerElementSize = ${st};
const tileInner = ${_e};

@compute @workgroup_size(${_[0]}, ${_[1]}, ${_[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
  let localRow = i32(localId.y);
  let tileRow = ${rt ? "0" : "localRow * rowPerThread"};
  let tileCol = i32(localId.x);

  let globalRow = ${rt ? "0" : "i32(globalId.y) * rowPerThread"};
  let globalCol = i32(globalId.x);
  let batch = ${tt ? "0" : "i32(globalId.z)"};
  let globalRowStart = i32(workgroupId.y) * ${ot};

  let numTiles = ${tt ? `${Math.ceil(nt / _e)}` : "(dimInner - 1) / tileInner + 1"};
  var kStart = ${tt ? `i32(globalId.z) * ${nt}` : "0"};

  var acc: array<vec4<f32>, rowPerThread>;

  // Loop over shared dimension.
  let tileRowB = localRow * ${at};
  for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let inputRow = tileRow + innerRow;
          let inputCol = tileCol;
          ${lt = $,
                    lt ? `
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          kStart + inputRow,
          globalRowStart / innerElementSize + inputCol);
        ` : `
        mm_Asub[inputRow][inputCol] = mm_readA(batch,
          globalRow + innerRow,
          kStart / innerElementSize + inputCol);
        `}
      }

      // Load one tile of B into local memory.
      for (var innerRow = 0; innerRow < ${at}; innerRow = innerRow + 1) {
          let inputRow = tileRowB + innerRow;
          let inputCol = tileCol;
          mm_Bsub[inputRow][inputCol] = mm_readB(batch, kStart + inputRow, globalCol);
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      for (var k = 0; k < tileInner / innerElementSize; k = k + 1) {
          let BCached0 = mm_Bsub[k * innerElementSize][tileCol];
          let BCached1 = mm_Bsub[k * innerElementSize + 1][tileCol];
          let BCached2 = mm_Bsub[k * innerElementSize + 2][tileCol];
          ${st === 3 ? "" : "let BCached3 = mm_Bsub[k * innerElementSize + 3][tileCol];"}

          ${( (ct, ut) => ct ? `
        let ACached0 = mm_Asub[k * innerElementSize][localRow];
        let ACached1 = mm_Asub[k * innerElementSize + 1][localRow];
        let ACached2 = mm_Asub[k * innerElementSize + 2][localRow];
        ${ut === 3 ? "" : "let ACached3 = mm_Asub[k * innerElementSize + 3][localRow];"}
        for (var i = 0; i < rowPerThread; i = i + 1) {
          acc[i] = BCached0 * ACached0[i] + acc[i];
          acc[i] = BCached1 * ACached1[i] + acc[i];
          acc[i] = BCached2 * ACached2[i] + acc[i];
          ${ut === 3 ? "" : "acc[i] = BCached3 * ACached3[i] + acc[i];"}
        }` : `
        for (var i = 0; i < rowPerThread; i = i + 1) {
          let ACached = mm_Asub[tileRow + i][k];
          acc[i] = BCached0 * ACached.x + acc[i];
          acc[i] = BCached1 * ACached.y + acc[i];
          acc[i] = BCached2 * ACached.z + acc[i];
          ${ut === 3 ? "" : "acc[i] = BCached3 * ACached.w + acc[i];"}
        }`)($, st)}
      }

      workgroupBarrier();
  }

  for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      mm_write(batch, globalRow + innerRow, globalCol, acc[innerRow]);
  }
}`;
                    var lt
                }
                ;
                const s = a => a ? `
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              kStart + inputRow,
              globalRowStart + inputCol);
            ` : `
            mm_Asub[inputRow][inputCol] = mm_readA(batch,
              globalRowStart + inputRow,
              kStart + inputCol);
            `;
                i.makeMatMulPackedSource = (a, _, $=!1, _e=32, tt=!1, nt=32, rt=!1) => {
                    const ot = a[1] * _[1]
                      , et = a[0] * _[0]
                      , j = $ ? ot : _e
                      , it = $ ? _e : ot;
                    if (it % _[1] != 0 || j % _[0] != 0 || _e % _[1] != 0)
                        throw new Error(`tileAHight ${it} must be divisible by workgroupSize[1]${_[1]}, tileAWidth ${j} must be divisible by workgroupSize[0]${_[0]}, tileInner ${_e} must be divisible by workgroupSize[1]${_[1]}`);
                    const st = it / _[1]
                      , at = j / _[0]
                      , lt = _e / _[1]
                      , ct = rt ? `
    let localRow = i32(localId.y);
    let localCol = i32(localId.x);
    let globalRowStart = i32(workgroupId.y) * ${ot};
    let globalColStart = i32(workgroupId.x) * ${et};

    // Loop over shared dimension.
    for (var t = 0; t < numTiles; t = t + 1) {
      // Load one tile of A into local memory.
      for (var inputRow = localRow; inputRow < ${it}; inputRow = inputRow + ${_[1]}) {
        for (var inputCol = localCol; inputCol < ${j}; inputCol = inputCol + ${_[0]}) {
          ${s($)}
        }
      }
      // Load one tile of B into local memory.
      for (var inputRow = localRow; inputRow < ${_e}; inputRow = inputRow + ${_[1]}) {
            for (var inputCol = localCol; inputCol < ${et}; inputCol = inputCol + ${_[0]}) {
          mm_Bsub[inputRow][inputCol] = mm_readB(batch,
            kStart + inputRow,
            globalColStart + inputCol);
        }
      }
      kStart = kStart + tileInner;
      workgroupBarrier();

      // Compute acc values for a single thread.
      var BCached : array<f32, colPerThread>;
      for (var k = 0; k < tileInner; k = k + 1) {
        for (var inner = 0; inner < colPerThread; inner = inner + 1) {
          BCached[inner] = mm_Bsub[k][localCol + inner * ${_[0]}];
        }
        for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
          let ACached = ${$ ? `mm_Asub[k][localRow + innerRow * ${_[1]}];` : `mm_Asub[localRow + innerRow * ${_[1]}][k];`}
          for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
            acc[innerRow][innerCol] = acc[innerRow][innerCol] +
                ACached * BCached[innerCol];
          }
        }
      }
      workgroupBarrier();
    }
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      let gRow = globalRowStart + localRow + innerRow * ${_[1]};
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        let gCol = globalColStart + localCol + innerCol * ${_[0]};
        mm_write(batch, gRow, gCol, acc[innerRow][innerCol]);
      }
    }
    ` : `
let tileRow = i32(localId.y) * rowPerThread;
let tileCol = i32(localId.x) * colPerThread;

let globalRow = i32(globalId.y) * rowPerThread;
let globalCol = i32(globalId.x) * colPerThread;
let globalRowStart = i32(workgroupId.y) * ${ot};

let tileRowA = i32(localId.y) * ${st};
let tileColA = i32(localId.x) * ${at};
let tileRowB = i32(localId.y) * ${lt};
// Loop over shared dimension.
for (var t = 0; t < numTiles; t = t + 1) {
  // Load one tile of A into local memory.
  for (var innerRow = 0; innerRow < ${st}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < ${at}; innerCol = innerCol + 1) {
      let inputRow = tileRowA + innerRow;
      let inputCol = tileColA + innerCol;
      ${s($)}
    }
  }

  // Load one tile of B into local memory.
  for (var innerRow = 0; innerRow < ${lt}; innerRow = innerRow + 1) {
    for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
      let inputRow = tileRowB + innerRow;
      let inputCol = tileCol + innerCol;
      mm_Bsub[inputRow][inputCol] = mm_readB(batch,
        kStart + inputRow,
        globalCol + innerCol);
    }
  }
  kStart = kStart + tileInner;
  workgroupBarrier();

  // Compute acc values for a single thread.
  var BCached : array<f32, colPerThread>;
  for (var k = 0; k < tileInner; k = k + 1) {
    for (var inner = 0; inner < colPerThread; inner = inner + 1) {
      BCached[inner] = mm_Bsub[k][tileCol + inner];
    }

    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      ${(ut => ut ? "let ACached = mm_Asub[k][tileRow + innerRow];" : "let ACached = mm_Asub[tileRow + innerRow][k];")($)}
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = acc[innerRow][innerCol] + ACached * BCached[innerCol];
      }
    }
  }

  workgroupBarrier();
}

for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
  for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
    mm_write(batch, globalRow + innerRow, globalCol + innerCol,
        acc[innerRow][innerCol]);
  }
}
`;
                    return `
  var<workgroup> mm_Asub : array<array<f32, ${j}>, ${it}>;
  var<workgroup> mm_Bsub : array<array<f32, ${et}>, ${_e}>;
  const rowPerThread = ${a[1]};
  const colPerThread = ${a[0]};
  const tileInner = ${_e};

@compute @workgroup_size(${_[0]}, ${_[1]}, ${_[2]})
fn main(@builtin(local_invocation_id) localId : vec3<u32>,
        @builtin(global_invocation_id) globalId : vec3<u32>,
        @builtin(workgroup_id) workgroupId : vec3<u32>) {
    let batch = ${tt ? "0" : "i32(globalId.z)"};
    let numTiles = ${tt ? `${Math.ceil(nt / _e)}` : "(dimInner - 1) / tileInner + 1"};
    var kStart = ${tt ? `i32(globalId.z) * ${nt}` : "0"};

    var acc : array<array<f32, colPerThread>, rowPerThread>;

    // Without this initialization strange values show up in acc.
    for (var innerRow = 0; innerRow < rowPerThread; innerRow = innerRow + 1) {
      for (var innerCol = 0; innerCol < colPerThread; innerCol = innerCol + 1) {
        acc[innerRow][innerCol] = 0.0;
      }
    }
    ${ct}
  }
`
                }
            }
            ,
            504: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.sub = i.pow = i.mul = i.div = i.add = void 0;
                const a = s(6952)
                  , _ = s(1163)
                  , $ = s(2075)
                  , _e = (tt, nt, rt, ot, et) => {
                    const j = {
                        name: nt,
                        inputTypes: [_.GpuDataType.default, _.GpuDataType.default],
                        cacheHint: et
                    };
                    return Object.assign(Object.assign({}, j), {
                        get: () => ( (it, st, at, lt, ct, ut=st.dataType) => {
                            var dt, ft;
                            const ht = !a.ShapeUtil.areEqual(st.dims, at.dims);
                            let pt = st.dims
                              , gt = a.ShapeUtil.size(st.dims)
                              , _t = !1;
                            if (ht) {
                                const mt = a.BroadcastUtil.calcShape(st.dims, at.dims, !1);
                                if (!mt)
                                    throw new Error("Can't perform binary op on the given tensors");
                                pt = mt,
                                gt = a.ShapeUtil.size(pt);
                                let yt = 1;
                                for (let bt = 0; bt < pt.length; bt++) {
                                    const vt = (dt = st.dims[st.dims.length - bt]) !== null && dt !== void 0 ? dt : 1;
                                    if (vt !== ((ft = at.dims[at.dims.length - bt]) !== null && ft !== void 0 ? ft : 1))
                                        break;
                                    yt *= vt
                                }
                                yt % 4 == 0 && (_t = !0)
                            } else
                                _t = !0;
                            return Object.assign(Object.assign({}, it), {
                                getShaderSource: mt => ( (yt, bt, vt, wt, Tt, $t, Et, Pt, Rt="f32", At="f32", Mt="f32") => {
                                    const Ut = a.ShapeUtil.size(wt)
                                      , Lt = Math.ceil(Ut / 4);
                                    let tn, Vt;
                                    typeof Et == "string" ? tn = Vt = (jt, Gt) => `${Et}((${jt}),(${Gt}))` : typeof Et == "function" ? tn = Vt = Et : (tn = Et.scalar,
                                    Vt = Et.vector);
                                    let Nt = "";
                                    const Yt = (0,
                                    $.createIndicesHelper)("output", wt);
                                    if ($t) {
                                        const jt = Gt => {
                                            const Kt = a.ShapeUtil.computeStrides(Gt)
                                              , qt = [];
                                            for (let rn = Gt.length - 1; rn >= 0; rn--) {
                                                const on = wt.length === 0 ? "0u" : wt.length === 1 ? "(*outputIndices)" : `(*outputIndices)[${rn + wt.length - Gt.length}]`;
                                                qt.push(`${Kt[rn]}u * (${on} % ${Gt[rn]}u)`)
                                            }
                                            return qt.length > 0 ? qt.join("+") : "0u"
                                        }
                                        ;
                                        Nt = `
  ${Yt.o2iImpl}

  fn calcOffsetA(outputIndices: ptr<function, ${Yt.iType}>) -> u32 {
    return ${jt(bt)};
  }

  fn calcOffsetB(outputIndices: ptr<function, ${Yt.iType}>) -> u32 {
    return ${jt(vt)};
  }
  `
                                    }
                                    let Xt;
                                    if (Tt)
                                        Xt = $t ? `
      ${Yt.indicesVariableDeclaration("outputIndices")}
      ${Yt.o2iCall("global_idx * 4u", "outputIndices")}
      let offsetA = calcOffsetA(&outputIndices);
      let offsetB = calcOffsetB(&outputIndices);
      outputData[global_idx] = ${Vt("aData[offsetA / 4u]", "bData[offsetB / 4u]")};` : `outputData[global_idx] = ${Vt("aData[global_idx]", "bData[global_idx]")};`;
                                    else {
                                        if (!$t)
                                            throw new Error("no necessary to use scalar implementation for element-wise binary op implementation.");
                                        const jt = Gt => {
                                            const Kt = `aData[indexA${Gt}][componentA${Gt}]`
                                              , qt = `bData[indexB${Gt}][componentB${Gt}]`;
                                            return `
      ${Yt.o2iCall(`global_idx * 4u + ${Gt}u`, "outputIndices")}
      let offsetA ${Gt} = calcOffsetA(&outputIndices);
      let offsetB ${Gt} = calcOffsetB(&outputIndices);
      let indexA ${Gt} = offsetA ${Gt} / 4u;
      let indexB ${Gt} = offsetB ${Gt} / 4u;
      let componentA ${Gt} = offsetA ${Gt} % 4u;
      let componentB ${Gt} = offsetB ${Gt} % 4u;
      outputData[global_idx][${Gt}] = ${tn(Kt, qt)};`
                                        }
                                        ;
                                        Xt = `
      ${Yt.indicesVariableDeclaration("outputIndices")}
      ${jt(0)}
      ${jt(1)}
      ${jt(2)}
      ${jt(3)}`
                                    }
                                    return `
  @group(0) @binding(0) var<storage, read> aData : array<vec4<${Rt}>>;
  @group(0) @binding(1) var<storage, read> bData : array<vec4<${At}>>;
  @group(0) @binding(2) var<storage, read_write> outputData : array<vec4<${Mt}>>;

  ${Pt ?? ""}
  ${Nt}

  ${yt.mainStart()}
    ${yt.guardAgainstOutOfBoundsWorkgroupSizes(Lt)}
    ${Xt}
  }`
                                }
                                )(mt, st.dims, at.dims, pt, _t, ht, lt, ct),
                                outputs: [{
                                    dims: pt,
                                    dataType: ut,
                                    gpuDataType: _.GpuDataType.default
                                }],
                                dispatchGroup: () => ({
                                    x: Math.ceil(gt / 64 / (_t ? 4 : 1))
                                })
                            })
                        }
                        )(j, tt[0], tt[1], rt, ot)
                    })
                }
                ;
                i.add = tt => {
                    tt.compute(_e(tt.inputs, "Add", (nt, rt) => `${nt}+${rt}`))
                }
                ,
                i.div = tt => {
                    tt.compute(_e(tt.inputs, "Div", (nt, rt) => `${nt}/${rt}`))
                }
                ,
                i.mul = tt => {
                    tt.compute(_e(tt.inputs, "Mul", (nt, rt) => `${nt}*${rt}`))
                }
                ,
                i.pow = tt => {
                    tt.compute(_e(tt.inputs, "Pow", {
                        scalar: (nt, rt) => `pow_f32(${nt},${rt})`,
                        vector: (nt, rt) => `pow_vf32(${nt},${rt})`
                    }, `
    fn pow_f32(a : f32, b : f32) -> f32 {
      if (b == 0.0) {
        return 1.0;
      } else if (a < 0.0 && b != floor(b)) {
        return pow(a, b); // NaN
      }
      return select(sign(a), 1.0, round(abs(b) % 2.0) != 1.0) * pow(abs(a), b);
    }
    fn pow_vf32(a : vec4<f32>, b : vec4<f32>) -> vec4<f32> {
      // TODO: implement vectorized pow
      return vec4<f32>(pow_f32(a.x, b.x), pow_f32(a.y, b.y), pow_f32(a.z, b.z), pow_f32(a.w, b.w));
    }
      `))
                }
                ,
                i.sub = tt => {
                    tt.compute(_e(tt.inputs, "Sub", (nt, rt) => `${nt}-${rt}`))
                }
            }
            ,
            2075: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.createShaderHelper = i.createIndicesHelper = i.WORKGROUP_SIZE = void 0;
                const a = s(6952);
                i.WORKGROUP_SIZE = 64,
                i.createIndicesHelper = ($, _e) => {
                    const tt = _e.length < 2 ? "u32" : `array<u32, ${_e.length}>`
                      , nt = a.ShapeUtil.computeStrides(_e);
                    let rt = "";
                    for (let j = 0; j < _e.length - 1; j++)
                        rt += `
    let dim${j} = current / ${nt[j]}u;
    let rest${j} = current % ${nt[j]}u;
    (*indices)[${j}] = dim${j};
    current = rest${j};
    `;
                    rt += `(*indices)[${_e.length - 1}] = current;`;
                    const ot = _e.length < 2 ? "" : `
  fn ih_o2i_${$}(offset: u32, indices: ptr<function, ${tt}>) {
    var current = offset;
    ${rt}
  }`
                      , et = [];
                    if (_e.length === 0)
                        et.push("0u");
                    else if (_e.length < 2)
                        et.push("(*indices)");
                    else
                        for (let j = _e.length - 1; j >= 0; j--)
                            et.push(`${nt[j]}u * ((*indices)[${j}])`);
                    return {
                        o2iImpl: ot,
                        o2iCall: (j, it) => _e.length < 2 ? `${it}=${j};` : `ih_o2i_${$}(${j}, &${it});`,
                        i2oImpl: _e.length < 2 ? "" : `
  fn ih_i2o_${$}(indices: ptr<function, ${tt}>) -> u32 {
    return ${et.join("+")};
  }`,
                        i2oExpression: (j, it) => _e.length < 2 ? `(${it ? "*" : ""}${j})` : `ih_i2o_${$}(${it ? "" : "&"}${j})`,
                        indicesVariableDeclaration: (j, it) => `var ${j}:${tt}${it ? `=${tt}(${it.join(",")})` : ""};`,
                        iType: tt
                    }
                }
                ;
                class _ {
                    constructor(_e) {
                        this.normalizedDispatchGroup = _e
                    }
                    guardAgainstOutOfBoundsWorkgroupSizes(_e) {
                        return `if (global_idx >= ${typeof _e == "number" ? `${_e}u` : _e}) { return; }`
                    }
                    mainStart(_e=i.WORKGROUP_SIZE) {
                        const tt = typeof _e == "number" ? _e : _e[0]
                          , nt = typeof _e == "number" ? 1 : _e[1]
                          , rt = typeof _e == "number" ? 1 : _e[2]
                          , ot = this.normalizedDispatchGroup[1] === 1 && this.normalizedDispatchGroup[2] === 1;
                        return `@compute @workgroup_size(${tt}, ${nt}, ${rt})
  fn main(${ot ? "@builtin(global_invocation_id) global_id : vec3<u32>" : `@builtin(local_invocation_index) local_index : u32,
    @builtin(workgroup_id) workgroup_id : vec3<u32>`}) {
    ${ot ? "let global_idx = global_id.x;" : `let global_idx = (workgroup_id.z * ${this.normalizedDispatchGroup[0] * this.normalizedDispatchGroup[1]}u +
          workgroup_id.y * ${this.normalizedDispatchGroup[0]}u + workgroup_id.x) * ${tt * nt * rt}u + local_index;`}
  `
                    }
                }
                i.createShaderHelper = $ => new _($)
            }
            ,
            9192: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.createGroupedConvProgramInfoLoader = void 0;
                const a = s(6952)
                  , _ = s(1163)
                  , $ = s(2075)
                  , _e = s(9770)
                  , tt = s(3997);
                i.createGroupedConvProgramInfoLoader = (nt, rt, ot) => {
                    const et = (j = nt.length > 2,
                    it = rt.cacheKey,
                    {
                        name: "GroupedConv",
                        inputTypes: j ? [_.GpuDataType.default, _.GpuDataType.default, _.GpuDataType.default] : [_.GpuDataType.default, _.GpuDataType.default],
                        cacheHint: it
                    });
                    var j, it;
                    return Object.assign(Object.assign({}, et), {
                        get: () => ( (st, at, lt, ct) => {
                            const ut = st.length > 2
                              , dt = ut ? "value += b[output_channel];" : ""
                              , ft = st[0].dims
                              , ht = st[1].dims
                              , pt = ht[0] / lt.group
                              , gt = "f32"
                              , {activationFunction: _t, applyActivation: mt} = (0,
                            tt.getActicationSnippet)(lt)
                              , yt = [`@group(0) @binding(0) var<storage, read> x : array<${gt}>;`, `@group(0) @binding(1) var<storage, read> w : array<${gt}>;`];
                            ut && yt.push(`@group(0) @binding(2) var<storage, read> b : array<${gt}>;`);
                            const bt = lt.format === "NHWC"
                              , vt = (0,
                            _e.calculateOutputShape)(ft, ht, lt.dilations, lt.pads, lt.strides, bt)
                              , wt = a.ShapeUtil.size(vt)
                              , Tt = (0,
                            $.createIndicesHelper)("output", vt)
                              , $t = (0,
                            $.createIndicesHelper)("x", ft)
                              , Et = (0,
                            $.createIndicesHelper)("w", ht);
                            return Object.assign(Object.assign({}, at), {
                                outputs: [{
                                    dims: ct ? ct(vt) : vt,
                                    dataType: st[0].dataType,
                                    gpuDataType: _.GpuDataType.default
                                }],
                                getShaderSource: Pt => `
  const strides: vec2<u32> = vec2(${lt.strides[0]}u, ${lt.strides[1]}u);
  const pads: vec2<u32> = vec2(${lt.pads[0]}u, ${lt.pads[1]}u);

  ${yt.join(`
`)}
  @group(0) @binding(${yt.length}) var<storage, read_write> output : array<${gt}>;

  ${_t}
  ${Tt.o2iImpl}
  ${$t.i2oImpl}
  ${Et.i2oImpl}

  ${Pt.mainStart()}
    ${Pt.guardAgainstOutOfBoundsWorkgroupSizes(wt)}

    ${Tt.indicesVariableDeclaration("outputIndices")}
    ${Tt.o2iCall("global_idx", "outputIndices")}
    let batch: u32 = outputIndices[0];
    let output_channel: u32 = outputIndices[${bt ? 3 : 1}];
    let xRCCorner: vec2<u32> = vec2<u32>(outputIndices[${bt ? 1 : 2}], outputIndices[${bt ? 2 : 3}]) * strides - pads;
    let group_id: u32 = output_channel / ${pt}u;

    var value: ${gt} = ${gt}(0);
    for (var wInChannel: u32 = 0u; wInChannel < ${ht[1]}u; wInChannel++) {
      let input_channel = group_id * ${ht[1]}u + wInChannel;
      for (var wHeight: u32 = 0u; wHeight < ${ht[2]}u; wHeight++) {
        let xHeight = xRCCorner.x + wHeight * ${lt.dilations[0]}u;

        if (xHeight < 0u || xHeight >= ${ft[bt ? 1 : 2]}u) {
          continue;
        }

        for (var wWidth: u32 = 0u; wWidth < ${ht[3]}u; wWidth++) {
          let xWidth = xRCCorner.y + wWidth * ${lt.dilations[1]}u;
          if (xWidth < 0u || xWidth >= ${ft[bt ? 2 : 3]}u) {
            continue;
          }

          ${$t.indicesVariableDeclaration("xIndices", bt ? ["batch", "xHeight", "xWidth", "input_channel"] : ["batch", "input_channel", "xHeight", "xWidth"])}
          let xVal = x[${$t.i2oExpression("xIndices")}];
          ${Et.indicesVariableDeclaration("wIndices", ["output_channel", "wInChannel", "wHeight", "wWidth"])}
          let wVal = w[${Et.i2oExpression("wIndices")}];
          value += xVal*wVal;
        }
      }
    }
    ${dt}
    ${mt}
    output[global_idx] = value;
  }`,
                                dispatchGroup: () => ({
                                    x: Math.ceil(wt / 64)
                                })
                            })
                        }
                        )(nt, et, rt, ot)
                    })
                }
            }
            ,
            9770: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.conv = i.parseConvAttributes = i.calculateOutputShape = void 0;
                const a = s(6952)
                  , _ = s(387)
                  , $ = s(9192)
                  , _e = s(3822)
                  , tt = s(3997)
                  , nt = s(2625);
                i.calculateOutputShape = (et, j, it, st, at, lt) => {
                    const ct = et[0]
                      , ut = et.slice(lt ? 1 : 2, lt ? 3 : 4)
                      , dt = ut.length
                      , ft = j[0]
                      , ht = j.slice(2).map( (gt, _t) => gt + (gt - 1) * (it[_t] - 1))
                      , pt = ut.map( (gt, _t) => gt + st[_t] + st[_t + dt]).map( (gt, _t) => Math.floor((gt - ht[_t] + at[_t]) / at[_t]));
                    return pt.splice(0, 0, ct),
                    pt.splice(lt ? 3 : 1, 0, ft),
                    pt
                }
                ;
                const rt = (0,
                _.createAttributeWithCacheKey)({
                    perm: [2, 3, 1, 0]
                })
                  , ot = (et, j) => {
                    const it = et.kernelShape.slice();
                    for (let lt = 2; lt < j[1].dims.length; ++lt)
                        it[lt - 2] === 0 && (it[lt - 2] = j[1].dims[lt]);
                    const st = et.pads.slice();
                    a.PoolConvUtil.adjustPadsBasedOnAutoPad(j[0].dims, et.strides, et.dilations, it, st, et.format === "NHWC", et.autoPad);
                    const at = Object.assign({}, et);
                    return Object.assign(at, {
                        kernelShape: it,
                        pads: st,
                        cacheKey: et.cacheKey
                    }),
                    at
                }
                ;
                i.parseConvAttributes = et => {
                    const j = (0,
                    tt.parseInternalActivationAttributes)(et)
                      , it = et.format
                      , st = ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][et.auto_pad]
                      , at = et.dilations
                      , lt = et.group
                      , ct = et.kernel_shape
                      , ut = et.pads
                      , dt = et.strides
                      , ft = et.w_is_const();
                    return (0,
                    _.createAttributeWithCacheKey)(Object.assign({
                        autoPad: st,
                        format: it,
                        dilations: at,
                        group: lt,
                        kernelShape: ct,
                        pads: ut,
                        strides: dt,
                        wIsConst: ft
                    }, j))
                }
                ,
                i.conv = (et, j) => {
                    ( (it, st) => {
                        if (!it || it.length !== 2 && it.length !== 3)
                            throw new Error("Conv requires 2 or 3 inputs");
                        if (it[0].dims.length !== 4 && it[0].dims.length !== 3)
                            throw new Error("currently only support conv 1D and 2D");
                        if (it[0].dims.length !== it[1].dims.length)
                            throw new Error("filter does not have same dimension as input");
                        if (it[0].dims[st.format === "NHWC" ? it[0].dims.length - 1 : 1] !== it[1].dims[1] * st.group)
                            throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
                        if (it.length === 3 && (it[2].dims.length !== 1 || it[1].dims[0] !== it[2].dims[0]))
                            throw new Error("invalid bias");
                        const at = it[0].dims.length - 2;
                        if (st.dilations.length !== at)
                            throw new Error(`dilations should be ${at}D`);
                        if (st.strides.length !== at)
                            throw new Error(`strides should be ${at}D`);
                        if (st.pads.length !== 2 * at)
                            throw new Error(`pads should be ${2 * at}D`);
                        if (st.kernelShape.length !== 0 && st.kernelShape.length !== it[1].dims.length - 2)
                            throw new Error("invalid kernel shape");
                        if (it[0].dataType !== 1 || it[1].dataType !== 1)
                            throw new Error("Conv input(X,W) should be float tensor");
                        if (it.length === 3 && it[2].dataType !== 1)
                            throw new Error("Conv input(bias) should be float tensor")
                    }
                    )(et.inputs, j),
                    et.inputs[0].dims.length === 3 ? ( (it, st) => {
                        const at = st.format === "NHWC"
                          , lt = [it.inputs[0].reshape(at ? [it.inputs[0].dims[0], 1, it.inputs[0].dims[1], it.inputs[0].dims[2]] : [it.inputs[0].dims[0], it.inputs[0].dims[1], 1, it.inputs[0].dims[2]]), it.inputs[1].reshape([it.inputs[1].dims[0], it.inputs[1].dims[1], 1, it.inputs[1].dims[2]])];
                        it.inputs.length === 3 && lt.push(it.inputs[2]);
                        const ct = [0, st.pads[0], 0, st.pads[1]]
                          , ut = [1].concat(st.strides)
                          , dt = [1].concat(st.dilations)
                          , ft = [1].concat(st.kernelShape)
                          , ht = ot(Object.assign(Object.assign({}, st), {
                            pads: ct,
                            strides: ut,
                            dilations: dt,
                            kernelShape: ft
                        }), lt);
                        it.compute((0,
                        $.createGroupedConvProgramInfoLoader)(lt, ht, pt => at ? [pt[0], pt[2], pt[3]] : []))
                    }
                    )(et, j) : ( (it, st, at) => {
                        var lt;
                        const ct = ot(at, st)
                          , ut = st.length === 3
                          , dt = at.format === "NHWC"
                          , ft = st[0].dims[dt ? 1 : 2]
                          , ht = st[0].dims[dt ? 2 : 3]
                          , pt = st[0].dims[dt ? 3 : 1]
                          , gt = st[1].dims[2]
                          , _t = st[1].dims[3]
                          , mt = (0,
                        i.calculateOutputShape)(st[0].dims, st[1].dims, at.dilations, ct.pads, at.strides, dt)
                          , yt = mt[dt ? 1 : 2]
                          , bt = mt[dt ? 2 : 3]
                          , vt = mt[dt ? 3 : 1];
                        if (dt && gt === ft && _t === ht && at.autoPad === "VALID" || gt === 1 && _t === 1 && at.dilations[0] === 1 && at.dilations[1] === 1 && at.strides[0] === 1 && at.strides[1] === 1 && (at.autoPad === "SAME_UPPER" || at.autoPad === "SAME_LOWER" || at.autoPad === "VALID") || !dt || at.group !== 1)
                            return void it.compute((0,
                            $.createGroupedConvProgramInfoLoader)(st, ct));
                        const wt = dt ? yt * bt : vt
                          , Tt = dt ? vt : yt * bt
                          , $t = gt * _t * pt
                          , Et = (lt = it.customData.wT) !== null && lt !== void 0 ? lt : it.compute(Object.assign(Object.assign({}, nt.transposeProgramMetadata), {
                            cacheHint: rt.cacheKey,
                            get: () => (0,
                            nt.createTransposeProgramInfo)(st[1], rt.perm)
                        }), {
                            inputs: [1],
                            outputs: [at.wIsConst ? -2 : -1]
                        })[0];
                        at.wIsConst && !it.customData.wT && (it.customData.wT = Et);
                        const Pt = [st[0], Et];
                        ut && (dt || st[2].dims.length !== 1 ? Pt.push(st[2]) : Pt.push(st[2].reshape([st[2].dims[0], 1, 1]))),
                        it.compute((0,
                        _e.createConv2DMatMulProgramInfoLoader)(Pt, ct, mt, wt, Tt, $t, ut, !0), {
                            inputs: Pt
                        })
                    }
                    )(et, et.inputs, j)
                }
            }
            ,
            3822: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.createConv2DMatMulProgramInfoLoader = void 0;
                const a = s(1163)
                  , _ = s(9456);
                i.createConv2DMatMulProgramInfoLoader = ($, _e, tt, nt, rt, ot, et, j) => {
                    const it = ( (st, at) => ({
                        name: "Conv2DMatMul",
                        inputTypes: st ? [a.GpuDataType.default, a.GpuDataType.default, a.GpuDataType.default] : [a.GpuDataType.default, a.GpuDataType.default],
                        cacheHint: at
                    }))(et, _e.cacheKey);
                    return Object.assign(Object.assign({}, it), {
                        get: () => (0,
                        _.createConv2DMatMulProgramInfo)($, it, _e, tt, nt, rt, ot, et, j)
                    })
                }
            }
            ,
            3997: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.parseInternalActivationAttributes = i.getActicationSnippet = void 0;
                const a = s(6952);
                i.getActicationSnippet = _ => {
                    switch (_.activation) {
                    case "Relu":
                        return {
                            activationFunction: "",
                            applyActivation: "value = max(value, 0.0);"
                        };
                    case "Sigmoid":
                        return {
                            activationFunction: "",
                            applyActivation: "value = (1.0 / (1.0 + exp(-value)));"
                        };
                    case "Clip":
                        return {
                            activationFunction: `const clip_min_=f32(${_.clipMin});const clip_max_=f32(${_.clipMax});`,
                            applyActivation: "value = clamp(value, clip_min_, clip_max_);"
                        };
                    default:
                        return {
                            activationFunction: "",
                            applyActivation: ""
                        }
                    }
                }
                ,
                i.parseInternalActivationAttributes = _ => {
                    const $ = (_ == null ? void 0 : _.activation) || "";
                    if ($ === "Clip") {
                        const [_e,tt] = (_ == null ? void 0 : _.activation_params) || [a.MIN_CLIP, a.MAX_CLIP];
                        return {
                            activation: $,
                            clipMax: tt,
                            clipMin: _e,
                            activationCacheKey: `${$}:${_e},${tt}`
                        }
                    }
                    return {
                        activation: $,
                        activationCacheKey: $
                    }
                }
            }
            ,
            4271: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.parseGemmAttributes = i.gemm = void 0;
                const a = s(6952)
                  , _ = s(387)
                  , $ = s(1163);
                i.gemm = (_e, tt) => {
                    (nt => {
                        if (!nt)
                            throw new Error("Input is missing");
                        if (nt.length < 2 || nt.length > 3)
                            throw new Error("Invaid input number.");
                        if (nt.length === 3 && nt[2].dims.length > 2)
                            throw new Error("Invalid input shape of C");
                        if (nt[0].dataType !== 1 || nt[1].dataType !== 1 || nt.length === 3 && nt[2].dataType !== 1)
                            throw new Error("Invalid input type.");
                        if (nt[0].dataType !== nt[1].dataType || nt.length === 3 && nt[0].dataType !== nt[2].dataType)
                            throw new Error("Input types are mismatched")
                    }
                    )(_e.inputs),
                    _e.compute(( (nt, rt) => {
                        const ot = {
                            name: "Gemm",
                            inputTypes: nt.length === 3 ? [$.GpuDataType.default, $.GpuDataType.default, $.GpuDataType.default] : [$.GpuDataType.default, $.GpuDataType.default],
                            cacheHint: rt.cacheKey
                        };
                        return Object.assign(Object.assign({}, ot), {
                            get: () => ( (et, j, it) => {
                                const st = j[0].dims.slice()
                                  , at = j[1].dims.slice()
                                  , [lt,ct,ut] = a.GemmUtil.getShapeOfGemmResult(st, it.transA, at, it.transB, j.length === 3 ? j[2].dims : void 0)
                                  , dt = [lt, ct];
                                if (!dt)
                                    throw new Error("Can't use gemm on the given tensors");
                                const ft = a.ShapeUtil.size(dt);
                                let ht = "";
                                it.transA && it.transB ? ht = "value += a[k * M + m] * b[n * K + k];" : it.transA && !it.transB ? ht = "value += a[k * M + m] * b[k * N + n];" : !it.transA && it.transB ? ht = "value += a[m * K + k] * b[n * K + k];" : it.transA || it.transB || (ht = "value += a[m * K + k] * b[k * N + n];");
                                const pt = "f32"
                                  , gt = it.alpha === 1 ? "" : "value *= alpha;"
                                  , _t = j.length === 3 ? `value += beta * c[${( (yt, bt, vt) => {
                                    if (vt.length === 0)
                                        return "0u";
                                    const wt = vt.length === 1 && yt !== 1 || vt.length === 2 && vt[0] !== yt
                                      , Tt = vt[vt.length - 1] !== bt;
                                    let$t = "0u";
                                    return wt || ($t += `+ m * ${vt[vt.length - 1]}u`),
                                    Tt || ($t += "+n"),
                                    $t
                                }
                                )(lt, ct, j[2].dims)}];` : ""
                                  , mt = [`@group(0) @binding(0) var<storage, read> a : array<${pt}>;`, `@group(0) @binding(1) var<storage, read> b : array<${pt}>;`];
                                return j.length === 3 && mt.push(`@group(0) @binding(2) var<storage, read> c : array<${pt}>;`),
                                Object.assign(Object.assign({}, et), {
                                    outputs: [{
                                        dims: dt,
                                        dataType: j[0].dataType,
                                        gpuDataType: $.GpuDataType.default
                                    }],
                                    getShaderSource: yt => `
  const M: u32 = ${lt}u;
  const N: u32 = ${ct}u;
  const K: u32 = ${ut}u;
  const alpha = ${pt}(${it.alpha});
  const beta = ${pt}(${it.beta});

  ${mt.join(`
`)}
  @group(0) @binding(${j.length}) var<storage, read_write> output : array<${pt}>;

  ${yt.mainStart()}
    ${yt.guardAgainstOutOfBoundsWorkgroupSizes(ft)}

    let m = global_id.x / N;
    let n = global_id.x % N;

    var value = ${pt}(0);
    for (var k: u32 = 0u; k<${ut}u; k++) {
      ${ht}
    }

    ${gt}
    ${_t}
    output[global_id.x] = value;

  }`,
                                    dispatchGroup: () => ({
                                        x: Math.ceil(ft / 64)
                                    })
                                })
                            }
                            )(ot, nt, rt)
                        })
                    }
                    )(_e.inputs, tt))
                }
                ,
                i.parseGemmAttributes = _e => (0,
                _.createAttributeWithCacheKey)(_e)
            }
            ,
            1522: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.matMul = i.createMatmulProgramInfoLoader = void 0;
                const a = s(6952)
                  , _ = s(1163)
                  , $ = s(3997);
                i.createMatmulProgramInfoLoader = (_e, tt) => {
                    const nt = (rt = _e.length > 2,
                    ot = tt.activationCacheKey,
                    {
                        name: "MatMul",
                        inputTypes: rt ? [_.GpuDataType.default, _.GpuDataType.default, _.GpuDataType.default] : [_.GpuDataType.default, _.GpuDataType.default],
                        cacheHint: ot
                    });
                    var rt, ot;
                    return Object.assign(Object.assign({}, nt), {
                        get: () => ( (et, j, it) => {
                            const st = j[0].dims
                              , at = j[1].dims
                              , lt = a.BroadcastUtil.calcShape(st, at, !0);
                            if (!lt)
                                throw new Error("Can't use matmul on the given tensors");
                            const ct = a.ShapeUtil.size(lt)
                              , ut = "f32"
                              , {activationFunction: dt, applyActivation: ft} = (0,
                            $.getActicationSnippet)(it)
                              , ht = lt[lt.length - 2]
                              , pt = st[st.length - 1]
                              , gt = lt[lt.length - 1];
                            return Object.assign(Object.assign({}, et), {
                                outputs: [{
                                    dims: lt,
                                    dataType: j[0].dataType,
                                    gpuDataType: _.GpuDataType.default
                                }],
                                getShaderSource: _t => `
  const M: u32 = ${ht}u;
  const N: u32 = ${gt}u;
  const K: u32 = ${pt}u;

  @group(0) @binding(0) var<storage, read> a : array<${ut}>;
  @group(0) @binding(1) var<storage, read> b : array<${ut}>;
  @group(0) @binding(2) var<storage, read_write> output : array<${ut}>;

  ${dt}

  ${_t.mainStart()}
    ${_t.guardAgainstOutOfBoundsWorkgroupSizes(ct)}

    let stack = global_idx / (M * N);
    let mn = global_idx % (M * N);
    let n = global_idx % N;
    let m = mn / N;

    let offsetA = stack * (M * K);
    let offsetB = stack * (K * N);

    var value = ${ut}(0);
    for (var k: u32 = 0u; k<${pt}u; k++) {
      value += a[offsetA + m * K + k] * b[offsetB + k * N + n];
    }
    ${ft}
    output[global_idx] = value;
  }`,
                                dispatchGroup: () => ({
                                    x: Math.ceil(ct / 64)
                                })
                            })
                        }
                        )(nt, _e, tt)
                    })
                }
                ,
                i.matMul = _e => {
                    (tt => {
                        if (!tt || tt.length !== 2)
                            throw new Error("MatMul requires 2 inputs.");
                        if (tt[0].dims[tt[0].dims.length - 1] !== tt[1].dims[tt[1].dims.length - 2])
                            throw new Error("shared dimension does not match.");
                        if (tt[0].dataType !== 1 || tt[1].dataType !== 1)
                            throw new Error("inputs should be float type")
                    }
                    )(_e.inputs),
                    _e.compute((0,
                    i.createMatmulProgramInfoLoader)(_e.inputs, {
                        activation: "",
                        activationCacheKey: ""
                    }))
                }
            }
            ,
            5262: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.globalMaxPool = i.parseGlobalMaxPoolAttributes = i.parseMaxPoolAttributes = i.maxPool = i.globalAveragePool = i.parseGlobalAveragePoolAttributes = i.averagePool = i.parseAveragePoolAttributes = void 0;
                const a = s(6952)
                  , _ = s(387)
                  , $ = s(1163)
                  , _e = s(2075)
                  , tt = st => {
                    if (!st || st.length !== 1)
                        throw new Error("Pool ops requires 1 input.");
                    if (st[0].dims.length !== 4)
                        throw new Error("Pool ops supports 2-D inputs only for now.");
                    if (st[0].dataType !== 1)
                        throw new Error("Invalid input type.")
                }
                  , nt = (st, at, lt) => {
                    const ct = at.format === "NHWC"
                      , ut = ct ? [st[0].dims[0], st[0].dims[3], st[0].dims[1], st[0].dims[2]] : st[0].dims.slice()
                      , dt = Object.hasOwnProperty.call(at, "dilations")
                      , ft = at.kernelShape.slice()
                      , ht = at.strides.slice()
                      , pt = dt ? at.dilations.slice() : []
                      , gt = at.pads.slice();
                    a.PoolConvUtil.adjustPoolAttributes(lt, ut, ft, ht, pt, gt);
                    const _t = a.PoolConvUtil.computePoolOutputShape(lt, ut, ht, pt, ft, gt, at.autoPad)
                      , mt = Object.assign({}, at);
                    return dt ? Object.assign(mt, {
                        kernelShape: ft,
                        strides: ht,
                        pads: gt,
                        dilations: pt,
                        cacheKey: at.cacheKey
                    }) : Object.assign(mt, {
                        kernelShape: ft,
                        strides: ht,
                        pads: gt,
                        cacheKey: at.cacheKey
                    }),
                    [mt, ct ? [_t[0], _t[2], _t[3], _t[1]] : _t]
                }
                  , rt = (st, at, lt, ct, ut, dt, ft, ht) => {
                    const pt = ct.format === "NHWC"
                      , gt = at.length
                      , _t = a.ShapeUtil.size(lt)
                      , mt = (0,
                    _e.createIndicesHelper)("output", lt)
                      , yt = (0,
                    _e.createIndicesHelper)("x", at);
                    if (ct.kernelShape.length <= 2) {
                        const bt = ct.kernelShape[ct.kernelShape.length - 1]
                          , vt = ct.strides[ct.strides.length - 1]
                          , wt = ct.pads[ct.pads.length / 2 - 1]
                          , Tt = gt - (pt ? 2 : 1);
                        let $t = ""
                          , Et = ""
                          , Pt = "";
                        if ($t = wt + ct.pads[ct.pads.length - 1] !== 0 ? `
              for (var i: u32 = 0u; i < ${bt}u; i++) {
                xIndices[${Tt}] = indices[${Tt}] * ${vt} - ${wt} + i;
                if (xIndices[${Tt}] < 0 || xIndices[${Tt}] >= ${at[Tt]}) {
                  pad++;
                  continue;
                }
                let x_val = x[${yt.i2oExpression("xIndices")}];
                ${ut}
              }` : `
              for (var i: u32 = 0u; i < ${bt}u; i++) {
                xIndices[${Tt}] = indices[${Tt}] * ${vt} - ${wt} + i;
                let x_val = x[${yt.i2oExpression("xIndices")}];
                ${ut}
              }`,
                        ct.kernelShape.length === 2) {
                            const Rt = ct.kernelShape[ct.kernelShape.length - 2]
                              , At = ct.strides[ct.strides.length - 2]
                              , Mt = ct.pads[ct.pads.length / 2 - 2]
                              , Ut = ct.pads[ct.pads.length - 2]
                              , Lt = gt - (pt ? 3 : 2)
                              , tn = at[Lt];
                            Et = Mt + Ut !== 0 ? `
                for (var j: u32 = 0u; j < ${Rt}u; j++) {
                  xIndices[${Lt}] = indices[${Lt}] * ${At} - ${Mt} + j;
                  if (xIndices[${Lt}] < 0 || xIndices[${Lt}] >= ${tn}) {
                    pad+= ${bt};
                    continue;
                  }
              ` : `
                for (var j: u32 = 0u; j < ${Rt}u; j++) {
                  xIndices[${Lt}] = indices[${Lt}] * ${At} - ${Mt} + j;
                `,
                            Pt = `
              }
            `
                        }
                        return `
            @group(0) @binding(0) var<storage, read> x : array<${ft}>;
            @group(0) @binding(1) var<storage, read_write> output : array<${ft}>;

            ${mt.o2iImpl}
            ${yt.i2oImpl}

            ${st.mainStart()}
              ${st.guardAgainstOutOfBoundsWorkgroupSizes(_t)}

              ${mt.indicesVariableDeclaration("indices")}
              ${mt.o2iCall("global_idx", "indices")}
              ${mt.indicesVariableDeclaration("xIndices")}
              ${mt.o2iCall("global_idx", "xIndices")}

              var value: ${ft} = ${ft}(${ht});
              var pad = 0;
              ${Et}
              ${$t}
              ${Pt}
              ${dt}

              output[global_idx] = value;
            }`
                    }
                    {
                        if (pt)
                            throw new Error("Pooling with kernelShape.length > 2 is not supported for NHWC format.");
                        const bt = a.ShapeUtil.size(ct.kernelShape)
                          , vt = a.ShapeUtil.computeStrides(ct.kernelShape)
                          , wt = vt.length
                          , Tt = ct.pads.length;
                        let $t = "";
                        return $t = ct.pads.reduce( (Et, Pt) => Et + Pt) ? `
                if (xIndices[j] >= inputDims[j]) {
                  pad++;
                  isPad = true;
                  break;
                }
              }
              if (!isPad) {
                let x_val = x[${yt.i2oExpression("xIndices")}];
                ${ut}
              }` : `
              }
              let x_val = x[${yt.i2oExpression("xIndices")}];
              ${ut}
            `,
                        `
            @group(0) @binding(0) var<storage, read> x : array<${ft}>;
            @group(0) @binding(1) var<storage, read_write> output : array<${ft}>;

            ${mt.o2iImpl}
            ${yt.i2oImpl}

            const pads = array<u32, ${Tt}>(${ct.pads.map(Et => `${Et}u`).join(",")});
            const inputDims = array<u32, ${gt}>(${at.map(Et => `${Et}u`).join(",")});
            const kernelStrides = array<u32, ${wt}>(${vt.map(Et => `${Et}u`).join(",")});
            const strides = array<u32, ${wt}>(${ct.strides.map(Et => `${Et}u`).join(",")});

            ${st.mainStart()}
              ${st.guardAgainstOutOfBoundsWorkgroupSizes(_t)}

              ${mt.indicesVariableDeclaration("indices")}
              ${mt.o2iCall("global_idx", "indices")}
              ${mt.indicesVariableDeclaration("xIndices")}
              ${mt.o2iCall("global_idx", "xIndices")}

              var offsets: array<u32, ${wt}>;

              var value = ${ft}(${ht});
              var pad = 0;
              var isPad = false;

              for (var i: u32 = 0u; i < ${bt}u; i++) {
                var offset = i;
                for (var j = 0u; j < ${wt - 1}u; j++) {
                  offsets[j] = offset / kernelStrides[j];
                  offset -= offsets[j] * kernelStrides[j];
                }
                offsets[${wt - 1}] = offset;

                isPad = false;
                for (var j = ${gt - wt}u; j < ${gt}u; j++) {
                  xIndices[j] = indices[j] * strides[j - ${gt - wt}u]
                    + offsets[j - ${gt - wt}u] - pads[j - 2u];
                  ${$t}
              }
              ${dt}

              output[global_idx] = value;
            }`
                    }
                }
                  , ot = st => ({
                    format: st.format,
                    autoPad: ["NOTSET", "VALID", "SAME_UPPER", "SAME_LOWER"][st.auto_pad],
                    ceilMode: st.ceil_mode,
                    kernelShape: st.kernel_shape,
                    strides: st.strides,
                    pads: st.pads
                })
                  , et = (st, at, lt, ct) => {
                    const [ut,dt] = nt(st, ct, lt)
                      , ft = a.ShapeUtil.size(ut.kernelShape)
                      , ht = "f32";
                    let pt = "";
                    return ut.countIncludePad ? pt += `value /= ${ht}(${ft});` : pt += `value /= ${ht}(${ft} - pad);`,
                    Object.assign(Object.assign({}, at), {
                        outputs: [{
                            dims: dt,
                            dataType: st[0].dataType,
                            gpuDataType: $.GpuDataType.default
                        }],
                        getShaderSource: gt => rt(gt, st[0].dims, dt, ut, "value += x_val;", pt, ht, "0.0"),
                        dispatchGroup: () => ({
                            x: Math.ceil(a.ShapeUtil.size(dt) / 64)
                        })
                    })
                }
                ;
                i.parseAveragePoolAttributes = st => {
                    const at = st.count_include_pad !== 0
                      , lt = ot(st);
                    if (lt.ceilMode !== 0)
                        throw new Error("using ceil() in shape computation is not yet supported for AveragePool");
                    return (0,
                    _.createAttributeWithCacheKey)(Object.assign({
                        countIncludePad: at
                    }, lt))
                }
                ,
                i.averagePool = (st, at) => {
                    tt(st.inputs);
                    const lt = {
                        name: "AveragePool",
                        inputTypes: [$.GpuDataType.default],
                        cacheHint: at.cacheKey
                    };
                    st.compute(Object.assign(Object.assign({}, lt), {
                        get: () => et(st.inputs, lt, !1, at)
                    }))
                }
                ;
                const j = {
                    autoPad: "",
                    ceilMode: 0,
                    countIncludePad: !1,
                    kernelShape: [],
                    strides: [],
                    pads: [],
                    storageOrder: 0,
                    dilations: [],
                    cacheKey: ""
                };
                i.parseGlobalAveragePoolAttributes = st => {
                    const at = st.format;
                    return Object.assign(Object.assign({
                        format: at
                    }, j), {
                        cacheKey: at
                    })
                }
                ,
                i.globalAveragePool = (st, at) => {
                    tt(st.inputs);
                    const lt = {
                        name: "GlobalAveragePool",
                        inputTypes: [$.GpuDataType.default],
                        cacheHint: at.cacheKey
                    };
                    st.compute(Object.assign(Object.assign({}, lt), {
                        get: () => et(st.inputs, lt, !0, at)
                    }))
                }
                ;
                const it = (st, at, lt, ct) => {
                    const [ut,dt] = nt(st, ct, lt);
                    return Object.assign(Object.assign({}, at), {
                        outputs: [{
                            dims: dt,
                            dataType: st[0].dataType,
                            gpuDataType: $.GpuDataType.default
                        }],
                        getShaderSource: ft => rt(ft, st[0].dims, dt, ut, `
      value = max(x_val, value);
    `, "", "f32", "-1e5"),
                        dispatchGroup: () => ({
                            x: Math.ceil(a.ShapeUtil.size(dt) / 64)
                        })
                    })
                }
                ;
                i.maxPool = (st, at) => {
                    tt(st.inputs);
                    const lt = {
                        name: "MaxPool",
                        inputTypes: [$.GpuDataType.default],
                        cacheHint: at.cacheKey
                    };
                    st.compute(Object.assign(Object.assign({}, lt), {
                        get: () => it(st.inputs, lt, !1, at)
                    }))
                }
                ,
                i.parseMaxPoolAttributes = st => {
                    const at = st.storage_order
                      , lt = st.dilations
                      , ct = ot(st);
                    if (at !== 0)
                        throw new Error("column major storage order is not yet supported for MaxPool");
                    if (ct.ceilMode !== 0)
                        throw new Error("using ceil() in shape computation is not yet supported for MaxPool");
                    return (0,
                    _.createAttributeWithCacheKey)(Object.assign({
                        storageOrder: at,
                        dilations: lt
                    }, ct))
                }
                ,
                i.parseGlobalMaxPoolAttributes = st => {
                    const at = st.format;
                    return Object.assign(Object.assign({
                        format: at
                    }, j), {
                        cacheKey: at
                    })
                }
                ,
                i.globalMaxPool = (st, at) => {
                    tt(st.inputs);
                    const lt = {
                        name: "GlobalMaxPool",
                        inputTypes: [$.GpuDataType.default],
                        cacheHint: at.cacheKey
                    };
                    st.compute(Object.assign(Object.assign({}, lt), {
                        get: () => it(st.inputs, lt, !0, at)
                    }))
                }
            }
            ,
            2625: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.parseTransposeAttributes = i.transpose = i.createTransposeProgramInfo = i.transposeProgramMetadata = void 0;
                const a = s(6952)
                  , _ = s(387)
                  , $ = s(1163)
                  , _e = s(2075);
                i.transposeProgramMetadata = {
                    name: "Transpose",
                    inputTypes: [$.GpuDataType.default]
                };
                const tt = (nt, rt) => rt && rt.length !== nt.length ? [...nt.keys()].reverse() : rt;
                i.createTransposeProgramInfo = (nt, rt) => {
                    const ot = nt.dims
                      , et = tt(ot, rt)
                      , j = ( (ct, ut) => a.ShapeUtil.sortBasedOnPerm(ct, tt(ct, ut)))(ot, et)
                      , it = ot.length
                      , st = a.ShapeUtil.size(j)
                      , at = (0,
                    _e.createIndicesHelper)("output", j)
                      , lt = (0,
                    _e.createIndicesHelper)("a", ot);
                    return Object.assign(Object.assign({}, i.transposeProgramMetadata), {
                        outputs: [{
                            dims: j,
                            dataType: nt.dataType,
                            gpuDataType: $.GpuDataType.default
                        }],
                        getShaderSource: ct => `
  @group(0) @binding(0) var<storage, read> a : array<f32>;
  @group(0) @binding(1) var<storage, read_write> output : array<f32>;

  ${( (ut, dt) => {
                            const ft = [];
                            ft.push(`fn perm(a: ptr<function, array<u32, ${dt}>>, i: ptr<function, array<u32, ${dt}>>) {`);
                            for (let ht = 0; ht < dt; ++ht)
                                ft.push(`	(*a)[${ut[ht]}]=(*i)[${ht}];`);
                            return ft.push("	}"),
                            ft.join(`
`)
                        }
                        )(et, it)}
  ${at.o2iImpl}
  ${lt.i2oImpl}

  ${ct.mainStart()}
    ${ct.guardAgainstOutOfBoundsWorkgroupSizes(st)}

    ${at.indicesVariableDeclaration("indices")}
    ${at.o2iCall("global_idx", "indices")}
    ${lt.indicesVariableDeclaration("aIndices")}
    perm(&aIndices, &indices);

    output[global_idx] = a[${lt.i2oExpression("aIndices")}];
  }`,
                        dispatchGroup: () => ({
                            x: Math.ceil(st / 64)
                        })
                    })
                }
                ,
                i.transpose = (nt, rt) => {
                    (ot => {
                        if (!ot || ot.length !== 1)
                            throw new Error("Transpose requires 1 input.");
                        if (ot[0].dataType !== 1)
                            throw new Error("input should be float tensor")
                    }
                    )(nt.inputs),
                    nt.compute(Object.assign(Object.assign({}, i.transposeProgramMetadata), {
                        cacheHint: rt.cacheKey,
                        get: () => (0,
                        i.createTransposeProgramInfo)(nt.inputs[0], rt.perm)
                    }))
                }
                ,
                i.parseTransposeAttributes = nt => (0,
                _.createAttributeWithCacheKey)({
                    perm: nt.perm
                })
            }
            ,
            9302: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.thresholdedRelu = i.tanh = i.tan = i.sqrt = i.sinh = i.sin = i.sigmoid = i.relu = i.reciprocal = i.neg = i.leakyRelu = i.floor = i.exp = i.erf = i.elu = i.parseAlphaAttributes = i.cosh = i.cos = i.ceil = i.clip = i.clipV10 = i.atanh = i.atan = i.asinh = i.asin = i.acosh = i.acos = i.abs = void 0;
                const a = s(6952)
                  , _ = s(387)
                  , $ = s(1163)
                  , _e = (tt, nt, rt, ot, et) => {
                    const j = {
                        name: nt,
                        inputTypes: [$.GpuDataType.default],
                        cacheHint: et
                    };
                    return Object.assign(Object.assign({}, j), {
                        get: () => ( (it, st, at, lt) => Object.assign(Object.assign({}, it), {
                            getShaderSource: ct => ( (ut, dt, ft, ht) => {
                                const pt = Math.ceil(dt / 4);
                                let gt = "";
                                return gt = typeof ft == "string" ? `${ft}(a)` : ft("a"),
                                `
  @group(0) @binding(0) var<storage, read> inputData : array<vec4<f32>>;
  @group(0) @binding(1) var<storage, read_write> outputData : array<vec4<f32>>;

  ${ht ?? ""}

  ${ut.mainStart()}
    ${ut.guardAgainstOutOfBoundsWorkgroupSizes(pt)}

    let a = inputData[global_idx];
    outputData[global_idx] = ${gt};
  }`
                            }
                            )(ct, a.ShapeUtil.size(st.dims), at, lt),
                            outputs: [{
                                dims: st.dims,
                                dataType: st.dataType,
                                gpuDataType: $.GpuDataType.default
                            }],
                            dispatchGroup: ct => ({
                                x: Math.ceil(a.ShapeUtil.size(ct[0].dims) / 64 / 4)
                            })
                        }))(j, tt, rt, ot)
                    })
                }
                ;
                i.abs = tt => {
                    tt.compute(_e(tt.inputs[0], "Abs", "abs"))
                }
                ,
                i.acos = tt => {
                    tt.compute(_e(tt.inputs[0], "Acos", "acos"))
                }
                ,
                i.acosh = tt => {
                    tt.compute(_e(tt.inputs[0], "Acosh", "acosh"))
                }
                ,
                i.asin = tt => {
                    tt.compute(_e(tt.inputs[0], "Asin", "asin"))
                }
                ,
                i.asinh = tt => {
                    tt.compute(_e(tt.inputs[0], "Asinh", "asinh"))
                }
                ,
                i.atan = tt => {
                    tt.compute(_e(tt.inputs[0], "Atan", "atan"))
                }
                ,
                i.atanh = tt => {
                    tt.compute(_e(tt.inputs[0], "Atanh", "atanh"))
                }
                ,
                i.clipV10 = (tt, nt) => {
                    tt.compute(_e(tt.inputs[0], "Clip", rt => `clamp(${rt}, clip_min_, clip_max_)`, `
    const clip_min_: vec4<f32> = vec4(f32(${nt.min}));
    const clip_max_: vec4<f32> = vec4(f32(${nt.max}));
`, nt.cacheKey), {
                        inputs: [0]
                    })
                }
                ,
                i.clip = tt => {
                    const nt = (rt => {
                        const ot = rt.length >= 2 ? rt[1].getFloat32Array()[0] : a.MIN_CLIP
                          , et = rt.length >= 3 ? rt[2].getFloat32Array()[0] : a.MAX_CLIP;
                        return (0,
                        _.createAttributeWithCacheKey)({
                            min: ot,
                            max: et
                        })
                    }
                    )(tt.inputs);
                    (0,
                    i.clipV10)(tt, nt)
                }
                ,
                i.ceil = tt => {
                    tt.compute(_e(tt.inputs[0], "Ceil", "ceil"))
                }
                ,
                i.cos = tt => {
                    tt.compute(_e(tt.inputs[0], "Cos", "cos"))
                }
                ,
                i.cosh = tt => {
                    tt.compute(_e(tt.inputs[0], "Cosh", "cosh"))
                }
                ,
                i.parseAlphaAttributes = tt => (0,
                _.createAttributeWithCacheKey)(tt),
                i.elu = (tt, nt) => {
                    tt.compute(_e(tt.inputs[0], "Elu", rt => `elu_vf32(${rt})`, `
  const elu_alpha_: f32 = f32(${nt.alpha});

  fn elu_f32(a: f32) -> f32 {
  return select((exp(a) - 1.0) * elu_alpha_, a, a >= 0.0);
  }

  fn elu_vf32(v: vec4<f32>) -> vec4<f32> {
  return vec4(elu_f32(v.x), elu_f32(v.y), elu_f32(v.z), elu_f32(v.w));
  }`, nt.cacheKey))
                }
                ,
                i.erf = tt => {
                    tt.compute(_e(tt.inputs[0], "Erf", nt => `erf_vf32(${nt})`, `
  const r0: f32 = 0.3275911;
  const r1: f32 = 0.254829592;
  const r2: f32 = -0.284496736;
  const r3: f32 = 1.421413741;
  const r4: f32 = -1.453152027;
  const r5: f32 = 1.061405429;

  fn erf_vf32(v: vec4<f32>) -> vec4<f32> {
    let absv = abs(v);
    let x = 1.0 / (1.0 + r0 * absv);
    return sign(v) * (1.0 - ((((r5 * x + r4) * x + r3) * x + r2) * x + r1) * x * exp(-absv * absv));
  }`))
                }
                ,
                i.exp = tt => {
                    tt.compute(_e(tt.inputs[0], "Exp", "exp"))
                }
                ,
                i.floor = tt => {
                    tt.compute(_e(tt.inputs[0], "Floor", "floor"))
                }
                ,
                i.leakyRelu = (tt, nt) => {
                    tt.compute(_e(tt.inputs[0], "LeakyRelu", rt => `select(leaky_relu_alpha_ * ${rt}, ${rt}, ${rt} >= vec4<f32>(0.0))`, `const leaky_relu_alpha_: f32 = f32(${nt.alpha});`, nt.cacheKey))
                }
                ,
                i.neg = tt => {
                    tt.compute(_e(tt.inputs[0], "Neg", nt => `-${nt}`))
                }
                ,
                i.reciprocal = tt => {
                    tt.compute(_e(tt.inputs[0], "Reciprocal", nt => `1.0/${nt}`))
                }
                ,
                i.relu = tt => {
                    tt.compute(_e(tt.inputs[0], "Relu", nt => `select(vec4<f32>(0.0), ${nt}, ${nt} > vec4<f32>(0.0))`))
                }
                ,
                i.sigmoid = tt => {
                    tt.compute(_e(tt.inputs[0], "Sigmoid", nt => `(1.0 / (1.0 + exp(-${nt})))`))
                }
                ,
                i.sin = tt => {
                    tt.compute(_e(tt.inputs[0], "Sin", "sin"))
                }
                ,
                i.sinh = tt => {
                    tt.compute(_e(tt.inputs[0], "Sinh", "sinh"))
                }
                ,
                i.sqrt = tt => {
                    tt.compute(_e(tt.inputs[0], "Sqrt", "sqrt"))
                }
                ,
                i.tan = tt => {
                    tt.compute(_e(tt.inputs[0], "Tan", "tan"))
                }
                ,
                i.tanh = tt => {
                    tt.compute(_e(tt.inputs[0], "Tanh", "tanh"))
                }
                ,
                i.thresholdedRelu = (tt, nt) => (tt.compute(_e(tt.inputs[0], "ThresholdedRelu", rt => `select(vec4<f32>(0.0), ${rt}, ${rt} > thresholded_relu_alpha_)`, `const thresholded_relu_alpha_: vec4<f32> = vec4<f32>(${nt.alpha});`, nt.cacheKey)),
                0)
            }
            ,
            8305: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.ProgramManager = void 0;
                const a = s(4955)
                  , _ = s(2075);
                i.ProgramManager = class {
                    constructor($) {
                        this.backend = $,
                        this.repo = new Map,
                        this.attributesBound = !1
                    }
                    getArtifact($) {
                        return this.repo.get($)
                    }
                    setArtifact($, _e) {
                        this.repo.set($, _e)
                    }
                    run($, _e, tt, nt) {
                        const rt = this.backend.device
                          , ot = this.backend.getComputePassEncoder();
                        this.backend.profilingEnabled && ot.writeTimestamp(this.backend.profilingQuerySet, 0),
                        ot.setPipeline($.computePipeline);
                        const et = [];
                        for (const it of _e)
                            et.push({
                                binding: et.length,
                                resource: {
                                    buffer: it.buffer
                                }
                            });
                        for (const it of tt)
                            et.push({
                                binding: et.length,
                                resource: {
                                    buffer: it.buffer
                                }
                            });
                        const j = rt.createBindGroup({
                            layout: $.computePipeline.getBindGroupLayout(0),
                            entries: et
                        });
                        if (ot.setBindGroup(0, j),
                        ot.dispatchWorkgroups(...nt),
                        this.backend.pendingDispatchNumber++,
                        this.backend.profilingEnabled) {
                            ot.writeTimestamp(this.backend.profilingQuerySet, 1);
                            const it = this.backend.gpuDataManager.create(16, GPUBufferUsage.COPY_SRC | GPUBufferUsage.QUERY_RESOLVE)
                              , st = this.backend.gpuDataManager.create(16, GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);
                            this.backend.endComputePass(),
                            this.backend.getCommandEncoder().resolveQuerySet(this.backend.profilingQuerySet, 0, 2, it.buffer, 0),
                            this.backend.getCommandEncoder().copyBufferToBuffer(it.buffer, 0, st.buffer, 0, 16),
                            this.backend.flush();
                            const at = this.backend.currentKernelId
                              , lt = this.backend.kernels.get(at)[0];
                            st.buffer.mapAsync(GPUMapMode.READ).then( () => {
                                const ct = new BigUint64Array(st.buffer.getMappedRange())
                                  , ut = ct[0]
                                  , dt = ct[1];
                                st.buffer.unmap(),
                                this.backend.profilingTimeBase === void 0 && (this.backend.profilingTimeBase = ut);
                                const ft = Number(ut - this.backend.profilingTimeBase)
                                  , ht = Number(dt - this.backend.profilingTimeBase);
                                if (!Number.isSafeInteger(ft) || !Number.isSafeInteger(ht))
                                    throw new RangeError("incorrect timestamp range");
                                this.backend.gpuDataManager.release(it.id),
                                this.backend.gpuDataManager.release(st.id),
                                console.log(`[profiling] kernel "${at}|${lt}" execution time: ${ht - ft} ns`)
                            }
                            )
                        }
                        this.backend.pendingDispatchNumber >= 16 && this.backend.flush()
                    }
                    dispose() {}
                    build($, _e) {
                        const tt = this.backend.device
                          , nt = $.getShaderSource((0,
                        _.createShaderHelper)(_e))
                          , rt = tt.createShaderModule({
                            code: nt
                        });
                        return (0,
                        a.LOG_DEBUG)("verbose", () => `[WebGPU] shader code: ${nt}`),
                        {
                            programInfo: $,
                            computePipeline: tt.createComputePipeline({
                                compute: {
                                    module: rt,
                                    entryPoint: "main"
                                },
                                layout: "auto"
                            })
                        }
                    }
                    normalizeDispatchGroupSize($) {
                        const _e = typeof $ == "number" ? $ : $.x
                          , tt = typeof $ == "number" ? 1 : $.y || 1
                          , nt = typeof $ == "number" ? 1 : $.z || 1
                          , rt = this.backend.device.limits.maxComputeWorkgroupsPerDimension;
                        if (_e <= rt && tt <= rt && nt <= rt)
                            return [_e, tt, nt];
                        const ot = _e * tt * nt;
                        let et = Math.ceil(Math.sqrt(ot));
                        if (et > rt) {
                            if (et = Math.ceil(Math.cbrt(ot)),
                            et > rt)
                                throw new Error("Total dispatch size exceeds WebGPU maximum.");
                            return [et, et, et]
                        }
                        return [et, et, 1]
                    }
                }
            }
            ,
            1163: (o, i) => {
                var s;
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.GpuDataType = void 0,
                (s = i.GpuDataType || (i.GpuDataType = {}))[s.default = 0] = "default",
                s[s.upload = 1] = "upload",
                s[s.profile = 2] = "profile"
            }
            ,
            3899: (o, i) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.iterateExtraOptions = void 0,
                i.iterateExtraOptions = (s, a, _, $) => {
                    if (typeof s == "object" && s !== null) {
                        if (_.has(s))
                            throw new Error("Circular reference in options");
                        _.add(s)
                    }
                    Object.entries(s).forEach( ([_e,tt]) => {
                        const nt = a ? a + _e : _e;
                        if (typeof tt == "object")
                            (0,
                            i.iterateExtraOptions)(tt, nt + ".", _, $);
                        else if (typeof tt == "string" || typeof tt == "number")
                            $(nt, tt.toString());
                        else {
                            if (typeof tt != "boolean")
                                throw new Error("Can't handle extra config type: " + typeof tt);
                            $(nt, tt ? "1" : "0")
                        }
                    }
                    )
                }
            }
            ,
            9544: function(o, i, s) {
                var a, _ = this && this.__createBinding || (Object.create ? function(bt, vt, wt, Tt) {
                    Tt === void 0 && (Tt = wt);
                    var $t = Object.getOwnPropertyDescriptor(vt, wt);
                    $t && !("get"in $t ? !vt.__esModule : $t.writable || $t.configurable) || ($t = {
                        enumerable: !0,
                        get: function() {
                            return vt[wt]
                        }
                    }),
                    Object.defineProperty(bt, Tt, $t)
                }
                : function(bt, vt, wt, Tt) {
                    Tt === void 0 && (Tt = wt),
                    bt[Tt] = vt[wt]
                }
                ), $ = this && this.__setModuleDefault || (Object.create ? function(bt, vt) {
                    Object.defineProperty(bt, "default", {
                        enumerable: !0,
                        value: vt
                    })
                }
                : function(bt, vt) {
                    bt.default = vt
                }
                ), _e = this && this.__importStar || function(bt) {
                    if (bt && bt.__esModule)
                        return bt;
                    var vt = {};
                    if (bt != null)
                        for (var wt in bt)
                            wt !== "default" && Object.prototype.hasOwnProperty.call(bt, wt) && _(vt, bt, wt);
                    return $(vt, bt),
                    vt
                }
                ;
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.endProfiling = i.run = i.releaseSession = i.createSession = i.createSessionFinalize = i.createSessionAllocate = i.initOrt = i.initWasm = void 0;
                const tt = s(8453)
                  , nt = s(7675)
                  , rt = _e(s(1259))
                  , ot = s(263)
                  , et = () => !!tt.env.wasm.proxy && typeof document < "u";
                let j, it, st, at = !1, lt = !1, ct = !1;
                const ut = []
                  , dt = []
                  , ft = []
                  , ht = []
                  , pt = []
                  , gt = []
                  , _t = () => {
                    if (at || !lt || ct || !j)
                        throw new Error("worker not ready")
                }
                  , mt = bt => {
                    switch (bt.data.type) {
                    case "init-wasm":
                        at = !1,
                        bt.data.err ? (ct = !0,
                        it[1](bt.data.err)) : (lt = !0,
                        it[0]());
                        break;
                    case "init-ort":
                        bt.data.err ? st[1](bt.data.err) : st[0]();
                        break;
                    case "create_allocate":
                        bt.data.err ? ut.shift()[1](bt.data.err) : ut.shift()[0](bt.data.out);
                        break;
                    case "create_finalize":
                        bt.data.err ? dt.shift()[1](bt.data.err) : dt.shift()[0](bt.data.out);
                        break;
                    case "create":
                        bt.data.err ? ft.shift()[1](bt.data.err) : ft.shift()[0](bt.data.out);
                        break;
                    case "release":
                        bt.data.err ? ht.shift()[1](bt.data.err) : ht.shift()[0]();
                        break;
                    case "run":
                        bt.data.err ? pt.shift()[1](bt.data.err) : pt.shift()[0](bt.data.out);
                        break;
                    case "end-profiling":
                        bt.data.err ? gt.shift()[1](bt.data.err) : gt.shift()[0]()
                    }
                }
                  , yt = typeof document < "u" ? (a = document == null ? void 0 : document.currentScript) === null || a === void 0 ? void 0 : a.src : void 0;
                i.initWasm = async () => {
                    if (et()) {
                        if (lt)
                            return;
                        if (at)
                            throw new Error("multiple calls to 'initWasm()' detected.");
                        if (ct)
                            throw new Error("previous call to 'initWasm()' failed.");
                        return at = !0,
                        tt.env.wasm.wasmPaths === void 0 && yt && yt.indexOf("blob:") !== 0 && (tt.env.wasm.wasmPaths = yt.substr(0, +yt.lastIndexOf("/") + 1)),
                        new Promise( (bt, vt) => {
                            j == null || j.terminate(),
                            j = s(8050).Z(),
                            j.onmessage = mt,
                            it = [bt, vt];
                            const wt = {
                                type: "init-wasm",
                                in: tt.env.wasm
                            };
                            j.postMessage(wt)
                        }
                        )
                    }
                    return (0,
                    ot.initializeWebAssembly)(tt.env.wasm)
                }
                ,
                i.initOrt = async (bt, vt) => {
                    if (et())
                        return _t(),
                        new Promise( (wt, Tt) => {
                            st = [wt, Tt];
                            const $t = {
                                type: "init-ort",
                                in: {
                                    numThreads: bt,
                                    loggingLevel: vt
                                }
                            };
                            j.postMessage($t)
                        }
                        );
                    rt.initOrt(bt, vt),
                    await (0,
                    nt.init)((0,
                    ot.getInstance)())
                }
                ,
                i.createSessionAllocate = async bt => et() ? (_t(),
                new Promise( (vt, wt) => {
                    ut.push([vt, wt]);
                    const Tt = {
                        type: "create_allocate",
                        in: {
                            model: bt
                        }
                    };
                    j.postMessage(Tt, [bt.buffer])
                }
                )) : rt.createSessionAllocate(bt),
                i.createSessionFinalize = async (bt, vt) => et() ? (_t(),
                new Promise( (wt, Tt) => {
                    dt.push([wt, Tt]);
                    const $t = {
                        type: "create_finalize",
                        in: {
                            modeldata: bt,
                            options: vt
                        }
                    };
                    j.postMessage($t)
                }
                )) : rt.createSessionFinalize(bt, vt),
                i.createSession = async (bt, vt) => et() ? (_t(),
                new Promise( (wt, Tt) => {
                    ft.push([wt, Tt]);
                    const $t = {
                        type: "create",
                        in: {
                            model: bt,
                            options: vt
                        }
                    };
                    j.postMessage($t, [bt.buffer])
                }
                )) : rt.createSession(bt, vt),
                i.releaseSession = async bt => {
                    if (et())
                        return _t(),
                        new Promise( (vt, wt) => {
                            ht.push([vt, wt]);
                            const Tt = {
                                type: "release",
                                in: bt
                            };
                            j.postMessage(Tt)
                        }
                        );
                    rt.releaseSession(bt)
                }
                ,
                i.run = async (bt, vt, wt, Tt, $t) => et() ? (_t(),
                new Promise( (Et, Pt) => {
                    pt.push([Et, Pt]);
                    const Rt = {
                        type: "run",
                        in: {
                            sessionId: bt,
                            inputIndices: vt,
                            inputs: wt,
                            outputIndices: Tt,
                            options: $t
                        }
                    };
                    j.postMessage(Rt, rt.extractTransferableBuffers(wt))
                }
                )) : rt.run(bt, vt, wt, Tt, $t),
                i.endProfiling = async bt => {
                    if (et())
                        return _t(),
                        new Promise( (vt, wt) => {
                            gt.push([vt, wt]);
                            const Tt = {
                                type: "end-profiling",
                                in: bt
                            };
                            j.postMessage(Tt)
                        }
                        );
                    rt.endProfiling(bt)
                }
            },
            7918: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.setRunOptions = void 0;
                const a = s(3899)
                  , _ = s(9444)
                  , $ = s(263);
                i.setRunOptions = _e => {
                    const tt = (0,
                    $.getInstance)();
                    let nt = 0;
                    const rt = []
                      , ot = _e || {};
                    try {
                        if ((_e == null ? void 0 : _e.logSeverityLevel) === void 0)
                            ot.logSeverityLevel = 2;
                        else if (typeof _e.logSeverityLevel != "number" || !Number.isInteger(_e.logSeverityLevel) || _e.logSeverityLevel < 0 || _e.logSeverityLevel > 4)
                            throw new Error(`log serverity level is not valid: ${_e.logSeverityLevel}`);
                        if ((_e == null ? void 0 : _e.logVerbosityLevel) === void 0)
                            ot.logVerbosityLevel = 0;
                        else if (typeof _e.logVerbosityLevel != "number" || !Number.isInteger(_e.logVerbosityLevel))
                            throw new Error(`log verbosity level is not valid: ${_e.logVerbosityLevel}`);
                        (_e == null ? void 0 : _e.terminate) === void 0 && (ot.terminate = !1);
                        let et = 0;
                        if ((_e == null ? void 0 : _e.tag) !== void 0 && (et = (0,
                        _.allocWasmString)(_e.tag, rt)),
                        nt = tt._OrtCreateRunOptions(ot.logSeverityLevel, ot.logVerbosityLevel, !!ot.terminate, et),
                        nt === 0)
                            throw new Error("Can't create run options");
                        return (_e == null ? void 0 : _e.extra) !== void 0 && (0,
                        a.iterateExtraOptions)(_e.extra, "", new WeakSet, (j, it) => {
                            const st = (0,
                            _.allocWasmString)(j, rt)
                              , at = (0,
                            _.allocWasmString)(it, rt);
                            if (tt._OrtAddRunConfigEntry(nt, st, at) !== 0)
                                throw new Error(`Can't set a run config entry: ${j} - ${it}`)
                        }
                        ),
                        [nt, rt]
                    } catch (et) {
                        throw nt !== 0 && tt._OrtReleaseRunOptions(nt),
                        rt.forEach(tt._free),
                        et
                    }
                }
            }
            ,
            6640: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.OnnxruntimeWebAssemblySessionHandler = void 0;
                const a = s(2806)
                  , _ = s(8453)
                  , $ = s(2850)
                  , _e = s(9544)
                  , tt = s(7917);
                let nt;
                i.OnnxruntimeWebAssemblySessionHandler = class {
                    async createSessionAllocate(rt) {
                        const ot = await fetch(rt)
                          , et = await ot.arrayBuffer();
                        return (0,
                        _e.createSessionAllocate)(new Uint8Array(et))
                    }
                    async loadModel(rt, ot) {
                        if (nt || (await (0,
                        _e.initOrt)(_.env.wasm.numThreads, (0,
                        tt.logLevelStringToEnum)(_.env.logLevel)),
                        nt = !0),
                        typeof rt == "string")
                            if (typeof fetch > "u") {
                                const et = await (0,
                                $.promisify)(a.readFile)(rt);
                                [this.sessionId,this.inputNames,this.outputNames] = await (0,
                                _e.createSession)(et, ot)
                            } else {
                                const et = await this.createSessionAllocate(rt);
                                [this.sessionId,this.inputNames,this.outputNames] = await (0,
                                _e.createSessionFinalize)(et, ot)
                            }
                        else
                            [this.sessionId,this.inputNames,this.outputNames] = await (0,
                            _e.createSession)(rt, ot)
                    }
                    async dispose() {
                        return (0,
                        _e.releaseSession)(this.sessionId)
                    }
                    async run(rt, ot, et) {
                        const j = []
                          , it = [];
                        Object.entries(rt).forEach(ct => {
                            const ut = ct[0]
                              , dt = ct[1]
                              , ft = this.inputNames.indexOf(ut);
                            if (ft === -1)
                                throw new Error(`invalid input '${ut}'`);
                            j.push(dt),
                            it.push(ft)
                        }
                        );
                        const st = [];
                        Object.entries(ot).forEach(ct => {
                            const ut = ct[0]
                              , dt = this.outputNames.indexOf(ut);
                            if (dt === -1)
                                throw new Error(`invalid output '${ut}'`);
                            st.push(dt)
                        }
                        );
                        const at = await (0,
                        _e.run)(this.sessionId, it, j.map(ct => [ct.type, ct.dims, ct.data]), st, et)
                          , lt = {};
                        for (let ct = 0; ct < at.length; ct++)
                            lt[this.outputNames[st[ct]]] = new _.Tensor(at[ct][0],at[ct][2],at[ct][1]);
                        return lt
                    }
                    startProfiling() {}
                    endProfiling() {
                        (0,
                        _e.endProfiling)(this.sessionId)
                    }
                }
            }
            ,
            7622: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.setSessionOptions = void 0;
                const a = s(3899)
                  , _ = s(9444)
                  , $ = s(263);
                i.setSessionOptions = _e => {
                    var tt, nt, rt, ot;
                    const et = (0,
                    $.getInstance)();
                    let j = 0;
                    const it = []
                      , st = _e || {};
                    (at => {
                        at.extra || (at.extra = {}),
                        at.extra.session || (at.extra.session = {});
                        const lt = at.extra.session;
                        lt.use_ort_model_bytes_directly || (lt.use_ort_model_bytes_directly = "1"),
                        at.executionProviders && at.executionProviders.some(ct => (typeof ct == "string" ? ct : ct.name) === "webgpu") && (at.enableMemPattern = !1)
                    }
                    )(st);
                    try {
                        const at = (ht => {
                            switch (ht) {
                            case "disabled":
                                return 0;
                            case "basic":
                                return 1;
                            case "extended":
                                return 2;
                            case "all":
                                return 99;
                            default:
                                throw new Error(`unsupported graph optimization level: ${ht}`)
                            }
                        }
                        )((tt = st.graphOptimizationLevel) !== null && tt !== void 0 ? tt : "all")
                          , lt = (ht => {
                            switch (ht) {
                            case "sequential":
                                return 0;
                            case "parallel":
                                return 1;
                            default:
                                throw new Error(`unsupported execution mode: ${ht}`)
                            }
                        }
                        )((nt = st.executionMode) !== null && nt !== void 0 ? nt : "sequential")
                          , ct = typeof st.logId == "string" ? (0,
                        _.allocWasmString)(st.logId, it) : 0
                          , ut = (rt = st.logSeverityLevel) !== null && rt !== void 0 ? rt : 2;
                        if (!Number.isInteger(ut) || ut < 0 || ut > 4)
                            throw new Error(`log serverity level is not valid: ${ut}`);
                        const dt = (ot = st.logVerbosityLevel) !== null && ot !== void 0 ? ot : 0;
                        if (!Number.isInteger(dt) || dt < 0 || dt > 4)
                            throw new Error(`log verbosity level is not valid: ${dt}`);
                        const ft = typeof st.optimizedModelFilePath == "string" ? (0,
                        _.allocWasmString)(st.optimizedModelFilePath, it) : 0;
                        if (j = et._OrtCreateSessionOptions(at, !!st.enableCpuMemArena, !!st.enableMemPattern, lt, !!st.enableProfiling, 0, ct, ut, dt, ft),
                        j === 0)
                            throw new Error("Can't create session options");
                        return st.executionProviders && ( (ht, pt, gt) => {
                            for (const _t of pt) {
                                let mt = typeof _t == "string" ? _t : _t.name;
                                switch (mt) {
                                case "xnnpack":
                                    mt = "XNNPACK";
                                    break;
                                case "webgpu":
                                    mt = "JS";
                                    break;
                                case "wasm":
                                case "cpu":
                                    continue;
                                default:
                                    throw new Error(`not supported EP: ${mt}`)
                                }
                                const yt = (0,
                                _.allocWasmString)(mt, gt);
                                if ((0,
                                $.getInstance)()._OrtAppendExecutionProvider(ht, yt) !== 0)
                                    throw new Error(`Can't append execution provider: ${mt}`)
                            }
                        }
                        )(j, st.executionProviders, it),
                        st.extra !== void 0 && (0,
                        a.iterateExtraOptions)(st.extra, "", new WeakSet, (ht, pt) => {
                            const gt = (0,
                            _.allocWasmString)(ht, it)
                              , _t = (0,
                            _.allocWasmString)(pt, it);
                            if (et._OrtAddSessionConfigEntry(j, gt, _t) !== 0)
                                throw new Error(`Can't set a session config entry: ${ht} - ${pt}`)
                        }
                        ),
                        [j, it]
                    } catch (at) {
                        throw j !== 0 && et._OrtReleaseSessionOptions(j),
                        it.forEach(et._free),
                        at
                    }
                }
            }
            ,
            9444: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.allocWasmString = void 0;
                const a = s(263);
                i.allocWasmString = (_, $) => {
                    const _e = (0,
                    a.getInstance)()
                      , tt = _e.lengthBytesUTF8(_) + 1
                      , nt = _e._malloc(tt);
                    return _e.stringToUTF8(_, nt, tt),
                    $.push(nt),
                    nt
                }
            }
            ,
            7917: (o, i) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.logLevelStringToEnum = i.tensorTypeToTypedArrayConstructor = i.getTensorElementSize = i.tensorDataTypeEnumToString = i.tensorDataTypeStringToEnum = void 0,
                i.tensorDataTypeStringToEnum = s => {
                    switch (s) {
                    case "int8":
                        return 3;
                    case "uint8":
                        return 2;
                    case "bool":
                        return 9;
                    case "int16":
                        return 5;
                    case "uint16":
                        return 4;
                    case "int32":
                        return 6;
                    case "uint32":
                        return 12;
                    case "float32":
                        return 1;
                    case "float64":
                        return 11;
                    case "string":
                        return 8;
                    case "int64":
                        return 7;
                    case "uint64":
                        return 13;
                    default:
                        throw new Error(`unsupported data type: ${s}`)
                    }
                }
                ,
                i.tensorDataTypeEnumToString = s => {
                    switch (s) {
                    case 3:
                        return "int8";
                    case 2:
                        return "uint8";
                    case 9:
                        return "bool";
                    case 5:
                        return "int16";
                    case 4:
                        return "uint16";
                    case 6:
                        return "int32";
                    case 12:
                        return "uint32";
                    case 1:
                        return "float32";
                    case 11:
                        return "float64";
                    case 8:
                        return "string";
                    case 7:
                        return "int64";
                    case 13:
                        return "uint64";
                    default:
                        throw new Error(`unsupported data type: ${s}`)
                    }
                }
                ,
                i.getTensorElementSize = s => [void 0, 4, 1, 1, 2, 2, 4, 8, void 0, 1, 2, 8, 4, 8, void 0, void 0, void 0][s],
                i.tensorTypeToTypedArrayConstructor = s => {
                    switch (s) {
                    case "float32":
                        return Float32Array;
                    case "uint8":
                    case "bool":
                        return Uint8Array;
                    case "int8":
                        return Int8Array;
                    case "uint16":
                        return Uint16Array;
                    case "int16":
                        return Int16Array;
                    case "int32":
                        return Int32Array;
                    case "float64":
                        return Float64Array;
                    case "uint32":
                        return Uint32Array;
                    case "int64":
                        return BigInt64Array;
                    case "uint64":
                        return BigUint64Array;
                    default:
                        throw new Error(`unsupported type: ${s}`)
                    }
                }
                ,
                i.logLevelStringToEnum = s => {
                    switch (s) {
                    case "verbose":
                        return 0;
                    case "info":
                        return 1;
                    case "warning":
                        return 2;
                    case "error":
                        return 3;
                    case "fatal":
                        return 4;
                    default:
                        throw new Error(`unsupported logging level: ${s}`)
                    }
                }
            }
            ,
            1259: (o, i, s) => {
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.extractTransferableBuffers = i.endProfiling = i.run = i.releaseSession = i.createSession = i.createSessionFinalize = i.createSessionAllocate = i.initOrt = void 0;
                const a = s(7918)
                  , _ = s(7622)
                  , $ = s(9444)
                  , _e = s(7917)
                  , tt = s(263);
                i.initOrt = (rt, ot) => {
                    const et = (0,
                    tt.getInstance)()._OrtInit(rt, ot);
                    if (et !== 0)
                        throw new Error(`Can't initialize onnxruntime. error code = ${et}`)
                }
                ;
                const nt = new Map;
                i.createSessionAllocate = rt => {
                    const ot = (0,
                    tt.getInstance)()
                      , et = ot._malloc(rt.byteLength);
                    return ot.HEAPU8.set(rt, et),
                    [et, rt.byteLength]
                }
                ,
                i.createSessionFinalize = (rt, ot) => {
                    const et = (0,
                    tt.getInstance)();
                    let j = 0
                      , it = 0
                      , st = [];
                    try {
                        if ([it,st] = (0,
                        _.setSessionOptions)(ot),
                        j = et._OrtCreateSession(rt[0], rt[1], it),
                        j === 0)
                            throw new Error("Can't create a session")
                    } finally {
                        et._free(rt[0]),
                        it !== 0 && et._OrtReleaseSessionOptions(it),
                        st.forEach(et._free)
                    }
                    const at = et._OrtGetInputCount(j)
                      , lt = et._OrtGetOutputCount(j)
                      , ct = []
                      , ut = []
                      , dt = []
                      , ft = [];
                    for (let ht = 0; ht < at; ht++) {
                        const pt = et._OrtGetInputName(j, ht);
                        if (pt === 0)
                            throw new Error("Can't get an input name");
                        ut.push(pt),
                        ct.push(et.UTF8ToString(pt))
                    }
                    for (let ht = 0; ht < lt; ht++) {
                        const pt = et._OrtGetOutputName(j, ht);
                        if (pt === 0)
                            throw new Error("Can't get an output name");
                        ft.push(pt),
                        dt.push(et.UTF8ToString(pt))
                    }
                    return nt.set(j, [j, ut, ft]),
                    [j, ct, dt]
                }
                ,
                i.createSession = (rt, ot) => {
                    const et = (0,
                    i.createSessionAllocate)(rt);
                    return (0,
                    i.createSessionFinalize)(et, ot)
                }
                ,
                i.releaseSession = rt => {
                    const ot = (0,
                    tt.getInstance)()
                      , et = nt.get(rt);
                    if (!et)
                        throw new Error("invalid session id");
                    const j = et[0]
                      , it = et[1]
                      , st = et[2];
                    it.forEach(ot._OrtFree),
                    st.forEach(ot._OrtFree),
                    ot._OrtReleaseSession(j),
                    nt.delete(rt)
                }
                ,
                i.run = async (rt, ot, et, j, it) => {
                    const st = (0,
                    tt.getInstance)()
                      , at = nt.get(rt);
                    if (!at)
                        throw new Error("invalid session id");
                    const lt = at[0]
                      , ct = at[1]
                      , ut = at[2]
                      , dt = ot.length
                      , ft = j.length;
                    let ht = 0
                      , pt = [];
                    const gt = []
                      , _t = [];
                    try {
                        [ht,pt] = (0,
                        a.setRunOptions)(it);
                        for (let Tt = 0; Tt < dt; Tt++) {
                            const $t = et[Tt][0]
                              , Et = et[Tt][1]
                              , Pt = et[Tt][2];
                            let Rt, At;
                            if (Array.isArray(Pt)) {
                                At = 4 * Pt.length,
                                Rt = st._malloc(At),
                                _t.push(Rt);
                                let Lt = Rt / 4;
                                for (let tn = 0; tn < Pt.length; tn++) {
                                    if (typeof Pt[tn] != "string")
                                        throw new TypeError(`tensor data at index ${tn} is not a string`);
                                    st.HEAPU32[Lt++] = (0,
                                    $.allocWasmString)(Pt[tn], _t)
                                }
                            } else
                                At = Pt.byteLength,
                                Rt = st._malloc(At),
                                _t.push(Rt),
                                st.HEAPU8.set(new Uint8Array(Pt.buffer,Pt.byteOffset,At), Rt);
                            const Mt = st.stackSave()
                              , Ut = st.stackAlloc(4 * Et.length);
                            try {
                                let Lt = Ut / 4;
                                Et.forEach(Vt => st.HEAP32[Lt++] = Vt);
                                const tn = st._OrtCreateTensor((0,
                                _e.tensorDataTypeStringToEnum)($t), Rt, At, Ut, Et.length);
                                if (tn === 0)
                                    throw new Error("Can't create a tensor");
                                gt.push(tn)
                            } finally {
                                st.stackRestore(Mt)
                            }
                        }
                        const mt = st.stackSave()
                          , yt = st.stackAlloc(4 * dt)
                          , bt = st.stackAlloc(4 * dt)
                          , vt = st.stackAlloc(4 * ft)
                          , wt = st.stackAlloc(4 * ft);
                        try {
                            let Tt = yt / 4
                              , $t = bt / 4
                              , Et = vt / 4
                              , Pt = wt / 4;
                            for (let Ut = 0; Ut < dt; Ut++)
                                st.HEAPU32[Tt++] = gt[Ut],
                                st.HEAPU32[$t++] = ct[ot[Ut]];
                            for (let Ut = 0; Ut < ft; Ut++)
                                st.HEAPU32[Et++] = 0,
                                st.HEAPU32[Pt++] = ut[j[Ut]];
                            let Rt = st._OrtRun(lt, bt, yt, dt, wt, ft, vt, ht);
                            const At = st.jsepRunPromise;
                            At && At.then !== void 0 && (Rt = await At);
                            const Mt = [];
                            if (Rt === 0)
                                for (let Ut = 0; Ut < ft; Ut++) {
                                    const Lt = st.HEAPU32[vt / 4 + Ut]
                                      , tn = st.stackSave()
                                      , Vt = st.stackAlloc(16);
                                    let Nt, Yt = 0;
                                    try {
                                        if (Rt = st._OrtGetTensorData(Lt, Vt, Vt + 4, Vt + 8, Vt + 12),
                                        Rt !== 0)
                                            throw new Error(`Can't access output tensor data. error code = ${Rt}`);
                                        let Xt = Vt / 4;
                                        const jt = st.HEAPU32[Xt++];
                                        Yt = st.HEAPU32[Xt++];
                                        const Gt = st.HEAPU32[Xt++]
                                          , Kt = st.HEAPU32[Xt++]
                                          , qt = [];
                                        for (let on = 0; on < Kt; on++)
                                            qt.push(st.HEAPU32[Gt / 4 + on]);
                                        st._OrtFree(Gt);
                                        const rn = qt.length === 0 ? 1 : qt.reduce( (on, _n) => on * _n);
                                        if (Nt = (0,
                                        _e.tensorDataTypeEnumToString)(jt),
                                        Nt === "string") {
                                            const on = [];
                                            let _n = Yt / 4;
                                            for (let mn = 0; mn < rn; mn++) {
                                                const Sn = st.HEAPU32[_n++]
                                                  , bn = mn === rn - 1 ? void 0 : st.HEAPU32[_n] - Sn;
                                                on.push(st.UTF8ToString(Sn, bn))
                                            }
                                            Mt.push([Nt, qt, on])
                                        } else {
                                            const on = new ((0,
                                            _e.tensorTypeToTypedArrayConstructor)(Nt))(rn);
                                            new Uint8Array(on.buffer,on.byteOffset,on.byteLength).set(st.HEAPU8.subarray(Yt, Yt + on.byteLength)),
                                            Mt.push([Nt, qt, on])
                                        }
                                    } finally {
                                        st.stackRestore(tn),
                                        Nt === "string" && Yt && st._free(Yt),
                                        st._OrtReleaseTensor(Lt)
                                    }
                                }
                            if (Rt === 0)
                                return Mt;
                            throw new Error(`failed to call OrtRun(). error code = ${Rt}.`)
                        } finally {
                            st.stackRestore(mt)
                        }
                    } finally {
                        gt.forEach(st._OrtReleaseTensor),
                        _t.forEach(st._free),
                        st._OrtReleaseRunOptions(ht),
                        pt.forEach(st._free)
                    }
                }
                ,
                i.endProfiling = rt => {
                    const ot = (0,
                    tt.getInstance)()
                      , et = nt.get(rt);
                    if (!et)
                        throw new Error("invalid session id");
                    const j = et[0]
                      , it = ot._OrtEndProfiling(j);
                    if (it === 0)
                        throw new Error("Can't get an profile file name");
                    ot._OrtFree(it)
                }
                ,
                i.extractTransferableBuffers = rt => {
                    const ot = [];
                    for (const et of rt) {
                        const j = et[2];
                        !Array.isArray(j) && j.buffer && ot.push(j.buffer)
                    }
                    return ot
                }
            }
            ,
            263: function(o, i, s) {
                var a = this && this.__createBinding || (Object.create ? function(it, st, at, lt) {
                    lt === void 0 && (lt = at);
                    var ct = Object.getOwnPropertyDescriptor(st, at);
                    ct && !("get"in ct ? !st.__esModule : ct.writable || ct.configurable) || (ct = {
                        enumerable: !0,
                        get: function() {
                            return st[at]
                        }
                    }),
                    Object.defineProperty(it, lt, ct)
                }
                : function(it, st, at, lt) {
                    lt === void 0 && (lt = at),
                    it[lt] = st[at]
                }
                )
                  , _ = this && this.__setModuleDefault || (Object.create ? function(it, st) {
                    Object.defineProperty(it, "default", {
                        enumerable: !0,
                        value: st
                    })
                }
                : function(it, st) {
                    it.default = st
                }
                )
                  , $ = this && this.__importStar || function(it) {
                    if (it && it.__esModule)
                        return it;
                    var st = {};
                    if (it != null)
                        for (var at in it)
                            at !== "default" && Object.prototype.hasOwnProperty.call(it, at) && a(st, it, at);
                    return _(st, it),
                    st
                }
                ;
                Object.defineProperty(i, "__esModule", {
                    value: !0
                }),
                i.dispose = i.getInstance = i.initializeWebAssembly = void 0;
                const _e = $(s(6449))
                  , tt = s(932)
                  , nt = s(3474);
                let rt, ot = !1, et = !1, j = !1;
                i.initializeWebAssembly = async it => {
                    if (ot)
                        return Promise.resolve();
                    if (et)
                        throw new Error("multiple calls to 'initializeWebAssembly()' detected.");
                    if (j)
                        throw new Error("previous call to 'initializeWebAssembly()' failed.");
                    et = !0;
                    const st = it.initTimeout
                      , at = it.numThreads
                      , lt = it.simd
                      , ct = at > 1 && ( () => {
                        try {
                            return typeof SharedArrayBuffer < "u" && (typeof MessageChannel < "u" && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)),
                            WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11])))
                        } catch {
                            return !1
                        }
                    }
                    )()
                      , ut = lt && ( () => {
                        try {
                            return WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 30, 1, 28, 0, 65, 0, 253, 15, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 186, 1, 26, 11]))
                        } catch {
                            return !1
                        }
                    }
                    )()
                      , dt = it.wasmPaths
                      , ft = typeof dt == "string" ? dt : void 0
                      , ht = ( (mt, yt) => yt ? mt ? "ort-wasm-simd-threaded.wasm" : "ort-wasm-threaded.wasm" : mt ? "ort-wasm-simd.wasm" : "ort-wasm.wasm")(ut, ct)
                      , pt = typeof dt == "object" ? dt[ht] : void 0;
                    let gt = !1;
                    const _t = [];
                    if (st > 0 && _t.push(new Promise(mt => {
                        setTimeout( () => {
                            gt = !0,
                            mt()
                        }
                        , st)
                    }
                    )),
                    _t.push(new Promise( (mt, yt) => {
                        const bt = ct ? nt : tt
                          , vt = {
                            locateFile: (wt, Tt) => ct && wt.endsWith(".worker.js") && typeof Blob < "u" ? URL.createObjectURL(new Blob([s(4154)],{
                                type: "text/javascript"
                            })) : wt.endsWith(".wasm") ? pt || (ft ?? Tt) + ht : Tt + wt
                        };
                        if (ct)
                            if (typeof Blob > "u")
                                vt.mainScriptUrlOrBlob = _e.join("/", "ort-wasm-threaded.js");
                            else {
                                const wt = `var ortWasmThreaded=(function(){var _scriptDir;return ${bt.toString()}})();`;
                                vt.mainScriptUrlOrBlob = new Blob([wt],{
                                    type: "text/javascript"
                                })
                            }
                        bt(vt).then(wt => {
                            et = !1,
                            ot = !0,
                            rt = wt,
                            mt()
                        }
                        , wt => {
                            et = !1,
                            j = !0,
                            yt(wt)
                        }
                        )
                    }
                    )),
                    await Promise.race(_t),
                    gt)
                        throw new Error(`WebAssembly backend initializing failed due to timeout: ${st}ms`)
                }
                ,
                i.getInstance = () => {
                    if (ot && rt)
                        return rt;
                    throw new Error("WebAssembly is not initialized yet.")
                }
                ,
                i.dispose = () => {
                    var it;
                    !ot || et || j || (et = !0,
                    (it = rt.PThread) === null || it === void 0 || it.terminateAllThreads(),
                    rt = void 0,
                    et = !1,
                    ot = !1,
                    j = !0)
                }
            },
            8050: (o, i, s) => {
                s.d(i, {
                    Z: () => $
                });
                var a = s(6614)
                  , _ = s.n(a);
                function $() {
                    return _()('/*!\n* ONNX Runtime Web v1.15.1\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var e={899:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.iterateExtraOptions=void 0,t.iterateExtraOptions=(e,n,r,a)=>{if("object"==typeof e&&null!==e){if(r.has(e))throw new Error("Circular reference in options");r.add(e)}Object.entries(e).forEach((([e,o])=>{const i=n?n+e:e;if("object"==typeof o)(0,t.iterateExtraOptions)(o,i+".",r,a);else if("string"==typeof o||"number"==typeof o)a(i,o.toString());else{if("boolean"!=typeof o)throw new Error("Can\'t handle extra config type: "+typeof o);a(i,o?"1":"0")}}))}},918:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setRunOptions=void 0;const r=n(899),a=n(444),o=n(263);t.setRunOptions=e=>{const t=(0,o.getInstance)();let n=0;const i=[],s=e||{};try{if(void 0===(null==e?void 0:e.logSeverityLevel))s.logSeverityLevel=2;else if("number"!=typeof e.logSeverityLevel||!Number.isInteger(e.logSeverityLevel)||e.logSeverityLevel<0||e.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);if(void 0===(null==e?void 0:e.logVerbosityLevel))s.logVerbosityLevel=0;else if("number"!=typeof e.logVerbosityLevel||!Number.isInteger(e.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);void 0===(null==e?void 0:e.terminate)&&(s.terminate=!1);let o=0;if(void 0!==(null==e?void 0:e.tag)&&(o=(0,a.allocWasmString)(e.tag,i)),n=t._OrtCreateRunOptions(s.logSeverityLevel,s.logVerbosityLevel,!!s.terminate,o),0===n)throw new Error("Can\'t create run options");return void 0!==(null==e?void 0:e.extra)&&(0,r.iterateExtraOptions)(e.extra,"",new WeakSet,((e,r)=>{const o=(0,a.allocWasmString)(e,i),s=(0,a.allocWasmString)(r,i);if(0!==t._OrtAddRunConfigEntry(n,o,s))throw new Error(`Can\'t set a run config entry: ${e} - ${r}`)})),[n,i]}catch(e){throw 0!==n&&t._OrtReleaseRunOptions(n),i.forEach(t._free),e}}},622:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.setSessionOptions=void 0;const r=n(899),a=n(444),o=n(263);t.setSessionOptions=e=>{var t,n,i,s;const u=(0,o.getInstance)();let c=0;const l=[],f=e||{};(e=>{e.extra||(e.extra={}),e.extra.session||(e.extra.session={});const t=e.extra.session;t.use_ort_model_bytes_directly||(t.use_ort_model_bytes_directly="1"),e.executionProviders&&e.executionProviders.some((e=>"webgpu"===("string"==typeof e?e:e.name)))&&(e.enableMemPattern=!1)})(f);try{const e=(e=>{switch(e){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${e}`)}})(null!==(t=f.graphOptimizationLevel)&&void 0!==t?t:"all"),p=(e=>{switch(e){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${e}`)}})(null!==(n=f.executionMode)&&void 0!==n?n:"sequential"),d="string"==typeof f.logId?(0,a.allocWasmString)(f.logId,l):0,m=null!==(i=f.logSeverityLevel)&&void 0!==i?i:2;if(!Number.isInteger(m)||m<0||m>4)throw new Error(`log serverity level is not valid: ${m}`);const g=null!==(s=f.logVerbosityLevel)&&void 0!==s?s:0;if(!Number.isInteger(g)||g<0||g>4)throw new Error(`log verbosity level is not valid: ${g}`);const h="string"==typeof f.optimizedModelFilePath?(0,a.allocWasmString)(f.optimizedModelFilePath,l):0;if(c=u._OrtCreateSessionOptions(e,!!f.enableCpuMemArena,!!f.enableMemPattern,p,!!f.enableProfiling,0,d,m,g,h),0===c)throw new Error("Can\'t create session options");return f.executionProviders&&((e,t,n)=>{for(const r of t){let t="string"==typeof r?r:r.name;switch(t){case"xnnpack":t="XNNPACK";break;case"webgpu":t="JS";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${t}`)}const i=(0,a.allocWasmString)(t,n);if(0!==(0,o.getInstance)()._OrtAppendExecutionProvider(e,i))throw new Error(`Can\'t append execution provider: ${t}`)}})(c,f.executionProviders,l),void 0!==f.extra&&(0,r.iterateExtraOptions)(f.extra,"",new WeakSet,((e,t)=>{const n=(0,a.allocWasmString)(e,l),r=(0,a.allocWasmString)(t,l);if(0!==u._OrtAddSessionConfigEntry(c,n,r))throw new Error(`Can\'t set a session config entry: ${e} - ${t}`)})),[c,l]}catch(e){throw 0!==c&&u._OrtReleaseSessionOptions(c),l.forEach(u._free),e}}},444:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.allocWasmString=void 0;const r=n(263);t.allocWasmString=(e,t)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(e)+1,o=n._malloc(a);return n.stringToUTF8(e,o,a),t.push(o),o}},917:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.logLevelStringToEnum=t.tensorTypeToTypedArrayConstructor=t.getTensorElementSize=t.tensorDataTypeEnumToString=t.tensorDataTypeStringToEnum=void 0,t.tensorDataTypeStringToEnum=e=>{switch(e){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${e}`)}},t.tensorDataTypeEnumToString=e=>{switch(e){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${e}`)}},t.getTensorElementSize=e=>[void 0,4,1,1,2,2,4,8,void 0,1,2,8,4,8,void 0,void 0,void 0][e],t.tensorTypeToTypedArrayConstructor=e=>{switch(e){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${e}`)}},t.logLevelStringToEnum=e=>{switch(e){case"verbose":return 0;case"info":return 1;case"warning":return 2;case"error":return 3;case"fatal":return 4;default:throw new Error(`unsupported logging level: ${e}`)}}},259:(e,t,n)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.extractTransferableBuffers=t.endProfiling=t.run=t.releaseSession=t.createSession=t.createSessionFinalize=t.createSessionAllocate=t.initOrt=void 0;const r=n(918),a=n(622),o=n(444),i=n(917),s=n(263);t.initOrt=(e,t)=>{const n=(0,s.getInstance)()._OrtInit(e,t);if(0!==n)throw new Error(`Can\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;t.createSessionAllocate=e=>{const t=(0,s.getInstance)(),n=t._malloc(e.byteLength);return t.HEAPU8.set(e,n),[n,e.byteLength]},t.createSessionFinalize=(e,t)=>{const n=(0,s.getInstance)();let r=0,o=0,i=[];try{if([o,i]=(0,a.setSessionOptions)(t),r=n._OrtCreateSession(e[0],e[1],o),0===r)throw new Error("Can\'t create a session")}finally{n._free(e[0]),0!==o&&n._OrtReleaseSessionOptions(o),i.forEach(n._free)}const c=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],d=[],m=[];for(let e=0;e<c;e++){const t=n._OrtGetInputName(r,e);if(0===t)throw new Error("Can\'t get an input name");p.push(t),f.push(n.UTF8ToString(t))}for(let e=0;e<l;e++){const t=n._OrtGetOutputName(r,e);if(0===t)throw new Error("Can\'t get an output name");m.push(t),d.push(n.UTF8ToString(t))}return u.set(r,[r,p,m]),[r,f,d]},t.createSession=(e,n)=>{const r=(0,t.createSessionAllocate)(e);return(0,t.createSessionFinalize)(r,n)},t.releaseSession=e=>{const t=(0,s.getInstance)(),n=u.get(e);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],o=n[2];a.forEach(t._OrtFree),o.forEach(t._OrtFree),t._OrtReleaseSession(r),u.delete(e)},t.run=async(e,t,n,a,c)=>{const l=(0,s.getInstance)(),f=u.get(e);if(!f)throw new Error("invalid session id");const p=f[0],d=f[1],m=f[2],g=t.length,h=a.length;let y=0,v=[];const b=[],w=[];try{[y,v]=(0,r.setRunOptions)(c);for(let e=0;e<g;e++){const t=n[e][0],r=n[e][1],a=n[e][2];let s,u;if(Array.isArray(a)){u=4*a.length,s=l._malloc(u),w.push(s);let e=s/4;for(let t=0;t<a.length;t++){if("string"!=typeof a[t])throw new TypeError(`tensor data at index ${t} is not a string`);l.HEAPU32[e++]=(0,o.allocWasmString)(a[t],w)}}else u=a.byteLength,s=l._malloc(u),w.push(s),l.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),s);const c=l.stackSave(),f=l.stackAlloc(4*r.length);try{let e=f/4;r.forEach((t=>l.HEAP32[e++]=t));const n=l._OrtCreateTensor((0,i.tensorDataTypeStringToEnum)(t),s,u,f,r.length);if(0===n)throw new Error("Can\'t create a tensor");b.push(n)}finally{l.stackRestore(c)}}const e=l.stackSave(),s=l.stackAlloc(4*g),u=l.stackAlloc(4*g),f=l.stackAlloc(4*h),_=l.stackAlloc(4*h);try{let e=s/4,n=u/4,r=f/4,o=_/4;for(let r=0;r<g;r++)l.HEAPU32[e++]=b[r],l.HEAPU32[n++]=d[t[r]];for(let e=0;e<h;e++)l.HEAPU32[r++]=0,l.HEAPU32[o++]=m[a[e]];let c=l._OrtRun(p,u,s,g,_,h,f,y);const v=l.jsepRunPromise;v&&void 0!==v.then&&(c=await v);const w=[];if(0===c)for(let e=0;e<h;e++){const t=l.HEAPU32[f/4+e],n=l.stackSave(),r=l.stackAlloc(16);let a,o=0;try{if(c=l._OrtGetTensorData(t,r,r+4,r+8,r+12),0!==c)throw new Error(`Can\'t access output tensor data. error code = ${c}`);let e=r/4;const n=l.HEAPU32[e++];o=l.HEAPU32[e++];const s=l.HEAPU32[e++],u=l.HEAPU32[e++],f=[];for(let e=0;e<u;e++)f.push(l.HEAPU32[s/4+e]);l._OrtFree(s);const p=0===f.length?1:f.reduce(((e,t)=>e*t));if(a=(0,i.tensorDataTypeEnumToString)(n),"string"===a){const e=[];let t=o/4;for(let n=0;n<p;n++){const r=l.HEAPU32[t++],a=n===p-1?void 0:l.HEAPU32[t]-r;e.push(l.UTF8ToString(r,a))}w.push([a,f,e])}else{const e=new((0,i.tensorTypeToTypedArrayConstructor)(a))(p);new Uint8Array(e.buffer,e.byteOffset,e.byteLength).set(l.HEAPU8.subarray(o,o+e.byteLength)),w.push([a,f,e])}}finally{l.stackRestore(n),"string"===a&&o&&l._free(o),l._OrtReleaseTensor(t)}}if(0===c)return w;throw new Error(`failed to call OrtRun(). error code = ${c}.`)}finally{l.stackRestore(e)}}finally{b.forEach(l._OrtReleaseTensor),w.forEach(l._free),l._OrtReleaseRunOptions(y),v.forEach(l._free)}},t.endProfiling=e=>{const t=(0,s.getInstance)(),n=u.get(e);if(!n)throw new Error("invalid session id");const r=n[0],a=t._OrtEndProfiling(r);if(0===a)throw new Error("Can\'t get an profile file name");t._OrtFree(a)},t.extractTransferableBuffers=e=>{const t=[];for(const n of e){const e=n[2];!Array.isArray(e)&&e.buffer&&t.push(e.buffer)}return t}},263:function(e,t,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(e,t,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(t,n);a&&!("get"in a?!t.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return t[n]}}),Object.defineProperty(e,r,a)}:function(e,t,n,r){void 0===r&&(r=n),e[r]=t[n]}),a=this&&this.__setModuleDefault||(Object.create?function(e,t){Object.defineProperty(e,"default",{enumerable:!0,value:t})}:function(e,t){e.default=t}),o=this&&this.__importStar||function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)"default"!==n&&Object.prototype.hasOwnProperty.call(e,n)&&r(t,e,n);return a(t,e),t};Object.defineProperty(t,"__esModule",{value:!0}),t.dispose=t.getInstance=t.initializeWebAssembly=void 0;const i=o(n(449)),s=n(932),u=n(474);let c,l=!1,f=!1,p=!1;t.initializeWebAssembly=async e=>{if(l)return Promise.resolve();if(f)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(p)throw new Error("previous call to \'initializeWebAssembly()\' failed.");f=!0;const t=e.initTimeout,r=e.numThreads,a=e.simd,o=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(e){return!1}})(),d=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(e){return!1}})(),m=e.wasmPaths,g="string"==typeof m?m:void 0,h=((e,t)=>t?e?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":e?"ort-wasm-simd.wasm":"ort-wasm.wasm")(d,o),y="object"==typeof m?m[h]:void 0;let v=!1;const b=[];if(t>0&&b.push(new Promise((e=>{setTimeout((()=>{v=!0,e()}),t)}))),b.push(new Promise(((e,t)=>{const r=o?u:s,a={locateFile:(e,t)=>o&&e.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:"text/javascript"})):e.endsWith(".wasm")?y||(null!=g?g:t)+h:t+e};if(o)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=i.join("/","ort-wasm-threaded.js");else{const e=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([e],{type:"text/javascript"})}r(a).then((t=>{f=!1,l=!0,c=t,e()}),(e=>{f=!1,p=!0,t(e)}))}))),await Promise.race(b),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`)},t.getInstance=()=>{if(l&&c)return c;throw new Error("WebAssembly is not initialized yet.")},t.dispose=()=>{var e;!l||f||p||(f=!0,null===(e=c.PThread)||void 0===e||e.terminateAllThreads(),c=void 0,f=!1,l=!1,p=!0)}},474:(e,t,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){function t(){return P.buffer!=D&&G(P.buffer),F}function r(){return P.buffer!=D&&G(P.buffer),U}function a(){return P.buffer!=D&&G(P.buffer),I}function o(){return P.buffer!=D&&G(P.buffer),W}function i(){return P.buffer!=D&&G(P.buffer),j}var s,u,c;e=e||{},s||(s=void 0!==e?e:{}),s.ready=new Promise((function(e,t){u=e,c=t}));var l,f,p,d,m,g,h=Object.assign({},s),y="./this.program",v=(e,t)=>{throw t},b="object"==typeof window,w="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=s.ENVIRONMENT_IS_PTHREAD||!1,S="";function T(e){return s.locateFile?s.locateFile(e,S):S+e}if(_){let t;S=w?n(908).dirname(S)+"/":"//",g=()=>{m||(d=n(384),m=n(908))},l=function(e,t){return g(),e=m.normalize(e),d.readFileSync(e,t?void 0:"utf8")},p=e=>((e=l(e,!0)).buffer||(e=new Uint8Array(e)),e),f=(e,t,n)=>{g(),e=m.normalize(e),d.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},1<process.argv.length&&(y=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof ie))throw e})),process.on("unhandledRejection",(function(e){throw e})),v=(e,t)=>{if(C)throw process.exitCode=e,t;t instanceof ie||x("exiting due to exception: "+t),process.exit(e)},s.inspect=function(){return"[Emscripten Module object]"};try{t=n(925)}catch(e){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),e}n.g.Worker=t.Worker}else(b||w)&&(w?S=self.location.href:"undefined"!=typeof document&&document.currentScript&&(S=document.currentScript.src),_scriptDir&&(S=_scriptDir),S=0!==S.indexOf("blob:")?S.substr(0,S.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(l=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},w&&(p=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),f=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(953).performance);var A=console.log.bind(console),E=console.warn.bind(console);_&&(g(),A=e=>d.writeSync(1,e+"\\n"),E=e=>d.writeSync(2,e+"\\n"));var M,R=s.print||A,x=s.printErr||E;Object.assign(s,h),h=null,s.thisProgram&&(y=s.thisProgram),s.quit&&(v=s.quit),s.wasmBinary&&(M=s.wasmBinary);var C=s.noExitRuntime||!0;"object"!=typeof WebAssembly&&ne("no native wasm support detected");var P,k,D,F,U,I,W,j,H=!1,L="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function Y(e,t,n){var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&L)return L.decode(e.buffer instanceof SharedArrayBuffer?e.slice(t,n):e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function z(e,t){return(e>>>=0)?Y(r(),e,t):""}function B(e,t,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(n>=r)break;t[n++>>>0]=i}else{if(2047>=i){if(n+1>=r)break;t[n++>>>0]=192|i>>6}else{if(65535>=i){if(n+2>=r)break;t[n++>>>0]=224|i>>12}else{if(n+3>=r)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63}t[n++>>>0]=128|i>>6&63}t[n++>>>0]=128|63&i}}return t[n>>>0]=0,n-a}function N(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t}function G(e){D=e,s.HEAP8=F=new Int8Array(e),s.HEAP16=new Int16Array(e),s.HEAP32=I=new Int32Array(e),s.HEAPU8=U=new Uint8Array(e),s.HEAPU16=new Uint16Array(e),s.HEAPU32=W=new Uint32Array(e),s.HEAPF32=new Float32Array(e),s.HEAPF64=j=new Float64Array(e)}O&&(D=s.buffer);var q=s.INITIAL_MEMORY||16777216;if(O)P=s.wasmMemory,D=s.buffer;else if(s.wasmMemory)P=s.wasmMemory;else if(!((P=new WebAssembly.Memory({initial:q/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");P&&(D=P.buffer),q=D.byteLength,G(D);var $,V=[],J=[],Q=[];function X(){var e=s.preRun.shift();V.unshift(e)}var K,Z=0,ee=null,te=null;function ne(e){throw O?postMessage({cmd:"onAbort",arg:e}):s.onAbort&&s.onAbort(e),x(e="Aborted("+e+")"),H=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),c(e),e}function re(){return K.startsWith("data:application/octet-stream;base64,")}function ae(){var e=K;try{if(e==K&&M)return new Uint8Array(M);if(p)return p(e);throw"both async and sync fetching of the wasm failed"}catch(e){ne(e)}}K="ort-wasm-threaded.wasm",re()||(K=T(K));var oe={};function ie(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function se(e){(e=fe.La[e])||ne(),fe.Xa(e)}function ue(e){var t=fe.lb();if(!t)return 6;fe.Ra.push(t),fe.La[e.Ka]=t,t.Ka=e.Ka;var n={cmd:"run",start_routine:e.pb,arg:e.ib,pthread_ptr:e.Ka};return t.Qa=()=>{n.time=performance.now(),t.postMessage(n,e.vb)},t.loaded&&(t.Qa(),delete t.Qa),0}function ce(e){if(O)return He(1,1,e);C||(fe.qb(),s.onExit&&s.onExit(e),H=!0),v(e,new ie(e))}function le(e,t){if(!t&&O)throw de(e),"unwind";ce(e)}var fe={Oa:[],Ra:[],$a:[],La:{},Ua:function(){O&&fe.mb()},xb:function(){},mb:function(){fe.receiveObjectTransfer=fe.ob,fe.threadInitTLS=fe.Za,fe.setExitStatus=fe.Ya,C=!1},Ya:function(){},qb:function(){for(var e of Object.values(fe.La))fe.Xa(e);for(e of fe.Oa)e.terminate();fe.Oa=[]},Xa:function(e){var t=e.Ka;delete fe.La[t],fe.Oa.push(e),fe.Ra.splice(fe.Ra.indexOf(e),1),e.Ka=0,ct(t)},ob:function(){},Za:function(){fe.$a.forEach((e=>e()))},nb:function(e,t){e.onmessage=n=>{var r=(n=n.data).cmd;if(e.Ka&&(fe.kb=e.Ka),n.targetThread&&n.targetThread!=rt()){var a=fe.La[n.yb];a?a.postMessage(n,n.transferList):x(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?De(n.queue):"spawnThread"===r?ue(n):"cleanupThread"===r?se(n.thread):"killThread"===r?(n=n.thread,r=fe.La[n],delete fe.La[n],r.terminate(),ct(n),fe.Ra.splice(fe.Ra.indexOf(r),1),r.Ka=0):"cancelThread"===r?fe.La[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(e.loaded=!0,t&&t(e),e.Qa&&(e.Qa(),delete e.Qa)):"print"===r?R("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?e.postMessage(n):"onAbort"===r?s.onAbort&&s.onAbort(n.arg):r&&x("worker sent an unknown command "+r);fe.kb=void 0},e.onerror=e=>{throw x("worker sent an error! "+e.filename+":"+e.lineno+": "+e.message),e},_&&(e.on("message",(function(t){e.onmessage({data:t})})),e.on("error",(function(t){e.onerror(t)})),e.on("detachedExit",(function(){}))),e.postMessage({cmd:"load",urlOrBlob:s.mainScriptUrlOrBlob||_scriptDir,wasmMemory:P,wasmModule:k})},hb:function(){var e=T("ort-wasm-threaded.worker.js");fe.Oa.push(new Worker(e))},lb:function(){return 0==fe.Oa.length&&(fe.hb(),fe.nb(fe.Oa[0])),fe.Oa.pop()}};function pe(e){for(;0<e.length;)e.shift()(s)}function de(e){if(O)return He(2,0,e);try{le(e)}catch(e){e instanceof ie||"unwind"==e||v(1,e)}}s.PThread=fe,s.establishStackSpace=function(){var e=rt(),t=a()[e+44>>2>>>0];e=a()[e+48>>2>>>0],ft(t,t-e),dt(t)};var me,ge,he=[];function ye(e){this.Pa=e-24,this.gb=function(e){o()[this.Pa+4>>2>>>0]=e},this.cb=function(e){o()[this.Pa+8>>2>>>0]=e},this.eb=function(){a()[this.Pa>>2>>>0]=0},this.bb=function(){t()[this.Pa+12>>0>>>0]=0},this.fb=function(){t()[this.Pa+13>>0>>>0]=0},this.Ua=function(e,t){this.ab(),this.gb(e),this.cb(t),this.eb(),this.bb(),this.fb()},this.ab=function(){o()[this.Pa+16>>2>>>0]=0}}function ve(e,t,n,r){return O?He(3,1,e,t,n,r):be(e,t,n,r)}function be(e,t,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?ve(e,t,n,r):(e={pb:n,Ka:e,ib:r,vb:a},O?(e.wb="spawnThread",postMessage(e,a),0):ue(e))}function we(e,t,n){return O?He(4,1,e,t,n):0}function _e(e,t){if(O)return He(5,1,e,t)}function Oe(e,t){if(O)return He(6,1,e,t)}function Se(e,t,n){if(O)return He(7,1,e,t,n)}function Te(e,t,n){return O?He(8,1,e,t,n):0}function Ae(e,t){if(O)return He(9,1,e,t)}function Ee(e,t,n){if(O)return He(10,1,e,t,n)}function Me(e,t,n,r){if(O)return He(11,1,e,t,n,r)}function Re(e,t,n,r){if(O)return He(12,1,e,t,n,r)}function xe(e,t,n,r){if(O)return He(13,1,e,t,n,r)}function Ce(e){if(O)return He(14,1,e)}function Pe(e,t){if(O)return He(15,1,e,t)}function ke(e,t,n){if(O)return He(16,1,e,t,n)}function De(e){Atomics.store(a(),e>>2,1),rt()&&ut(e),Atomics.compareExchange(a(),e>>2,1,0)}function Fe(e){return o()[e>>>2]+4294967296*a()[e+4>>>2]}function Ue(e,t,n,r,a,o){return O?He(17,1,e,t,n,r,a,o):-52}function Ie(e,t,n,r,a,o){if(O)return He(18,1,e,t,n,r,a,o)}function We(e){var n=N(e)+1,r=at(n);return r&&B(e,t(),r,n),r}function je(e,t,n){function r(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}if(O)return He(19,1,e,t,n);var i=(new Date).getFullYear(),s=new Date(i,0,1),u=new Date(i,6,1);i=s.getTimezoneOffset();var c=u.getTimezoneOffset(),l=Math.max(i,c);a()[e>>2>>>0]=60*l,a()[t>>2>>>0]=Number(i!=c),e=r(s),t=r(u),e=We(e),t=We(t),c<i?(o()[n>>2>>>0]=e,o()[n+4>>2>>>0]=t):(o()[n>>2>>>0]=t,o()[n+4>>2>>>0]=e)}function He(e,t){var n=arguments.length-2,r=arguments;return function(e){var t=pt();return e=e(),dt(t),e}((()=>{for(var a=mt(8*n),o=a>>3,s=0;s<n;s++){var u=r[2+s];i()[o+s>>>0]=u}return st(e,n,a,t)}))}s.invokeEntryPoint=function(e,t){var n=he[e];n||(e>=he.length&&(he.length=e+1),he[e]=n=$.get(e)),e=n(t),C?fe.Ya(e):lt(e)},s.executeNotifiedProxyingQueue=De,ge=_?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:O?()=>performance.now()-s.__performance_now_clock_drift:()=>performance.now();var Le,Ye=[],ze={};function Be(){if(!Le){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:y||"./this.program"};for(e in ze)void 0===ze[e]?delete t[e]:t[e]=ze[e];var n=[];for(e in t)n.push(e+"="+t[e]);Le=n}return Le}function Ne(e,n){if(O)return He(20,1,e,n);var r=0;return Be().forEach((function(a,i){var s=n+r;for(i=o()[e+4*i>>2>>>0]=s,s=0;s<a.length;++s)t()[i++>>0>>>0]=a.charCodeAt(s);t()[i>>0>>>0]=0,r+=a.length+1})),0}function Ge(e,t){if(O)return He(21,1,e,t);var n=Be();o()[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),o()[t>>2>>>0]=r,0}function qe(e){return O?He(22,1,e):52}function $e(e,t,n,r){return O?He(23,1,e,t,n,r):52}function Ve(e,t,n,r,a){return O?He(24,1,e,t,n,r,a):70}var Je=[null,[],[]];function Qe(e,t,n,a){if(O)return He(25,1,e,t,n,a);for(var i=0,s=0;s<n;s++){var u=o()[t>>2>>>0],c=o()[t+4>>2>>>0];t+=8;for(var l=0;l<c;l++){var f=r()[u+l>>>0],p=Je[e];0===f||10===f?((1===e?R:x)(Y(p,0)),p.length=0):p.push(f)}i+=c}return o()[a>>2>>>0]=i,0}function Xe(e){return 0==e%4&&(0!=e%100||0==e%400)}var Ke=[31,29,31,30,31,30,31,31,30,31,30,31],Ze=[31,28,31,30,31,30,31,31,30,31,30,31];function et(e,n,r,o){function i(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function s(e,t){return i(e,t,"0")}function u(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function c(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function l(e){var t=e.Ma;for(e=new Date(new Date(e.Na+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(Xe(e.getFullYear())?Ke:Ze)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=c(new Date(e.getFullYear(),0,4)),n=c(n),0>=u(t,e)?0>=u(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var f=a()[o+40>>2>>>0];for(var p in o={tb:a()[o>>2>>>0],sb:a()[o+4>>2>>>0],Sa:a()[o+8>>2>>>0],Va:a()[o+12>>2>>>0],Ta:a()[o+16>>2>>>0],Na:a()[o+20>>2>>>0],Ja:a()[o+24>>2>>>0],Ma:a()[o+28>>2>>>0],zb:a()[o+32>>2>>>0],rb:a()[o+36>>2>>>0],ub:f?z(f):""},r=z(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var d="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),m="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(e){return d[e.Ja].substring(0,3)},"%A":function(e){return d[e.Ja]},"%b":function(e){return m[e.Ta].substring(0,3)},"%B":function(e){return m[e.Ta]},"%C":function(e){return s((e.Na+1900)/100|0,2)},"%d":function(e){return s(e.Va,2)},"%e":function(e){return i(e.Va,2," ")},"%g":function(e){return l(e).toString().substring(2)},"%G":function(e){return l(e)},"%H":function(e){return s(e.Sa,2)},"%I":function(e){return 0==(e=e.Sa)?e=12:12<e&&(e-=12),s(e,2)},"%j":function(e){for(var t=0,n=0;n<=e.Ta-1;t+=(Xe(e.Na+1900)?Ke:Ze)[n++]);return s(e.Va+t,3)},"%m":function(e){return s(e.Ta+1,2)},"%M":function(e){return s(e.sb,2)},"%n":function(){return"\\n"},"%p":function(e){return 0<=e.Sa&&12>e.Sa?"AM":"PM"},"%S":function(e){return s(e.tb,2)},"%t":function(){return"\\t"},"%u":function(e){return e.Ja||7},"%U":function(e){return s(Math.floor((e.Ma+7-e.Ja)/7),2)},"%V":function(e){var t=Math.floor((e.Ma+7-(e.Ja+6)%7)/7);if(2>=(e.Ja+371-e.Ma-2)%7&&t++,t)53==t&&(4==(n=(e.Ja+371-e.Ma)%7)||3==n&&Xe(e.Na)||(t=1));else{t=52;var n=(e.Ja+7-e.Ma-1)%7;(4==n||5==n&&Xe(e.Na%400-1))&&t++}return s(t,2)},"%w":function(e){return e.Ja},"%W":function(e){return s(Math.floor((e.Ma+7-(e.Ja+6)%7)/7),2)},"%y":function(e){return(e.Na+1900).toString().substring(2)},"%Y":function(e){return e.Na+1900},"%z":function(e){var t=0<=(e=e.rb);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.ub},"%%":function(){return"%"}},r=r.replace(/%%/g,"\\0\\0"),f)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](o)));return p=function(e){var t=Array(N(e)+1);return B(e,t,0,t.length),t}(r=r.replace(/\\0\\0/g,"%")),p.length>n?0:(function(e,n){t().set(e,n>>>0)}(p,e),p.length-1)}fe.Ua();var tt=[null,ce,de,ve,we,_e,Oe,Se,Te,Ae,Ee,Me,Re,xe,Ce,Pe,ke,Ue,Ie,je,Ne,Ge,qe,$e,Ve,Qe],nt={b:function(e){return at(e+24)+24},c:function(e,t,n){throw new ye(e).Ua(t,n),e},L:function(e){ot(e,!w,1,!b),fe.Za()},l:function(e){O?postMessage({cmd:"cleanupThread",thread:e}):se(e)},D:be,i:we,R:_e,z:Oe,B:Se,T:Te,P:Ae,I:Ee,O:Me,p:Re,A:xe,x:Ce,Q:Pe,y:ke,r:function(){},j:function(){ne("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},s:function(){ne("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},q:function(){return Date.now()},E:function(){return 2097152},V:function(){return!0},F:function(e,t,n,r){if(e==t)setTimeout((()=>De(r)));else if(O)postMessage({targetThread:e,cmd:"processProxyingQueue",queue:r});else{if(!(e=fe.La[e]))return;e.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},K:function(){return-1},W:function(e,t){e=new Date(1e3*Fe(e)),a()[t>>2>>>0]=e.getUTCSeconds(),a()[t+4>>2>>>0]=e.getUTCMinutes(),a()[t+8>>2>>>0]=e.getUTCHours(),a()[t+12>>2>>>0]=e.getUTCDate(),a()[t+16>>2>>>0]=e.getUTCMonth(),a()[t+20>>2>>>0]=e.getUTCFullYear()-1900,a()[t+24>>2>>>0]=e.getUTCDay(),e=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[t+28>>2>>>0]=e},X:function(e,t){e=new Date(1e3*Fe(e)),a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),a()[t+20>>2>>>0]=e.getFullYear()-1900,a()[t+24>>2>>>0]=e.getDay();var n=new Date(e.getFullYear(),0,1),r=(e.getTime()-n.getTime())/864e5|0;a()[t+28>>2>>>0]=r,a()[t+36>>2>>>0]=-60*e.getTimezoneOffset(),r=new Date(e.getFullYear(),6,1).getTimezoneOffset(),e=0|(r!=(n=n.getTimezoneOffset())&&e.getTimezoneOffset()==Math.min(n,r)),a()[t+32>>2>>>0]=e},Y:function(e){var t=new Date(a()[e+20>>2>>>0]+1900,a()[e+16>>2>>>0],a()[e+12>>2>>>0],a()[e+8>>2>>>0],a()[e+4>>2>>>0],a()[e>>2>>>0],0),n=a()[e+32>>2>>>0],r=t.getTimezoneOffset(),o=new Date(t.getFullYear(),0,1),i=new Date(t.getFullYear(),6,1).getTimezoneOffset(),s=o.getTimezoneOffset(),u=Math.min(s,i);return 0>n?a()[e+32>>2>>>0]=Number(i!=s&&u==r):0<n!=(u==r)&&(i=Math.max(s,i),t.setTime(t.getTime()+6e4*((0<n?u:i)-r))),a()[e+24>>2>>>0]=t.getDay(),n=(t.getTime()-o.getTime())/864e5|0,a()[e+28>>2>>>0]=n,a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),t.getTime()/1e3|0},G:Ue,H:Ie,Z:function e(t,n,r){e.jb||(e.jb=!0,je(t,n,r))},d:function(){ne("")},m:function(){if(!_&&!w){var e="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";me||(me={}),me[e]||(me[e]=1,_&&(e="warning: "+e),x(e))}},w:function(){return 4294901760},f:ge,S:function(e,t,n){r().copyWithin(e>>>0,t>>>0,t+n>>>0)},g:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},J:function(e,t,n){Ye.length=t,n>>=3;for(var r=0;r<t;r++)Ye[r]=i()[n+r>>>0];return(0>e?oe[-e-1]:tt[e]).apply(null,Ye)},v:function(e){var t=r().length;if((e>>>=0)<=t||4294901760<e)return!1;for(var n=1;4>=n;n*=2){var a=t*(1+.2/n);a=Math.min(a,e+100663296);var o=Math;a=Math.max(e,a),o=o.min.call(o,4294901760,a+(65536-a%65536)%65536);e:{try{P.grow(o-D.byteLength+65535>>>16),G(P.buffer);var i=1;break e}catch(e){}i=void 0}if(i)return!0}return!1},U:function(){throw"unwind"},M:Ne,N:Ge,k:le,h:qe,o:$e,t:Ve,n:Qe,u:function e(r,a){e.Wa||(e.Wa=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var e=new Uint8Array(1);return()=>(crypto.getRandomValues(e),e[0])}if(_)try{var t=n(760);return()=>t.randomBytes(1)[0]}catch(e){}return()=>ne("randomDevice")}());for(var o=0;o<a;o++)t()[r+o>>0>>>0]=e.Wa();return 0},a:P||s.wasmMemory,C:et,e:function(e,t,n,r){return et(e,t,n,r)}};!function(){function e(e,t){s.asm=e.exports,fe.$a.push(s.asm.wa),$=s.asm.za,J.unshift(s.asm._),k=t,O||(Z--,s.monitorRunDependencies&&s.monitorRunDependencies(Z),0==Z&&(null!==ee&&(clearInterval(ee),ee=null),te&&(e=te,te=null,e())))}function t(t){e(t.instance,t.module)}function n(e){return function(){if(!M&&(b||w)){if("function"==typeof fetch&&!K.startsWith("file://"))return fetch(K,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at \'"+K+"\'";return e.arrayBuffer()})).catch((function(){return ae()}));if(f)return new Promise((function(e,t){f(K,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return ae()}))}().then((function(e){return WebAssembly.instantiate(e,r)})).then((function(e){return e})).then(e,(function(e){x("failed to asynchronously prepare wasm: "+e),ne(e)}))}var r={a:nt};if(O||(Z++,s.monitorRunDependencies&&s.monitorRunDependencies(Z)),s.instantiateWasm)try{return s.instantiateWasm(r,e)}catch(e){return x("Module.instantiateWasm callback failed with error: "+e),!1}(M||"function"!=typeof WebAssembly.instantiateStreaming||re()||K.startsWith("file://")||_||"function"!=typeof fetch?n(t):fetch(K,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,r).then(t,(function(e){return x("wasm streaming compile failed: "+e),x("falling back to ArrayBuffer instantiation"),n(t)}))}))).catch(c)}(),s.___wasm_call_ctors=function(){return(s.___wasm_call_ctors=s.asm._).apply(null,arguments)},s._OrtInit=function(){return(s._OrtInit=s.asm.$).apply(null,arguments)},s._OrtCreateSessionOptions=function(){return(s._OrtCreateSessionOptions=s.asm.aa).apply(null,arguments)},s._OrtAppendExecutionProvider=function(){return(s._OrtAppendExecutionProvider=s.asm.ba).apply(null,arguments)},s._OrtAddSessionConfigEntry=function(){return(s._OrtAddSessionConfigEntry=s.asm.ca).apply(null,arguments)},s._OrtReleaseSessionOptions=function(){return(s._OrtReleaseSessionOptions=s.asm.da).apply(null,arguments)},s._OrtCreateSession=function(){return(s._OrtCreateSession=s.asm.ea).apply(null,arguments)},s._OrtReleaseSession=function(){return(s._OrtReleaseSession=s.asm.fa).apply(null,arguments)},s._OrtGetInputCount=function(){return(s._OrtGetInputCount=s.asm.ga).apply(null,arguments)},s._OrtGetOutputCount=function(){return(s._OrtGetOutputCount=s.asm.ha).apply(null,arguments)},s._OrtGetInputName=function(){return(s._OrtGetInputName=s.asm.ia).apply(null,arguments)},s._OrtGetOutputName=function(){return(s._OrtGetOutputName=s.asm.ja).apply(null,arguments)},s._OrtFree=function(){return(s._OrtFree=s.asm.ka).apply(null,arguments)},s._OrtCreateTensor=function(){return(s._OrtCreateTensor=s.asm.la).apply(null,arguments)},s._OrtGetTensorData=function(){return(s._OrtGetTensorData=s.asm.ma).apply(null,arguments)},s._OrtReleaseTensor=function(){return(s._OrtReleaseTensor=s.asm.na).apply(null,arguments)},s._OrtCreateRunOptions=function(){return(s._OrtCreateRunOptions=s.asm.oa).apply(null,arguments)},s._OrtAddRunConfigEntry=function(){return(s._OrtAddRunConfigEntry=s.asm.pa).apply(null,arguments)},s._OrtReleaseRunOptions=function(){return(s._OrtReleaseRunOptions=s.asm.qa).apply(null,arguments)},s._OrtRun=function(){return(s._OrtRun=s.asm.ra).apply(null,arguments)},s._OrtEndProfiling=function(){return(s._OrtEndProfiling=s.asm.sa).apply(null,arguments)};var rt=s._pthread_self=function(){return(rt=s._pthread_self=s.asm.ta).apply(null,arguments)},at=s._malloc=function(){return(at=s._malloc=s.asm.ua).apply(null,arguments)};s._free=function(){return(s._free=s.asm.va).apply(null,arguments)},s.__emscripten_tls_init=function(){return(s.__emscripten_tls_init=s.asm.wa).apply(null,arguments)};var ot=s.__emscripten_thread_init=function(){return(ot=s.__emscripten_thread_init=s.asm.xa).apply(null,arguments)};s.__emscripten_thread_crashed=function(){return(s.__emscripten_thread_crashed=s.asm.ya).apply(null,arguments)};var it,st=s._emscripten_run_in_main_runtime_thread_js=function(){return(st=s._emscripten_run_in_main_runtime_thread_js=s.asm.Aa).apply(null,arguments)},ut=s.__emscripten_proxy_execute_task_queue=function(){return(ut=s.__emscripten_proxy_execute_task_queue=s.asm.Ba).apply(null,arguments)},ct=s.__emscripten_thread_free_data=function(){return(ct=s.__emscripten_thread_free_data=s.asm.Ca).apply(null,arguments)},lt=s.__emscripten_thread_exit=function(){return(lt=s.__emscripten_thread_exit=s.asm.Da).apply(null,arguments)},ft=s._emscripten_stack_set_limits=function(){return(ft=s._emscripten_stack_set_limits=s.asm.Ea).apply(null,arguments)},pt=s.stackSave=function(){return(pt=s.stackSave=s.asm.Fa).apply(null,arguments)},dt=s.stackRestore=function(){return(dt=s.stackRestore=s.asm.Ga).apply(null,arguments)},mt=s.stackAlloc=function(){return(mt=s.stackAlloc=s.asm.Ha).apply(null,arguments)};function gt(){function e(){if(!it&&(it=!0,s.calledRun=!0,!H)&&(O||pe(J),u(s),s.onRuntimeInitialized&&s.onRuntimeInitialized(),!O)){if(s.postRun)for("function"==typeof s.postRun&&(s.postRun=[s.postRun]);s.postRun.length;){var e=s.postRun.shift();Q.unshift(e)}pe(Q)}}if(!(0<Z))if(O)u(s),O||pe(J),postMessage({cmd:"loaded"});else{if(s.preRun)for("function"==typeof s.preRun&&(s.preRun=[s.preRun]);s.preRun.length;)X();pe(V),0<Z||(s.setStatus?(s.setStatus("Running..."),setTimeout((function(){setTimeout((function(){s.setStatus("")}),1),e()}),1)):e())}}if(s.___cxa_is_pointer_type=function(){return(s.___cxa_is_pointer_type=s.asm.Ia).apply(null,arguments)},s.UTF8ToString=z,s.stringToUTF8=function(e,t,n){return B(e,r(),t,n)},s.lengthBytesUTF8=N,s.keepRuntimeAlive=function(){return C},s.wasmMemory=P,s.stackSave=pt,s.stackRestore=dt,s.stackAlloc=mt,s.ExitStatus=ie,s.PThread=fe,te=function e(){it||gt(),it||(te=e)},s.preInit)for("function"==typeof s.preInit&&(s.preInit=[s.preInit]);0<s.preInit.length;)s.preInit.pop()();return gt(),e.ready});e.exports=r},932:(e,t,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(e){var t,r,a;e=e||{},t||(t=void 0!==e?e:{}),t.ready=new Promise((function(e,t){r=e,a=t}));var o,i,s,u,c,l,f=Object.assign({},t),p="./this.program",d=(e,t)=>{throw t},m="object"==typeof window,g="function"==typeof importScripts,h="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,y="";h?(y=g?n(908).dirname(y)+"/":"//",l=()=>{c||(u=n(384),c=n(908))},o=function(e,t){return l(),e=c.normalize(e),u.readFileSync(e,t?void 0:"utf8")},s=e=>((e=o(e,!0)).buffer||(e=new Uint8Array(e)),e),i=(e,t,n)=>{l(),e=c.normalize(e),u.readFile(e,(function(e,r){e?n(e):t(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(e){if(!(e instanceof $))throw e})),process.on("unhandledRejection",(function(e){throw e})),d=(e,t)=>{if(_)throw process.exitCode=e,t;t instanceof $||w("exiting due to exception: "+t),process.exit(e)},t.inspect=function(){return"[Emscripten Module object]"}):(m||g)&&(g?y=self.location.href:"undefined"!=typeof document&&document.currentScript&&(y=document.currentScript.src),_scriptDir&&(y=_scriptDir),y=0!==y.indexOf("blob:")?y.substr(0,y.replace(/[?#].*/,"").lastIndexOf("/")+1):"",o=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.send(null),t.responseText},g&&(s=e=>{var t=new XMLHttpRequest;return t.open("GET",e,!1),t.responseType="arraybuffer",t.send(null),new Uint8Array(t.response)}),i=(e,t,n)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?t(r.response):n()},r.onerror=n,r.send(null)});var v,b=t.print||console.log.bind(console),w=t.printErr||console.warn.bind(console);Object.assign(t,f),f=null,t.thisProgram&&(p=t.thisProgram),t.quit&&(d=t.quit),t.wasmBinary&&(v=t.wasmBinary);var _=t.noExitRuntime||!0;"object"!=typeof WebAssembly&&B("no native wasm support detected");var O,S,T,A,E,M,R=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function C(e,t,n){var r=(t>>>=0)+n;for(n=t;e[n]&&!(n>=r);)++n;if(16<n-t&&e.buffer&&x)return x.decode(e.subarray(t,n));for(r="";t<n;){var a=e[t++];if(128&a){var o=63&e[t++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|o);else{var i=63&e[t++];65536>(a=224==(240&a)?(15&a)<<12|o<<6|i:(7&a)<<18|o<<12|i<<6|63&e[t++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function P(e,t){return(e>>>=0)?C(A,e,t):""}function k(e,t,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var o=0;o<e.length;++o){var i=e.charCodeAt(o);if(55296<=i&&57343>=i&&(i=65536+((1023&i)<<10)|1023&e.charCodeAt(++o)),127>=i){if(n>=r)break;t[n++>>>0]=i}else{if(2047>=i){if(n+1>=r)break;t[n++>>>0]=192|i>>6}else{if(65535>=i){if(n+2>=r)break;t[n++>>>0]=224|i>>12}else{if(n+3>=r)break;t[n++>>>0]=240|i>>18,t[n++>>>0]=128|i>>12&63}t[n++>>>0]=128|i>>6&63}t[n++>>>0]=128|63&i}}return t[n>>>0]=0,n-a}function D(e){for(var t=0,n=0;n<e.length;++n){var r=e.charCodeAt(n);127>=r?t++:2047>=r?t+=2:55296<=r&&57343>=r?(t+=4,++n):t+=3}return t}function F(){var e=O.buffer;S=e,t.HEAP8=T=new Int8Array(e),t.HEAP16=new Int16Array(e),t.HEAP32=E=new Int32Array(e),t.HEAPU8=A=new Uint8Array(e),t.HEAPU16=new Uint16Array(e),t.HEAPU32=M=new Uint32Array(e),t.HEAPF32=new Float32Array(e),t.HEAPF64=new Float64Array(e)}var U=[],I=[],W=[];function j(){var e=t.preRun.shift();U.unshift(e)}var H,L=0,Y=null,z=null;function B(e){throw t.onAbort&&t.onAbort(e),w(e="Aborted("+e+")"),R=!0,e=new WebAssembly.RuntimeError(e+". Build with -sASSERTIONS for more info."),a(e),e}function N(){return H.startsWith("data:application/octet-stream;base64,")}if(H="ort-wasm.wasm",!N()){var G=H;H=t.locateFile?t.locateFile(G,y):y+G}function q(){var e=H;try{if(e==H&&v)return new Uint8Array(v);if(s)return s(e);throw"both async and sync fetching of the wasm failed"}catch(e){B(e)}}function $(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function V(e){for(;0<e.length;)e.shift()(t)}function J(e){this.sa=e-24,this.Ia=function(e){M[this.sa+4>>2>>>0]=e},this.Ba=function(e){M[this.sa+8>>2>>>0]=e},this.Ga=function(){E[this.sa>>2>>>0]=0},this.Aa=function(){T[this.sa+12>>0>>>0]=0},this.Ha=function(){T[this.sa+13>>0>>>0]=0},this.ya=function(e,t){this.za(),this.Ia(e),this.Ba(t),this.Ga(),this.Aa(),this.Ha()},this.za=function(){M[this.sa+16>>2>>>0]=0}}function Q(e){var t=D(e)+1,n=ie(t);return n&&k(e,T,n,t),n}var X={};function K(){if(!Z){var e,t={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(e in X)void 0===X[e]?delete t[e]:t[e]=X[e];var n=[];for(e in t)n.push(e+"="+t[e]);Z=n}return Z}var Z,ee=[null,[],[]];function te(e){return 0==e%4&&(0!=e%100||0==e%400)}var ne=[31,29,31,30,31,30,31,31,30,31,30,31],re=[31,28,31,30,31,30,31,31,30,31,30,31];function ae(e,t,n,r){function a(e,t,n){for(e="number"==typeof e?e.toString():e||"";e.length<t;)e=n[0]+e;return e}function o(e,t){return a(e,t,"0")}function i(e,t){function n(e){return 0>e?-1:0<e?1:0}var r;return 0===(r=n(e.getFullYear()-t.getFullYear()))&&0===(r=n(e.getMonth()-t.getMonth()))&&(r=n(e.getDate()-t.getDate())),r}function s(e){switch(e.getDay()){case 0:return new Date(e.getFullYear()-1,11,29);case 1:return e;case 2:return new Date(e.getFullYear(),0,3);case 3:return new Date(e.getFullYear(),0,2);case 4:return new Date(e.getFullYear(),0,1);case 5:return new Date(e.getFullYear()-1,11,31);case 6:return new Date(e.getFullYear()-1,11,30)}}function u(e){var t=e.qa;for(e=new Date(new Date(e.ra+1900,0,1).getTime());0<t;){var n=e.getMonth(),r=(te(e.getFullYear())?ne:re)[n];if(!(t>r-e.getDate())){e.setDate(e.getDate()+t);break}t-=r-e.getDate()+1,e.setDate(1),11>n?e.setMonth(n+1):(e.setMonth(0),e.setFullYear(e.getFullYear()+1))}return n=new Date(e.getFullYear()+1,0,4),t=s(new Date(e.getFullYear(),0,4)),n=s(n),0>=i(t,e)?0>=i(n,e)?e.getFullYear()+1:e.getFullYear():e.getFullYear()-1}var c=E[r+40>>2>>>0];for(var l in r={Ea:E[r>>2>>>0],Da:E[r+4>>2>>>0],ta:E[r+8>>2>>>0],va:E[r+12>>2>>>0],ua:E[r+16>>2>>>0],ra:E[r+20>>2>>>0],la:E[r+24>>2>>>0],qa:E[r+28>>2>>>0],Ja:E[r+32>>2>>>0],Ca:E[r+36>>2>>>0],Fa:c?P(c):""},n=P(n),c={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),c[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in c={"%a":function(e){return f[e.la].substring(0,3)},"%A":function(e){return f[e.la]},"%b":function(e){return p[e.ua].substring(0,3)},"%B":function(e){return p[e.ua]},"%C":function(e){return o((e.ra+1900)/100|0,2)},"%d":function(e){return o(e.va,2)},"%e":function(e){return a(e.va,2," ")},"%g":function(e){return u(e).toString().substring(2)},"%G":function(e){return u(e)},"%H":function(e){return o(e.ta,2)},"%I":function(e){return 0==(e=e.ta)?e=12:12<e&&(e-=12),o(e,2)},"%j":function(e){for(var t=0,n=0;n<=e.ua-1;t+=(te(e.ra+1900)?ne:re)[n++]);return o(e.va+t,3)},"%m":function(e){return o(e.ua+1,2)},"%M":function(e){return o(e.Da,2)},"%n":function(){return"\\n"},"%p":function(e){return 0<=e.ta&&12>e.ta?"AM":"PM"},"%S":function(e){return o(e.Ea,2)},"%t":function(){return"\\t"},"%u":function(e){return e.la||7},"%U":function(e){return o(Math.floor((e.qa+7-e.la)/7),2)},"%V":function(e){var t=Math.floor((e.qa+7-(e.la+6)%7)/7);if(2>=(e.la+371-e.qa-2)%7&&t++,t)53==t&&(4==(n=(e.la+371-e.qa)%7)||3==n&&te(e.ra)||(t=1));else{t=52;var n=(e.la+7-e.qa-1)%7;(4==n||5==n&&te(e.ra%400-1))&&t++}return o(t,2)},"%w":function(e){return e.la},"%W":function(e){return o(Math.floor((e.qa+7-(e.la+6)%7)/7),2)},"%y":function(e){return(e.ra+1900).toString().substring(2)},"%Y":function(e){return e.ra+1900},"%z":function(e){var t=0<=(e=e.Ca);return e=Math.abs(e)/60,(t?"+":"-")+String("0000"+(e/60*100+e%60)).slice(-4)},"%Z":function(e){return e.Fa},"%%":function(){return"%"}},n=n.replace(/%%/g,"\\0\\0"),c)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),c[l](r)));return l=function(e){var t=Array(D(e)+1);return k(e,t,0,t.length),t}(n=n.replace(/\\0\\0/g,"%")),l.length>t?0:(T.set(l,e>>>0),l.length-1)}var oe={a:function(e){return ie(e+24)+24},b:function(e,t,n){throw new J(e).ya(t,n),e},g:function(){return 0},I:function(){},w:function(){},y:function(){},K:function(){return 0},G:function(){},C:function(){},F:function(){},k:function(){},x:function(){},u:function(){},H:function(){},v:function(){},n:function(){},p:function(){B("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},o:function(){B("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},l:function(){return Date.now()},L:function(){return!0},M:function(e,t){e=new Date(1e3*(M[e>>>2]+4294967296*E[e+4>>>2])),E[t>>2>>>0]=e.getUTCSeconds(),E[t+4>>2>>>0]=e.getUTCMinutes(),E[t+8>>2>>>0]=e.getUTCHours(),E[t+12>>2>>>0]=e.getUTCDate(),E[t+16>>2>>>0]=e.getUTCMonth(),E[t+20>>2>>>0]=e.getUTCFullYear()-1900,E[t+24>>2>>>0]=e.getUTCDay(),E[t+28>>2>>>0]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},N:function(e,t){e=new Date(1e3*(M[e>>>2]+4294967296*E[e+4>>>2])),E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),E[t+20>>2>>>0]=e.getFullYear()-1900,E[t+24>>2>>>0]=e.getDay();var n=new Date(e.getFullYear(),0,1);E[t+28>>2>>>0]=(e.getTime()-n.getTime())/864e5|0,E[t+36>>2>>>0]=-60*e.getTimezoneOffset();var r=new Date(e.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[t+32>>2>>>0]=0|(r!=n&&e.getTimezoneOffset()==Math.min(n,r))},O:function(e){var t=new Date(E[e+20>>2>>>0]+1900,E[e+16>>2>>>0],E[e+12>>2>>>0],E[e+8>>2>>>0],E[e+4>>2>>>0],E[e>>2>>>0],0),n=E[e+32>>2>>>0],r=t.getTimezoneOffset(),a=new Date(t.getFullYear(),0,1),o=new Date(t.getFullYear(),6,1).getTimezoneOffset(),i=a.getTimezoneOffset(),s=Math.min(i,o);return 0>n?E[e+32>>2>>>0]=Number(o!=i&&s==r):0<n!=(s==r)&&(o=Math.max(i,o),t.setTime(t.getTime()+6e4*((0<n?s:o)-r))),E[e+24>>2>>>0]=t.getDay(),E[e+28>>2>>>0]=(t.getTime()-a.getTime())/864e5|0,E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),t.getTime()/1e3|0},z:function(){return-52},B:function(){},m:function e(t,n,r){e.xa||(e.xa=!0,function(e,t,n){function r(e){return(e=e.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?e[1]:"GMT"}var a=(new Date).getFullYear(),o=new Date(a,0,1),i=new Date(a,6,1);a=o.getTimezoneOffset();var s=i.getTimezoneOffset();E[e>>2>>>0]=60*Math.max(a,s),E[t>>2>>>0]=Number(a!=s),e=r(o),t=r(i),e=Q(e),t=Q(t),s<a?(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t):(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e)}(t,n,r))},d:function(){B("")},t:function(){return 4294901760},h:h?()=>{var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:()=>performance.now(),J:function(e,t,n){A.copyWithin(e>>>0,t>>>0,t+n>>>0)},f:function(e){var t=A.length;if(4294901760<(e>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=t*(1+.2/n);r=Math.min(r,e+100663296);var a=Math;r=Math.max(e,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);e:{try{O.grow(a-S.byteLength+65535>>>16),F();var o=1;break e}catch(e){}o=void 0}if(o)return!0}return!1},D:function(e,t){var n=0;return K().forEach((function(r,a){var o=t+n;for(a=M[e+4*a>>2>>>0]=o,o=0;o<r.length;++o)T[a++>>0>>>0]=r.charCodeAt(o);T[a>>0>>>0]=0,n+=r.length+1})),0},E:function(e,t){var n=K();M[e>>2>>>0]=n.length;var r=0;return n.forEach((function(e){r+=e.length+1})),M[t>>2>>>0]=r,0},r:function(e){_||(t.onExit&&t.onExit(e),R=!0),d(e,new $(e))},e:function(){return 52},j:function(){return 52},q:function(){return 70},i:function(e,t,n,r){for(var a=0,o=0;o<n;o++){var i=M[t>>2>>>0],s=M[t+4>>2>>>0];t+=8;for(var u=0;u<s;u++){var c=A[i+u>>>0],l=ee[e];0===c||10===c?((1===e?b:w)(C(l,0)),l.length=0):l.push(c)}a+=s}return M[r>>2>>>0]=a,0},s:function e(t,r){e.wa||(e.wa=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var e=new Uint8Array(1);return()=>(crypto.getRandomValues(e),e[0])}if(h)try{var t=n(760);return()=>t.randomBytes(1)[0]}catch(e){}return()=>B("randomDevice")}());for(var a=0;a<r;a++)T[t+a>>0>>>0]=e.wa();return 0},A:ae,c:function(e,t,n,r){return ae(e,t,n,r)}};!function(){function e(e){t.asm=e.exports,O=t.asm.P,F(),I.unshift(t.asm.Q),L--,t.monitorRunDependencies&&t.monitorRunDependencies(L),0==L&&(null!==Y&&(clearInterval(Y),Y=null),z&&(e=z,z=null,e()))}function n(t){e(t.instance)}function r(e){return function(){if(!v&&(m||g)){if("function"==typeof fetch&&!H.startsWith("file://"))return fetch(H,{credentials:"same-origin"}).then((function(e){if(!e.ok)throw"failed to load wasm binary file at \'"+H+"\'";return e.arrayBuffer()})).catch((function(){return q()}));if(i)return new Promise((function(e,t){i(H,(function(t){e(new Uint8Array(t))}),t)}))}return Promise.resolve().then((function(){return q()}))}().then((function(e){return WebAssembly.instantiate(e,o)})).then((function(e){return e})).then(e,(function(e){w("failed to asynchronously prepare wasm: "+e),B(e)}))}var o={a:oe};if(L++,t.monitorRunDependencies&&t.monitorRunDependencies(L),t.instantiateWasm)try{return t.instantiateWasm(o,e)}catch(e){return w("Module.instantiateWasm callback failed with error: "+e),!1}(v||"function"!=typeof WebAssembly.instantiateStreaming||N()||H.startsWith("file://")||h||"function"!=typeof fetch?r(n):fetch(H,{credentials:"same-origin"}).then((function(e){return WebAssembly.instantiateStreaming(e,o).then(n,(function(e){return w("wasm streaming compile failed: "+e),w("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),t.___wasm_call_ctors=function(){return(t.___wasm_call_ctors=t.asm.Q).apply(null,arguments)},t._OrtInit=function(){return(t._OrtInit=t.asm.R).apply(null,arguments)},t._OrtCreateSessionOptions=function(){return(t._OrtCreateSessionOptions=t.asm.S).apply(null,arguments)},t._OrtAppendExecutionProvider=function(){return(t._OrtAppendExecutionProvider=t.asm.T).apply(null,arguments)},t._OrtAddSessionConfigEntry=function(){return(t._OrtAddSessionConfigEntry=t.asm.U).apply(null,arguments)},t._OrtReleaseSessionOptions=function(){return(t._OrtReleaseSessionOptions=t.asm.V).apply(null,arguments)},t._OrtCreateSession=function(){return(t._OrtCreateSession=t.asm.W).apply(null,arguments)},t._OrtReleaseSession=function(){return(t._OrtReleaseSession=t.asm.X).apply(null,arguments)},t._OrtGetInputCount=function(){return(t._OrtGetInputCount=t.asm.Y).apply(null,arguments)},t._OrtGetOutputCount=function(){return(t._OrtGetOutputCount=t.asm.Z).apply(null,arguments)},t._OrtGetInputName=function(){return(t._OrtGetInputName=t.asm._).apply(null,arguments)},t._OrtGetOutputName=function(){return(t._OrtGetOutputName=t.asm.$).apply(null,arguments)},t._OrtFree=function(){return(t._OrtFree=t.asm.aa).apply(null,arguments)},t._OrtCreateTensor=function(){return(t._OrtCreateTensor=t.asm.ba).apply(null,arguments)},t._OrtGetTensorData=function(){return(t._OrtGetTensorData=t.asm.ca).apply(null,arguments)},t._OrtReleaseTensor=function(){return(t._OrtReleaseTensor=t.asm.da).apply(null,arguments)},t._OrtCreateRunOptions=function(){return(t._OrtCreateRunOptions=t.asm.ea).apply(null,arguments)},t._OrtAddRunConfigEntry=function(){return(t._OrtAddRunConfigEntry=t.asm.fa).apply(null,arguments)},t._OrtReleaseRunOptions=function(){return(t._OrtReleaseRunOptions=t.asm.ga).apply(null,arguments)},t._OrtRun=function(){return(t._OrtRun=t.asm.ha).apply(null,arguments)},t._OrtEndProfiling=function(){return(t._OrtEndProfiling=t.asm.ia).apply(null,arguments)};var ie=t._malloc=function(){return(ie=t._malloc=t.asm.ja).apply(null,arguments)};t._free=function(){return(t._free=t.asm.ka).apply(null,arguments)};var se,ue=t.stackSave=function(){return(ue=t.stackSave=t.asm.ma).apply(null,arguments)},ce=t.stackRestore=function(){return(ce=t.stackRestore=t.asm.na).apply(null,arguments)},le=t.stackAlloc=function(){return(le=t.stackAlloc=t.asm.oa).apply(null,arguments)};function fe(){function e(){if(!se&&(se=!0,t.calledRun=!0,!R)){if(V(I),r(t),t.onRuntimeInitialized&&t.onRuntimeInitialized(),t.postRun)for("function"==typeof t.postRun&&(t.postRun=[t.postRun]);t.postRun.length;){var e=t.postRun.shift();W.unshift(e)}V(W)}}if(!(0<L)){if(t.preRun)for("function"==typeof t.preRun&&(t.preRun=[t.preRun]);t.preRun.length;)j();V(U),0<L||(t.setStatus?(t.setStatus("Running..."),setTimeout((function(){setTimeout((function(){t.setStatus("")}),1),e()}),1)):e())}}if(t.___cxa_is_pointer_type=function(){return(t.___cxa_is_pointer_type=t.asm.pa).apply(null,arguments)},t.UTF8ToString=P,t.stringToUTF8=function(e,t,n){return k(e,A,t,n)},t.lengthBytesUTF8=D,t.stackSave=ue,t.stackRestore=ce,t.stackAlloc=le,z=function e(){se||fe(),se||(z=e)},t.preInit)for("function"==typeof t.preInit&&(t.preInit=[t.preInit]);0<t.preInit.length;)t.preInit.pop()();return fe(),e.ready});e.exports=r},154:e=>{"use strict";e.exports=\'"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n\'},760:()=>{},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},t={};function n(r){var a=t[r];if(void 0!==a)return a.exports;var o=t[r]={exports:{}};return e[r].call(o.exports,o,o.exports,n),o.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),(()=>{"use strict";const e=n(259),t=n(263);self.onmessage=n=>{switch(n.data.type){case"init-wasm":(0,t.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(e=>postMessage({type:"init-wasm",err:e})));break;case"init-ort":try{const{numThreads:t,loggingLevel:r}=n.data.in;(0,e.initOrt)(t,r),postMessage({type:"init-ort"})}catch(e){postMessage({type:"init-ort",err:e})}break;case"create_allocate":try{const{model:t}=n.data.in,r=(0,e.createSessionAllocate)(t);postMessage({type:"create_allocate",out:r})}catch(e){postMessage({type:"create_allocate",err:e})}break;case"create_finalize":try{const{modeldata:t,options:r}=n.data.in,a=(0,e.createSessionFinalize)(t,r);postMessage({type:"create_finalize",out:a})}catch(e){postMessage({type:"create_finalize",err:e})}break;case"create":try{const{model:t,options:r}=n.data.in,a=(0,e.createSession)(t,r);postMessage({type:"create",out:a})}catch(e){postMessage({type:"create",err:e})}break;case"release":try{const t=n.data.in;(0,e.releaseSession)(t),postMessage({type:"release"})}catch(e){postMessage({type:"release",err:e})}break;case"run":try{const{sessionId:t,inputIndices:r,inputs:a,outputIndices:o,options:i}=n.data.in;(0,e.run)(t,r,a,o,i).then((t=>{postMessage({type:"run",out:t},(0,e.extractTransferableBuffers)(t))}),(e=>{postMessage({type:"run",err:e})}))}catch(e){postMessage({type:"run",err:e})}break;case"end-profiling":try{const t=n.data.in;(0,e.endProfiling)(t),postMessage({type:"end-profiling"})}catch(e){postMessage({type:"end-profiling",err:e})}}}})()})();\n', "Worker", void 0, void 0)
                }
            }
            ,
            6614: o => {
                o.exports = function(i, s, a, _) {
                    var $ = self || window;
                    try {
                        try {
                            var _e;
                            try {
                                _e = new $.Blob([i])
                            } catch {
                                (_e = new ($.BlobBuilder || $.WebKitBlobBuilder || $.MozBlobBuilder || $.MSBlobBuilder)).append(i),
                                _e = _e.getBlob()
                            }
                            var tt = $.URL || $.webkitURL
                              , nt = tt.createObjectURL(_e)
                              , rt = new $[s](nt,a);
                            return tt.revokeObjectURL(nt),
                            rt
                        } catch {
                            return new $[s]("data:application/javascript,".concat(encodeURIComponent(i)),a)
                        }
                    } catch {
                        if (!_)
                            throw Error("Inline worker is not supported");
                        return new $[s](_,a)
                    }
                }
            }
            ,
            3474: (o, i, s) => {
                var a, _ = (a = (a = typeof document < "u" && document.currentScript ? document.currentScript.src : void 0) || "/index.js",
                function($) {
                    function _e() {
                        return At.buffer != Ut && on(At.buffer),
                        Lt
                    }
                    function tt() {
                        return At.buffer != Ut && on(At.buffer),
                        tn
                    }
                    function nt() {
                        return At.buffer != Ut && on(At.buffer),
                        Vt
                    }
                    function rt() {
                        return At.buffer != Ut && on(At.buffer),
                        Nt
                    }
                    function ot() {
                        return At.buffer != Ut && on(At.buffer),
                        Yt
                    }
                    var et, j, it;
                    $ = $ || {},
                    et || (et = $ !== void 0 ? $ : {}),
                    et.ready = new Promise(function(St, Ct) {
                        j = St,
                        it = Ct
                    }
                    );
                    var st, at, lt, ct, ut, dt, ft = Object.assign({}, et), ht = "./this.program", pt = (St, Ct) => {
                        throw Ct
                    }
                    , gt = typeof window == "object", _t = typeof importScripts == "function", mt = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string", yt = et.ENVIRONMENT_IS_PTHREAD || !1, bt = "";
                    function vt(St) {
                        return et.locateFile ? et.locateFile(St, bt) : bt + St
                    }
                    if (mt) {
                        let St;
                        bt = _t ? s(908).dirname(bt) + "/" : "//",
                        dt = () => {
                            ut || (ct = s(1384),
                            ut = s(908))
                        }
                        ,
                        st = function(Ct, kt) {
                            return dt(),
                            Ct = ut.normalize(Ct),
                            ct.readFileSync(Ct, kt ? void 0 : "utf8")
                        }
                        ,
                        lt = Ct => ((Ct = st(Ct, !0)).buffer || (Ct = new Uint8Array(Ct)),
                        Ct),
                        at = (Ct, kt, zt) => {
                            dt(),
                            Ct = ut.normalize(Ct),
                            ct.readFile(Ct, function(nn, ln) {
                                nn ? zt(nn) : kt(ln.buffer)
                            })
                        }
                        ,
                        1 < process.argv.length && (ht = process.argv[1].replace(/\\/g, "/")),
                        process.argv.slice(2),
                        process.on("uncaughtException", function(Ct) {
                            if (!(Ct instanceof Fn))
                                throw Ct
                        }),
                        process.on("unhandledRejection", function(Ct) {
                            throw Ct
                        }),
                        pt = (Ct, kt) => {
                            if (Rt)
                                throw process.exitCode = Ct,
                                kt;
                            kt instanceof Fn || Pt("exiting due to exception: " + kt),
                            process.exit(Ct)
                        }
                        ,
                        et.inspect = function() {
                            return "[Emscripten Module object]"
                        }
                        ;
                        try {
                            St = s(9925)
                        } catch (Ct) {
                            throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'),
                            Ct
                        }
                        s.g.Worker = St.Worker
                    } else
                        (gt || _t) && (_t ? bt = self.location.href : typeof document < "u" && document.currentScript && (bt = document.currentScript.src),
                        a && (bt = a),
                        bt = bt.indexOf("blob:") !== 0 ? bt.substr(0, bt.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "",
                        mt || (st = St => {
                            var Ct = new XMLHttpRequest;
                            return Ct.open("GET", St, !1),
                            Ct.send(null),
                            Ct.responseText
                        }
                        ,
                        _t && (lt = St => {
                            var Ct = new XMLHttpRequest;
                            return Ct.open("GET", St, !1),
                            Ct.responseType = "arraybuffer",
                            Ct.send(null),
                            new Uint8Array(Ct.response)
                        }
                        ),
                        at = (St, Ct, kt) => {
                            var zt = new XMLHttpRequest;
                            zt.open("GET", St, !0),
                            zt.responseType = "arraybuffer",
                            zt.onload = () => {
                                zt.status == 200 || zt.status == 0 && zt.response ? Ct(zt.response) : kt()
                            }
                            ,
                            zt.onerror = kt,
                            zt.send(null)
                        }
                        ));
                    mt && typeof performance > "u" && (s.g.performance = s(6953).performance);
                    var wt = console.log.bind(console)
                      , Tt = console.warn.bind(console);
                    mt && (dt(),
                    wt = St => ct.writeSync(1, St + `
`),
                    Tt = St => ct.writeSync(2, St + `
`));
                    var $t, Et = et.print || wt, Pt = et.printErr || Tt;
                    Object.assign(et, ft),
                    ft = null,
                    et.thisProgram && (ht = et.thisProgram),
                    et.quit && (pt = et.quit),
                    et.wasmBinary && ($t = et.wasmBinary);
                    var Rt = et.noExitRuntime || !0;
                    typeof WebAssembly != "object" && dn("no native wasm support detected");
                    var At, Mt, Ut, Lt, tn, Vt, Nt, Yt, Xt = !1, jt = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
                    function Gt(St, Ct, kt) {
                        var zt = (Ct >>>= 0) + kt;
                        for (kt = Ct; St[kt] && !(kt >= zt); )
                            ++kt;
                        if (16 < kt - Ct && St.buffer && jt)
                            return jt.decode(St.buffer instanceof SharedArrayBuffer ? St.slice(Ct, kt) : St.subarray(Ct, kt));
                        for (zt = ""; Ct < kt; ) {
                            var nn = St[Ct++];
                            if (128 & nn) {
                                var ln = 63 & St[Ct++];
                                if ((224 & nn) == 192)
                                    zt += String.fromCharCode((31 & nn) << 6 | ln);
                                else {
                                    var xn = 63 & St[Ct++];
                                    65536 > (nn = (240 & nn) == 224 ? (15 & nn) << 12 | ln << 6 | xn : (7 & nn) << 18 | ln << 12 | xn << 6 | 63 & St[Ct++]) ? zt += String.fromCharCode(nn) : (nn -= 65536,
                                    zt += String.fromCharCode(55296 | nn >> 10, 56320 | 1023 & nn))
                                }
                            } else
                                zt += String.fromCharCode(nn)
                        }
                        return zt
                    }
                    function Kt(St, Ct) {
                        return (St >>>= 0) ? Gt(tt(), St, Ct) : ""
                    }
                    function qt(St, Ct, kt, zt) {
                        if (!(0 < zt))
                            return 0;
                        var nn = kt >>>= 0;
                        zt = kt + zt - 1;
                        for (var ln = 0; ln < St.length; ++ln) {
                            var xn = St.charCodeAt(ln);
                            if (55296 <= xn && 57343 >= xn && (xn = 65536 + ((1023 & xn) << 10) | 1023 & St.charCodeAt(++ln)),
                            127 >= xn) {
                                if (kt >= zt)
                                    break;
                                Ct[kt++ >>> 0] = xn
                            } else {
                                if (2047 >= xn) {
                                    if (kt + 1 >= zt)
                                        break;
                                    Ct[kt++ >>> 0] = 192 | xn >> 6
                                } else {
                                    if (65535 >= xn) {
                                        if (kt + 2 >= zt)
                                            break;
                                        Ct[kt++ >>> 0] = 224 | xn >> 12
                                    } else {
                                        if (kt + 3 >= zt)
                                            break;
                                        Ct[kt++ >>> 0] = 240 | xn >> 18,
                                        Ct[kt++ >>> 0] = 128 | xn >> 12 & 63
                                    }
                                    Ct[kt++ >>> 0] = 128 | xn >> 6 & 63
                                }
                                Ct[kt++ >>> 0] = 128 | 63 & xn
                            }
                        }
                        return Ct[kt >>> 0] = 0,
                        kt - nn
                    }
                    function rn(St) {
                        for (var Ct = 0, kt = 0; kt < St.length; ++kt) {
                            var zt = St.charCodeAt(kt);
                            127 >= zt ? Ct++ : 2047 >= zt ? Ct += 2 : 55296 <= zt && 57343 >= zt ? (Ct += 4,
                            ++kt) : Ct += 3
                        }
                        return Ct
                    }
                    function on(St) {
                        Ut = St,
                        et.HEAP8 = Lt = new Int8Array(St),
                        et.HEAP16 = new Int16Array(St),
                        et.HEAP32 = Vt = new Int32Array(St),
                        et.HEAPU8 = tn = new Uint8Array(St),
                        et.HEAPU16 = new Uint16Array(St),
                        et.HEAPU32 = Nt = new Uint32Array(St),
                        et.HEAPF32 = new Float32Array(St),
                        et.HEAPF64 = Yt = new Float64Array(St)
                    }
                    yt && (Ut = et.buffer);
                    var _n = et.INITIAL_MEMORY || 16777216;
                    if (yt)
                        At = et.wasmMemory,
                        Ut = et.buffer;
                    else if (et.wasmMemory)
                        At = et.wasmMemory;
                    else if (!((At = new WebAssembly.Memory({
                        initial: _n / 65536,
                        maximum: 65536,
                        shared: !0
                    })).buffer instanceof SharedArrayBuffer))
                        throw Pt("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),
                        mt && console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),
                        Error("bad memory");
                    At && (Ut = At.buffer),
                    _n = Ut.byteLength,
                    on(Ut);
                    var mn, Sn = [], bn = [], In = [];
                    function Nn() {
                        var St = et.preRun.shift();
                        Sn.unshift(St)
                    }
                    var cn, $n = 0, gn = null;
                    function dn(St) {
                        throw yt ? postMessage({
                            cmd: "onAbort",
                            arg: St
                        }) : et.onAbort && et.onAbort(St),
                        Pt(St = "Aborted(" + St + ")"),
                        Xt = !0,
                        St = new WebAssembly.RuntimeError(St + ". Build with -sASSERTIONS for more info."),
                        it(St),
                        St
                    }
                    function Dn() {
                        return cn.startsWith("data:application/octet-stream;base64,")
                    }
                    function kn() {
                        var St = cn;
                        try {
                            if (St == cn && $t)
                                return new Uint8Array($t);
                            if (lt)
                                return lt(St);
                            throw "both async and sync fetching of the wasm failed"
                        } catch (Ct) {
                            dn(Ct)
                        }
                    }
                    cn = "ort-wasm-threaded.wasm",
                    Dn() || (cn = vt(cn));
                    var An = {};
                    function Fn(St) {
                        this.name = "ExitStatus",
                        this.message = "Program terminated with exit(" + St + ")",
                        this.status = St
                    }
                    function On(St) {
                        (St = fn.La[St]) || dn(),
                        fn.Xa(St)
                    }
                    function jn(St) {
                        var Ct = fn.lb();
                        if (!Ct)
                            return 6;
                        fn.Ra.push(Ct),
                        fn.La[St.Ka] = Ct,
                        Ct.Ka = St.Ka;
                        var kt = {
                            cmd: "run",
                            start_routine: St.pb,
                            arg: St.ib,
                            pthread_ptr: St.Ka
                        };
                        return Ct.Qa = () => {
                            kt.time = performance.now(),
                            Ct.postMessage(kt, St.vb)
                        }
                        ,
                        Ct.loaded && (Ct.Qa(),
                        delete Ct.Qa),
                        0
                    }
                    function Vn(St) {
                        if (yt)
                            return un(1, 1, St);
                        Rt || (fn.qb(),
                        et.onExit && et.onExit(St),
                        Xt = !0),
                        pt(St, new Fn(St))
                    }
                    function Mn(St, Ct) {
                        if (!Ct && yt)
                            throw xt(St),
                            "unwind";
                        Vn(St)
                    }
                    var fn = {
                        Oa: [],
                        Ra: [],
                        $a: [],
                        La: {},
                        Ua: function() {
                            yt && fn.mb()
                        },
                        xb: function() {},
                        mb: function() {
                            fn.receiveObjectTransfer = fn.ob,
                            fn.threadInitTLS = fn.Za,
                            fn.setExitStatus = fn.Ya,
                            Rt = !1
                        },
                        Ya: function() {},
                        qb: function() {
                            for (var St of Object.values(fn.La))
                                fn.Xa(St);
                            for (St of fn.Oa)
                                St.terminate();
                            fn.Oa = []
                        },
                        Xa: function(St) {
                            var Ct = St.Ka;
                            delete fn.La[Ct],
                            fn.Oa.push(St),
                            fn.Ra.splice(fn.Ra.indexOf(St), 1),
                            St.Ka = 0,
                            ur(Ct)
                        },
                        ob: function() {},
                        Za: function() {
                            fn.$a.forEach(St => St())
                        },
                        nb: function(St, Ct) {
                            St.onmessage = kt => {
                                var zt = (kt = kt.data).cmd;
                                if (St.Ka && (fn.kb = St.Ka),
                                kt.targetThread && kt.targetThread != sr()) {
                                    var nn = fn.La[kt.yb];
                                    nn ? nn.postMessage(kt, kt.transferList) : Pt('Internal error! Worker sent a message "' + zt + '" to target pthread ' + kt.targetThread + ", but that thread no longer exists!")
                                } else
                                    zt === "processProxyingQueue" ? zn(kt.queue) : zt === "spawnThread" ? jn(kt) : zt === "cleanupThread" ? On(kt.thread) : zt === "killThread" ? (kt = kt.thread,
                                    zt = fn.La[kt],
                                    delete fn.La[kt],
                                    zt.terminate(),
                                    ur(kt),
                                    fn.Ra.splice(fn.Ra.indexOf(zt), 1),
                                    zt.Ka = 0) : zt === "cancelThread" ? fn.La[kt.thread].postMessage({
                                        cmd: "cancel"
                                    }) : zt === "loaded" ? (St.loaded = !0,
                                    Ct && Ct(St),
                                    St.Qa && (St.Qa(),
                                    delete St.Qa)) : zt === "print" ? Et("Thread " + kt.threadId + ": " + kt.text) : zt === "printErr" ? Pt("Thread " + kt.threadId + ": " + kt.text) : zt === "alert" ? alert("Thread " + kt.threadId + ": " + kt.text) : kt.target === "setimmediate" ? St.postMessage(kt) : zt === "onAbort" ? et.onAbort && et.onAbort(kt.arg) : zt && Pt("worker sent an unknown command " + zt);
                                fn.kb = void 0
                            }
                            ,
                            St.onerror = kt => {
                                throw Pt("worker sent an error! " + kt.filename + ":" + kt.lineno + ": " + kt.message),
                                kt
                            }
                            ,
                            mt && (St.on("message", function(kt) {
                                St.onmessage({
                                    data: kt
                                })
                            }),
                            St.on("error", function(kt) {
                                St.onerror(kt)
                            }),
                            St.on("detachedExit", function() {})),
                            St.postMessage({
                                cmd: "load",
                                urlOrBlob: et.mainScriptUrlOrBlob || a,
                                wasmMemory: At,
                                wasmModule: Mt
                            })
                        },
                        hb: function() {
                            var St = vt("ort-wasm-threaded.worker.js");
                            fn.Oa.push(new Worker(St))
                        },
                        lb: function() {
                            return fn.Oa.length == 0 && (fn.hb(),
                            fn.nb(fn.Oa[0])),
                            fn.Oa.pop()
                        }
                    };
                    function It(St) {
                        for (; 0 < St.length; )
                            St.shift()(et)
                    }
                    function xt(St) {
                        if (yt)
                            return un(2, 0, St);
                        try {
                            Mn(St)
                        } catch (Ct) {
                            Ct instanceof Fn || Ct == "unwind" || pt(1, Ct)
                        }
                    }
                    et.PThread = fn,
                    et.establishStackSpace = function() {
                        var St = sr()
                          , Ct = nt()[St + 44 >> 2 >>> 0];
                        St = nt()[St + 48 >> 2 >>> 0],
                        Tr(Ct, Ct - St),
                        lr(Ct)
                    }
                    ;
                    var Ot, Dt, Bt = [];
                    function Wt(St) {
                        this.Pa = St - 24,
                        this.gb = function(Ct) {
                            rt()[this.Pa + 4 >> 2 >>> 0] = Ct
                        }
                        ,
                        this.cb = function(Ct) {
                            rt()[this.Pa + 8 >> 2 >>> 0] = Ct
                        }
                        ,
                        this.eb = function() {
                            nt()[this.Pa >> 2 >>> 0] = 0
                        }
                        ,
                        this.bb = function() {
                            _e()[this.Pa + 12 >> 0 >>> 0] = 0
                        }
                        ,
                        this.fb = function() {
                            _e()[this.Pa + 13 >> 0 >>> 0] = 0
                        }
                        ,
                        this.Ua = function(Ct, kt) {
                            this.ab(),
                            this.gb(Ct),
                            this.cb(kt),
                            this.eb(),
                            this.bb(),
                            this.fb()
                        }
                        ,
                        this.ab = function() {
                            rt()[this.Pa + 16 >> 2 >>> 0] = 0
                        }
                    }
                    function Zt(St, Ct, kt, zt) {
                        return yt ? un(3, 1, St, Ct, kt, zt) : an(St, Ct, kt, zt)
                    }
                    function an(St, Ct, kt, zt) {
                        if (typeof SharedArrayBuffer > "u")
                            return Pt("Current environment does not support SharedArrayBuffer, pthreads are not available!"),
                            6;
                        var nn = [];
                        return yt && nn.length === 0 ? Zt(St, Ct, kt, zt) : (St = {
                            pb: kt,
                            Ka: St,
                            ib: zt,
                            vb: nn
                        },
                        yt ? (St.wb = "spawnThread",
                        postMessage(St, nn),
                        0) : jn(St))
                    }
                    function en(St, Ct, kt) {
                        return yt ? un(4, 1, St, Ct, kt) : 0
                    }
                    function Jt(St, Ct) {
                        if (yt)
                            return un(5, 1, St, Ct)
                    }
                    function pn(St, Ct) {
                        if (yt)
                            return un(6, 1, St, Ct)
                    }
                    function vn(St, Ct, kt) {
                        if (yt)
                            return un(7, 1, St, Ct, kt)
                    }
                    function hn(St, Ct, kt) {
                        return yt ? un(8, 1, St, Ct, kt) : 0
                    }
                    function Ft(St, Ct) {
                        if (yt)
                            return un(9, 1, St, Ct)
                    }
                    function Qt(St, Ct, kt) {
                        if (yt)
                            return un(10, 1, St, Ct, kt)
                    }
                    function yn(St, Ct, kt, zt) {
                        if (yt)
                            return un(11, 1, St, Ct, kt, zt)
                    }
                    function wn(St, Ct, kt, zt) {
                        if (yt)
                            return un(12, 1, St, Ct, kt, zt)
                    }
                    function Ln(St, Ct, kt, zt) {
                        if (yt)
                            return un(13, 1, St, Ct, kt, zt)
                    }
                    function Hn(St) {
                        if (yt)
                            return un(14, 1, St)
                    }
                    function Rn(St, Ct) {
                        if (yt)
                            return un(15, 1, St, Ct)
                    }
                    function Cn(St, Ct, kt) {
                        if (yt)
                            return un(16, 1, St, Ct, kt)
                    }
                    function zn(St) {
                        Atomics.store(nt(), St >> 2, 1),
                        sr() && Er(St),
                        Atomics.compareExchange(nt(), St >> 2, 1, 0)
                    }
                    function qn(St) {
                        return rt()[St >>> 2] + 4294967296 * nt()[St + 4 >>> 2]
                    }
                    function Qn(St, Ct, kt, zt, nn, ln) {
                        return yt ? un(17, 1, St, Ct, kt, zt, nn, ln) : -52
                    }
                    function er(St, Ct, kt, zt, nn, ln) {
                        if (yt)
                            return un(18, 1, St, Ct, kt, zt, nn, ln)
                    }
                    function Tn(St) {
                        var Ct = rn(St) + 1
                          , kt = cr(Ct);
                        return kt && qt(St, _e(), kt, Ct),
                        kt
                    }
                    function sn(St, Ct, kt) {
                        function zt(Wn) {
                            return (Wn = Wn.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? Wn[1] : "GMT"
                        }
                        if (yt)
                            return un(19, 1, St, Ct, kt);
                        var nn = new Date().getFullYear()
                          , ln = new Date(nn,0,1)
                          , xn = new Date(nn,6,1);
                        nn = ln.getTimezoneOffset();
                        var Gn = xn.getTimezoneOffset()
                          , tr = Math.max(nn, Gn);
                        nt()[St >> 2 >>> 0] = 60 * tr,
                        nt()[Ct >> 2 >>> 0] = +(nn != Gn),
                        St = zt(ln),
                        Ct = zt(xn),
                        St = Tn(St),
                        Ct = Tn(Ct),
                        Gn < nn ? (rt()[kt >> 2 >>> 0] = St,
                        rt()[kt + 4 >> 2 >>> 0] = Ct) : (rt()[kt >> 2 >>> 0] = Ct,
                        rt()[kt + 4 >> 2 >>> 0] = St)
                    }
                    function un(St, Ct) {
                        var kt = arguments.length - 2
                          , zt = arguments;
                        return function(nn) {
                            var ln = dr();
                            return nn = nn(),
                            lr(ln),
                            nn
                        }( () => {
                            for (var nn = fr(8 * kt), ln = nn >> 3, xn = 0; xn < kt; xn++) {
                                var Gn = zt[2 + xn];
                                ot()[ln + xn >>> 0] = Gn
                            }
                            return xr(St, kt, nn, Ct)
                        }
                        )
                    }
                    et.invokeEntryPoint = function(St, Ct) {
                        var kt = Bt[St];
                        kt || (St >= Bt.length && (Bt.length = St + 1),
                        Bt[St] = kt = mn.get(St)),
                        St = kt(Ct),
                        Rt ? fn.Ya(St) : Sr(St)
                    }
                    ,
                    et.executeNotifiedProxyingQueue = zn,
                    Dt = mt ? () => {
                        var St = process.hrtime();
                        return 1e3 * St[0] + St[1] / 1e6
                    }
                    : yt ? () => performance.now() - et.__performance_now_clock_drift : () => performance.now();
                    var Bn, En = [], Jn = {};
                    function rr() {
                        if (!Bn) {
                            var St, Ct = {
                                USER: "web_user",
                                LOGNAME: "web_user",
                                PATH: "/",
                                PWD: "/",
                                HOME: "/home/web_user",
                                LANG: (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8",
                                _: ht || "./this.program"
                            };
                            for (St in Jn)
                                Jn[St] === void 0 ? delete Ct[St] : Ct[St] = Jn[St];
                            var kt = [];
                            for (St in Ct)
                                kt.push(St + "=" + Ct[St]);
                            Bn = kt
                        }
                        return Bn
                    }
                    function ir(St, Ct) {
                        if (yt)
                            return un(20, 1, St, Ct);
                        var kt = 0;
                        return rr().forEach(function(zt, nn) {
                            var ln = Ct + kt;
                            for (nn = rt()[St + 4 * nn >> 2 >>> 0] = ln,
                            ln = 0; ln < zt.length; ++ln)
                                _e()[nn++ >> 0 >>> 0] = zt.charCodeAt(ln);
                            _e()[nn >> 0 >>> 0] = 0,
                            kt += zt.length + 1
                        }),
                        0
                    }
                    function hr(St, Ct) {
                        if (yt)
                            return un(21, 1, St, Ct);
                        var kt = rr();
                        rt()[St >> 2 >>> 0] = kt.length;
                        var zt = 0;
                        return kt.forEach(function(nn) {
                            zt += nn.length + 1
                        }),
                        rt()[Ct >> 2 >>> 0] = zt,
                        0
                    }
                    function pr(St) {
                        return yt ? un(22, 1, St) : 52
                    }
                    function gr(St, Ct, kt, zt) {
                        return yt ? un(23, 1, St, Ct, kt, zt) : 52
                    }
                    function mr(St, Ct, kt, zt, nn) {
                        return yt ? un(24, 1, St, Ct, kt, zt, nn) : 70
                    }
                    var Ir = [null, [], []];
                    function _r(St, Ct, kt, zt) {
                        if (yt)
                            return un(25, 1, St, Ct, kt, zt);
                        for (var nn = 0, ln = 0; ln < kt; ln++) {
                            var xn = rt()[Ct >> 2 >>> 0]
                              , Gn = rt()[Ct + 4 >> 2 >>> 0];
                            Ct += 8;
                            for (var tr = 0; tr < Gn; tr++) {
                                var Wn = tt()[xn + tr >>> 0]
                                  , Kn = Ir[St];
                                Wn === 0 || Wn === 10 ? ((St === 1 ? Et : Pt)(Gt(Kn, 0)),
                                Kn.length = 0) : Kn.push(Wn)
                            }
                            nn += Gn
                        }
                        return rt()[zt >> 2 >>> 0] = nn,
                        0
                    }
                    function or(St) {
                        return St % 4 == 0 && (St % 100 != 0 || St % 400 == 0)
                    }
                    var yr = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
                      , br = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
                    function vr(St, Ct, kt, zt) {
                        function nn(Ht, Pn, Un) {
                            for (Ht = typeof Ht == "number" ? Ht.toString() : Ht || ""; Ht.length < Pn; )
                                Ht = Un[0] + Ht;
                            return Ht
                        }
                        function ln(Ht, Pn) {
                            return nn(Ht, Pn, "0")
                        }
                        function xn(Ht, Pn) {
                            function Un(Rr) {
                                return 0 > Rr ? -1 : 0 < Rr ? 1 : 0
                            }
                            var nr;
                            return (nr = Un(Ht.getFullYear() - Pn.getFullYear())) === 0 && (nr = Un(Ht.getMonth() - Pn.getMonth())) === 0 && (nr = Un(Ht.getDate() - Pn.getDate())),
                            nr
                        }
                        function Gn(Ht) {
                            switch (Ht.getDay()) {
                            case 0:
                                return new Date(Ht.getFullYear() - 1,11,29);
                            case 1:
                                return Ht;
                            case 2:
                                return new Date(Ht.getFullYear(),0,3);
                            case 3:
                                return new Date(Ht.getFullYear(),0,2);
                            case 4:
                                return new Date(Ht.getFullYear(),0,1);
                            case 5:
                                return new Date(Ht.getFullYear() - 1,11,31);
                            case 6:
                                return new Date(Ht.getFullYear() - 1,11,30)
                            }
                        }
                        function tr(Ht) {
                            var Pn = Ht.Ma;
                            for (Ht = new Date(new Date(Ht.Na + 1900,0,1).getTime()); 0 < Pn; ) {
                                var Un = Ht.getMonth()
                                  , nr = (or(Ht.getFullYear()) ? yr : br)[Un];
                                if (!(Pn > nr - Ht.getDate())) {
                                    Ht.setDate(Ht.getDate() + Pn);
                                    break
                                }
                                Pn -= nr - Ht.getDate() + 1,
                                Ht.setDate(1),
                                11 > Un ? Ht.setMonth(Un + 1) : (Ht.setMonth(0),
                                Ht.setFullYear(Ht.getFullYear() + 1))
                            }
                            return Un = new Date(Ht.getFullYear() + 1,0,4),
                            Pn = Gn(new Date(Ht.getFullYear(),0,4)),
                            Un = Gn(Un),
                            0 >= xn(Pn, Ht) ? 0 >= xn(Un, Ht) ? Ht.getFullYear() + 1 : Ht.getFullYear() : Ht.getFullYear() - 1
                        }
                        var Wn = nt()[zt + 40 >> 2 >>> 0];
                        for (var Kn in zt = {
                            tb: nt()[zt >> 2 >>> 0],
                            sb: nt()[zt + 4 >> 2 >>> 0],
                            Sa: nt()[zt + 8 >> 2 >>> 0],
                            Va: nt()[zt + 12 >> 2 >>> 0],
                            Ta: nt()[zt + 16 >> 2 >>> 0],
                            Na: nt()[zt + 20 >> 2 >>> 0],
                            Ja: nt()[zt + 24 >> 2 >>> 0],
                            Ma: nt()[zt + 28 >> 2 >>> 0],
                            zb: nt()[zt + 32 >> 2 >>> 0],
                            rb: nt()[zt + 36 >> 2 >>> 0],
                            ub: Wn ? Kt(Wn) : ""
                        },
                        kt = Kt(kt),
                        Wn = {
                            "%c": "%a %b %d %H:%M:%S %Y",
                            "%D": "%m/%d/%y",
                            "%F": "%Y-%m-%d",
                            "%h": "%b",
                            "%r": "%I:%M:%S %p",
                            "%R": "%H:%M",
                            "%T": "%H:%M:%S",
                            "%x": "%m/%d/%y",
                            "%X": "%H:%M:%S",
                            "%Ec": "%c",
                            "%EC": "%C",
                            "%Ex": "%m/%d/%y",
                            "%EX": "%H:%M:%S",
                            "%Ey": "%y",
                            "%EY": "%Y",
                            "%Od": "%d",
                            "%Oe": "%e",
                            "%OH": "%H",
                            "%OI": "%I",
                            "%Om": "%m",
                            "%OM": "%M",
                            "%OS": "%S",
                            "%Ou": "%u",
                            "%OU": "%U",
                            "%OV": "%V",
                            "%Ow": "%w",
                            "%OW": "%W",
                            "%Oy": "%y"
                        })
                            kt = kt.replace(new RegExp(Kn,"g"), Wn[Kn]);
                        var $r = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" ")
                          , Or = "January February March April May June July August September October November December".split(" ");
                        for (Kn in Wn = {
                            "%a": function(Ht) {
                                return $r[Ht.Ja].substring(0, 3)
                            },
                            "%A": function(Ht) {
                                return $r[Ht.Ja]
                            },
                            "%b": function(Ht) {
                                return Or[Ht.Ta].substring(0, 3)
                            },
                            "%B": function(Ht) {
                                return Or[Ht.Ta]
                            },
                            "%C": function(Ht) {
                                return ln((Ht.Na + 1900) / 100 | 0, 2)
                            },
                            "%d": function(Ht) {
                                return ln(Ht.Va, 2)
                            },
                            "%e": function(Ht) {
                                return nn(Ht.Va, 2, " ")
                            },
                            "%g": function(Ht) {
                                return tr(Ht).toString().substring(2)
                            },
                            "%G": function(Ht) {
                                return tr(Ht)
                            },
                            "%H": function(Ht) {
                                return ln(Ht.Sa, 2)
                            },
                            "%I": function(Ht) {
                                return (Ht = Ht.Sa) == 0 ? Ht = 12 : 12 < Ht && (Ht -= 12),
                                ln(Ht, 2)
                            },
                            "%j": function(Ht) {
                                for (var Pn = 0, Un = 0; Un <= Ht.Ta - 1; Pn += (or(Ht.Na + 1900) ? yr : br)[Un++])
                                    ;
                                return ln(Ht.Va + Pn, 3)
                            },
                            "%m": function(Ht) {
                                return ln(Ht.Ta + 1, 2)
                            },
                            "%M": function(Ht) {
                                return ln(Ht.sb, 2)
                            },
                            "%n": function() {
                                return `
`
                            },
                            "%p": function(Ht) {
                                return 0 <= Ht.Sa && 12 > Ht.Sa ? "AM" : "PM"
                            },
                            "%S": function(Ht) {
                                return ln(Ht.tb, 2)
                            },
                            "%t": function() {
                                return "	"
                            },
                            "%u": function(Ht) {
                                return Ht.Ja || 7
                            },
                            "%U": function(Ht) {
                                return ln(Math.floor((Ht.Ma + 7 - Ht.Ja) / 7), 2)
                            },
                            "%V": function(Ht) {
                                var Pn = Math.floor((Ht.Ma + 7 - (Ht.Ja + 6) % 7) / 7);
                                if (2 >= (Ht.Ja + 371 - Ht.Ma - 2) % 7 && Pn++,
                                Pn)
                                    Pn == 53 && ((Un = (Ht.Ja + 371 - Ht.Ma) % 7) == 4 || Un == 3 && or(Ht.Na) || (Pn = 1));
                                else {
                                    Pn = 52;
                                    var Un = (Ht.Ja + 7 - Ht.Ma - 1) % 7;
                                    (Un == 4 || Un == 5 && or(Ht.Na % 400 - 1)) && Pn++
                                }
                                return ln(Pn, 2)
                            },
                            "%w": function(Ht) {
                                return Ht.Ja
                            },
                            "%W": function(Ht) {
                                return ln(Math.floor((Ht.Ma + 7 - (Ht.Ja + 6) % 7) / 7), 2)
                            },
                            "%y": function(Ht) {
                                return (Ht.Na + 1900).toString().substring(2)
                            },
                            "%Y": function(Ht) {
                                return Ht.Na + 1900
                            },
                            "%z": function(Ht) {
                                var Pn = 0 <= (Ht = Ht.rb);
                                return Ht = Math.abs(Ht) / 60,
                                (Pn ? "+" : "-") + ("0000" + (Ht / 60 * 100 + Ht % 60)).slice(-4)
                            },
                            "%Z": function(Ht) {
                                return Ht.ub
                            },
                            "%%": function() {
                                return "%"
                            }
                        },
                        kt = kt.replace(/%%/g, "\0\0"),
                        Wn)
                            kt.includes(Kn) && (kt = kt.replace(new RegExp(Kn,"g"), Wn[Kn](zt)));
                        return Kn = function(Ht) {
                            var Pn = Array(rn(Ht) + 1);
                            return qt(Ht, Pn, 0, Pn.length),
                            Pn
                        }(kt = kt.replace(/\0\0/g, "%")),
                        Kn.length > Ct ? 0 : (function(Ht, Pn) {
                            _e().set(Ht, Pn >>> 0)
                        }(Kn, St),
                        Kn.length - 1)
                    }
                    fn.Ua();
                    var Ar = [null, Vn, xt, Zt, en, Jt, pn, vn, hn, Ft, Qt, yn, wn, Ln, Hn, Rn, Cn, Qn, er, sn, ir, hr, pr, gr, mr, _r]
                      , Dr = {
                        b: function(St) {
                            return cr(St + 24) + 24
                        },
                        c: function(St, Ct, kt) {
                            throw new Wt(St).Ua(Ct, kt),
                            St
                        },
                        L: function(St) {
                            wr(St, !_t, 1, !gt),
                            fn.Za()
                        },
                        l: function(St) {
                            yt ? postMessage({
                                cmd: "cleanupThread",
                                thread: St
                            }) : On(St)
                        },
                        D: an,
                        i: en,
                        R: Jt,
                        z: pn,
                        B: vn,
                        T: hn,
                        P: Ft,
                        I: Qt,
                        O: yn,
                        p: wn,
                        A: Ln,
                        x: Hn,
                        Q: Rn,
                        y: Cn,
                        r: function() {},
                        j: function() {
                            dn("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")
                        },
                        s: function() {
                            dn("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")
                        },
                        q: function() {
                            return Date.now()
                        },
                        E: function() {
                            return 2097152
                        },
                        V: function() {
                            return !0
                        },
                        F: function(St, Ct, kt, zt) {
                            if (St == Ct)
                                setTimeout( () => zn(zt));
                            else if (yt)
                                postMessage({
                                    targetThread: St,
                                    cmd: "processProxyingQueue",
                                    queue: zt
                                });
                            else {
                                if (!(St = fn.La[St]))
                                    return;
                                St.postMessage({
                                    cmd: "processProxyingQueue",
                                    queue: zt
                                })
                            }
                            return 1
                        },
                        K: function() {
                            return -1
                        },
                        W: function(St, Ct) {
                            St = new Date(1e3 * qn(St)),
                            nt()[Ct >> 2 >>> 0] = St.getUTCSeconds(),
                            nt()[Ct + 4 >> 2 >>> 0] = St.getUTCMinutes(),
                            nt()[Ct + 8 >> 2 >>> 0] = St.getUTCHours(),
                            nt()[Ct + 12 >> 2 >>> 0] = St.getUTCDate(),
                            nt()[Ct + 16 >> 2 >>> 0] = St.getUTCMonth(),
                            nt()[Ct + 20 >> 2 >>> 0] = St.getUTCFullYear() - 1900,
                            nt()[Ct + 24 >> 2 >>> 0] = St.getUTCDay(),
                            St = (St.getTime() - Date.UTC(St.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0,
                            nt()[Ct + 28 >> 2 >>> 0] = St
                        },
                        X: function(St, Ct) {
                            St = new Date(1e3 * qn(St)),
                            nt()[Ct >> 2 >>> 0] = St.getSeconds(),
                            nt()[Ct + 4 >> 2 >>> 0] = St.getMinutes(),
                            nt()[Ct + 8 >> 2 >>> 0] = St.getHours(),
                            nt()[Ct + 12 >> 2 >>> 0] = St.getDate(),
                            nt()[Ct + 16 >> 2 >>> 0] = St.getMonth(),
                            nt()[Ct + 20 >> 2 >>> 0] = St.getFullYear() - 1900,
                            nt()[Ct + 24 >> 2 >>> 0] = St.getDay();
                            var kt = new Date(St.getFullYear(),0,1)
                              , zt = (St.getTime() - kt.getTime()) / 864e5 | 0;
                            nt()[Ct + 28 >> 2 >>> 0] = zt,
                            nt()[Ct + 36 >> 2 >>> 0] = -60 * St.getTimezoneOffset(),
                            zt = new Date(St.getFullYear(),6,1).getTimezoneOffset(),
                            St = 0 | (zt != (kt = kt.getTimezoneOffset()) && St.getTimezoneOffset() == Math.min(kt, zt)),
                            nt()[Ct + 32 >> 2 >>> 0] = St
                        },
                        Y: function(St) {
                            var Ct = new Date(nt()[St + 20 >> 2 >>> 0] + 1900,nt()[St + 16 >> 2 >>> 0],nt()[St + 12 >> 2 >>> 0],nt()[St + 8 >> 2 >>> 0],nt()[St + 4 >> 2 >>> 0],nt()[St >> 2 >>> 0],0)
                              , kt = nt()[St + 32 >> 2 >>> 0]
                              , zt = Ct.getTimezoneOffset()
                              , nn = new Date(Ct.getFullYear(),0,1)
                              , ln = new Date(Ct.getFullYear(),6,1).getTimezoneOffset()
                              , xn = nn.getTimezoneOffset()
                              , Gn = Math.min(xn, ln);
                            return 0 > kt ? nt()[St + 32 >> 2 >>> 0] = +(ln != xn && Gn == zt) : 0 < kt != (Gn == zt) && (ln = Math.max(xn, ln),
                            Ct.setTime(Ct.getTime() + 6e4 * ((0 < kt ? Gn : ln) - zt))),
                            nt()[St + 24 >> 2 >>> 0] = Ct.getDay(),
                            kt = (Ct.getTime() - nn.getTime()) / 864e5 | 0,
                            nt()[St + 28 >> 2 >>> 0] = kt,
                            nt()[St >> 2 >>> 0] = Ct.getSeconds(),
                            nt()[St + 4 >> 2 >>> 0] = Ct.getMinutes(),
                            nt()[St + 8 >> 2 >>> 0] = Ct.getHours(),
                            nt()[St + 12 >> 2 >>> 0] = Ct.getDate(),
                            nt()[St + 16 >> 2 >>> 0] = Ct.getMonth(),
                            Ct.getTime() / 1e3 | 0
                        },
                        G: Qn,
                        H: er,
                        Z: function St(Ct, kt, zt) {
                            St.jb || (St.jb = !0,
                            sn(Ct, kt, zt))
                        },
                        d: function() {
                            dn("")
                        },
                        m: function() {
                            if (!mt && !_t) {
                                var St = "Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";
                                Ot || (Ot = {}),
                                Ot[St] || (Ot[St] = 1,
                                mt && (St = "warning: " + St),
                                Pt(St))
                            }
                        },
                        w: function() {
                            return 4294901760
                        },
                        f: Dt,
                        S: function(St, Ct, kt) {
                            tt().copyWithin(St >>> 0, Ct >>> 0, Ct + kt >>> 0)
                        },
                        g: function() {
                            return mt ? s(3993).cpus().length : navigator.hardwareConcurrency
                        },
                        J: function(St, Ct, kt) {
                            En.length = Ct,
                            kt >>= 3;
                            for (var zt = 0; zt < Ct; zt++)
                                En[zt] = ot()[kt + zt >>> 0];
                            return (0 > St ? An[-St - 1] : Ar[St]).apply(null, En)
                        },
                        v: function(St) {
                            var Ct = tt().length;
                            if ((St >>>= 0) <= Ct || 4294901760 < St)
                                return !1;
                            for (var kt = 1; 4 >= kt; kt *= 2) {
                                var zt = Ct * (1 + .2 / kt);
                                zt = Math.min(zt, St + 100663296);
                                var nn = Math;
                                zt = Math.max(St, zt),
                                nn = nn.min.call(nn, 4294901760, zt + (65536 - zt % 65536) % 65536);
                                e: {
                                    try {
                                        At.grow(nn - Ut.byteLength + 65535 >>> 16),
                                        on(At.buffer);
                                        var ln = 1;
                                        break e
                                    } catch {}
                                    ln = void 0
                                }
                                if (ln)
                                    return !0
                            }
                            return !1
                        },
                        U: function() {
                            throw "unwind"
                        },
                        M: ir,
                        N: hr,
                        k: Mn,
                        h: pr,
                        o: gr,
                        t: mr,
                        n: _r,
                        u: function St(Ct, kt) {
                            St.Wa || (St.Wa = function() {
                                if (typeof crypto == "object" && typeof crypto.getRandomValues == "function") {
                                    var nn = new Uint8Array(1);
                                    return () => (crypto.getRandomValues(nn),
                                    nn[0])
                                }
                                if (mt)
                                    try {
                                        var ln = s(760);
                                        return () => ln.randomBytes(1)[0]
                                    } catch {}
                                return () => dn("randomDevice")
                            }());
                            for (var zt = 0; zt < kt; zt++)
                                _e()[Ct + zt >> 0 >>> 0] = St.Wa();
                            return 0
                        },
                        a: At || et.wasmMemory,
                        C: vr,
                        e: function(St, Ct, kt, zt) {
                            return vr(St, Ct, kt, zt)
                        }
                    };
                    (function() {
                        function St(nn, ln) {
                            et.asm = nn.exports,
                            fn.$a.push(et.asm.wa),
                            mn = et.asm.za,
                            bn.unshift(et.asm._),
                            Mt = ln,
                            yt || ($n--,
                            et.monitorRunDependencies && et.monitorRunDependencies($n),
                            $n == 0 && gn && (nn = gn,
                            gn = null,
                            nn()))
                        }
                        function Ct(nn) {
                            St(nn.instance, nn.module)
                        }
                        function kt(nn) {
                            return function() {
                                if (!$t && (gt || _t)) {
                                    if (typeof fetch == "function" && !cn.startsWith("file://"))
                                        return fetch(cn, {
                                            credentials: "same-origin"
                                        }).then(function(ln) {
                                            if (!ln.ok)
                                                throw "failed to load wasm binary file at '" + cn + "'";
                                            return ln.arrayBuffer()
                                        }).catch(function() {
                                            return kn()
                                        });
                                    if (at)
                                        return new Promise(function(ln, xn) {
                                            at(cn, function(Gn) {
                                                ln(new Uint8Array(Gn))
                                            }, xn)
                                        }
                                        )
                                }
                                return Promise.resolve().then(function() {
                                    return kn()
                                })
                            }().then(function(ln) {
                                return WebAssembly.instantiate(ln, zt)
                            }).then(function(ln) {
                                return ln
                            }).then(nn, function(ln) {
                                Pt("failed to asynchronously prepare wasm: " + ln),
                                dn(ln)
                            })
                        }
                        var zt = {
                            a: Dr
                        };
                        if (yt || ($n++,
                        et.monitorRunDependencies && et.monitorRunDependencies($n)),
                        et.instantiateWasm)
                            try {
                                return et.instantiateWasm(zt, St)
                            } catch (nn) {
                                return Pt("Module.instantiateWasm callback failed with error: " + nn),
                                !1
                            }
                        ($t || typeof WebAssembly.instantiateStreaming != "function" || Dn() || cn.startsWith("file://") || mt || typeof fetch != "function" ? kt(Ct) : fetch(cn, {
                            credentials: "same-origin"
                        }).then(function(nn) {
                            return WebAssembly.instantiateStreaming(nn, zt).then(Ct, function(ln) {
                                return Pt("wasm streaming compile failed: " + ln),
                                Pt("falling back to ArrayBuffer instantiation"),
                                kt(Ct)
                            })
                        })).catch(it)
                    }
                    )(),
                    et.___wasm_call_ctors = function() {
                        return (et.___wasm_call_ctors = et.asm._).apply(null, arguments)
                    }
                    ,
                    et._OrtInit = function() {
                        return (et._OrtInit = et.asm.$).apply(null, arguments)
                    }
                    ,
                    et._OrtCreateSessionOptions = function() {
                        return (et._OrtCreateSessionOptions = et.asm.aa).apply(null, arguments)
                    }
                    ,
                    et._OrtAppendExecutionProvider = function() {
                        return (et._OrtAppendExecutionProvider = et.asm.ba).apply(null, arguments)
                    }
                    ,
                    et._OrtAddSessionConfigEntry = function() {
                        return (et._OrtAddSessionConfigEntry = et.asm.ca).apply(null, arguments)
                    }
                    ,
                    et._OrtReleaseSessionOptions = function() {
                        return (et._OrtReleaseSessionOptions = et.asm.da).apply(null, arguments)
                    }
                    ,
                    et._OrtCreateSession = function() {
                        return (et._OrtCreateSession = et.asm.ea).apply(null, arguments)
                    }
                    ,
                    et._OrtReleaseSession = function() {
                        return (et._OrtReleaseSession = et.asm.fa).apply(null, arguments)
                    }
                    ,
                    et._OrtGetInputCount = function() {
                        return (et._OrtGetInputCount = et.asm.ga).apply(null, arguments)
                    }
                    ,
                    et._OrtGetOutputCount = function() {
                        return (et._OrtGetOutputCount = et.asm.ha).apply(null, arguments)
                    }
                    ,
                    et._OrtGetInputName = function() {
                        return (et._OrtGetInputName = et.asm.ia).apply(null, arguments)
                    }
                    ,
                    et._OrtGetOutputName = function() {
                        return (et._OrtGetOutputName = et.asm.ja).apply(null, arguments)
                    }
                    ,
                    et._OrtFree = function() {
                        return (et._OrtFree = et.asm.ka).apply(null, arguments)
                    }
                    ,
                    et._OrtCreateTensor = function() {
                        return (et._OrtCreateTensor = et.asm.la).apply(null, arguments)
                    }
                    ,
                    et._OrtGetTensorData = function() {
                        return (et._OrtGetTensorData = et.asm.ma).apply(null, arguments)
                    }
                    ,
                    et._OrtReleaseTensor = function() {
                        return (et._OrtReleaseTensor = et.asm.na).apply(null, arguments)
                    }
                    ,
                    et._OrtCreateRunOptions = function() {
                        return (et._OrtCreateRunOptions = et.asm.oa).apply(null, arguments)
                    }
                    ,
                    et._OrtAddRunConfigEntry = function() {
                        return (et._OrtAddRunConfigEntry = et.asm.pa).apply(null, arguments)
                    }
                    ,
                    et._OrtReleaseRunOptions = function() {
                        return (et._OrtReleaseRunOptions = et.asm.qa).apply(null, arguments)
                    }
                    ,
                    et._OrtRun = function() {
                        return (et._OrtRun = et.asm.ra).apply(null, arguments)
                    }
                    ,
                    et._OrtEndProfiling = function() {
                        return (et._OrtEndProfiling = et.asm.sa).apply(null, arguments)
                    }
                    ;
                    var sr = et._pthread_self = function() {
                        return (sr = et._pthread_self = et.asm.ta).apply(null, arguments)
                    }
                      , cr = et._malloc = function() {
                        return (cr = et._malloc = et.asm.ua).apply(null, arguments)
                    }
                    ;
                    et._free = function() {
                        return (et._free = et.asm.va).apply(null, arguments)
                    }
                    ,
                    et.__emscripten_tls_init = function() {
                        return (et.__emscripten_tls_init = et.asm.wa).apply(null, arguments)
                    }
                    ;
                    var wr = et.__emscripten_thread_init = function() {
                        return (wr = et.__emscripten_thread_init = et.asm.xa).apply(null, arguments)
                    }
                    ;
                    et.__emscripten_thread_crashed = function() {
                        return (et.__emscripten_thread_crashed = et.asm.ya).apply(null, arguments)
                    }
                    ;
                    var ar, xr = et._emscripten_run_in_main_runtime_thread_js = function() {
                        return (xr = et._emscripten_run_in_main_runtime_thread_js = et.asm.Aa).apply(null, arguments)
                    }
                    , Er = et.__emscripten_proxy_execute_task_queue = function() {
                        return (Er = et.__emscripten_proxy_execute_task_queue = et.asm.Ba).apply(null, arguments)
                    }
                    , ur = et.__emscripten_thread_free_data = function() {
                        return (ur = et.__emscripten_thread_free_data = et.asm.Ca).apply(null, arguments)
                    }
                    , Sr = et.__emscripten_thread_exit = function() {
                        return (Sr = et.__emscripten_thread_exit = et.asm.Da).apply(null, arguments)
                    }
                    , Tr = et._emscripten_stack_set_limits = function() {
                        return (Tr = et._emscripten_stack_set_limits = et.asm.Ea).apply(null, arguments)
                    }
                    , dr = et.stackSave = function() {
                        return (dr = et.stackSave = et.asm.Fa).apply(null, arguments)
                    }
                    , lr = et.stackRestore = function() {
                        return (lr = et.stackRestore = et.asm.Ga).apply(null, arguments)
                    }
                    , fr = et.stackAlloc = function() {
                        return (fr = et.stackAlloc = et.asm.Ha).apply(null, arguments)
                    }
                    ;
                    function Pr() {
                        function St() {
                            if (!ar && (ar = !0,
                            et.calledRun = !0,
                            !Xt) && (yt || It(bn),
                            j(et),
                            et.onRuntimeInitialized && et.onRuntimeInitialized(),
                            !yt)) {
                                if (et.postRun)
                                    for (typeof et.postRun == "function" && (et.postRun = [et.postRun]); et.postRun.length; ) {
                                        var Ct = et.postRun.shift();
                                        In.unshift(Ct)
                                    }
                                It(In)
                            }
                        }
                        if (!(0 < $n))
                            if (yt)
                                j(et),
                                yt || It(bn),
                                postMessage({
                                    cmd: "loaded"
                                });
                            else {
                                if (et.preRun)
                                    for (typeof et.preRun == "function" && (et.preRun = [et.preRun]); et.preRun.length; )
                                        Nn();
                                It(Sn),
                                0 < $n || (et.setStatus ? (et.setStatus("Running..."),
                                setTimeout(function() {
                                    setTimeout(function() {
                                        et.setStatus("")
                                    }, 1),
                                    St()
                                }, 1)) : St())
                            }
                    }
                    if (et.___cxa_is_pointer_type = function() {
                        return (et.___cxa_is_pointer_type = et.asm.Ia).apply(null, arguments)
                    }
                    ,
                    et.UTF8ToString = Kt,
                    et.stringToUTF8 = function(St, Ct, kt) {
                        return qt(St, tt(), Ct, kt)
                    }
                    ,
                    et.lengthBytesUTF8 = rn,
                    et.keepRuntimeAlive = function() {
                        return Rt
                    }
                    ,
                    et.wasmMemory = At,
                    et.stackSave = dr,
                    et.stackRestore = lr,
                    et.stackAlloc = fr,
                    et.ExitStatus = Fn,
                    et.PThread = fn,
                    gn = function St() {
                        ar || Pr(),
                        ar || (gn = St)
                    }
                    ,
                    et.preInit)
                        for (typeof et.preInit == "function" && (et.preInit = [et.preInit]); 0 < et.preInit.length; )
                            et.preInit.pop()();
                    return Pr(),
                    $.ready
                }
                );
                o.exports = _
            }
            ,
            932: (o, i, s) => {
                var a, _ = (a = (a = typeof document < "u" && document.currentScript ? document.currentScript.src : void 0) || "/index.js",
                function($) {
                    var _e, tt, nt;
                    $ = $ || {},
                    _e || (_e = $ !== void 0 ? $ : {}),
                    _e.ready = new Promise(function(It, xt) {
                        tt = It,
                        nt = xt
                    }
                    );
                    var rt, ot, et, j, it, st, at = Object.assign({}, _e), lt = "./this.program", ct = (It, xt) => {
                        throw xt
                    }
                    , ut = typeof window == "object", dt = typeof importScripts == "function", ft = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string", ht = "";
                    ft ? (ht = dt ? s(908).dirname(ht) + "/" : "//",
                    st = () => {
                        it || (j = s(1384),
                        it = s(908))
                    }
                    ,
                    rt = function(It, xt) {
                        return st(),
                        It = it.normalize(It),
                        j.readFileSync(It, xt ? void 0 : "utf8")
                    }
                    ,
                    et = It => ((It = rt(It, !0)).buffer || (It = new Uint8Array(It)),
                    It),
                    ot = (It, xt, Ot) => {
                        st(),
                        It = it.normalize(It),
                        j.readFile(It, function(Dt, Bt) {
                            Dt ? Ot(Dt) : xt(Bt.buffer)
                        })
                    }
                    ,
                    1 < process.argv.length && (lt = process.argv[1].replace(/\\/g, "/")),
                    process.argv.slice(2),
                    process.on("uncaughtException", function(It) {
                        if (!(It instanceof _n))
                            throw It
                    }),
                    process.on("unhandledRejection", function(It) {
                        throw It
                    }),
                    ct = (It, xt) => {
                        if (mt)
                            throw process.exitCode = It,
                            xt;
                        xt instanceof _n || _t("exiting due to exception: " + xt),
                        process.exit(It)
                    }
                    ,
                    _e.inspect = function() {
                        return "[Emscripten Module object]"
                    }
                    ) : (ut || dt) && (dt ? ht = self.location.href : typeof document < "u" && document.currentScript && (ht = document.currentScript.src),
                    a && (ht = a),
                    ht = ht.indexOf("blob:") !== 0 ? ht.substr(0, ht.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "",
                    rt = It => {
                        var xt = new XMLHttpRequest;
                        return xt.open("GET", It, !1),
                        xt.send(null),
                        xt.responseText
                    }
                    ,
                    dt && (et = It => {
                        var xt = new XMLHttpRequest;
                        return xt.open("GET", It, !1),
                        xt.responseType = "arraybuffer",
                        xt.send(null),
                        new Uint8Array(xt.response)
                    }
                    ),
                    ot = (It, xt, Ot) => {
                        var Dt = new XMLHttpRequest;
                        Dt.open("GET", It, !0),
                        Dt.responseType = "arraybuffer",
                        Dt.onload = () => {
                            Dt.status == 200 || Dt.status == 0 && Dt.response ? xt(Dt.response) : Ot()
                        }
                        ,
                        Dt.onerror = Ot,
                        Dt.send(null)
                    }
                    );
                    var pt, gt = _e.print || console.log.bind(console), _t = _e.printErr || console.warn.bind(console);
                    Object.assign(_e, at),
                    at = null,
                    _e.thisProgram && (lt = _e.thisProgram),
                    _e.quit && (ct = _e.quit),
                    _e.wasmBinary && (pt = _e.wasmBinary);
                    var mt = _e.noExitRuntime || !0;
                    typeof WebAssembly != "object" && Kt("no native wasm support detected");
                    var yt, bt, vt, wt, Tt, $t, Et = !1, Pt = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
                    function Rt(It, xt, Ot) {
                        var Dt = (xt >>>= 0) + Ot;
                        for (Ot = xt; It[Ot] && !(Ot >= Dt); )
                            ++Ot;
                        if (16 < Ot - xt && It.buffer && Pt)
                            return Pt.decode(It.subarray(xt, Ot));
                        for (Dt = ""; xt < Ot; ) {
                            var Bt = It[xt++];
                            if (128 & Bt) {
                                var Wt = 63 & It[xt++];
                                if ((224 & Bt) == 192)
                                    Dt += String.fromCharCode((31 & Bt) << 6 | Wt);
                                else {
                                    var Zt = 63 & It[xt++];
                                    65536 > (Bt = (240 & Bt) == 224 ? (15 & Bt) << 12 | Wt << 6 | Zt : (7 & Bt) << 18 | Wt << 12 | Zt << 6 | 63 & It[xt++]) ? Dt += String.fromCharCode(Bt) : (Bt -= 65536,
                                    Dt += String.fromCharCode(55296 | Bt >> 10, 56320 | 1023 & Bt))
                                }
                            } else
                                Dt += String.fromCharCode(Bt)
                        }
                        return Dt
                    }
                    function At(It, xt) {
                        return (It >>>= 0) ? Rt(wt, It, xt) : ""
                    }
                    function Mt(It, xt, Ot, Dt) {
                        if (!(0 < Dt))
                            return 0;
                        var Bt = Ot >>>= 0;
                        Dt = Ot + Dt - 1;
                        for (var Wt = 0; Wt < It.length; ++Wt) {
                            var Zt = It.charCodeAt(Wt);
                            if (55296 <= Zt && 57343 >= Zt && (Zt = 65536 + ((1023 & Zt) << 10) | 1023 & It.charCodeAt(++Wt)),
                            127 >= Zt) {
                                if (Ot >= Dt)
                                    break;
                                xt[Ot++ >>> 0] = Zt
                            } else {
                                if (2047 >= Zt) {
                                    if (Ot + 1 >= Dt)
                                        break;
                                    xt[Ot++ >>> 0] = 192 | Zt >> 6
                                } else {
                                    if (65535 >= Zt) {
                                        if (Ot + 2 >= Dt)
                                            break;
                                        xt[Ot++ >>> 0] = 224 | Zt >> 12
                                    } else {
                                        if (Ot + 3 >= Dt)
                                            break;
                                        xt[Ot++ >>> 0] = 240 | Zt >> 18,
                                        xt[Ot++ >>> 0] = 128 | Zt >> 12 & 63
                                    }
                                    xt[Ot++ >>> 0] = 128 | Zt >> 6 & 63
                                }
                                xt[Ot++ >>> 0] = 128 | 63 & Zt
                            }
                        }
                        return xt[Ot >>> 0] = 0,
                        Ot - Bt
                    }
                    function Ut(It) {
                        for (var xt = 0, Ot = 0; Ot < It.length; ++Ot) {
                            var Dt = It.charCodeAt(Ot);
                            127 >= Dt ? xt++ : 2047 >= Dt ? xt += 2 : 55296 <= Dt && 57343 >= Dt ? (xt += 4,
                            ++Ot) : xt += 3
                        }
                        return xt
                    }
                    function Lt() {
                        var It = yt.buffer;
                        bt = It,
                        _e.HEAP8 = vt = new Int8Array(It),
                        _e.HEAP16 = new Int16Array(It),
                        _e.HEAP32 = Tt = new Int32Array(It),
                        _e.HEAPU8 = wt = new Uint8Array(It),
                        _e.HEAPU16 = new Uint16Array(It),
                        _e.HEAPU32 = $t = new Uint32Array(It),
                        _e.HEAPF32 = new Float32Array(It),
                        _e.HEAPF64 = new Float64Array(It)
                    }
                    var tn = []
                      , Vt = []
                      , Nt = [];
                    function Yt() {
                        var It = _e.preRun.shift();
                        tn.unshift(It)
                    }
                    var Xt, jt = 0, Gt = null;
                    function Kt(It) {
                        throw _e.onAbort && _e.onAbort(It),
                        _t(It = "Aborted(" + It + ")"),
                        Et = !0,
                        It = new WebAssembly.RuntimeError(It + ". Build with -sASSERTIONS for more info."),
                        nt(It),
                        It
                    }
                    function qt() {
                        return Xt.startsWith("data:application/octet-stream;base64,")
                    }
                    if (Xt = "ort-wasm.wasm",
                    !qt()) {
                        var rn = Xt;
                        Xt = _e.locateFile ? _e.locateFile(rn, ht) : ht + rn
                    }
                    function on() {
                        var It = Xt;
                        try {
                            if (It == Xt && pt)
                                return new Uint8Array(pt);
                            if (et)
                                return et(It);
                            throw "both async and sync fetching of the wasm failed"
                        } catch (xt) {
                            Kt(xt)
                        }
                    }
                    function _n(It) {
                        this.name = "ExitStatus",
                        this.message = "Program terminated with exit(" + It + ")",
                        this.status = It
                    }
                    function mn(It) {
                        for (; 0 < It.length; )
                            It.shift()(_e)
                    }
                    function Sn(It) {
                        this.sa = It - 24,
                        this.Ia = function(xt) {
                            $t[this.sa + 4 >> 2 >>> 0] = xt
                        }
                        ,
                        this.Ba = function(xt) {
                            $t[this.sa + 8 >> 2 >>> 0] = xt
                        }
                        ,
                        this.Ga = function() {
                            Tt[this.sa >> 2 >>> 0] = 0
                        }
                        ,
                        this.Aa = function() {
                            vt[this.sa + 12 >> 0 >>> 0] = 0
                        }
                        ,
                        this.Ha = function() {
                            vt[this.sa + 13 >> 0 >>> 0] = 0
                        }
                        ,
                        this.ya = function(xt, Ot) {
                            this.za(),
                            this.Ia(xt),
                            this.Ba(Ot),
                            this.Ga(),
                            this.Aa(),
                            this.Ha()
                        }
                        ,
                        this.za = function() {
                            $t[this.sa + 16 >> 2 >>> 0] = 0
                        }
                    }
                    function bn(It) {
                        var xt = Ut(It) + 1
                          , Ot = Fn(xt);
                        return Ot && Mt(It, vt, Ot, xt),
                        Ot
                    }
                    var In = {};
                    function Nn() {
                        if (!cn) {
                            var It, xt = {
                                USER: "web_user",
                                LOGNAME: "web_user",
                                PATH: "/",
                                PWD: "/",
                                HOME: "/home/web_user",
                                LANG: (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8",
                                _: lt || "./this.program"
                            };
                            for (It in In)
                                In[It] === void 0 ? delete xt[It] : xt[It] = In[It];
                            var Ot = [];
                            for (It in xt)
                                Ot.push(It + "=" + xt[It]);
                            cn = Ot
                        }
                        return cn
                    }
                    var cn, $n = [null, [], []];
                    function gn(It) {
                        return It % 4 == 0 && (It % 100 != 0 || It % 400 == 0)
                    }
                    var dn = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
                      , Dn = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
                    function kn(It, xt, Ot, Dt) {
                        function Bt(Ft, Qt, yn) {
                            for (Ft = typeof Ft == "number" ? Ft.toString() : Ft || ""; Ft.length < Qt; )
                                Ft = yn[0] + Ft;
                            return Ft
                        }
                        function Wt(Ft, Qt) {
                            return Bt(Ft, Qt, "0")
                        }
                        function Zt(Ft, Qt) {
                            function yn(Ln) {
                                return 0 > Ln ? -1 : 0 < Ln ? 1 : 0
                            }
                            var wn;
                            return (wn = yn(Ft.getFullYear() - Qt.getFullYear())) === 0 && (wn = yn(Ft.getMonth() - Qt.getMonth())) === 0 && (wn = yn(Ft.getDate() - Qt.getDate())),
                            wn
                        }
                        function an(Ft) {
                            switch (Ft.getDay()) {
                            case 0:
                                return new Date(Ft.getFullYear() - 1,11,29);
                            case 1:
                                return Ft;
                            case 2:
                                return new Date(Ft.getFullYear(),0,3);
                            case 3:
                                return new Date(Ft.getFullYear(),0,2);
                            case 4:
                                return new Date(Ft.getFullYear(),0,1);
                            case 5:
                                return new Date(Ft.getFullYear() - 1,11,31);
                            case 6:
                                return new Date(Ft.getFullYear() - 1,11,30)
                            }
                        }
                        function en(Ft) {
                            var Qt = Ft.qa;
                            for (Ft = new Date(new Date(Ft.ra + 1900,0,1).getTime()); 0 < Qt; ) {
                                var yn = Ft.getMonth()
                                  , wn = (gn(Ft.getFullYear()) ? dn : Dn)[yn];
                                if (!(Qt > wn - Ft.getDate())) {
                                    Ft.setDate(Ft.getDate() + Qt);
                                    break
                                }
                                Qt -= wn - Ft.getDate() + 1,
                                Ft.setDate(1),
                                11 > yn ? Ft.setMonth(yn + 1) : (Ft.setMonth(0),
                                Ft.setFullYear(Ft.getFullYear() + 1))
                            }
                            return yn = new Date(Ft.getFullYear() + 1,0,4),
                            Qt = an(new Date(Ft.getFullYear(),0,4)),
                            yn = an(yn),
                            0 >= Zt(Qt, Ft) ? 0 >= Zt(yn, Ft) ? Ft.getFullYear() + 1 : Ft.getFullYear() : Ft.getFullYear() - 1
                        }
                        var Jt = Tt[Dt + 40 >> 2 >>> 0];
                        for (var pn in Dt = {
                            Ea: Tt[Dt >> 2 >>> 0],
                            Da: Tt[Dt + 4 >> 2 >>> 0],
                            ta: Tt[Dt + 8 >> 2 >>> 0],
                            va: Tt[Dt + 12 >> 2 >>> 0],
                            ua: Tt[Dt + 16 >> 2 >>> 0],
                            ra: Tt[Dt + 20 >> 2 >>> 0],
                            la: Tt[Dt + 24 >> 2 >>> 0],
                            qa: Tt[Dt + 28 >> 2 >>> 0],
                            Ja: Tt[Dt + 32 >> 2 >>> 0],
                            Ca: Tt[Dt + 36 >> 2 >>> 0],
                            Fa: Jt ? At(Jt) : ""
                        },
                        Ot = At(Ot),
                        Jt = {
                            "%c": "%a %b %d %H:%M:%S %Y",
                            "%D": "%m/%d/%y",
                            "%F": "%Y-%m-%d",
                            "%h": "%b",
                            "%r": "%I:%M:%S %p",
                            "%R": "%H:%M",
                            "%T": "%H:%M:%S",
                            "%x": "%m/%d/%y",
                            "%X": "%H:%M:%S",
                            "%Ec": "%c",
                            "%EC": "%C",
                            "%Ex": "%m/%d/%y",
                            "%EX": "%H:%M:%S",
                            "%Ey": "%y",
                            "%EY": "%Y",
                            "%Od": "%d",
                            "%Oe": "%e",
                            "%OH": "%H",
                            "%OI": "%I",
                            "%Om": "%m",
                            "%OM": "%M",
                            "%OS": "%S",
                            "%Ou": "%u",
                            "%OU": "%U",
                            "%OV": "%V",
                            "%Ow": "%w",
                            "%OW": "%W",
                            "%Oy": "%y"
                        })
                            Ot = Ot.replace(new RegExp(pn,"g"), Jt[pn]);
                        var vn = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" ")
                          , hn = "January February March April May June July August September October November December".split(" ");
                        for (pn in Jt = {
                            "%a": function(Ft) {
                                return vn[Ft.la].substring(0, 3)
                            },
                            "%A": function(Ft) {
                                return vn[Ft.la]
                            },
                            "%b": function(Ft) {
                                return hn[Ft.ua].substring(0, 3)
                            },
                            "%B": function(Ft) {
                                return hn[Ft.ua]
                            },
                            "%C": function(Ft) {
                                return Wt((Ft.ra + 1900) / 100 | 0, 2)
                            },
                            "%d": function(Ft) {
                                return Wt(Ft.va, 2)
                            },
                            "%e": function(Ft) {
                                return Bt(Ft.va, 2, " ")
                            },
                            "%g": function(Ft) {
                                return en(Ft).toString().substring(2)
                            },
                            "%G": function(Ft) {
                                return en(Ft)
                            },
                            "%H": function(Ft) {
                                return Wt(Ft.ta, 2)
                            },
                            "%I": function(Ft) {
                                return (Ft = Ft.ta) == 0 ? Ft = 12 : 12 < Ft && (Ft -= 12),
                                Wt(Ft, 2)
                            },
                            "%j": function(Ft) {
                                for (var Qt = 0, yn = 0; yn <= Ft.ua - 1; Qt += (gn(Ft.ra + 1900) ? dn : Dn)[yn++])
                                    ;
                                return Wt(Ft.va + Qt, 3)
                            },
                            "%m": function(Ft) {
                                return Wt(Ft.ua + 1, 2)
                            },
                            "%M": function(Ft) {
                                return Wt(Ft.Da, 2)
                            },
                            "%n": function() {
                                return `
`
                            },
                            "%p": function(Ft) {
                                return 0 <= Ft.ta && 12 > Ft.ta ? "AM" : "PM"
                            },
                            "%S": function(Ft) {
                                return Wt(Ft.Ea, 2)
                            },
                            "%t": function() {
                                return "	"
                            },
                            "%u": function(Ft) {
                                return Ft.la || 7
                            },
                            "%U": function(Ft) {
                                return Wt(Math.floor((Ft.qa + 7 - Ft.la) / 7), 2)
                            },
                            "%V": function(Ft) {
                                var Qt = Math.floor((Ft.qa + 7 - (Ft.la + 6) % 7) / 7);
                                if (2 >= (Ft.la + 371 - Ft.qa - 2) % 7 && Qt++,
                                Qt)
                                    Qt == 53 && ((yn = (Ft.la + 371 - Ft.qa) % 7) == 4 || yn == 3 && gn(Ft.ra) || (Qt = 1));
                                else {
                                    Qt = 52;
                                    var yn = (Ft.la + 7 - Ft.qa - 1) % 7;
                                    (yn == 4 || yn == 5 && gn(Ft.ra % 400 - 1)) && Qt++
                                }
                                return Wt(Qt, 2)
                            },
                            "%w": function(Ft) {
                                return Ft.la
                            },
                            "%W": function(Ft) {
                                return Wt(Math.floor((Ft.qa + 7 - (Ft.la + 6) % 7) / 7), 2)
                            },
                            "%y": function(Ft) {
                                return (Ft.ra + 1900).toString().substring(2)
                            },
                            "%Y": function(Ft) {
                                return Ft.ra + 1900
                            },
                            "%z": function(Ft) {
                                var Qt = 0 <= (Ft = Ft.Ca);
                                return Ft = Math.abs(Ft) / 60,
                                (Qt ? "+" : "-") + ("0000" + (Ft / 60 * 100 + Ft % 60)).slice(-4)
                            },
                            "%Z": function(Ft) {
                                return Ft.Fa
                            },
                            "%%": function() {
                                return "%"
                            }
                        },
                        Ot = Ot.replace(/%%/g, "\0\0"),
                        Jt)
                            Ot.includes(pn) && (Ot = Ot.replace(new RegExp(pn,"g"), Jt[pn](Dt)));
                        return pn = function(Ft) {
                            var Qt = Array(Ut(Ft) + 1);
                            return Mt(Ft, Qt, 0, Qt.length),
                            Qt
                        }(Ot = Ot.replace(/\0\0/g, "%")),
                        pn.length > xt ? 0 : (vt.set(pn, It >>> 0),
                        pn.length - 1)
                    }
                    var An = {
                        a: function(It) {
                            return Fn(It + 24) + 24
                        },
                        b: function(It, xt, Ot) {
                            throw new Sn(It).ya(xt, Ot),
                            It
                        },
                        g: function() {
                            return 0
                        },
                        I: function() {},
                        w: function() {},
                        y: function() {},
                        K: function() {
                            return 0
                        },
                        G: function() {},
                        C: function() {},
                        F: function() {},
                        k: function() {},
                        x: function() {},
                        u: function() {},
                        H: function() {},
                        v: function() {},
                        n: function() {},
                        p: function() {
                            Kt("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")
                        },
                        o: function() {
                            Kt("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")
                        },
                        l: function() {
                            return Date.now()
                        },
                        L: function() {
                            return !0
                        },
                        M: function(It, xt) {
                            It = new Date(1e3 * ($t[It >>> 2] + 4294967296 * Tt[It + 4 >>> 2])),
                            Tt[xt >> 2 >>> 0] = It.getUTCSeconds(),
                            Tt[xt + 4 >> 2 >>> 0] = It.getUTCMinutes(),
                            Tt[xt + 8 >> 2 >>> 0] = It.getUTCHours(),
                            Tt[xt + 12 >> 2 >>> 0] = It.getUTCDate(),
                            Tt[xt + 16 >> 2 >>> 0] = It.getUTCMonth(),
                            Tt[xt + 20 >> 2 >>> 0] = It.getUTCFullYear() - 1900,
                            Tt[xt + 24 >> 2 >>> 0] = It.getUTCDay(),
                            Tt[xt + 28 >> 2 >>> 0] = (It.getTime() - Date.UTC(It.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0
                        },
                        N: function(It, xt) {
                            It = new Date(1e3 * ($t[It >>> 2] + 4294967296 * Tt[It + 4 >>> 2])),
                            Tt[xt >> 2 >>> 0] = It.getSeconds(),
                            Tt[xt + 4 >> 2 >>> 0] = It.getMinutes(),
                            Tt[xt + 8 >> 2 >>> 0] = It.getHours(),
                            Tt[xt + 12 >> 2 >>> 0] = It.getDate(),
                            Tt[xt + 16 >> 2 >>> 0] = It.getMonth(),
                            Tt[xt + 20 >> 2 >>> 0] = It.getFullYear() - 1900,
                            Tt[xt + 24 >> 2 >>> 0] = It.getDay();
                            var Ot = new Date(It.getFullYear(),0,1);
                            Tt[xt + 28 >> 2 >>> 0] = (It.getTime() - Ot.getTime()) / 864e5 | 0,
                            Tt[xt + 36 >> 2 >>> 0] = -60 * It.getTimezoneOffset();
                            var Dt = new Date(It.getFullYear(),6,1).getTimezoneOffset();
                            Ot = Ot.getTimezoneOffset(),
                            Tt[xt + 32 >> 2 >>> 0] = 0 | (Dt != Ot && It.getTimezoneOffset() == Math.min(Ot, Dt))
                        },
                        O: function(It) {
                            var xt = new Date(Tt[It + 20 >> 2 >>> 0] + 1900,Tt[It + 16 >> 2 >>> 0],Tt[It + 12 >> 2 >>> 0],Tt[It + 8 >> 2 >>> 0],Tt[It + 4 >> 2 >>> 0],Tt[It >> 2 >>> 0],0)
                              , Ot = Tt[It + 32 >> 2 >>> 0]
                              , Dt = xt.getTimezoneOffset()
                              , Bt = new Date(xt.getFullYear(),0,1)
                              , Wt = new Date(xt.getFullYear(),6,1).getTimezoneOffset()
                              , Zt = Bt.getTimezoneOffset()
                              , an = Math.min(Zt, Wt);
                            return 0 > Ot ? Tt[It + 32 >> 2 >>> 0] = +(Wt != Zt && an == Dt) : 0 < Ot != (an == Dt) && (Wt = Math.max(Zt, Wt),
                            xt.setTime(xt.getTime() + 6e4 * ((0 < Ot ? an : Wt) - Dt))),
                            Tt[It + 24 >> 2 >>> 0] = xt.getDay(),
                            Tt[It + 28 >> 2 >>> 0] = (xt.getTime() - Bt.getTime()) / 864e5 | 0,
                            Tt[It >> 2 >>> 0] = xt.getSeconds(),
                            Tt[It + 4 >> 2 >>> 0] = xt.getMinutes(),
                            Tt[It + 8 >> 2 >>> 0] = xt.getHours(),
                            Tt[It + 12 >> 2 >>> 0] = xt.getDate(),
                            Tt[It + 16 >> 2 >>> 0] = xt.getMonth(),
                            xt.getTime() / 1e3 | 0
                        },
                        z: function() {
                            return -52
                        },
                        B: function() {},
                        m: function It(xt, Ot, Dt) {
                            It.xa || (It.xa = !0,
                            function(Bt, Wt, Zt) {
                                function an(hn) {
                                    return (hn = hn.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? hn[1] : "GMT"
                                }
                                var en = new Date().getFullYear()
                                  , Jt = new Date(en,0,1)
                                  , pn = new Date(en,6,1);
                                en = Jt.getTimezoneOffset();
                                var vn = pn.getTimezoneOffset();
                                Tt[Bt >> 2 >>> 0] = 60 * Math.max(en, vn),
                                Tt[Wt >> 2 >>> 0] = +(en != vn),
                                Bt = an(Jt),
                                Wt = an(pn),
                                Bt = bn(Bt),
                                Wt = bn(Wt),
                                vn < en ? ($t[Zt >> 2 >>> 0] = Bt,
                                $t[Zt + 4 >> 2 >>> 0] = Wt) : ($t[Zt >> 2 >>> 0] = Wt,
                                $t[Zt + 4 >> 2 >>> 0] = Bt)
                            }(xt, Ot, Dt))
                        },
                        d: function() {
                            Kt("")
                        },
                        t: function() {
                            return 4294901760
                        },
                        h: ft ? () => {
                            var It = process.hrtime();
                            return 1e3 * It[0] + It[1] / 1e6
                        }
                        : () => performance.now(),
                        J: function(It, xt, Ot) {
                            wt.copyWithin(It >>> 0, xt >>> 0, xt + Ot >>> 0)
                        },
                        f: function(It) {
                            var xt = wt.length;
                            if (4294901760 < (It >>>= 0))
                                return !1;
                            for (var Ot = 1; 4 >= Ot; Ot *= 2) {
                                var Dt = xt * (1 + .2 / Ot);
                                Dt = Math.min(Dt, It + 100663296);
                                var Bt = Math;
                                Dt = Math.max(It, Dt),
                                Bt = Bt.min.call(Bt, 4294901760, Dt + (65536 - Dt % 65536) % 65536);
                                e: {
                                    try {
                                        yt.grow(Bt - bt.byteLength + 65535 >>> 16),
                                        Lt();
                                        var Wt = 1;
                                        break e
                                    } catch {}
                                    Wt = void 0
                                }
                                if (Wt)
                                    return !0
                            }
                            return !1
                        },
                        D: function(It, xt) {
                            var Ot = 0;
                            return Nn().forEach(function(Dt, Bt) {
                                var Wt = xt + Ot;
                                for (Bt = $t[It + 4 * Bt >> 2 >>> 0] = Wt,
                                Wt = 0; Wt < Dt.length; ++Wt)
                                    vt[Bt++ >> 0 >>> 0] = Dt.charCodeAt(Wt);
                                vt[Bt >> 0 >>> 0] = 0,
                                Ot += Dt.length + 1
                            }),
                            0
                        },
                        E: function(It, xt) {
                            var Ot = Nn();
                            $t[It >> 2 >>> 0] = Ot.length;
                            var Dt = 0;
                            return Ot.forEach(function(Bt) {
                                Dt += Bt.length + 1
                            }),
                            $t[xt >> 2 >>> 0] = Dt,
                            0
                        },
                        r: function(It) {
                            mt || (_e.onExit && _e.onExit(It),
                            Et = !0),
                            ct(It, new _n(It))
                        },
                        e: function() {
                            return 52
                        },
                        j: function() {
                            return 52
                        },
                        q: function() {
                            return 70
                        },
                        i: function(It, xt, Ot, Dt) {
                            for (var Bt = 0, Wt = 0; Wt < Ot; Wt++) {
                                var Zt = $t[xt >> 2 >>> 0]
                                  , an = $t[xt + 4 >> 2 >>> 0];
                                xt += 8;
                                for (var en = 0; en < an; en++) {
                                    var Jt = wt[Zt + en >>> 0]
                                      , pn = $n[It];
                                    Jt === 0 || Jt === 10 ? ((It === 1 ? gt : _t)(Rt(pn, 0)),
                                    pn.length = 0) : pn.push(Jt)
                                }
                                Bt += an
                            }
                            return $t[Dt >> 2 >>> 0] = Bt,
                            0
                        },
                        s: function It(xt, Ot) {
                            It.wa || (It.wa = function() {
                                if (typeof crypto == "object" && typeof crypto.getRandomValues == "function") {
                                    var Bt = new Uint8Array(1);
                                    return () => (crypto.getRandomValues(Bt),
                                    Bt[0])
                                }
                                if (ft)
                                    try {
                                        var Wt = s(760);
                                        return () => Wt.randomBytes(1)[0]
                                    } catch {}
                                return () => Kt("randomDevice")
                            }());
                            for (var Dt = 0; Dt < Ot; Dt++)
                                vt[xt + Dt >> 0 >>> 0] = It.wa();
                            return 0
                        },
                        A: kn,
                        c: function(It, xt, Ot, Dt) {
                            return kn(It, xt, Ot, Dt)
                        }
                    };
                    (function() {
                        function It(Bt) {
                            _e.asm = Bt.exports,
                            yt = _e.asm.P,
                            Lt(),
                            Vt.unshift(_e.asm.Q),
                            jt--,
                            _e.monitorRunDependencies && _e.monitorRunDependencies(jt),
                            jt == 0 && Gt && (Bt = Gt,
                            Gt = null,
                            Bt())
                        }
                        function xt(Bt) {
                            It(Bt.instance)
                        }
                        function Ot(Bt) {
                            return function() {
                                if (!pt && (ut || dt)) {
                                    if (typeof fetch == "function" && !Xt.startsWith("file://"))
                                        return fetch(Xt, {
                                            credentials: "same-origin"
                                        }).then(function(Wt) {
                                            if (!Wt.ok)
                                                throw "failed to load wasm binary file at '" + Xt + "'";
                                            return Wt.arrayBuffer()
                                        }).catch(function() {
                                            return on()
                                        });
                                    if (ot)
                                        return new Promise(function(Wt, Zt) {
                                            ot(Xt, function(an) {
                                                Wt(new Uint8Array(an))
                                            }, Zt)
                                        }
                                        )
                                }
                                return Promise.resolve().then(function() {
                                    return on()
                                })
                            }().then(function(Wt) {
                                return WebAssembly.instantiate(Wt, Dt)
                            }).then(function(Wt) {
                                return Wt
                            }).then(Bt, function(Wt) {
                                _t("failed to asynchronously prepare wasm: " + Wt),
                                Kt(Wt)
                            })
                        }
                        var Dt = {
                            a: An
                        };
                        if (jt++,
                        _e.monitorRunDependencies && _e.monitorRunDependencies(jt),
                        _e.instantiateWasm)
                            try {
                                return _e.instantiateWasm(Dt, It)
                            } catch (Bt) {
                                return _t("Module.instantiateWasm callback failed with error: " + Bt),
                                !1
                            }
                        (pt || typeof WebAssembly.instantiateStreaming != "function" || qt() || Xt.startsWith("file://") || ft || typeof fetch != "function" ? Ot(xt) : fetch(Xt, {
                            credentials: "same-origin"
                        }).then(function(Bt) {
                            return WebAssembly.instantiateStreaming(Bt, Dt).then(xt, function(Wt) {
                                return _t("wasm streaming compile failed: " + Wt),
                                _t("falling back to ArrayBuffer instantiation"),
                                Ot(xt)
                            })
                        })).catch(nt)
                    }
                    )(),
                    _e.___wasm_call_ctors = function() {
                        return (_e.___wasm_call_ctors = _e.asm.Q).apply(null, arguments)
                    }
                    ,
                    _e._OrtInit = function() {
                        return (_e._OrtInit = _e.asm.R).apply(null, arguments)
                    }
                    ,
                    _e._OrtCreateSessionOptions = function() {
                        return (_e._OrtCreateSessionOptions = _e.asm.S).apply(null, arguments)
                    }
                    ,
                    _e._OrtAppendExecutionProvider = function() {
                        return (_e._OrtAppendExecutionProvider = _e.asm.T).apply(null, arguments)
                    }
                    ,
                    _e._OrtAddSessionConfigEntry = function() {
                        return (_e._OrtAddSessionConfigEntry = _e.asm.U).apply(null, arguments)
                    }
                    ,
                    _e._OrtReleaseSessionOptions = function() {
                        return (_e._OrtReleaseSessionOptions = _e.asm.V).apply(null, arguments)
                    }
                    ,
                    _e._OrtCreateSession = function() {
                        return (_e._OrtCreateSession = _e.asm.W).apply(null, arguments)
                    }
                    ,
                    _e._OrtReleaseSession = function() {
                        return (_e._OrtReleaseSession = _e.asm.X).apply(null, arguments)
                    }
                    ,
                    _e._OrtGetInputCount = function() {
                        return (_e._OrtGetInputCount = _e.asm.Y).apply(null, arguments)
                    }
                    ,
                    _e._OrtGetOutputCount = function() {
                        return (_e._OrtGetOutputCount = _e.asm.Z).apply(null, arguments)
                    }
                    ,
                    _e._OrtGetInputName = function() {
                        return (_e._OrtGetInputName = _e.asm._).apply(null, arguments)
                    }
                    ,
                    _e._OrtGetOutputName = function() {
                        return (_e._OrtGetOutputName = _e.asm.$).apply(null, arguments)
                    }
                    ,
                    _e._OrtFree = function() {
                        return (_e._OrtFree = _e.asm.aa).apply(null, arguments)
                    }
                    ,
                    _e._OrtCreateTensor = function() {
                        return (_e._OrtCreateTensor = _e.asm.ba).apply(null, arguments)
                    }
                    ,
                    _e._OrtGetTensorData = function() {
                        return (_e._OrtGetTensorData = _e.asm.ca).apply(null, arguments)
                    }
                    ,
                    _e._OrtReleaseTensor = function() {
                        return (_e._OrtReleaseTensor = _e.asm.da).apply(null, arguments)
                    }
                    ,
                    _e._OrtCreateRunOptions = function() {
                        return (_e._OrtCreateRunOptions = _e.asm.ea).apply(null, arguments)
                    }
                    ,
                    _e._OrtAddRunConfigEntry = function() {
                        return (_e._OrtAddRunConfigEntry = _e.asm.fa).apply(null, arguments)
                    }
                    ,
                    _e._OrtReleaseRunOptions = function() {
                        return (_e._OrtReleaseRunOptions = _e.asm.ga).apply(null, arguments)
                    }
                    ,
                    _e._OrtRun = function() {
                        return (_e._OrtRun = _e.asm.ha).apply(null, arguments)
                    }
                    ,
                    _e._OrtEndProfiling = function() {
                        return (_e._OrtEndProfiling = _e.asm.ia).apply(null, arguments)
                    }
                    ;
                    var Fn = _e._malloc = function() {
                        return (Fn = _e._malloc = _e.asm.ja).apply(null, arguments)
                    }
                    ;
                    _e._free = function() {
                        return (_e._free = _e.asm.ka).apply(null, arguments)
                    }
                    ;
                    var On, jn = _e.stackSave = function() {
                        return (jn = _e.stackSave = _e.asm.ma).apply(null, arguments)
                    }
                    , Vn = _e.stackRestore = function() {
                        return (Vn = _e.stackRestore = _e.asm.na).apply(null, arguments)
                    }
                    , Mn = _e.stackAlloc = function() {
                        return (Mn = _e.stackAlloc = _e.asm.oa).apply(null, arguments)
                    }
                    ;
                    function fn() {
                        function It() {
                            if (!On && (On = !0,
                            _e.calledRun = !0,
                            !Et)) {
                                if (mn(Vt),
                                tt(_e),
                                _e.onRuntimeInitialized && _e.onRuntimeInitialized(),
                                _e.postRun)
                                    for (typeof _e.postRun == "function" && (_e.postRun = [_e.postRun]); _e.postRun.length; ) {
                                        var xt = _e.postRun.shift();
                                        Nt.unshift(xt)
                                    }
                                mn(Nt)
                            }
                        }
                        if (!(0 < jt)) {
                            if (_e.preRun)
                                for (typeof _e.preRun == "function" && (_e.preRun = [_e.preRun]); _e.preRun.length; )
                                    Yt();
                            mn(tn),
                            0 < jt || (_e.setStatus ? (_e.setStatus("Running..."),
                            setTimeout(function() {
                                setTimeout(function() {
                                    _e.setStatus("")
                                }, 1),
                                It()
                            }, 1)) : It())
                        }
                    }
                    if (_e.___cxa_is_pointer_type = function() {
                        return (_e.___cxa_is_pointer_type = _e.asm.pa).apply(null, arguments)
                    }
                    ,
                    _e.UTF8ToString = At,
                    _e.stringToUTF8 = function(It, xt, Ot) {
                        return Mt(It, wt, xt, Ot)
                    }
                    ,
                    _e.lengthBytesUTF8 = Ut,
                    _e.stackSave = jn,
                    _e.stackRestore = Vn,
                    _e.stackAlloc = Mn,
                    Gt = function It() {
                        On || fn(),
                        On || (Gt = It)
                    }
                    ,
                    _e.preInit)
                        for (typeof _e.preInit == "function" && (_e.preInit = [_e.preInit]); 0 < _e.preInit.length; )
                            _e.preInit.pop()();
                    return fn(),
                    $.ready
                }
                );
                o.exports = _
            }
            ,
            4537: o => {
                o.exports = function(i, s) {
                    for (var a = new Array(arguments.length - 1), _ = 0, $ = 2, _e = !0; $ < arguments.length; )
                        a[_++] = arguments[$++];
                    return new Promise(function(tt, nt) {
                        a[_] = function(rt) {
                            if (_e)
                                if (_e = !1,
                                rt)
                                    nt(rt);
                                else {
                                    for (var ot = new Array(arguments.length - 1), et = 0; et < ot.length; )
                                        ot[et++] = arguments[et];
                                    tt.apply(null, ot)
                                }
                        }
                        ;
                        try {
                            i.apply(s || null, a)
                        } catch (rt) {
                            _e && (_e = !1,
                            nt(rt))
                        }
                    }
                    )
                }
            }
            ,
            7419: (o, i) => {
                var s = i;
                s.length = function(tt) {
                    var nt = tt.length;
                    if (!nt)
                        return 0;
                    for (var rt = 0; --nt % 4 > 1 && tt.charAt(nt) === "="; )
                        ++rt;
                    return Math.ceil(3 * tt.length) / 4 - rt
                }
                ;
                for (var a = new Array(64), _ = new Array(123), $ = 0; $ < 64; )
                    _[a[$] = $ < 26 ? $ + 65 : $ < 52 ? $ + 71 : $ < 62 ? $ - 4 : $ - 59 | 43] = $++;
                s.encode = function(tt, nt, rt) {
                    for (var ot, et = null, j = [], it = 0, st = 0; nt < rt; ) {
                        var at = tt[nt++];
                        switch (st) {
                        case 0:
                            j[it++] = a[at >> 2],
                            ot = (3 & at) << 4,
                            st = 1;
                            break;
                        case 1:
                            j[it++] = a[ot | at >> 4],
                            ot = (15 & at) << 2,
                            st = 2;
                            break;
                        case 2:
                            j[it++] = a[ot | at >> 6],
                            j[it++] = a[63 & at],
                            st = 0
                        }
                        it > 8191 && ((et || (et = [])).push(String.fromCharCode.apply(String, j)),
                        it = 0)
                    }
                    return st && (j[it++] = a[ot],
                    j[it++] = 61,
                    st === 1 && (j[it++] = 61)),
                    et ? (it && et.push(String.fromCharCode.apply(String, j.slice(0, it))),
                    et.join("")) : String.fromCharCode.apply(String, j.slice(0, it))
                }
                ;
                var _e = "invalid encoding";
                s.decode = function(tt, nt, rt) {
                    for (var ot, et = rt, j = 0, it = 0; it < tt.length; ) {
                        var st = tt.charCodeAt(it++);
                        if (st === 61 && j > 1)
                            break;
                        if ((st = _[st]) === void 0)
                            throw Error(_e);
                        switch (j) {
                        case 0:
                            ot = st,
                            j = 1;
                            break;
                        case 1:
                            nt[rt++] = ot << 2 | (48 & st) >> 4,
                            ot = st,
                            j = 2;
                            break;
                        case 2:
                            nt[rt++] = (15 & ot) << 4 | (60 & st) >> 2,
                            ot = st,
                            j = 3;
                            break;
                        case 3:
                            nt[rt++] = (3 & ot) << 6 | st,
                            j = 0
                        }
                    }
                    if (j === 1)
                        throw Error(_e);
                    return rt - et
                }
                ,
                s.test = function(tt) {
                    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(tt)
                }
            }
            ,
            9211: o => {
                function i() {
                    this._listeners = {}
                }
                o.exports = i,
                i.prototype.on = function(s, a, _) {
                    return (this._listeners[s] || (this._listeners[s] = [])).push({
                        fn: a,
                        ctx: _ || this
                    }),
                    this
                }
                ,
                i.prototype.off = function(s, a) {
                    if (s === void 0)
                        this._listeners = {};
                    else if (a === void 0)
                        this._listeners[s] = [];
                    else
                        for (var _ = this._listeners[s], $ = 0; $ < _.length; )
                            _[$].fn === a ? _.splice($, 1) : ++$;
                    return this
                }
                ,
                i.prototype.emit = function(s) {
                    var a = this._listeners[s];
                    if (a) {
                        for (var _ = [], $ = 1; $ < arguments.length; )
                            _.push(arguments[$++]);
                        for ($ = 0; $ < a.length; )
                            a[$].fn.apply(a[$++].ctx, _)
                    }
                    return this
                }
            }
            ,
            945: o => {
                function i(_e) {
                    return typeof Float32Array < "u" ? function() {
                        var tt = new Float32Array([-0])
                          , nt = new Uint8Array(tt.buffer)
                          , rt = nt[3] === 128;
                        function ot(st, at, lt) {
                            tt[0] = st,
                            at[lt] = nt[0],
                            at[lt + 1] = nt[1],
                            at[lt + 2] = nt[2],
                            at[lt + 3] = nt[3]
                        }
                        function et(st, at, lt) {
                            tt[0] = st,
                            at[lt] = nt[3],
                            at[lt + 1] = nt[2],
                            at[lt + 2] = nt[1],
                            at[lt + 3] = nt[0]
                        }
                        function j(st, at) {
                            return nt[0] = st[at],
                            nt[1] = st[at + 1],
                            nt[2] = st[at + 2],
                            nt[3] = st[at + 3],
                            tt[0]
                        }
                        function it(st, at) {
                            return nt[3] = st[at],
                            nt[2] = st[at + 1],
                            nt[1] = st[at + 2],
                            nt[0] = st[at + 3],
                            tt[0]
                        }
                        _e.writeFloatLE = rt ? ot : et,
                        _e.writeFloatBE = rt ? et : ot,
                        _e.readFloatLE = rt ? j : it,
                        _e.readFloatBE = rt ? it : j
                    }() : function() {
                        function tt(rt, ot, et, j) {
                            var it = ot < 0 ? 1 : 0;
                            if (it && (ot = -ot),
                            ot === 0)
                                rt(1 / ot > 0 ? 0 : 2147483648, et, j);
                            else if (isNaN(ot))
                                rt(2143289344, et, j);
                            else if (ot > 34028234663852886e22)
                                rt((it << 31 | 2139095040) >>> 0, et, j);
                            else if (ot < 11754943508222875e-54)
                                rt((it << 31 | Math.round(ot / 1401298464324817e-60)) >>> 0, et, j);
                            else {
                                var st = Math.floor(Math.log(ot) / Math.LN2);
                                rt((it << 31 | st + 127 << 23 | 8388607 & Math.round(ot * Math.pow(2, -st) * 8388608)) >>> 0, et, j)
                            }
                        }
                        function nt(rt, ot, et) {
                            var j = rt(ot, et)
                              , it = 2 * (j >> 31) + 1
                              , st = j >>> 23 & 255
                              , at = 8388607 & j;
                            return st === 255 ? at ? NaN : it * (1 / 0) : st === 0 ? 1401298464324817e-60 * it * at : it * Math.pow(2, st - 150) * (at + 8388608)
                        }
                        _e.writeFloatLE = tt.bind(null, s),
                        _e.writeFloatBE = tt.bind(null, a),
                        _e.readFloatLE = nt.bind(null, _),
                        _e.readFloatBE = nt.bind(null, $)
                    }(),
                    typeof Float64Array < "u" ? function() {
                        var tt = new Float64Array([-0])
                          , nt = new Uint8Array(tt.buffer)
                          , rt = nt[7] === 128;
                        function ot(st, at, lt) {
                            tt[0] = st,
                            at[lt] = nt[0],
                            at[lt + 1] = nt[1],
                            at[lt + 2] = nt[2],
                            at[lt + 3] = nt[3],
                            at[lt + 4] = nt[4],
                            at[lt + 5] = nt[5],
                            at[lt + 6] = nt[6],
                            at[lt + 7] = nt[7]
                        }
                        function et(st, at, lt) {
                            tt[0] = st,
                            at[lt] = nt[7],
                            at[lt + 1] = nt[6],
                            at[lt + 2] = nt[5],
                            at[lt + 3] = nt[4],
                            at[lt + 4] = nt[3],
                            at[lt + 5] = nt[2],
                            at[lt + 6] = nt[1],
                            at[lt + 7] = nt[0]
                        }
                        function j(st, at) {
                            return nt[0] = st[at],
                            nt[1] = st[at + 1],
                            nt[2] = st[at + 2],
                            nt[3] = st[at + 3],
                            nt[4] = st[at + 4],
                            nt[5] = st[at + 5],
                            nt[6] = st[at + 6],
                            nt[7] = st[at + 7],
                            tt[0]
                        }
                        function it(st, at) {
                            return nt[7] = st[at],
                            nt[6] = st[at + 1],
                            nt[5] = st[at + 2],
                            nt[4] = st[at + 3],
                            nt[3] = st[at + 4],
                            nt[2] = st[at + 5],
                            nt[1] = st[at + 6],
                            nt[0] = st[at + 7],
                            tt[0]
                        }
                        _e.writeDoubleLE = rt ? ot : et,
                        _e.writeDoubleBE = rt ? et : ot,
                        _e.readDoubleLE = rt ? j : it,
                        _e.readDoubleBE = rt ? it : j
                    }() : function() {
                        function tt(rt, ot, et, j, it, st) {
                            var at = j < 0 ? 1 : 0;
                            if (at && (j = -j),
                            j === 0)
                                rt(0, it, st + ot),
                                rt(1 / j > 0 ? 0 : 2147483648, it, st + et);
                            else if (isNaN(j))
                                rt(0, it, st + ot),
                                rt(2146959360, it, st + et);
                            else if (j > 17976931348623157e292)
                                rt(0, it, st + ot),
                                rt((at << 31 | 2146435072) >>> 0, it, st + et);
                            else {
                                var lt;
                                if (j < 22250738585072014e-324)
                                    rt((lt = j / 5e-324) >>> 0, it, st + ot),
                                    rt((at << 31 | lt / 4294967296) >>> 0, it, st + et);
                                else {
                                    var ct = Math.floor(Math.log(j) / Math.LN2);
                                    ct === 1024 && (ct = 1023),
                                    rt(4503599627370496 * (lt = j * Math.pow(2, -ct)) >>> 0, it, st + ot),
                                    rt((at << 31 | ct + 1023 << 20 | 1048576 * lt & 1048575) >>> 0, it, st + et)
                                }
                            }
                        }
                        function nt(rt, ot, et, j, it) {
                            var st = rt(j, it + ot)
                              , at = rt(j, it + et)
                              , lt = 2 * (at >> 31) + 1
                              , ct = at >>> 20 & 2047
                              , ut = 4294967296 * (1048575 & at) + st;
                            return ct === 2047 ? ut ? NaN : lt * (1 / 0) : ct === 0 ? 5e-324 * lt * ut : lt * Math.pow(2, ct - 1075) * (ut + 4503599627370496)
                        }
                        _e.writeDoubleLE = tt.bind(null, s, 0, 4),
                        _e.writeDoubleBE = tt.bind(null, a, 4, 0),
                        _e.readDoubleLE = nt.bind(null, _, 0, 4),
                        _e.readDoubleBE = nt.bind(null, $, 4, 0)
                    }(),
                    _e
                }
                function s(_e, tt, nt) {
                    tt[nt] = 255 & _e,
                    tt[nt + 1] = _e >>> 8 & 255,
                    tt[nt + 2] = _e >>> 16 & 255,
                    tt[nt + 3] = _e >>> 24
                }
                function a(_e, tt, nt) {
                    tt[nt] = _e >>> 24,
                    tt[nt + 1] = _e >>> 16 & 255,
                    tt[nt + 2] = _e >>> 8 & 255,
                    tt[nt + 3] = 255 & _e
                }
                function _(_e, tt) {
                    return (_e[tt] | _e[tt + 1] << 8 | _e[tt + 2] << 16 | _e[tt + 3] << 24) >>> 0
                }
                function $(_e, tt) {
                    return (_e[tt] << 24 | _e[tt + 1] << 16 | _e[tt + 2] << 8 | _e[tt + 3]) >>> 0
                }
                o.exports = i(i)
            }
            ,
            7199: module => {
                function inquire(moduleName) {
                    try {
                        var mod = eval("quire".replace(/^/, "re"))(moduleName);
                        if (mod && (mod.length || Object.keys(mod).length))
                            return mod
                    } catch (o) {}
                    return null
                }
                module.exports = inquire
            }
            ,
            6662: o => {
                o.exports = function(i, s, a) {
                    var _ = a || 8192
                      , $ = _ >>> 1
                      , _e = null
                      , tt = _;
                    return function(nt) {
                        if (nt < 1 || nt > $)
                            return i(nt);
                        tt + nt > _ && (_e = i(_),
                        tt = 0);
                        var rt = s.call(_e, tt, tt += nt);
                        return 7 & tt && (tt = 1 + (7 | tt)),
                        rt
                    }
                }
            }
            ,
            4997: (o, i) => {
                var s = i;
                s.length = function(a) {
                    for (var _ = 0, $ = 0, _e = 0; _e < a.length; ++_e)
                        ($ = a.charCodeAt(_e)) < 128 ? _ += 1 : $ < 2048 ? _ += 2 : (64512 & $) == 55296 && (64512 & a.charCodeAt(_e + 1)) == 56320 ? (++_e,
                        _ += 4) : _ += 3;
                    return _
                }
                ,
                s.read = function(a, _, $) {
                    if ($ - _ < 1)
                        return "";
                    for (var _e, tt = null, nt = [], rt = 0; _ < $; )
                        (_e = a[_++]) < 128 ? nt[rt++] = _e : _e > 191 && _e < 224 ? nt[rt++] = (31 & _e) << 6 | 63 & a[_++] : _e > 239 && _e < 365 ? (_e = ((7 & _e) << 18 | (63 & a[_++]) << 12 | (63 & a[_++]) << 6 | 63 & a[_++]) - 65536,
                        nt[rt++] = 55296 + (_e >> 10),
                        nt[rt++] = 56320 + (1023 & _e)) : nt[rt++] = (15 & _e) << 12 | (63 & a[_++]) << 6 | 63 & a[_++],
                        rt > 8191 && ((tt || (tt = [])).push(String.fromCharCode.apply(String, nt)),
                        rt = 0);
                    return tt ? (rt && tt.push(String.fromCharCode.apply(String, nt.slice(0, rt))),
                    tt.join("")) : String.fromCharCode.apply(String, nt.slice(0, rt))
                }
                ,
                s.write = function(a, _, $) {
                    for (var _e, tt, nt = $, rt = 0; rt < a.length; ++rt)
                        (_e = a.charCodeAt(rt)) < 128 ? _[$++] = _e : _e < 2048 ? (_[$++] = _e >> 6 | 192,
                        _[$++] = 63 & _e | 128) : (64512 & _e) == 55296 && (64512 & (tt = a.charCodeAt(rt + 1))) == 56320 ? (_e = 65536 + ((1023 & _e) << 10) + (1023 & tt),
                        ++rt,
                        _[$++] = _e >> 18 | 240,
                        _[$++] = _e >> 12 & 63 | 128,
                        _[$++] = _e >> 6 & 63 | 128,
                        _[$++] = 63 & _e | 128) : (_[$++] = _e >> 12 | 224,
                        _[$++] = _e >> 6 & 63 | 128,
                        _[$++] = 63 & _e | 128);
                    return $ - nt
                }
            }
            ,
            3442: (o, i) => {
                i.__esModule = !0;
                var s = function() {
                    function a(_) {
                        if (!_)
                            throw new TypeError("Invalid argument; `value` has no value.");
                        this.value = a.EMPTY,
                        _ && a.isGuid(_) && (this.value = _)
                    }
                    return a.isGuid = function(_) {
                        var $ = _.toString();
                        return _ && (_ instanceof a || a.validator.test($))
                    }
                    ,
                    a.create = function() {
                        return new a([a.gen(2), a.gen(1), a.gen(1), a.gen(1), a.gen(3)].join("-"))
                    }
                    ,
                    a.createEmpty = function() {
                        return new a("emptyguid")
                    }
                    ,
                    a.parse = function(_) {
                        return new a(_)
                    }
                    ,
                    a.raw = function() {
                        return [a.gen(2), a.gen(1), a.gen(1), a.gen(1), a.gen(3)].join("-")
                    }
                    ,
                    a.gen = function(_) {
                        for (var $ = "", _e = 0; _e < _; _e++)
                            $ += (65536 * (1 + Math.random()) | 0).toString(16).substring(1);
                        return $
                    }
                    ,
                    a.prototype.equals = function(_) {
                        return a.isGuid(_) && this.value === _.toString()
                    }
                    ,
                    a.prototype.isEmpty = function() {
                        return this.value === a.EMPTY
                    }
                    ,
                    a.prototype.toString = function() {
                        return this.value
                    }
                    ,
                    a.prototype.toJSON = function() {
                        return {
                            value: this.value
                        }
                    }
                    ,
                    a.validator = new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$","i"),
                    a.EMPTY = "00000000-0000-0000-0000-000000000000",
                    a
                }();
                i.Guid = s
            }
            ,
            3720: o => {
                o.exports = s;
                var i = null;
                try {
                    i = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])),{}).exports
                } catch {}
                function s(mt, yt, bt) {
                    this.low = 0 | mt,
                    this.high = 0 | yt,
                    this.unsigned = !!bt
                }
                function a(mt) {
                    return (mt && mt.__isLong__) === !0
                }
                s.prototype.__isLong__,
                Object.defineProperty(s.prototype, "__isLong__", {
                    value: !0
                }),
                s.isLong = a;
                var _ = {}
                  , $ = {};
                function _e(mt, yt) {
                    var bt, vt, wt;
                    return yt ? (wt = 0 <= (mt >>>= 0) && mt < 256) && (vt = $[mt]) ? vt : (bt = nt(mt, (0 | mt) < 0 ? -1 : 0, !0),
                    wt && ($[mt] = bt),
                    bt) : (wt = -128 <= (mt |= 0) && mt < 128) && (vt = _[mt]) ? vt : (bt = nt(mt, mt < 0 ? -1 : 0, !1),
                    wt && (_[mt] = bt),
                    bt)
                }
                function tt(mt, yt) {
                    if (isNaN(mt))
                        return yt ? ct : lt;
                    if (yt) {
                        if (mt < 0)
                            return ct;
                        if (mt >= it)
                            return pt
                    } else {
                        if (mt <= -st)
                            return gt;
                        if (mt + 1 >= st)
                            return ht
                    }
                    return mt < 0 ? tt(-mt, yt).neg() : nt(mt % j | 0, mt / j | 0, yt)
                }
                function nt(mt, yt, bt) {
                    return new s(mt,yt,bt)
                }
                s.fromInt = _e,
                s.fromNumber = tt,
                s.fromBits = nt;
                var rt = Math.pow;
                function ot(mt, yt, bt) {
                    if (mt.length === 0)
                        throw Error("empty string");
                    if (mt === "NaN" || mt === "Infinity" || mt === "+Infinity" || mt === "-Infinity")
                        return lt;
                    if (typeof yt == "number" ? (bt = yt,
                    yt = !1) : yt = !!yt,
                    (bt = bt || 10) < 2 || 36 < bt)
                        throw RangeError("radix");
                    var vt;
                    if ((vt = mt.indexOf("-")) > 0)
                        throw Error("interior hyphen");
                    if (vt === 0)
                        return ot(mt.substring(1), yt, bt).neg();
                    for (var wt = tt(rt(bt, 8)), Tt = lt, $t = 0; $t < mt.length; $t += 8) {
                        var Et = Math.min(8, mt.length - $t)
                          , Pt = parseInt(mt.substring($t, $t + Et), bt);
                        if (Et < 8) {
                            var Rt = tt(rt(bt, Et));
                            Tt = Tt.mul(Rt).add(tt(Pt))
                        } else
                            Tt = (Tt = Tt.mul(wt)).add(tt(Pt))
                    }
                    return Tt.unsigned = yt,
                    Tt
                }
                function et(mt, yt) {
                    return typeof mt == "number" ? tt(mt, yt) : typeof mt == "string" ? ot(mt, yt) : nt(mt.low, mt.high, typeof yt == "boolean" ? yt : mt.unsigned)
                }
                s.fromString = ot,
                s.fromValue = et;
                var j = 4294967296
                  , it = j * j
                  , st = it / 2
                  , at = _e(1 << 24)
                  , lt = _e(0);
                s.ZERO = lt;
                var ct = _e(0, !0);
                s.UZERO = ct;
                var ut = _e(1);
                s.ONE = ut;
                var dt = _e(1, !0);
                s.UONE = dt;
                var ft = _e(-1);
                s.NEG_ONE = ft;
                var ht = nt(-1, 2147483647, !1);
                s.MAX_VALUE = ht;
                var pt = nt(-1, -1, !0);
                s.MAX_UNSIGNED_VALUE = pt;
                var gt = nt(0, -2147483648, !1);
                s.MIN_VALUE = gt;
                var _t = s.prototype;
                _t.toInt = function() {
                    return this.unsigned ? this.low >>> 0 : this.low
                }
                ,
                _t.toNumber = function() {
                    return this.unsigned ? (this.high >>> 0) * j + (this.low >>> 0) : this.high * j + (this.low >>> 0)
                }
                ,
                _t.toString = function(mt) {
                    if ((mt = mt || 10) < 2 || 36 < mt)
                        throw RangeError("radix");
                    if (this.isZero())
                        return "0";
                    if (this.isNegative()) {
                        if (this.eq(gt)) {
                            var yt = tt(mt)
                              , bt = this.div(yt)
                              , vt = bt.mul(yt).sub(this);
                            return bt.toString(mt) + vt.toInt().toString(mt)
                        }
                        return "-" + this.neg().toString(mt)
                    }
                    for (var wt = tt(rt(mt, 6), this.unsigned), Tt = this, $t = ""; ; ) {
                        var Et = Tt.div(wt)
                          , Pt = (Tt.sub(Et.mul(wt)).toInt() >>> 0).toString(mt);
                        if ((Tt = Et).isZero())
                            return Pt + $t;
                        for (; Pt.length < 6; )
                            Pt = "0" + Pt;
                        $t = "" + Pt + $t
                    }
                }
                ,
                _t.getHighBits = function() {
                    return this.high
                }
                ,
                _t.getHighBitsUnsigned = function() {
                    return this.high >>> 0
                }
                ,
                _t.getLowBits = function() {
                    return this.low
                }
                ,
                _t.getLowBitsUnsigned = function() {
                    return this.low >>> 0
                }
                ,
                _t.getNumBitsAbs = function() {
                    if (this.isNegative())
                        return this.eq(gt) ? 64 : this.neg().getNumBitsAbs();
                    for (var mt = this.high != 0 ? this.high : this.low, yt = 31; yt > 0 && !(mt & 1 << yt); yt--)
                        ;
                    return this.high != 0 ? yt + 33 : yt + 1
                }
                ,
                _t.isZero = function() {
                    return this.high === 0 && this.low === 0
                }
                ,
                _t.eqz = _t.isZero,
                _t.isNegative = function() {
                    return !this.unsigned && this.high < 0
                }
                ,
                _t.isPositive = function() {
                    return this.unsigned || this.high >= 0
                }
                ,
                _t.isOdd = function() {
                    return (1 & this.low) == 1
                }
                ,
                _t.isEven = function() {
                    return (1 & this.low) == 0
                }
                ,
                _t.equals = function(mt) {
                    return a(mt) || (mt = et(mt)),
                    (this.unsigned === mt.unsigned || this.high >>> 31 != 1 || mt.high >>> 31 != 1) && this.high === mt.high && this.low === mt.low
                }
                ,
                _t.eq = _t.equals,
                _t.notEquals = function(mt) {
                    return !this.eq(mt)
                }
                ,
                _t.neq = _t.notEquals,
                _t.ne = _t.notEquals,
                _t.lessThan = function(mt) {
                    return this.comp(mt) < 0
                }
                ,
                _t.lt = _t.lessThan,
                _t.lessThanOrEqual = function(mt) {
                    return this.comp(mt) <= 0
                }
                ,
                _t.lte = _t.lessThanOrEqual,
                _t.le = _t.lessThanOrEqual,
                _t.greaterThan = function(mt) {
                    return this.comp(mt) > 0
                }
                ,
                _t.gt = _t.greaterThan,
                _t.greaterThanOrEqual = function(mt) {
                    return this.comp(mt) >= 0
                }
                ,
                _t.gte = _t.greaterThanOrEqual,
                _t.ge = _t.greaterThanOrEqual,
                _t.compare = function(mt) {
                    if (a(mt) || (mt = et(mt)),
                    this.eq(mt))
                        return 0;
                    var yt = this.isNegative()
                      , bt = mt.isNegative();
                    return yt && !bt ? -1 : !yt && bt ? 1 : this.unsigned ? mt.high >>> 0 > this.high >>> 0 || mt.high === this.high && mt.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(mt).isNegative() ? -1 : 1
                }
                ,
                _t.comp = _t.compare,
                _t.negate = function() {
                    return !this.unsigned && this.eq(gt) ? gt : this.not().add(ut)
                }
                ,
                _t.neg = _t.negate,
                _t.add = function(mt) {
                    a(mt) || (mt = et(mt));
                    var yt = this.high >>> 16
                      , bt = 65535 & this.high
                      , vt = this.low >>> 16
                      , wt = 65535 & this.low
                      , Tt = mt.high >>> 16
                      , $t = 65535 & mt.high
                      , Et = mt.low >>> 16
                      , Pt = 0
                      , Rt = 0
                      , At = 0
                      , Mt = 0;
                    return At += (Mt += wt + (65535 & mt.low)) >>> 16,
                    Rt += (At += vt + Et) >>> 16,
                    Pt += (Rt += bt + $t) >>> 16,
                    Pt += yt + Tt,
                    nt((At &= 65535) << 16 | (Mt &= 65535), (Pt &= 65535) << 16 | (Rt &= 65535), this.unsigned)
                }
                ,
                _t.subtract = function(mt) {
                    return a(mt) || (mt = et(mt)),
                    this.add(mt.neg())
                }
                ,
                _t.sub = _t.subtract,
                _t.multiply = function(mt) {
                    if (this.isZero())
                        return lt;
                    if (a(mt) || (mt = et(mt)),
                    i)
                        return nt(i.mul(this.low, this.high, mt.low, mt.high), i.get_high(), this.unsigned);
                    if (mt.isZero())
                        return lt;
                    if (this.eq(gt))
                        return mt.isOdd() ? gt : lt;
                    if (mt.eq(gt))
                        return this.isOdd() ? gt : lt;
                    if (this.isNegative())
                        return mt.isNegative() ? this.neg().mul(mt.neg()) : this.neg().mul(mt).neg();
                    if (mt.isNegative())
                        return this.mul(mt.neg()).neg();
                    if (this.lt(at) && mt.lt(at))
                        return tt(this.toNumber() * mt.toNumber(), this.unsigned);
                    var yt = this.high >>> 16
                      , bt = 65535 & this.high
                      , vt = this.low >>> 16
                      , wt = 65535 & this.low
                      , Tt = mt.high >>> 16
                      , $t = 65535 & mt.high
                      , Et = mt.low >>> 16
                      , Pt = 65535 & mt.low
                      , Rt = 0
                      , At = 0
                      , Mt = 0
                      , Ut = 0;
                    return Mt += (Ut += wt * Pt) >>> 16,
                    At += (Mt += vt * Pt) >>> 16,
                    Mt &= 65535,
                    At += (Mt += wt * Et) >>> 16,
                    Rt += (At += bt * Pt) >>> 16,
                    At &= 65535,
                    Rt += (At += vt * Et) >>> 16,
                    At &= 65535,
                    Rt += (At += wt * $t) >>> 16,
                    Rt += yt * Pt + bt * Et + vt * $t + wt * Tt,
                    nt((Mt &= 65535) << 16 | (Ut &= 65535), (Rt &= 65535) << 16 | (At &= 65535), this.unsigned)
                }
                ,
                _t.mul = _t.multiply,
                _t.divide = function(mt) {
                    if (a(mt) || (mt = et(mt)),
                    mt.isZero())
                        throw Error("division by zero");
                    var yt, bt, vt;
                    if (i)
                        return this.unsigned || this.high !== -2147483648 || mt.low !== -1 || mt.high !== -1 ? nt((this.unsigned ? i.div_u : i.div_s)(this.low, this.high, mt.low, mt.high), i.get_high(), this.unsigned) : this;
                    if (this.isZero())
                        return this.unsigned ? ct : lt;
                    if (this.unsigned) {
                        if (mt.unsigned || (mt = mt.toUnsigned()),
                        mt.gt(this))
                            return ct;
                        if (mt.gt(this.shru(1)))
                            return dt;
                        vt = ct
                    } else {
                        if (this.eq(gt))
                            return mt.eq(ut) || mt.eq(ft) ? gt : mt.eq(gt) ? ut : (yt = this.shr(1).div(mt).shl(1)).eq(lt) ? mt.isNegative() ? ut : ft : (bt = this.sub(mt.mul(yt)),
                            vt = yt.add(bt.div(mt)));
                        if (mt.eq(gt))
                            return this.unsigned ? ct : lt;
                        if (this.isNegative())
                            return mt.isNegative() ? this.neg().div(mt.neg()) : this.neg().div(mt).neg();
                        if (mt.isNegative())
                            return this.div(mt.neg()).neg();
                        vt = lt
                    }
                    for (bt = this; bt.gte(mt); ) {
                        yt = Math.max(1, Math.floor(bt.toNumber() / mt.toNumber()));
                        for (var wt = Math.ceil(Math.log(yt) / Math.LN2), Tt = wt <= 48 ? 1 : rt(2, wt - 48), $t = tt(yt), Et = $t.mul(mt); Et.isNegative() || Et.gt(bt); )
                            Et = ($t = tt(yt -= Tt, this.unsigned)).mul(mt);
                        $t.isZero() && ($t = ut),
                        vt = vt.add($t),
                        bt = bt.sub(Et)
                    }
                    return vt
                }
                ,
                _t.div = _t.divide,
                _t.modulo = function(mt) {
                    return a(mt) || (mt = et(mt)),
                    i ? nt((this.unsigned ? i.rem_u : i.rem_s)(this.low, this.high, mt.low, mt.high), i.get_high(), this.unsigned) : this.sub(this.div(mt).mul(mt))
                }
                ,
                _t.mod = _t.modulo,
                _t.rem = _t.modulo,
                _t.not = function() {
                    return nt(~this.low, ~this.high, this.unsigned)
                }
                ,
                _t.and = function(mt) {
                    return a(mt) || (mt = et(mt)),
                    nt(this.low & mt.low, this.high & mt.high, this.unsigned)
                }
                ,
                _t.or = function(mt) {
                    return a(mt) || (mt = et(mt)),
                    nt(this.low | mt.low, this.high | mt.high, this.unsigned)
                }
                ,
                _t.xor = function(mt) {
                    return a(mt) || (mt = et(mt)),
                    nt(this.low ^ mt.low, this.high ^ mt.high, this.unsigned)
                }
                ,
                _t.shiftLeft = function(mt) {
                    return a(mt) && (mt = mt.toInt()),
                    (mt &= 63) == 0 ? this : mt < 32 ? nt(this.low << mt, this.high << mt | this.low >>> 32 - mt, this.unsigned) : nt(0, this.low << mt - 32, this.unsigned)
                }
                ,
                _t.shl = _t.shiftLeft,
                _t.shiftRight = function(mt) {
                    return a(mt) && (mt = mt.toInt()),
                    (mt &= 63) == 0 ? this : mt < 32 ? nt(this.low >>> mt | this.high << 32 - mt, this.high >> mt, this.unsigned) : nt(this.high >> mt - 32, this.high >= 0 ? 0 : -1, this.unsigned)
                }
                ,
                _t.shr = _t.shiftRight,
                _t.shiftRightUnsigned = function(mt) {
                    if (a(mt) && (mt = mt.toInt()),
                    (mt &= 63) == 0)
                        return this;
                    var yt = this.high;
                    return mt < 32 ? nt(this.low >>> mt | yt << 32 - mt, yt >>> mt, this.unsigned) : nt(mt === 32 ? yt : yt >>> mt - 32, 0, this.unsigned)
                }
                ,
                _t.shru = _t.shiftRightUnsigned,
                _t.shr_u = _t.shiftRightUnsigned,
                _t.toSigned = function() {
                    return this.unsigned ? nt(this.low, this.high, !1) : this
                }
                ,
                _t.toUnsigned = function() {
                    return this.unsigned ? this : nt(this.low, this.high, !0)
                }
                ,
                _t.toBytes = function(mt) {
                    return mt ? this.toBytesLE() : this.toBytesBE()
                }
                ,
                _t.toBytesLE = function() {
                    var mt = this.high
                      , yt = this.low;
                    return [255 & yt, yt >>> 8 & 255, yt >>> 16 & 255, yt >>> 24, 255 & mt, mt >>> 8 & 255, mt >>> 16 & 255, mt >>> 24]
                }
                ,
                _t.toBytesBE = function() {
                    var mt = this.high
                      , yt = this.low;
                    return [mt >>> 24, mt >>> 16 & 255, mt >>> 8 & 255, 255 & mt, yt >>> 24, yt >>> 16 & 255, yt >>> 8 & 255, 255 & yt]
                }
                ,
                s.fromBytes = function(mt, yt, bt) {
                    return bt ? s.fromBytesLE(mt, yt) : s.fromBytesBE(mt, yt)
                }
                ,
                s.fromBytesLE = function(mt, yt) {
                    return new s(mt[0] | mt[1] << 8 | mt[2] << 16 | mt[3] << 24,mt[4] | mt[5] << 8 | mt[6] << 16 | mt[7] << 24,yt)
                }
                ,
                s.fromBytesBE = function(mt, yt) {
                    return new s(mt[4] << 24 | mt[5] << 16 | mt[6] << 8 | mt[7],mt[0] << 24 | mt[1] << 16 | mt[2] << 8 | mt[3],yt)
                }
            }
            ,
            1446: (o, i, s) => {
                var a, _, $, _e = s(2100), tt = _e.Reader, nt = _e.Writer, rt = _e.util, ot = _e.roots.default || (_e.roots.default = {});
                ot.onnx = (($ = {}).Version = (a = {},
                (_ = Object.create(a))[a[0] = "_START_VERSION"] = 0,
                _[a[1] = "IR_VERSION_2017_10_10"] = 1,
                _[a[2] = "IR_VERSION_2017_10_30"] = 2,
                _[a[3] = "IR_VERSION_2017_11_3"] = 3,
                _[a[4] = "IR_VERSION_2019_1_22"] = 4,
                _[a[5] = "IR_VERSION"] = 5,
                _),
                $.AttributeProto = function() {
                    function et(j) {
                        if (this.floats = [],
                        this.ints = [],
                        this.strings = [],
                        this.tensors = [],
                        this.graphs = [],
                        j)
                            for (var it = Object.keys(j), st = 0; st < it.length; ++st)
                                j[it[st]] != null && (this[it[st]] = j[it[st]])
                    }
                    return et.prototype.name = "",
                    et.prototype.refAttrName = "",
                    et.prototype.docString = "",
                    et.prototype.type = 0,
                    et.prototype.f = 0,
                    et.prototype.i = rt.Long ? rt.Long.fromBits(0, 0, !1) : 0,
                    et.prototype.s = rt.newBuffer([]),
                    et.prototype.t = null,
                    et.prototype.g = null,
                    et.prototype.floats = rt.emptyArray,
                    et.prototype.ints = rt.emptyArray,
                    et.prototype.strings = rt.emptyArray,
                    et.prototype.tensors = rt.emptyArray,
                    et.prototype.graphs = rt.emptyArray,
                    et.create = function(j) {
                        return new et(j)
                    }
                    ,
                    et.encode = function(j, it) {
                        if (it || (it = nt.create()),
                        j.name != null && j.hasOwnProperty("name") && it.uint32(10).string(j.name),
                        j.f != null && j.hasOwnProperty("f") && it.uint32(21).float(j.f),
                        j.i != null && j.hasOwnProperty("i") && it.uint32(24).int64(j.i),
                        j.s != null && j.hasOwnProperty("s") && it.uint32(34).bytes(j.s),
                        j.t != null && j.hasOwnProperty("t") && ot.onnx.TensorProto.encode(j.t, it.uint32(42).fork()).ldelim(),
                        j.g != null && j.hasOwnProperty("g") && ot.onnx.GraphProto.encode(j.g, it.uint32(50).fork()).ldelim(),
                        j.floats != null && j.floats.length) {
                            it.uint32(58).fork();
                            for (var st = 0; st < j.floats.length; ++st)
                                it.float(j.floats[st]);
                            it.ldelim()
                        }
                        if (j.ints != null && j.ints.length) {
                            for (it.uint32(66).fork(),
                            st = 0; st < j.ints.length; ++st)
                                it.int64(j.ints[st]);
                            it.ldelim()
                        }
                        if (j.strings != null && j.strings.length)
                            for (st = 0; st < j.strings.length; ++st)
                                it.uint32(74).bytes(j.strings[st]);
                        if (j.tensors != null && j.tensors.length)
                            for (st = 0; st < j.tensors.length; ++st)
                                ot.onnx.TensorProto.encode(j.tensors[st], it.uint32(82).fork()).ldelim();
                        if (j.graphs != null && j.graphs.length)
                            for (st = 0; st < j.graphs.length; ++st)
                                ot.onnx.GraphProto.encode(j.graphs[st], it.uint32(90).fork()).ldelim();
                        return j.docString != null && j.hasOwnProperty("docString") && it.uint32(106).string(j.docString),
                        j.type != null && j.hasOwnProperty("type") && it.uint32(160).int32(j.type),
                        j.refAttrName != null && j.hasOwnProperty("refAttrName") && it.uint32(170).string(j.refAttrName),
                        it
                    }
                    ,
                    et.encodeDelimited = function(j, it) {
                        return this.encode(j, it).ldelim()
                    }
                    ,
                    et.decode = function(j, it) {
                        j instanceof tt || (j = tt.create(j));
                        for (var st = it === void 0 ? j.len : j.pos + it, at = new ot.onnx.AttributeProto; j.pos < st; ) {
                            var lt = j.uint32();
                            switch (lt >>> 3) {
                            case 1:
                                at.name = j.string();
                                break;
                            case 21:
                                at.refAttrName = j.string();
                                break;
                            case 13:
                                at.docString = j.string();
                                break;
                            case 20:
                                at.type = j.int32();
                                break;
                            case 2:
                                at.f = j.float();
                                break;
                            case 3:
                                at.i = j.int64();
                                break;
                            case 4:
                                at.s = j.bytes();
                                break;
                            case 5:
                                at.t = ot.onnx.TensorProto.decode(j, j.uint32());
                                break;
                            case 6:
                                at.g = ot.onnx.GraphProto.decode(j, j.uint32());
                                break;
                            case 7:
                                if (at.floats && at.floats.length || (at.floats = []),
                                (7 & lt) == 2)
                                    for (var ct = j.uint32() + j.pos; j.pos < ct; )
                                        at.floats.push(j.float());
                                else
                                    at.floats.push(j.float());
                                break;
                            case 8:
                                if (at.ints && at.ints.length || (at.ints = []),
                                (7 & lt) == 2)
                                    for (ct = j.uint32() + j.pos; j.pos < ct; )
                                        at.ints.push(j.int64());
                                else
                                    at.ints.push(j.int64());
                                break;
                            case 9:
                                at.strings && at.strings.length || (at.strings = []),
                                at.strings.push(j.bytes());
                                break;
                            case 10:
                                at.tensors && at.tensors.length || (at.tensors = []),
                                at.tensors.push(ot.onnx.TensorProto.decode(j, j.uint32()));
                                break;
                            case 11:
                                at.graphs && at.graphs.length || (at.graphs = []),
                                at.graphs.push(ot.onnx.GraphProto.decode(j, j.uint32()));
                                break;
                            default:
                                j.skipType(7 & lt)
                            }
                        }
                        return at
                    }
                    ,
                    et.decodeDelimited = function(j) {
                        return j instanceof tt || (j = new tt(j)),
                        this.decode(j, j.uint32())
                    }
                    ,
                    et.verify = function(j) {
                        if (typeof j != "object" || j === null)
                            return "object expected";
                        if (j.name != null && j.hasOwnProperty("name") && !rt.isString(j.name))
                            return "name: string expected";
                        if (j.refAttrName != null && j.hasOwnProperty("refAttrName") && !rt.isString(j.refAttrName))
                            return "refAttrName: string expected";
                        if (j.docString != null && j.hasOwnProperty("docString") && !rt.isString(j.docString))
                            return "docString: string expected";
                        if (j.type != null && j.hasOwnProperty("type"))
                            switch (j.type) {
                            default:
                                return "type: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                            case 9:
                            case 10:
                            }
                        if (j.f != null && j.hasOwnProperty("f") && typeof j.f != "number")
                            return "f: number expected";
                        if (j.i != null && j.hasOwnProperty("i") && !(rt.isInteger(j.i) || j.i && rt.isInteger(j.i.low) && rt.isInteger(j.i.high)))
                            return "i: integer|Long expected";
                        if (j.s != null && j.hasOwnProperty("s") && !(j.s && typeof j.s.length == "number" || rt.isString(j.s)))
                            return "s: buffer expected";
                        if (j.t != null && j.hasOwnProperty("t") && (st = ot.onnx.TensorProto.verify(j.t)))
                            return "t." + st;
                        if (j.g != null && j.hasOwnProperty("g") && (st = ot.onnx.GraphProto.verify(j.g)))
                            return "g." + st;
                        if (j.floats != null && j.hasOwnProperty("floats")) {
                            if (!Array.isArray(j.floats))
                                return "floats: array expected";
                            for (var it = 0; it < j.floats.length; ++it)
                                if (typeof j.floats[it] != "number")
                                    return "floats: number[] expected"
                        }
                        if (j.ints != null && j.hasOwnProperty("ints")) {
                            if (!Array.isArray(j.ints))
                                return "ints: array expected";
                            for (it = 0; it < j.ints.length; ++it)
                                if (!(rt.isInteger(j.ints[it]) || j.ints[it] && rt.isInteger(j.ints[it].low) && rt.isInteger(j.ints[it].high)))
                                    return "ints: integer|Long[] expected"
                        }
                        if (j.strings != null && j.hasOwnProperty("strings")) {
                            if (!Array.isArray(j.strings))
                                return "strings: array expected";
                            for (it = 0; it < j.strings.length; ++it)
                                if (!(j.strings[it] && typeof j.strings[it].length == "number" || rt.isString(j.strings[it])))
                                    return "strings: buffer[] expected"
                        }
                        if (j.tensors != null && j.hasOwnProperty("tensors")) {
                            if (!Array.isArray(j.tensors))
                                return "tensors: array expected";
                            for (it = 0; it < j.tensors.length; ++it)
                                if (st = ot.onnx.TensorProto.verify(j.tensors[it]))
                                    return "tensors." + st
                        }
                        if (j.graphs != null && j.hasOwnProperty("graphs")) {
                            if (!Array.isArray(j.graphs))
                                return "graphs: array expected";
                            for (it = 0; it < j.graphs.length; ++it) {
                                var st;
                                if (st = ot.onnx.GraphProto.verify(j.graphs[it]))
                                    return "graphs." + st
                            }
                        }
                        return null
                    }
                    ,
                    et.fromObject = function(j) {
                        if (j instanceof ot.onnx.AttributeProto)
                            return j;
                        var it = new ot.onnx.AttributeProto;
                        switch (j.name != null && (it.name = String(j.name)),
                        j.refAttrName != null && (it.refAttrName = String(j.refAttrName)),
                        j.docString != null && (it.docString = String(j.docString)),
                        j.type) {
                        case "UNDEFINED":
                        case 0:
                            it.type = 0;
                            break;
                        case "FLOAT":
                        case 1:
                            it.type = 1;
                            break;
                        case "INT":
                        case 2:
                            it.type = 2;
                            break;
                        case "STRING":
                        case 3:
                            it.type = 3;
                            break;
                        case "TENSOR":
                        case 4:
                            it.type = 4;
                            break;
                        case "GRAPH":
                        case 5:
                            it.type = 5;
                            break;
                        case "FLOATS":
                        case 6:
                            it.type = 6;
                            break;
                        case "INTS":
                        case 7:
                            it.type = 7;
                            break;
                        case "STRINGS":
                        case 8:
                            it.type = 8;
                            break;
                        case "TENSORS":
                        case 9:
                            it.type = 9;
                            break;
                        case "GRAPHS":
                        case 10:
                            it.type = 10
                        }
                        if (j.f != null && (it.f = Number(j.f)),
                        j.i != null && (rt.Long ? (it.i = rt.Long.fromValue(j.i)).unsigned = !1 : typeof j.i == "string" ? it.i = parseInt(j.i, 10) : typeof j.i == "number" ? it.i = j.i : typeof j.i == "object" && (it.i = new rt.LongBits(j.i.low >>> 0,j.i.high >>> 0).toNumber())),
                        j.s != null && (typeof j.s == "string" ? rt.base64.decode(j.s, it.s = rt.newBuffer(rt.base64.length(j.s)), 0) : j.s.length && (it.s = j.s)),
                        j.t != null) {
                            if (typeof j.t != "object")
                                throw TypeError(".onnx.AttributeProto.t: object expected");
                            it.t = ot.onnx.TensorProto.fromObject(j.t)
                        }
                        if (j.g != null) {
                            if (typeof j.g != "object")
                                throw TypeError(".onnx.AttributeProto.g: object expected");
                            it.g = ot.onnx.GraphProto.fromObject(j.g)
                        }
                        if (j.floats) {
                            if (!Array.isArray(j.floats))
                                throw TypeError(".onnx.AttributeProto.floats: array expected");
                            it.floats = [];
                            for (var st = 0; st < j.floats.length; ++st)
                                it.floats[st] = Number(j.floats[st])
                        }
                        if (j.ints) {
                            if (!Array.isArray(j.ints))
                                throw TypeError(".onnx.AttributeProto.ints: array expected");
                            for (it.ints = [],
                            st = 0; st < j.ints.length; ++st)
                                rt.Long ? (it.ints[st] = rt.Long.fromValue(j.ints[st])).unsigned = !1 : typeof j.ints[st] == "string" ? it.ints[st] = parseInt(j.ints[st], 10) : typeof j.ints[st] == "number" ? it.ints[st] = j.ints[st] : typeof j.ints[st] == "object" && (it.ints[st] = new rt.LongBits(j.ints[st].low >>> 0,j.ints[st].high >>> 0).toNumber())
                        }
                        if (j.strings) {
                            if (!Array.isArray(j.strings))
                                throw TypeError(".onnx.AttributeProto.strings: array expected");
                            for (it.strings = [],
                            st = 0; st < j.strings.length; ++st)
                                typeof j.strings[st] == "string" ? rt.base64.decode(j.strings[st], it.strings[st] = rt.newBuffer(rt.base64.length(j.strings[st])), 0) : j.strings[st].length && (it.strings[st] = j.strings[st])
                        }
                        if (j.tensors) {
                            if (!Array.isArray(j.tensors))
                                throw TypeError(".onnx.AttributeProto.tensors: array expected");
                            for (it.tensors = [],
                            st = 0; st < j.tensors.length; ++st) {
                                if (typeof j.tensors[st] != "object")
                                    throw TypeError(".onnx.AttributeProto.tensors: object expected");
                                it.tensors[st] = ot.onnx.TensorProto.fromObject(j.tensors[st])
                            }
                        }
                        if (j.graphs) {
                            if (!Array.isArray(j.graphs))
                                throw TypeError(".onnx.AttributeProto.graphs: array expected");
                            for (it.graphs = [],
                            st = 0; st < j.graphs.length; ++st) {
                                if (typeof j.graphs[st] != "object")
                                    throw TypeError(".onnx.AttributeProto.graphs: object expected");
                                it.graphs[st] = ot.onnx.GraphProto.fromObject(j.graphs[st])
                            }
                        }
                        return it
                    }
                    ,
                    et.toObject = function(j, it) {
                        it || (it = {});
                        var st = {};
                        if ((it.arrays || it.defaults) && (st.floats = [],
                        st.ints = [],
                        st.strings = [],
                        st.tensors = [],
                        st.graphs = []),
                        it.defaults) {
                            if (st.name = "",
                            st.f = 0,
                            rt.Long) {
                                var at = new rt.Long(0,0,!1);
                                st.i = it.longs === String ? at.toString() : it.longs === Number ? at.toNumber() : at
                            } else
                                st.i = it.longs === String ? "0" : 0;
                            it.bytes === String ? st.s = "" : (st.s = [],
                            it.bytes !== Array && (st.s = rt.newBuffer(st.s))),
                            st.t = null,
                            st.g = null,
                            st.docString = "",
                            st.type = it.enums === String ? "UNDEFINED" : 0,
                            st.refAttrName = ""
                        }
                        if (j.name != null && j.hasOwnProperty("name") && (st.name = j.name),
                        j.f != null && j.hasOwnProperty("f") && (st.f = it.json && !isFinite(j.f) ? String(j.f) : j.f),
                        j.i != null && j.hasOwnProperty("i") && (typeof j.i == "number" ? st.i = it.longs === String ? String(j.i) : j.i : st.i = it.longs === String ? rt.Long.prototype.toString.call(j.i) : it.longs === Number ? new rt.LongBits(j.i.low >>> 0,j.i.high >>> 0).toNumber() : j.i),
                        j.s != null && j.hasOwnProperty("s") && (st.s = it.bytes === String ? rt.base64.encode(j.s, 0, j.s.length) : it.bytes === Array ? Array.prototype.slice.call(j.s) : j.s),
                        j.t != null && j.hasOwnProperty("t") && (st.t = ot.onnx.TensorProto.toObject(j.t, it)),
                        j.g != null && j.hasOwnProperty("g") && (st.g = ot.onnx.GraphProto.toObject(j.g, it)),
                        j.floats && j.floats.length) {
                            st.floats = [];
                            for (var lt = 0; lt < j.floats.length; ++lt)
                                st.floats[lt] = it.json && !isFinite(j.floats[lt]) ? String(j.floats[lt]) : j.floats[lt]
                        }
                        if (j.ints && j.ints.length)
                            for (st.ints = [],
                            lt = 0; lt < j.ints.length; ++lt)
                                typeof j.ints[lt] == "number" ? st.ints[lt] = it.longs === String ? String(j.ints[lt]) : j.ints[lt] : st.ints[lt] = it.longs === String ? rt.Long.prototype.toString.call(j.ints[lt]) : it.longs === Number ? new rt.LongBits(j.ints[lt].low >>> 0,j.ints[lt].high >>> 0).toNumber() : j.ints[lt];
                        if (j.strings && j.strings.length)
                            for (st.strings = [],
                            lt = 0; lt < j.strings.length; ++lt)
                                st.strings[lt] = it.bytes === String ? rt.base64.encode(j.strings[lt], 0, j.strings[lt].length) : it.bytes === Array ? Array.prototype.slice.call(j.strings[lt]) : j.strings[lt];
                        if (j.tensors && j.tensors.length)
                            for (st.tensors = [],
                            lt = 0; lt < j.tensors.length; ++lt)
                                st.tensors[lt] = ot.onnx.TensorProto.toObject(j.tensors[lt], it);
                        if (j.graphs && j.graphs.length)
                            for (st.graphs = [],
                            lt = 0; lt < j.graphs.length; ++lt)
                                st.graphs[lt] = ot.onnx.GraphProto.toObject(j.graphs[lt], it);
                        return j.docString != null && j.hasOwnProperty("docString") && (st.docString = j.docString),
                        j.type != null && j.hasOwnProperty("type") && (st.type = it.enums === String ? ot.onnx.AttributeProto.AttributeType[j.type] : j.type),
                        j.refAttrName != null && j.hasOwnProperty("refAttrName") && (st.refAttrName = j.refAttrName),
                        st
                    }
                    ,
                    et.prototype.toJSON = function() {
                        return this.constructor.toObject(this, _e.util.toJSONOptions)
                    }
                    ,
                    et.AttributeType = function() {
                        var j = {}
                          , it = Object.create(j);
                        return it[j[0] = "UNDEFINED"] = 0,
                        it[j[1] = "FLOAT"] = 1,
                        it[j[2] = "INT"] = 2,
                        it[j[3] = "STRING"] = 3,
                        it[j[4] = "TENSOR"] = 4,
                        it[j[5] = "GRAPH"] = 5,
                        it[j[6] = "FLOATS"] = 6,
                        it[j[7] = "INTS"] = 7,
                        it[j[8] = "STRINGS"] = 8,
                        it[j[9] = "TENSORS"] = 9,
                        it[j[10] = "GRAPHS"] = 10,
                        it
                    }(),
                    et
                }(),
                $.ValueInfoProto = function() {
                    function et(j) {
                        if (j)
                            for (var it = Object.keys(j), st = 0; st < it.length; ++st)
                                j[it[st]] != null && (this[it[st]] = j[it[st]])
                    }
                    return et.prototype.name = "",
                    et.prototype.type = null,
                    et.prototype.docString = "",
                    et.create = function(j) {
                        return new et(j)
                    }
                    ,
                    et.encode = function(j, it) {
                        return it || (it = nt.create()),
                        j.name != null && j.hasOwnProperty("name") && it.uint32(10).string(j.name),
                        j.type != null && j.hasOwnProperty("type") && ot.onnx.TypeProto.encode(j.type, it.uint32(18).fork()).ldelim(),
                        j.docString != null && j.hasOwnProperty("docString") && it.uint32(26).string(j.docString),
                        it
                    }
                    ,
                    et.encodeDelimited = function(j, it) {
                        return this.encode(j, it).ldelim()
                    }
                    ,
                    et.decode = function(j, it) {
                        j instanceof tt || (j = tt.create(j));
                        for (var st = it === void 0 ? j.len : j.pos + it, at = new ot.onnx.ValueInfoProto; j.pos < st; ) {
                            var lt = j.uint32();
                            switch (lt >>> 3) {
                            case 1:
                                at.name = j.string();
                                break;
                            case 2:
                                at.type = ot.onnx.TypeProto.decode(j, j.uint32());
                                break;
                            case 3:
                                at.docString = j.string();
                                break;
                            default:
                                j.skipType(7 & lt)
                            }
                        }
                        return at
                    }
                    ,
                    et.decodeDelimited = function(j) {
                        return j instanceof tt || (j = new tt(j)),
                        this.decode(j, j.uint32())
                    }
                    ,
                    et.verify = function(j) {
                        if (typeof j != "object" || j === null)
                            return "object expected";
                        if (j.name != null && j.hasOwnProperty("name") && !rt.isString(j.name))
                            return "name: string expected";
                        if (j.type != null && j.hasOwnProperty("type")) {
                            var it = ot.onnx.TypeProto.verify(j.type);
                            if (it)
                                return "type." + it
                        }
                        return j.docString != null && j.hasOwnProperty("docString") && !rt.isString(j.docString) ? "docString: string expected" : null
                    }
                    ,
                    et.fromObject = function(j) {
                        if (j instanceof ot.onnx.ValueInfoProto)
                            return j;
                        var it = new ot.onnx.ValueInfoProto;
                        if (j.name != null && (it.name = String(j.name)),
                        j.type != null) {
                            if (typeof j.type != "object")
                                throw TypeError(".onnx.ValueInfoProto.type: object expected");
                            it.type = ot.onnx.TypeProto.fromObject(j.type)
                        }
                        return j.docString != null && (it.docString = String(j.docString)),
                        it
                    }
                    ,
                    et.toObject = function(j, it) {
                        it || (it = {});
                        var st = {};
                        return it.defaults && (st.name = "",
                        st.type = null,
                        st.docString = ""),
                        j.name != null && j.hasOwnProperty("name") && (st.name = j.name),
                        j.type != null && j.hasOwnProperty("type") && (st.type = ot.onnx.TypeProto.toObject(j.type, it)),
                        j.docString != null && j.hasOwnProperty("docString") && (st.docString = j.docString),
                        st
                    }
                    ,
                    et.prototype.toJSON = function() {
                        return this.constructor.toObject(this, _e.util.toJSONOptions)
                    }
                    ,
                    et
                }(),
                $.NodeProto = function() {
                    function et(j) {
                        if (this.input = [],
                        this.output = [],
                        this.attribute = [],
                        j)
                            for (var it = Object.keys(j), st = 0; st < it.length; ++st)
                                j[it[st]] != null && (this[it[st]] = j[it[st]])
                    }
                    return et.prototype.input = rt.emptyArray,
                    et.prototype.output = rt.emptyArray,
                    et.prototype.name = "",
                    et.prototype.opType = "",
                    et.prototype.domain = "",
                    et.prototype.attribute = rt.emptyArray,
                    et.prototype.docString = "",
                    et.create = function(j) {
                        return new et(j)
                    }
                    ,
                    et.encode = function(j, it) {
                        if (it || (it = nt.create()),
                        j.input != null && j.input.length)
                            for (var st = 0; st < j.input.length; ++st)
                                it.uint32(10).string(j.input[st]);
                        if (j.output != null && j.output.length)
                            for (st = 0; st < j.output.length; ++st)
                                it.uint32(18).string(j.output[st]);
                        if (j.name != null && j.hasOwnProperty("name") && it.uint32(26).string(j.name),
                        j.opType != null && j.hasOwnProperty("opType") && it.uint32(34).string(j.opType),
                        j.attribute != null && j.attribute.length)
                            for (st = 0; st < j.attribute.length; ++st)
                                ot.onnx.AttributeProto.encode(j.attribute[st], it.uint32(42).fork()).ldelim();
                        return j.docString != null && j.hasOwnProperty("docString") && it.uint32(50).string(j.docString),
                        j.domain != null && j.hasOwnProperty("domain") && it.uint32(58).string(j.domain),
                        it
                    }
                    ,
                    et.encodeDelimited = function(j, it) {
                        return this.encode(j, it).ldelim()
                    }
                    ,
                    et.decode = function(j, it) {
                        j instanceof tt || (j = tt.create(j));
                        for (var st = it === void 0 ? j.len : j.pos + it, at = new ot.onnx.NodeProto; j.pos < st; ) {
                            var lt = j.uint32();
                            switch (lt >>> 3) {
                            case 1:
                                at.input && at.input.length || (at.input = []),
                                at.input.push(j.string());
                                break;
                            case 2:
                                at.output && at.output.length || (at.output = []),
                                at.output.push(j.string());
                                break;
                            case 3:
                                at.name = j.string();
                                break;
                            case 4:
                                at.opType = j.string();
                                break;
                            case 7:
                                at.domain = j.string();
                                break;
                            case 5:
                                at.attribute && at.attribute.length || (at.attribute = []),
                                at.attribute.push(ot.onnx.AttributeProto.decode(j, j.uint32()));
                                break;
                            case 6:
                                at.docString = j.string();
                                break;
                            default:
                                j.skipType(7 & lt)
                            }
                        }
                        return at
                    }
                    ,
                    et.decodeDelimited = function(j) {
                        return j instanceof tt || (j = new tt(j)),
                        this.decode(j, j.uint32())
                    }
                    ,
                    et.verify = function(j) {
                        if (typeof j != "object" || j === null)
                            return "object expected";
                        if (j.input != null && j.hasOwnProperty("input")) {
                            if (!Array.isArray(j.input))
                                return "input: array expected";
                            for (var it = 0; it < j.input.length; ++it)
                                if (!rt.isString(j.input[it]))
                                    return "input: string[] expected"
                        }
                        if (j.output != null && j.hasOwnProperty("output")) {
                            if (!Array.isArray(j.output))
                                return "output: array expected";
                            for (it = 0; it < j.output.length; ++it)
                                if (!rt.isString(j.output[it]))
                                    return "output: string[] expected"
                        }
                        if (j.name != null && j.hasOwnProperty("name") && !rt.isString(j.name))
                            return "name: string expected";
                        if (j.opType != null && j.hasOwnProperty("opType") && !rt.isString(j.opType))
                            return "opType: string expected";
                        if (j.domain != null && j.hasOwnProperty("domain") && !rt.isString(j.domain))
                            return "domain: string expected";
                        if (j.attribute != null && j.hasOwnProperty("attribute")) {
                            if (!Array.isArray(j.attribute))
                                return "attribute: array expected";
                            for (it = 0; it < j.attribute.length; ++it) {
                                var st = ot.onnx.AttributeProto.verify(j.attribute[it]);
                                if (st)
                                    return "attribute." + st
                            }
                        }
                        return j.docString != null && j.hasOwnProperty("docString") && !rt.isString(j.docString) ? "docString: string expected" : null
                    }
                    ,
                    et.fromObject = function(j) {
                        if (j instanceof ot.onnx.NodeProto)
                            return j;
                        var it = new ot.onnx.NodeProto;
                        if (j.input) {
                            if (!Array.isArray(j.input))
                                throw TypeError(".onnx.NodeProto.input: array expected");
                            it.input = [];
                            for (var st = 0; st < j.input.length; ++st)
                                it.input[st] = String(j.input[st])
                        }
                        if (j.output) {
                            if (!Array.isArray(j.output))
                                throw TypeError(".onnx.NodeProto.output: array expected");
                            for (it.output = [],
                            st = 0; st < j.output.length; ++st)
                                it.output[st] = String(j.output[st])
                        }
                        if (j.name != null && (it.name = String(j.name)),
                        j.opType != null && (it.opType = String(j.opType)),
                        j.domain != null && (it.domain = String(j.domain)),
                        j.attribute) {
                            if (!Array.isArray(j.attribute))
                                throw TypeError(".onnx.NodeProto.attribute: array expected");
                            for (it.attribute = [],
                            st = 0; st < j.attribute.length; ++st) {
                                if (typeof j.attribute[st] != "object")
                                    throw TypeError(".onnx.NodeProto.attribute: object expected");
                                it.attribute[st] = ot.onnx.AttributeProto.fromObject(j.attribute[st])
                            }
                        }
                        return j.docString != null && (it.docString = String(j.docString)),
                        it
                    }
                    ,
                    et.toObject = function(j, it) {
                        it || (it = {});
                        var st = {};
                        if ((it.arrays || it.defaults) && (st.input = [],
                        st.output = [],
                        st.attribute = []),
                        it.defaults && (st.name = "",
                        st.opType = "",
                        st.docString = "",
                        st.domain = ""),
                        j.input && j.input.length) {
                            st.input = [];
                            for (var at = 0; at < j.input.length; ++at)
                                st.input[at] = j.input[at]
                        }
                        if (j.output && j.output.length)
                            for (st.output = [],
                            at = 0; at < j.output.length; ++at)
                                st.output[at] = j.output[at];
                        if (j.name != null && j.hasOwnProperty("name") && (st.name = j.name),
                        j.opType != null && j.hasOwnProperty("opType") && (st.opType = j.opType),
                        j.attribute && j.attribute.length)
                            for (st.attribute = [],
                            at = 0; at < j.attribute.length; ++at)
                                st.attribute[at] = ot.onnx.AttributeProto.toObject(j.attribute[at], it);
                        return j.docString != null && j.hasOwnProperty("docString") && (st.docString = j.docString),
                        j.domain != null && j.hasOwnProperty("domain") && (st.domain = j.domain),
                        st
                    }
                    ,
                    et.prototype.toJSON = function() {
                        return this.constructor.toObject(this, _e.util.toJSONOptions)
                    }
                    ,
                    et
                }(),
                $.ModelProto = function() {
                    function et(j) {
                        if (this.opsetImport = [],
                        this.metadataProps = [],
                        j)
                            for (var it = Object.keys(j), st = 0; st < it.length; ++st)
                                j[it[st]] != null && (this[it[st]] = j[it[st]])
                    }
                    return et.prototype.irVersion = rt.Long ? rt.Long.fromBits(0, 0, !1) : 0,
                    et.prototype.opsetImport = rt.emptyArray,
                    et.prototype.producerName = "",
                    et.prototype.producerVersion = "",
                    et.prototype.domain = "",
                    et.prototype.modelVersion = rt.Long ? rt.Long.fromBits(0, 0, !1) : 0,
                    et.prototype.docString = "",
                    et.prototype.graph = null,
                    et.prototype.metadataProps = rt.emptyArray,
                    et.create = function(j) {
                        return new et(j)
                    }
                    ,
                    et.encode = function(j, it) {
                        if (it || (it = nt.create()),
                        j.irVersion != null && j.hasOwnProperty("irVersion") && it.uint32(8).int64(j.irVersion),
                        j.producerName != null && j.hasOwnProperty("producerName") && it.uint32(18).string(j.producerName),
                        j.producerVersion != null && j.hasOwnProperty("producerVersion") && it.uint32(26).string(j.producerVersion),
                        j.domain != null && j.hasOwnProperty("domain") && it.uint32(34).string(j.domain),
                        j.modelVersion != null && j.hasOwnProperty("modelVersion") && it.uint32(40).int64(j.modelVersion),
                        j.docString != null && j.hasOwnProperty("docString") && it.uint32(50).string(j.docString),
                        j.graph != null && j.hasOwnProperty("graph") && ot.onnx.GraphProto.encode(j.graph, it.uint32(58).fork()).ldelim(),
                        j.opsetImport != null && j.opsetImport.length)
                            for (var st = 0; st < j.opsetImport.length; ++st)
                                ot.onnx.OperatorSetIdProto.encode(j.opsetImport[st], it.uint32(66).fork()).ldelim();
                        if (j.metadataProps != null && j.metadataProps.length)
                            for (st = 0; st < j.metadataProps.length; ++st)
                                ot.onnx.StringStringEntryProto.encode(j.metadataProps[st], it.uint32(114).fork()).ldelim();
                        return it
                    }
                    ,
                    et.encodeDelimited = function(j, it) {
                        return this.encode(j, it).ldelim()
                    }
                    ,
                    et.decode = function(j, it) {
                        j instanceof tt || (j = tt.create(j));
                        for (var st = it === void 0 ? j.len : j.pos + it, at = new ot.onnx.ModelProto; j.pos < st; ) {
                            var lt = j.uint32();
                            switch (lt >>> 3) {
                            case 1:
                                at.irVersion = j.int64();
                                break;
                            case 8:
                                at.opsetImport && at.opsetImport.length || (at.opsetImport = []),
                                at.opsetImport.push(ot.onnx.OperatorSetIdProto.decode(j, j.uint32()));
                                break;
                            case 2:
                                at.producerName = j.string();
                                break;
                            case 3:
                                at.producerVersion = j.string();
                                break;
                            case 4:
                                at.domain = j.string();
                                break;
                            case 5:
                                at.modelVersion = j.int64();
                                break;
                            case 6:
                                at.docString = j.string();
                                break;
                            case 7:
                                at.graph = ot.onnx.GraphProto.decode(j, j.uint32());
                                break;
                            case 14:
                                at.metadataProps && at.metadataProps.length || (at.metadataProps = []),
                                at.metadataProps.push(ot.onnx.StringStringEntryProto.decode(j, j.uint32()));
                                break;
                            default:
                                j.skipType(7 & lt)
                            }
                        }
                        return at
                    }
                    ,
                    et.decodeDelimited = function(j) {
                        return j instanceof tt || (j = new tt(j)),
                        this.decode(j, j.uint32())
                    }
                    ,
                    et.verify = function(j) {
                        if (typeof j != "object" || j === null)
                            return "object expected";
                        if (j.irVersion != null && j.hasOwnProperty("irVersion") && !(rt.isInteger(j.irVersion) || j.irVersion && rt.isInteger(j.irVersion.low) && rt.isInteger(j.irVersion.high)))
                            return "irVersion: integer|Long expected";
                        if (j.opsetImport != null && j.hasOwnProperty("opsetImport")) {
                            if (!Array.isArray(j.opsetImport))
                                return "opsetImport: array expected";
                            for (var it = 0; it < j.opsetImport.length; ++it)
                                if (st = ot.onnx.OperatorSetIdProto.verify(j.opsetImport[it]))
                                    return "opsetImport." + st
                        }
                        if (j.producerName != null && j.hasOwnProperty("producerName") && !rt.isString(j.producerName))
                            return "producerName: string expected";
                        if (j.producerVersion != null && j.hasOwnProperty("producerVersion") && !rt.isString(j.producerVersion))
                            return "producerVersion: string expected";
                        if (j.domain != null && j.hasOwnProperty("domain") && !rt.isString(j.domain))
                            return "domain: string expected";
                        if (j.modelVersion != null && j.hasOwnProperty("modelVersion") && !(rt.isInteger(j.modelVersion) || j.modelVersion && rt.isInteger(j.modelVersion.low) && rt.isInteger(j.modelVersion.high)))
                            return "modelVersion: integer|Long expected";
                        if (j.docString != null && j.hasOwnProperty("docString") && !rt.isString(j.docString))
                            return "docString: string expected";
                        if (j.graph != null && j.hasOwnProperty("graph") && (st = ot.onnx.GraphProto.verify(j.graph)))
                            return "graph." + st;
                        if (j.metadataProps != null && j.hasOwnProperty("metadataProps")) {
                            if (!Array.isArray(j.metadataProps))
                                return "metadataProps: array expected";
                            for (it = 0; it < j.metadataProps.length; ++it) {
                                var st;
                                if (st = ot.onnx.StringStringEntryProto.verify(j.metadataProps[it]))
                                    return "metadataProps." + st
                            }
                        }
                        return null
                    }
                    ,
                    et.fromObject = function(j) {
                        if (j instanceof ot.onnx.ModelProto)
                            return j;
                        var it = new ot.onnx.ModelProto;
                        if (j.irVersion != null && (rt.Long ? (it.irVersion = rt.Long.fromValue(j.irVersion)).unsigned = !1 : typeof j.irVersion == "string" ? it.irVersion = parseInt(j.irVersion, 10) : typeof j.irVersion == "number" ? it.irVersion = j.irVersion : typeof j.irVersion == "object" && (it.irVersion = new rt.LongBits(j.irVersion.low >>> 0,j.irVersion.high >>> 0).toNumber())),
                        j.opsetImport) {
                            if (!Array.isArray(j.opsetImport))
                                throw TypeError(".onnx.ModelProto.opsetImport: array expected");
                            it.opsetImport = [];
                            for (var st = 0; st < j.opsetImport.length; ++st) {
                                if (typeof j.opsetImport[st] != "object")
                                    throw TypeError(".onnx.ModelProto.opsetImport: object expected");
                                it.opsetImport[st] = ot.onnx.OperatorSetIdProto.fromObject(j.opsetImport[st])
                            }
                        }
                        if (j.producerName != null && (it.producerName = String(j.producerName)),
                        j.producerVersion != null && (it.producerVersion = String(j.producerVersion)),
                        j.domain != null && (it.domain = String(j.domain)),
                        j.modelVersion != null && (rt.Long ? (it.modelVersion = rt.Long.fromValue(j.modelVersion)).unsigned = !1 : typeof j.modelVersion == "string" ? it.modelVersion = parseInt(j.modelVersion, 10) : typeof j.modelVersion == "number" ? it.modelVersion = j.modelVersion : typeof j.modelVersion == "object" && (it.modelVersion = new rt.LongBits(j.modelVersion.low >>> 0,j.modelVersion.high >>> 0).toNumber())),
                        j.docString != null && (it.docString = String(j.docString)),
                        j.graph != null) {
                            if (typeof j.graph != "object")
                                throw TypeError(".onnx.ModelProto.graph: object expected");
                            it.graph = ot.onnx.GraphProto.fromObject(j.graph)
                        }
                        if (j.metadataProps) {
                            if (!Array.isArray(j.metadataProps))
                                throw TypeError(".onnx.ModelProto.metadataProps: array expected");
                            for (it.metadataProps = [],
                            st = 0; st < j.metadataProps.length; ++st) {
                                if (typeof j.metadataProps[st] != "object")
                                    throw TypeError(".onnx.ModelProto.metadataProps: object expected");
                                it.metadataProps[st] = ot.onnx.StringStringEntryProto.fromObject(j.metadataProps[st])
                            }
                        }
                        return it
                    }
                    ,
                    et.toObject = function(j, it) {
                        it || (it = {});
                        var st = {};
                        if ((it.arrays || it.defaults) && (st.opsetImport = [],
                        st.metadataProps = []),
                        it.defaults) {
                            if (rt.Long) {
                                var at = new rt.Long(0,0,!1);
                                st.irVersion = it.longs === String ? at.toString() : it.longs === Number ? at.toNumber() : at
                            } else
                                st.irVersion = it.longs === String ? "0" : 0;
                            st.producerName = "",
                            st.producerVersion = "",
                            st.domain = "",
                            rt.Long ? (at = new rt.Long(0,0,!1),
                            st.modelVersion = it.longs === String ? at.toString() : it.longs === Number ? at.toNumber() : at) : st.modelVersion = it.longs === String ? "0" : 0,
                            st.docString = "",
                            st.graph = null
                        }
                        if (j.irVersion != null && j.hasOwnProperty("irVersion") && (typeof j.irVersion == "number" ? st.irVersion = it.longs === String ? String(j.irVersion) : j.irVersion : st.irVersion = it.longs === String ? rt.Long.prototype.toString.call(j.irVersion) : it.longs === Number ? new rt.LongBits(j.irVersion.low >>> 0,j.irVersion.high >>> 0).toNumber() : j.irVersion),
                        j.producerName != null && j.hasOwnProperty("producerName") && (st.producerName = j.producerName),
                        j.producerVersion != null && j.hasOwnProperty("producerVersion") && (st.producerVersion = j.producerVersion),
                        j.domain != null && j.hasOwnProperty("domain") && (st.domain = j.domain),
                        j.modelVersion != null && j.hasOwnProperty("modelVersion") && (typeof j.modelVersion == "number" ? st.modelVersion = it.longs === String ? String(j.modelVersion) : j.modelVersion : st.modelVersion = it.longs === String ? rt.Long.prototype.toString.call(j.modelVersion) : it.longs === Number ? new rt.LongBits(j.modelVersion.low >>> 0,j.modelVersion.high >>> 0).toNumber() : j.modelVersion),
                        j.docString != null && j.hasOwnProperty("docString") && (st.docString = j.docString),
                        j.graph != null && j.hasOwnProperty("graph") && (st.graph = ot.onnx.GraphProto.toObject(j.graph, it)),
                        j.opsetImport && j.opsetImport.length) {
                            st.opsetImport = [];
                            for (var lt = 0; lt < j.opsetImport.length; ++lt)
                                st.opsetImport[lt] = ot.onnx.OperatorSetIdProto.toObject(j.opsetImport[lt], it)
                        }
                        if (j.metadataProps && j.metadataProps.length)
                            for (st.metadataProps = [],
                            lt = 0; lt < j.metadataProps.length; ++lt)
                                st.metadataProps[lt] = ot.onnx.StringStringEntryProto.toObject(j.metadataProps[lt], it);
                        return st
                    }
                    ,
                    et.prototype.toJSON = function() {
                        return this.constructor.toObject(this, _e.util.toJSONOptions)
                    }
                    ,
                    et
                }(),
                $.StringStringEntryProto = function() {
                    function et(j) {
                        if (j)
                            for (var it = Object.keys(j), st = 0; st < it.length; ++st)
                                j[it[st]] != null && (this[it[st]] = j[it[st]])
                    }
                    return et.prototype.key = "",
                    et.prototype.value = "",
                    et.create = function(j) {
                        return new et(j)
                    }
                    ,
                    et.encode = function(j, it) {
                        return it || (it = nt.create()),
                        j.key != null && j.hasOwnProperty("key") && it.uint32(10).string(j.key),
                        j.value != null && j.hasOwnProperty("value") && it.uint32(18).string(j.value),
                        it
                    }
                    ,
                    et.encodeDelimited = function(j, it) {
                        return this.encode(j, it).ldelim()
                    }
                    ,
                    et.decode = function(j, it) {
                        j instanceof tt || (j = tt.create(j));
                        for (var st = it === void 0 ? j.len : j.pos + it, at = new ot.onnx.StringStringEntryProto; j.pos < st; ) {
                            var lt = j.uint32();
                            switch (lt >>> 3) {
                            case 1:
                                at.key = j.string();
                                break;
                            case 2:
                                at.value = j.string();
                                break;
                            default:
                                j.skipType(7 & lt)
                            }
                        }
                        return at
                    }
                    ,
                    et.decodeDelimited = function(j) {
                        return j instanceof tt || (j = new tt(j)),
                        this.decode(j, j.uint32())
                    }
                    ,
                    et.verify = function(j) {
                        return typeof j != "object" || j === null ? "object expected" : j.key != null && j.hasOwnProperty("key") && !rt.isString(j.key) ? "key: string expected" : j.value != null && j.hasOwnProperty("value") && !rt.isString(j.value) ? "value: string expected" : null
                    }
                    ,
                    et.fromObject = function(j) {
                        if (j instanceof ot.onnx.StringStringEntryProto)
                            return j;
                        var it = new ot.onnx.StringStringEntryProto;
                        return j.key != null && (it.key = String(j.key)),
                        j.value != null && (it.value = String(j.value)),
                        it
                    }
                    ,
                    et.toObject = function(j, it) {
                        it || (it = {});
                        var st = {};
                        return it.defaults && (st.key = "",
                        st.value = ""),
                        j.key != null && j.hasOwnProperty("key") && (st.key = j.key),
                        j.value != null && j.hasOwnProperty("value") && (st.value = j.value),
                        st
                    }
                    ,
                    et.prototype.toJSON = function() {
                        return this.constructor.toObject(this, _e.util.toJSONOptions)
                    }
                    ,
                    et
                }(),
                $.TensorAnnotation = function() {
                    function et(j) {
                        if (this.quantParameterTensorNames = [],
                        j)
                            for (var it = Object.keys(j), st = 0; st < it.length; ++st)
                                j[it[st]] != null && (this[it[st]] = j[it[st]])
                    }
                    return et.prototype.tensorName = "",
                    et.prototype.quantParameterTensorNames = rt.emptyArray,
                    et.create = function(j) {
                        return new et(j)
                    }
                    ,
                    et.encode = function(j, it) {
                        if (it || (it = nt.create()),
                        j.tensorName != null && j.hasOwnProperty("tensorName") && it.uint32(10).string(j.tensorName),
                        j.quantParameterTensorNames != null && j.quantParameterTensorNames.length)
                            for (var st = 0; st < j.quantParameterTensorNames.length; ++st)
                                ot.onnx.StringStringEntryProto.encode(j.quantParameterTensorNames[st], it.uint32(18).fork()).ldelim();
                        return it
                    }
                    ,
                    et.encodeDelimited = function(j, it) {
                        return this.encode(j, it).ldelim()
                    }
                    ,
                    et.decode = function(j, it) {
                        j instanceof tt || (j = tt.create(j));
                        for (var st = it === void 0 ? j.len : j.pos + it, at = new ot.onnx.TensorAnnotation; j.pos < st; ) {
                            var lt = j.uint32();
                            switch (lt >>> 3) {
                            case 1:
                                at.tensorName = j.string();
                                break;
                            case 2:
                                at.quantParameterTensorNames && at.quantParameterTensorNames.length || (at.quantParameterTensorNames = []),
                                at.quantParameterTensorNames.push(ot.onnx.StringStringEntryProto.decode(j, j.uint32()));
                                break;
                            default:
                                j.skipType(7 & lt)
                            }
                        }
                        return at
                    }
                    ,
                    et.decodeDelimited = function(j) {
                        return j instanceof tt || (j = new tt(j)),
                        this.decode(j, j.uint32())
                    }
                    ,
                    et.verify = function(j) {
                        if (typeof j != "object" || j === null)
                            return "object expected";
                        if (j.tensorName != null && j.hasOwnProperty("tensorName") && !rt.isString(j.tensorName))
                            return "tensorName: string expected";
                        if (j.quantParameterTensorNames != null && j.hasOwnProperty("quantParameterTensorNames")) {
                            if (!Array.isArray(j.quantParameterTensorNames))
                                return "quantParameterTensorNames: array expected";
                            for (var it = 0; it < j.quantParameterTensorNames.length; ++it) {
                                var st = ot.onnx.StringStringEntryProto.verify(j.quantParameterTensorNames[it]);
                                if (st)
                                    return "quantParameterTensorNames." + st
                            }
                        }
                        return null
                    }
                    ,
                    et.fromObject = function(j) {
                        if (j instanceof ot.onnx.TensorAnnotation)
                            return j;
                        var it = new ot.onnx.TensorAnnotation;
                        if (j.tensorName != null && (it.tensorName = String(j.tensorName)),
                        j.quantParameterTensorNames) {
                            if (!Array.isArray(j.quantParameterTensorNames))
                                throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");
                            it.quantParameterTensorNames = [];
                            for (var st = 0; st < j.quantParameterTensorNames.length; ++st) {
                                if (typeof j.quantParameterTensorNames[st] != "object")
                                    throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");
                                it.quantParameterTensorNames[st] = ot.onnx.StringStringEntryProto.fromObject(j.quantParameterTensorNames[st])
                            }
                        }
                        return it
                    }
                    ,
                    et.toObject = function(j, it) {
                        it || (it = {});
                        var st = {};
                        if ((it.arrays || it.defaults) && (st.quantParameterTensorNames = []),
                        it.defaults && (st.tensorName = ""),
                        j.tensorName != null && j.hasOwnProperty("tensorName") && (st.tensorName = j.tensorName),
                        j.quantParameterTensorNames && j.quantParameterTensorNames.length) {
                            st.quantParameterTensorNames = [];
                            for (var at = 0; at < j.quantParameterTensorNames.length; ++at)
                                st.quantParameterTensorNames[at] = ot.onnx.StringStringEntryProto.toObject(j.quantParameterTensorNames[at], it)
                        }
                        return st
                    }
                    ,
                    et.prototype.toJSON = function() {
                        return this.constructor.toObject(this, _e.util.toJSONOptions)
                    }
                    ,
                    et
                }(),
                $.GraphProto = function() {
                    function et(j) {
                        if (this.node = [],
                        this.initializer = [],
                        this.input = [],
                        this.output = [],
                        this.valueInfo = [],
                        this.quantizationAnnotation = [],
                        j)
                            for (var it = Object.keys(j), st = 0; st < it.length; ++st)
                                j[it[st]] != null && (this[it[st]] = j[it[st]])
                    }
                    return et.prototype.node = rt.emptyArray,
                    et.prototype.name = "",
                    et.prototype.initializer = rt.emptyArray,
                    et.prototype.docString = "",
                    et.prototype.input = rt.emptyArray,
                    et.prototype.output = rt.emptyArray,
                    et.prototype.valueInfo = rt.emptyArray,
                    et.prototype.quantizationAnnotation = rt.emptyArray,
                    et.create = function(j) {
                        return new et(j)
                    }
                    ,
                    et.encode = function(j, it) {
                        if (it || (it = nt.create()),
                        j.node != null && j.node.length)
                            for (var st = 0; st < j.node.length; ++st)
                                ot.onnx.NodeProto.encode(j.node[st], it.uint32(10).fork()).ldelim();
                        if (j.name != null && j.hasOwnProperty("name") && it.uint32(18).string(j.name),
                        j.initializer != null && j.initializer.length)
                            for (st = 0; st < j.initializer.length; ++st)
                                ot.onnx.TensorProto.encode(j.initializer[st], it.uint32(42).fork()).ldelim();
                        if (j.docString != null && j.hasOwnProperty("docString") && it.uint32(82).string(j.docString),
                        j.input != null && j.input.length)
                            for (st = 0; st < j.input.length; ++st)
                                ot.onnx.ValueInfoProto.encode(j.input[st], it.uint32(90).fork()).ldelim();
                        if (j.output != null && j.output.length)
                            for (st = 0; st < j.output.length; ++st)
                                ot.onnx.ValueInfoProto.encode(j.output[st], it.uint32(98).fork()).ldelim();
                        if (j.valueInfo != null && j.valueInfo.length)
                            for (st = 0; st < j.valueInfo.length; ++st)
                                ot.onnx.ValueInfoProto.encode(j.valueInfo[st], it.uint32(106).fork()).ldelim();
                        if (j.quantizationAnnotation != null && j.quantizationAnnotation.length)
                            for (st = 0; st < j.quantizationAnnotation.length; ++st)
                                ot.onnx.TensorAnnotation.encode(j.quantizationAnnotation[st], it.uint32(114).fork()).ldelim();
                        return it
                    }
                    ,
                    et.encodeDelimited = function(j, it) {
                        return this.encode(j, it).ldelim()
                    }
                    ,
                    et.decode = function(j, it) {
                        j instanceof tt || (j = tt.create(j));
                        for (var st = it === void 0 ? j.len : j.pos + it, at = new ot.onnx.GraphProto; j.pos < st; ) {
                            var lt = j.uint32();
                            switch (lt >>> 3) {
                            case 1:
                                at.node && at.node.length || (at.node = []),
                                at.node.push(ot.onnx.NodeProto.decode(j, j.uint32()));
                                break;
                            case 2:
                                at.name = j.string();
                                break;
                            case 5:
                                at.initializer && at.initializer.length || (at.initializer = []),
                                at.initializer.push(ot.onnx.TensorProto.decode(j, j.uint32()));
                                break;
                            case 10:
                                at.docString = j.string();
                                break;
                            case 11:
                                at.input && at.input.length || (at.input = []),
                                at.input.push(ot.onnx.ValueInfoProto.decode(j, j.uint32()));
                                break;
                            case 12:
                                at.output && at.output.length || (at.output = []),
                                at.output.push(ot.onnx.ValueInfoProto.decode(j, j.uint32()));
                                break;
                            case 13:
                                at.valueInfo && at.valueInfo.length || (at.valueInfo = []),
                                at.valueInfo.push(ot.onnx.ValueInfoProto.decode(j, j.uint32()));
                                break;
                            case 14:
                                at.quantizationAnnotation && at.quantizationAnnotation.length || (at.quantizationAnnotation = []),
                                at.quantizationAnnotation.push(ot.onnx.TensorAnnotation.decode(j, j.uint32()));
                                break;
                            default:
                                j.skipType(7 & lt)
                            }
                        }
                        return at
                    }
                    ,
                    et.decodeDelimited = function(j) {
                        return j instanceof tt || (j = new tt(j)),
                        this.decode(j, j.uint32())
                    }
                    ,
                    et.verify = function(j) {
                        if (typeof j != "object" || j === null)
                            return "object expected";
                        if (j.node != null && j.hasOwnProperty("node")) {
                            if (!Array.isArray(j.node))
                                return "node: array expected";
                            for (var it = 0; it < j.node.length; ++it)
                                if (st = ot.onnx.NodeProto.verify(j.node[it]))
                                    return "node." + st
                        }
                        if (j.name != null && j.hasOwnProperty("name") && !rt.isString(j.name))
                            return "name: string expected";
                        if (j.initializer != null && j.hasOwnProperty("initializer")) {
                            if (!Array.isArray(j.initializer))
                                return "initializer: array expected";
                            for (it = 0; it < j.initializer.length; ++it)
                                if (st = ot.onnx.TensorProto.verify(j.initializer[it]))
                                    return "initializer." + st
                        }
                        if (j.docString != null && j.hasOwnProperty("docString") && !rt.isString(j.docString))
                            return "docString: string expected";
                        if (j.input != null && j.hasOwnProperty("input")) {
                            if (!Array.isArray(j.input))
                                return "input: array expected";
                            for (it = 0; it < j.input.length; ++it)
                                if (st = ot.onnx.ValueInfoProto.verify(j.input[it]))
                                    return "input." + st
                        }
                        if (j.output != null && j.hasOwnProperty("output")) {
                            if (!Array.isArray(j.output))
                                return "output: array expected";
                            for (it = 0; it < j.output.length; ++it)
                                if (st = ot.onnx.ValueInfoProto.verify(j.output[it]))
                                    return "output." + st
                        }
                        if (j.valueInfo != null && j.hasOwnProperty("valueInfo")) {
                            if (!Array.isArray(j.valueInfo))
                                return "valueInfo: array expected";
                            for (it = 0; it < j.valueInfo.length; ++it)
                                if (st = ot.onnx.ValueInfoProto.verify(j.valueInfo[it]))
                                    return "valueInfo." + st
                        }
                        if (j.quantizationAnnotation != null && j.hasOwnProperty("quantizationAnnotation")) {
                            if (!Array.isArray(j.quantizationAnnotation))
                                return "quantizationAnnotation: array expected";
                            for (it = 0; it < j.quantizationAnnotation.length; ++it) {
                                var st;
                                if (st = ot.onnx.TensorAnnotation.verify(j.quantizationAnnotation[it]))
                                    return "quantizationAnnotation." + st
                            }
                        }
                        return null
                    }
                    ,
                    et.fromObject = function(j) {
                        if (j instanceof ot.onnx.GraphProto)
                            return j;
                        var it = new ot.onnx.GraphProto;
                        if (j.node) {
                            if (!Array.isArray(j.node))
                                throw TypeError(".onnx.GraphProto.node: array expected");
                            it.node = [];
                            for (var st = 0; st < j.node.length; ++st) {
                                if (typeof j.node[st] != "object")
                                    throw TypeError(".onnx.GraphProto.node: object expected");
                                it.node[st] = ot.onnx.NodeProto.fromObject(j.node[st])
                            }
                        }
                        if (j.name != null && (it.name = String(j.name)),
                        j.initializer) {
                            if (!Array.isArray(j.initializer))
                                throw TypeError(".onnx.GraphProto.initializer: array expected");
                            for (it.initializer = [],
                            st = 0; st < j.initializer.length; ++st) {
                                if (typeof j.initializer[st] != "object")
                                    throw TypeError(".onnx.GraphProto.initializer: object expected");
                                it.initializer[st] = ot.onnx.TensorProto.fromObject(j.initializer[st])
                            }
                        }
                        if (j.docString != null && (it.docString = String(j.docString)),
                        j.input) {
                            if (!Array.isArray(j.input))
                                throw TypeError(".onnx.GraphProto.input: array expected");
                            for (it.input = [],
                            st = 0; st < j.input.length; ++st) {
                                if (typeof j.input[st] != "object")
                                    throw TypeError(".onnx.GraphProto.input: object expected");
                                it.input[st] = ot.onnx.ValueInfoProto.fromObject(j.input[st])
                            }
                        }
                        if (j.output) {
                            if (!Array.isArray(j.output))
                                throw TypeError(".onnx.GraphProto.output: array expected");
                            for (it.output = [],
                            st = 0; st < j.output.length; ++st) {
                                if (typeof j.output[st] != "object")
                                    throw TypeError(".onnx.GraphProto.output: object expected");
                                it.output[st] = ot.onnx.ValueInfoProto.fromObject(j.output[st])
                            }
                        }
                        if (j.valueInfo) {
                            if (!Array.isArray(j.valueInfo))
                                throw TypeError(".onnx.GraphProto.valueInfo: array expected");
                            for (it.valueInfo = [],
                            st = 0; st < j.valueInfo.length; ++st) {
                                if (typeof j.valueInfo[st] != "object")
                                    throw TypeError(".onnx.GraphProto.valueInfo: object expected");
                                it.valueInfo[st] = ot.onnx.ValueInfoProto.fromObject(j.valueInfo[st])
                            }
                        }
                        if (j.quantizationAnnotation) {
                            if (!Array.isArray(j.quantizationAnnotation))
                                throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");
                            for (it.quantizationAnnotation = [],
                            st = 0; st < j.quantizationAnnotation.length; ++st) {
                                if (typeof j.quantizationAnnotation[st] != "object")
                                    throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");
                                it.quantizationAnnotation[st] = ot.onnx.TensorAnnotation.fromObject(j.quantizationAnnotation[st])
                            }
                        }
                        return it
                    }
                    ,
                    et.toObject = function(j, it) {
                        it || (it = {});
                        var st = {};
                        if ((it.arrays || it.defaults) && (st.node = [],
                        st.initializer = [],
                        st.input = [],
                        st.output = [],
                        st.valueInfo = [],
                        st.quantizationAnnotation = []),
                        it.defaults && (st.name = "",
                        st.docString = ""),
                        j.node && j.node.length) {
                            st.node = [];
                            for (var at = 0; at < j.node.length; ++at)
                                st.node[at] = ot.onnx.NodeProto.toObject(j.node[at], it)
                        }
                        if (j.name != null && j.hasOwnProperty("name") && (st.name = j.name),
                        j.initializer && j.initializer.length)
                            for (st.initializer = [],
                            at = 0; at < j.initializer.length; ++at)
                                st.initializer[at] = ot.onnx.TensorProto.toObject(j.initializer[at], it);
                        if (j.docString != null && j.hasOwnProperty("docString") && (st.docString = j.docString),
                        j.input && j.input.length)
                            for (st.input = [],
                            at = 0; at < j.input.length; ++at)
                                st.input[at] = ot.onnx.ValueInfoProto.toObject(j.input[at], it);
                        if (j.output && j.output.length)
                            for (st.output = [],
                            at = 0; at < j.output.length; ++at)
                                st.output[at] = ot.onnx.ValueInfoProto.toObject(j.output[at], it);
                        if (j.valueInfo && j.valueInfo.length)
                            for (st.valueInfo = [],
                            at = 0; at < j.valueInfo.length; ++at)
                                st.valueInfo[at] = ot.onnx.ValueInfoProto.toObject(j.valueInfo[at], it);
                        if (j.quantizationAnnotation && j.quantizationAnnotation.length)
                            for (st.quantizationAnnotation = [],
                            at = 0; at < j.quantizationAnnotation.length; ++at)
                                st.quantizationAnnotation[at] = ot.onnx.TensorAnnotation.toObject(j.quantizationAnnotation[at], it);
                        return st
                    }
                    ,
                    et.prototype.toJSON = function() {
                        return this.constructor.toObject(this, _e.util.toJSONOptions)
                    }
                    ,
                    et
                }(),
                $.TensorProto = function() {
                    function et(j) {
                        if (this.dims = [],
                        this.floatData = [],
                        this.int32Data = [],
                        this.stringData = [],
                        this.int64Data = [],
                        this.externalData = [],
                        this.doubleData = [],
                        this.uint64Data = [],
                        j)
                            for (var it = Object.keys(j), st = 0; st < it.length; ++st)
                                j[it[st]] != null && (this[it[st]] = j[it[st]])
                    }
                    return et.prototype.dims = rt.emptyArray,
                    et.prototype.dataType = 0,
                    et.prototype.segment = null,
                    et.prototype.floatData = rt.emptyArray,
                    et.prototype.int32Data = rt.emptyArray,
                    et.prototype.stringData = rt.emptyArray,
                    et.prototype.int64Data = rt.emptyArray,
                    et.prototype.name = "",
                    et.prototype.docString = "",
                    et.prototype.rawData = rt.newBuffer([]),
                    et.prototype.externalData = rt.emptyArray,
                    et.prototype.dataLocation = 0,
                    et.prototype.doubleData = rt.emptyArray,
                    et.prototype.uint64Data = rt.emptyArray,
                    et.create = function(j) {
                        return new et(j)
                    }
                    ,
                    et.encode = function(j, it) {
                        if (it || (it = nt.create()),
                        j.dims != null && j.dims.length) {
                            it.uint32(10).fork();
                            for (var st = 0; st < j.dims.length; ++st)
                                it.int64(j.dims[st]);
                            it.ldelim()
                        }
                        if (j.dataType != null && j.hasOwnProperty("dataType") && it.uint32(16).int32(j.dataType),
                        j.segment != null && j.hasOwnProperty("segment") && ot.onnx.TensorProto.Segment.encode(j.segment, it.uint32(26).fork()).ldelim(),
                        j.floatData != null && j.floatData.length) {
                            for (it.uint32(34).fork(),
                            st = 0; st < j.floatData.length; ++st)
                                it.float(j.floatData[st]);
                            it.ldelim()
                        }
                        if (j.int32Data != null && j.int32Data.length) {
                            for (it.uint32(42).fork(),
                            st = 0; st < j.int32Data.length; ++st)
                                it.int32(j.int32Data[st]);
                            it.ldelim()
                        }
                        if (j.stringData != null && j.stringData.length)
                            for (st = 0; st < j.stringData.length; ++st)
                                it.uint32(50).bytes(j.stringData[st]);
                        if (j.int64Data != null && j.int64Data.length) {
                            for (it.uint32(58).fork(),
                            st = 0; st < j.int64Data.length; ++st)
                                it.int64(j.int64Data[st]);
                            it.ldelim()
                        }
                        if (j.name != null && j.hasOwnProperty("name") && it.uint32(66).string(j.name),
                        j.rawData != null && j.hasOwnProperty("rawData") && it.uint32(74).bytes(j.rawData),
                        j.doubleData != null && j.doubleData.length) {
                            for (it.uint32(82).fork(),
                            st = 0; st < j.doubleData.length; ++st)
                                it.double(j.doubleData[st]);
                            it.ldelim()
                        }
                        if (j.uint64Data != null && j.uint64Data.length) {
                            for (it.uint32(90).fork(),
                            st = 0; st < j.uint64Data.length; ++st)
                                it.uint64(j.uint64Data[st]);
                            it.ldelim()
                        }
                        if (j.docString != null && j.hasOwnProperty("docString") && it.uint32(98).string(j.docString),
                        j.externalData != null && j.externalData.length)
                            for (st = 0; st < j.externalData.length; ++st)
                                ot.onnx.StringStringEntryProto.encode(j.externalData[st], it.uint32(106).fork()).ldelim();
                        return j.dataLocation != null && j.hasOwnProperty("dataLocation") && it.uint32(112).int32(j.dataLocation),
                        it
                    }
                    ,
                    et.encodeDelimited = function(j, it) {
                        return this.encode(j, it).ldelim()
                    }
                    ,
                    et.decode = function(j, it) {
                        j instanceof tt || (j = tt.create(j));
                        for (var st = it === void 0 ? j.len : j.pos + it, at = new ot.onnx.TensorProto; j.pos < st; ) {
                            var lt = j.uint32();
                            switch (lt >>> 3) {
                            case 1:
                                if (at.dims && at.dims.length || (at.dims = []),
                                (7 & lt) == 2)
                                    for (var ct = j.uint32() + j.pos; j.pos < ct; )
                                        at.dims.push(j.int64());
                                else
                                    at.dims.push(j.int64());
                                break;
                            case 2:
                                at.dataType = j.int32();
                                break;
                            case 3:
                                at.segment = ot.onnx.TensorProto.Segment.decode(j, j.uint32());
                                break;
                            case 4:
                                if (at.floatData && at.floatData.length || (at.floatData = []),
                                (7 & lt) == 2)
                                    for (ct = j.uint32() + j.pos; j.pos < ct; )
                                        at.floatData.push(j.float());
                                else
                                    at.floatData.push(j.float());
                                break;
                            case 5:
                                if (at.int32Data && at.int32Data.length || (at.int32Data = []),
                                (7 & lt) == 2)
                                    for (ct = j.uint32() + j.pos; j.pos < ct; )
                                        at.int32Data.push(j.int32());
                                else
                                    at.int32Data.push(j.int32());
                                break;
                            case 6:
                                at.stringData && at.stringData.length || (at.stringData = []),
                                at.stringData.push(j.bytes());
                                break;
                            case 7:
                                if (at.int64Data && at.int64Data.length || (at.int64Data = []),
                                (7 & lt) == 2)
                                    for (ct = j.uint32() + j.pos; j.pos < ct; )
                                        at.int64Data.push(j.int64());
                                else
                                    at.int64Data.push(j.int64());
                                break;
                            case 8:
                                at.name = j.string();
                                break;
                            case 12:
                                at.docString = j.string();
                                break;
                            case 9:
                                at.rawData = j.bytes();
                                break;
                            case 13:
                                at.externalData && at.externalData.length || (at.externalData = []),
                                at.externalData.push(ot.onnx.StringStringEntryProto.decode(j, j.uint32()));
                                break;
                            case 14:
                                at.dataLocation = j.int32();
                                break;
                            case 10:
                                if (at.doubleData && at.doubleData.length || (at.doubleData = []),
                                (7 & lt) == 2)
                                    for (ct = j.uint32() + j.pos; j.pos < ct; )
                                        at.doubleData.push(j.double());
                                else
                                    at.doubleData.push(j.double());
                                break;
                            case 11:
                                if (at.uint64Data && at.uint64Data.length || (at.uint64Data = []),
                                (7 & lt) == 2)
                                    for (ct = j.uint32() + j.pos; j.pos < ct; )
                                        at.uint64Data.push(j.uint64());
                                else
                                    at.uint64Data.push(j.uint64());
                                break;
                            default:
                                j.skipType(7 & lt)
                            }
                        }
                        return at
                    }
                    ,
                    et.decodeDelimited = function(j) {
                        return j instanceof tt || (j = new tt(j)),
                        this.decode(j, j.uint32())
                    }
                    ,
                    et.verify = function(j) {
                        if (typeof j != "object" || j === null)
                            return "object expected";
                        if (j.dims != null && j.hasOwnProperty("dims")) {
                            if (!Array.isArray(j.dims))
                                return "dims: array expected";
                            for (var it = 0; it < j.dims.length; ++it)
                                if (!(rt.isInteger(j.dims[it]) || j.dims[it] && rt.isInteger(j.dims[it].low) && rt.isInteger(j.dims[it].high)))
                                    return "dims: integer|Long[] expected"
                        }
                        if (j.dataType != null && j.hasOwnProperty("dataType") && !rt.isInteger(j.dataType))
                            return "dataType: integer expected";
                        if (j.segment != null && j.hasOwnProperty("segment") && (st = ot.onnx.TensorProto.Segment.verify(j.segment)))
                            return "segment." + st;
                        if (j.floatData != null && j.hasOwnProperty("floatData")) {
                            if (!Array.isArray(j.floatData))
                                return "floatData: array expected";
                            for (it = 0; it < j.floatData.length; ++it)
                                if (typeof j.floatData[it] != "number")
                                    return "floatData: number[] expected"
                        }
                        if (j.int32Data != null && j.hasOwnProperty("int32Data")) {
                            if (!Array.isArray(j.int32Data))
                                return "int32Data: array expected";
                            for (it = 0; it < j.int32Data.length; ++it)
                                if (!rt.isInteger(j.int32Data[it]))
                                    return "int32Data: integer[] expected"
                        }
                        if (j.stringData != null && j.hasOwnProperty("stringData")) {
                            if (!Array.isArray(j.stringData))
                                return "stringData: array expected";
                            for (it = 0; it < j.stringData.length; ++it)
                                if (!(j.stringData[it] && typeof j.stringData[it].length == "number" || rt.isString(j.stringData[it])))
                                    return "stringData: buffer[] expected"
                        }
                        if (j.int64Data != null && j.hasOwnProperty("int64Data")) {
                            if (!Array.isArray(j.int64Data))
                                return "int64Data: array expected";
                            for (it = 0; it < j.int64Data.length; ++it)
                                if (!(rt.isInteger(j.int64Data[it]) || j.int64Data[it] && rt.isInteger(j.int64Data[it].low) && rt.isInteger(j.int64Data[it].high)))
                                    return "int64Data: integer|Long[] expected"
                        }
                        if (j.name != null && j.hasOwnProperty("name") && !rt.isString(j.name))
                            return "name: string expected";
                        if (j.docString != null && j.hasOwnProperty("docString") && !rt.isString(j.docString))
                            return "docString: string expected";
                        if (j.rawData != null && j.hasOwnProperty("rawData") && !(j.rawData && typeof j.rawData.length == "number" || rt.isString(j.rawData)))
                            return "rawData: buffer expected";
                        if (j.externalData != null && j.hasOwnProperty("externalData")) {
                            if (!Array.isArray(j.externalData))
                                return "externalData: array expected";
                            for (it = 0; it < j.externalData.length; ++it) {
                                var st;
                                if (st = ot.onnx.StringStringEntryProto.verify(j.externalData[it]))
                                    return "externalData." + st
                            }
                        }
                        if (j.dataLocation != null && j.hasOwnProperty("dataLocation"))
                            switch (j.dataLocation) {
                            default:
                                return "dataLocation: enum value expected";
                            case 0:
                            case 1:
                            }
                        if (j.doubleData != null && j.hasOwnProperty("doubleData")) {
                            if (!Array.isArray(j.doubleData))
                                return "doubleData: array expected";
                            for (it = 0; it < j.doubleData.length; ++it)
                                if (typeof j.doubleData[it] != "number")
                                    return "doubleData: number[] expected"
                        }
                        if (j.uint64Data != null && j.hasOwnProperty("uint64Data")) {
                            if (!Array.isArray(j.uint64Data))
                                return "uint64Data: array expected";
                            for (it = 0; it < j.uint64Data.length; ++it)
                                if (!(rt.isInteger(j.uint64Data[it]) || j.uint64Data[it] && rt.isInteger(j.uint64Data[it].low) && rt.isInteger(j.uint64Data[it].high)))
                                    return "uint64Data: integer|Long[] expected"
                        }
                        return null
                    }
                    ,
                    et.fromObject = function(j) {
                        if (j instanceof ot.onnx.TensorProto)
                            return j;
                        var it = new ot.onnx.TensorProto;
                        if (j.dims) {
                            if (!Array.isArray(j.dims))
                                throw TypeError(".onnx.TensorProto.dims: array expected");
                            it.dims = [];
                            for (var st = 0; st < j.dims.length; ++st)
                                rt.Long ? (it.dims[st] = rt.Long.fromValue(j.dims[st])).unsigned = !1 : typeof j.dims[st] == "string" ? it.dims[st] = parseInt(j.dims[st], 10) : typeof j.dims[st] == "number" ? it.dims[st] = j.dims[st] : typeof j.dims[st] == "object" && (it.dims[st] = new rt.LongBits(j.dims[st].low >>> 0,j.dims[st].high >>> 0).toNumber())
                        }
                        if (j.dataType != null && (it.dataType = 0 | j.dataType),
                        j.segment != null) {
                            if (typeof j.segment != "object")
                                throw TypeError(".onnx.TensorProto.segment: object expected");
                            it.segment = ot.onnx.TensorProto.Segment.fromObject(j.segment)
                        }
                        if (j.floatData) {
                            if (!Array.isArray(j.floatData))
                                throw TypeError(".onnx.TensorProto.floatData: array expected");
                            for (it.floatData = [],
                            st = 0; st < j.floatData.length; ++st)
                                it.floatData[st] = Number(j.floatData[st])
                        }
                        if (j.int32Data) {
                            if (!Array.isArray(j.int32Data))
                                throw TypeError(".onnx.TensorProto.int32Data: array expected");
                            for (it.int32Data = [],
                            st = 0; st < j.int32Data.length; ++st)
                                it.int32Data[st] = 0 | j.int32Data[st]
                        }
                        if (j.stringData) {
                            if (!Array.isArray(j.stringData))
                                throw TypeError(".onnx.TensorProto.stringData: array expected");
                            for (it.stringData = [],
                            st = 0; st < j.stringData.length; ++st)
                                typeof j.stringData[st] == "string" ? rt.base64.decode(j.stringData[st], it.stringData[st] = rt.newBuffer(rt.base64.length(j.stringData[st])), 0) : j.stringData[st].length && (it.stringData[st] = j.stringData[st])
                        }
                        if (j.int64Data) {
                            if (!Array.isArray(j.int64Data))
                                throw TypeError(".onnx.TensorProto.int64Data: array expected");
                            for (it.int64Data = [],
                            st = 0; st < j.int64Data.length; ++st)
                                rt.Long ? (it.int64Data[st] = rt.Long.fromValue(j.int64Data[st])).unsigned = !1 : typeof j.int64Data[st] == "string" ? it.int64Data[st] = parseInt(j.int64Data[st], 10) : typeof j.int64Data[st] == "number" ? it.int64Data[st] = j.int64Data[st] : typeof j.int64Data[st] == "object" && (it.int64Data[st] = new rt.LongBits(j.int64Data[st].low >>> 0,j.int64Data[st].high >>> 0).toNumber())
                        }
                        if (j.name != null && (it.name = String(j.name)),
                        j.docString != null && (it.docString = String(j.docString)),
                        j.rawData != null && (typeof j.rawData == "string" ? rt.base64.decode(j.rawData, it.rawData = rt.newBuffer(rt.base64.length(j.rawData)), 0) : j.rawData.length && (it.rawData = j.rawData)),
                        j.externalData) {
                            if (!Array.isArray(j.externalData))
                                throw TypeError(".onnx.TensorProto.externalData: array expected");
                            for (it.externalData = [],
                            st = 0; st < j.externalData.length; ++st) {
                                if (typeof j.externalData[st] != "object")
                                    throw TypeError(".onnx.TensorProto.externalData: object expected");
                                it.externalData[st] = ot.onnx.StringStringEntryProto.fromObject(j.externalData[st])
                            }
                        }
                        switch (j.dataLocation) {
                        case "DEFAULT":
                        case 0:
                            it.dataLocation = 0;
                            break;
                        case "EXTERNAL":
                        case 1:
                            it.dataLocation = 1
                        }
                        if (j.doubleData) {
                            if (!Array.isArray(j.doubleData))
                                throw TypeError(".onnx.TensorProto.doubleData: array expected");
                            for (it.doubleData = [],
                            st = 0; st < j.doubleData.length; ++st)
                                it.doubleData[st] = Number(j.doubleData[st])
                        }
                        if (j.uint64Data) {
                            if (!Array.isArray(j.uint64Data))
                                throw TypeError(".onnx.TensorProto.uint64Data: array expected");
                            for (it.uint64Data = [],
                            st = 0; st < j.uint64Data.length; ++st)
                                rt.Long ? (it.uint64Data[st] = rt.Long.fromValue(j.uint64Data[st])).unsigned = !0 : typeof j.uint64Data[st] == "string" ? it.uint64Data[st] = parseInt(j.uint64Data[st], 10) : typeof j.uint64Data[st] == "number" ? it.uint64Data[st] = j.uint64Data[st] : typeof j.uint64Data[st] == "object" && (it.uint64Data[st] = new rt.LongBits(j.uint64Data[st].low >>> 0,j.uint64Data[st].high >>> 0).toNumber(!0))
                        }
                        return it
                    }
                    ,
                    et.toObject = function(j, it) {
                        it || (it = {});
                        var st = {};
                        if ((it.arrays || it.defaults) && (st.dims = [],
                        st.floatData = [],
                        st.int32Data = [],
                        st.stringData = [],
                        st.int64Data = [],
                        st.doubleData = [],
                        st.uint64Data = [],
                        st.externalData = []),
                        it.defaults && (st.dataType = 0,
                        st.segment = null,
                        st.name = "",
                        it.bytes === String ? st.rawData = "" : (st.rawData = [],
                        it.bytes !== Array && (st.rawData = rt.newBuffer(st.rawData))),
                        st.docString = "",
                        st.dataLocation = it.enums === String ? "DEFAULT" : 0),
                        j.dims && j.dims.length) {
                            st.dims = [];
                            for (var at = 0; at < j.dims.length; ++at)
                                typeof j.dims[at] == "number" ? st.dims[at] = it.longs === String ? String(j.dims[at]) : j.dims[at] : st.dims[at] = it.longs === String ? rt.Long.prototype.toString.call(j.dims[at]) : it.longs === Number ? new rt.LongBits(j.dims[at].low >>> 0,j.dims[at].high >>> 0).toNumber() : j.dims[at]
                        }
                        if (j.dataType != null && j.hasOwnProperty("dataType") && (st.dataType = j.dataType),
                        j.segment != null && j.hasOwnProperty("segment") && (st.segment = ot.onnx.TensorProto.Segment.toObject(j.segment, it)),
                        j.floatData && j.floatData.length)
                            for (st.floatData = [],
                            at = 0; at < j.floatData.length; ++at)
                                st.floatData[at] = it.json && !isFinite(j.floatData[at]) ? String(j.floatData[at]) : j.floatData[at];
                        if (j.int32Data && j.int32Data.length)
                            for (st.int32Data = [],
                            at = 0; at < j.int32Data.length; ++at)
                                st.int32Data[at] = j.int32Data[at];
                        if (j.stringData && j.stringData.length)
                            for (st.stringData = [],
                            at = 0; at < j.stringData.length; ++at)
                                st.stringData[at] = it.bytes === String ? rt.base64.encode(j.stringData[at], 0, j.stringData[at].length) : it.bytes === Array ? Array.prototype.slice.call(j.stringData[at]) : j.stringData[at];
                        if (j.int64Data && j.int64Data.length)
                            for (st.int64Data = [],
                            at = 0; at < j.int64Data.length; ++at)
                                typeof j.int64Data[at] == "number" ? st.int64Data[at] = it.longs === String ? String(j.int64Data[at]) : j.int64Data[at] : st.int64Data[at] = it.longs === String ? rt.Long.prototype.toString.call(j.int64Data[at]) : it.longs === Number ? new rt.LongBits(j.int64Data[at].low >>> 0,j.int64Data[at].high >>> 0).toNumber() : j.int64Data[at];
                        if (j.name != null && j.hasOwnProperty("name") && (st.name = j.name),
                        j.rawData != null && j.hasOwnProperty("rawData") && (st.rawData = it.bytes === String ? rt.base64.encode(j.rawData, 0, j.rawData.length) : it.bytes === Array ? Array.prototype.slice.call(j.rawData) : j.rawData),
                        j.doubleData && j.doubleData.length)
                            for (st.doubleData = [],
                            at = 0; at < j.doubleData.length; ++at)
                                st.doubleData[at] = it.json && !isFinite(j.doubleData[at]) ? String(j.doubleData[at]) : j.doubleData[at];
                        if (j.uint64Data && j.uint64Data.length)
                            for (st.uint64Data = [],
                            at = 0; at < j.uint64Data.length; ++at)
                                typeof j.uint64Data[at] == "number" ? st.uint64Data[at] = it.longs === String ? String(j.uint64Data[at]) : j.uint64Data[at] : st.uint64Data[at] = it.longs === String ? rt.Long.prototype.toString.call(j.uint64Data[at]) : it.longs === Number ? new rt.LongBits(j.uint64Data[at].low >>> 0,j.uint64Data[at].high >>> 0).toNumber(!0) : j.uint64Data[at];
                        if (j.docString != null && j.hasOwnProperty("docString") && (st.docString = j.docString),
                        j.externalData && j.externalData.length)
                            for (st.externalData = [],
                            at = 0; at < j.externalData.length; ++at)
                                st.externalData[at] = ot.onnx.StringStringEntryProto.toObject(j.externalData[at], it);
                        return j.dataLocation != null && j.hasOwnProperty("dataLocation") && (st.dataLocation = it.enums === String ? ot.onnx.TensorProto.DataLocation[j.dataLocation] : j.dataLocation),
                        st
                    }
                    ,
                    et.prototype.toJSON = function() {
                        return this.constructor.toObject(this, _e.util.toJSONOptions)
                    }
                    ,
                    et.DataType = function() {
                        var j = {}
                          , it = Object.create(j);
                        return it[j[0] = "UNDEFINED"] = 0,
                        it[j[1] = "FLOAT"] = 1,
                        it[j[2] = "UINT8"] = 2,
                        it[j[3] = "INT8"] = 3,
                        it[j[4] = "UINT16"] = 4,
                        it[j[5] = "INT16"] = 5,
                        it[j[6] = "INT32"] = 6,
                        it[j[7] = "INT64"] = 7,
                        it[j[8] = "STRING"] = 8,
                        it[j[9] = "BOOL"] = 9,
                        it[j[10] = "FLOAT16"] = 10,
                        it[j[11] = "DOUBLE"] = 11,
                        it[j[12] = "UINT32"] = 12,
                        it[j[13] = "UINT64"] = 13,
                        it[j[14] = "COMPLEX64"] = 14,
                        it[j[15] = "COMPLEX128"] = 15,
                        it[j[16] = "BFLOAT16"] = 16,
                        it
                    }(),
                    et.Segment = function() {
                        function j(it) {
                            if (it)
                                for (var st = Object.keys(it), at = 0; at < st.length; ++at)
                                    it[st[at]] != null && (this[st[at]] = it[st[at]])
                        }
                        return j.prototype.begin = rt.Long ? rt.Long.fromBits(0, 0, !1) : 0,
                        j.prototype.end = rt.Long ? rt.Long.fromBits(0, 0, !1) : 0,
                        j.create = function(it) {
                            return new j(it)
                        }
                        ,
                        j.encode = function(it, st) {
                            return st || (st = nt.create()),
                            it.begin != null && it.hasOwnProperty("begin") && st.uint32(8).int64(it.begin),
                            it.end != null && it.hasOwnProperty("end") && st.uint32(16).int64(it.end),
                            st
                        }
                        ,
                        j.encodeDelimited = function(it, st) {
                            return this.encode(it, st).ldelim()
                        }
                        ,
                        j.decode = function(it, st) {
                            it instanceof tt || (it = tt.create(it));
                            for (var at = st === void 0 ? it.len : it.pos + st, lt = new ot.onnx.TensorProto.Segment; it.pos < at; ) {
                                var ct = it.uint32();
                                switch (ct >>> 3) {
                                case 1:
                                    lt.begin = it.int64();
                                    break;
                                case 2:
                                    lt.end = it.int64();
                                    break;
                                default:
                                    it.skipType(7 & ct)
                                }
                            }
                            return lt
                        }
                        ,
                        j.decodeDelimited = function(it) {
                            return it instanceof tt || (it = new tt(it)),
                            this.decode(it, it.uint32())
                        }
                        ,
                        j.verify = function(it) {
                            return typeof it != "object" || it === null ? "object expected" : it.begin != null && it.hasOwnProperty("begin") && !(rt.isInteger(it.begin) || it.begin && rt.isInteger(it.begin.low) && rt.isInteger(it.begin.high)) ? "begin: integer|Long expected" : it.end != null && it.hasOwnProperty("end") && !(rt.isInteger(it.end) || it.end && rt.isInteger(it.end.low) && rt.isInteger(it.end.high)) ? "end: integer|Long expected" : null
                        }
                        ,
                        j.fromObject = function(it) {
                            if (it instanceof ot.onnx.TensorProto.Segment)
                                return it;
                            var st = new ot.onnx.TensorProto.Segment;
                            return it.begin != null && (rt.Long ? (st.begin = rt.Long.fromValue(it.begin)).unsigned = !1 : typeof it.begin == "string" ? st.begin = parseInt(it.begin, 10) : typeof it.begin == "number" ? st.begin = it.begin : typeof it.begin == "object" && (st.begin = new rt.LongBits(it.begin.low >>> 0,it.begin.high >>> 0).toNumber())),
                            it.end != null && (rt.Long ? (st.end = rt.Long.fromValue(it.end)).unsigned = !1 : typeof it.end == "string" ? st.end = parseInt(it.end, 10) : typeof it.end == "number" ? st.end = it.end : typeof it.end == "object" && (st.end = new rt.LongBits(it.end.low >>> 0,it.end.high >>> 0).toNumber())),
                            st
                        }
                        ,
                        j.toObject = function(it, st) {
                            st || (st = {});
                            var at = {};
                            if (st.defaults) {
                                if (rt.Long) {
                                    var lt = new rt.Long(0,0,!1);
                                    at.begin = st.longs === String ? lt.toString() : st.longs === Number ? lt.toNumber() : lt
                                } else
                                    at.begin = st.longs === String ? "0" : 0;
                                rt.Long ? (lt = new rt.Long(0,0,!1),
                                at.end = st.longs === String ? lt.toString() : st.longs === Number ? lt.toNumber() : lt) : at.end = st.longs === String ? "0" : 0
                            }
                            return it.begin != null && it.hasOwnProperty("begin") && (typeof it.begin == "number" ? at.begin = st.longs === String ? String(it.begin) : it.begin : at.begin = st.longs === String ? rt.Long.prototype.toString.call(it.begin) : st.longs === Number ? new rt.LongBits(it.begin.low >>> 0,it.begin.high >>> 0).toNumber() : it.begin),
                            it.end != null && it.hasOwnProperty("end") && (typeof it.end == "number" ? at.end = st.longs === String ? String(it.end) : it.end : at.end = st.longs === String ? rt.Long.prototype.toString.call(it.end) : st.longs === Number ? new rt.LongBits(it.end.low >>> 0,it.end.high >>> 0).toNumber() : it.end),
                            at
                        }
                        ,
                        j.prototype.toJSON = function() {
                            return this.constructor.toObject(this, _e.util.toJSONOptions)
                        }
                        ,
                        j
                    }(),
                    et.DataLocation = function() {
                        var j = {}
                          , it = Object.create(j);
                        return it[j[0] = "DEFAULT"] = 0,
                        it[j[1] = "EXTERNAL"] = 1,
                        it
                    }(),
                    et
                }(),
                $.TensorShapeProto = function() {
                    function et(j) {
                        if (this.dim = [],
                        j)
                            for (var it = Object.keys(j), st = 0; st < it.length; ++st)
                                j[it[st]] != null && (this[it[st]] = j[it[st]])
                    }
                    return et.prototype.dim = rt.emptyArray,
                    et.create = function(j) {
                        return new et(j)
                    }
                    ,
                    et.encode = function(j, it) {
                        if (it || (it = nt.create()),
                        j.dim != null && j.dim.length)
                            for (var st = 0; st < j.dim.length; ++st)
                                ot.onnx.TensorShapeProto.Dimension.encode(j.dim[st], it.uint32(10).fork()).ldelim();
                        return it
                    }
                    ,
                    et.encodeDelimited = function(j, it) {
                        return this.encode(j, it).ldelim()
                    }
                    ,
                    et.decode = function(j, it) {
                        j instanceof tt || (j = tt.create(j));
                        for (var st = it === void 0 ? j.len : j.pos + it, at = new ot.onnx.TensorShapeProto; j.pos < st; ) {
                            var lt = j.uint32();
                            lt >>> 3 == 1 ? (at.dim && at.dim.length || (at.dim = []),
                            at.dim.push(ot.onnx.TensorShapeProto.Dimension.decode(j, j.uint32()))) : j.skipType(7 & lt)
                        }
                        return at
                    }
                    ,
                    et.decodeDelimited = function(j) {
                        return j instanceof tt || (j = new tt(j)),
                        this.decode(j, j.uint32())
                    }
                    ,
                    et.verify = function(j) {
                        if (typeof j != "object" || j === null)
                            return "object expected";
                        if (j.dim != null && j.hasOwnProperty("dim")) {
                            if (!Array.isArray(j.dim))
                                return "dim: array expected";
                            for (var it = 0; it < j.dim.length; ++it) {
                                var st = ot.onnx.TensorShapeProto.Dimension.verify(j.dim[it]);
                                if (st)
                                    return "dim." + st
                            }
                        }
                        return null
                    }
                    ,
                    et.fromObject = function(j) {
                        if (j instanceof ot.onnx.TensorShapeProto)
                            return j;
                        var it = new ot.onnx.TensorShapeProto;
                        if (j.dim) {
                            if (!Array.isArray(j.dim))
                                throw TypeError(".onnx.TensorShapeProto.dim: array expected");
                            it.dim = [];
                            for (var st = 0; st < j.dim.length; ++st) {
                                if (typeof j.dim[st] != "object")
                                    throw TypeError(".onnx.TensorShapeProto.dim: object expected");
                                it.dim[st] = ot.onnx.TensorShapeProto.Dimension.fromObject(j.dim[st])
                            }
                        }
                        return it
                    }
                    ,
                    et.toObject = function(j, it) {
                        it || (it = {});
                        var st = {};
                        if ((it.arrays || it.defaults) && (st.dim = []),
                        j.dim && j.dim.length) {
                            st.dim = [];
                            for (var at = 0; at < j.dim.length; ++at)
                                st.dim[at] = ot.onnx.TensorShapeProto.Dimension.toObject(j.dim[at], it)
                        }
                        return st
                    }
                    ,
                    et.prototype.toJSON = function() {
                        return this.constructor.toObject(this, _e.util.toJSONOptions)
                    }
                    ,
                    et.Dimension = function() {
                        function j(st) {
                            if (st)
                                for (var at = Object.keys(st), lt = 0; lt < at.length; ++lt)
                                    st[at[lt]] != null && (this[at[lt]] = st[at[lt]])
                        }
                        var it;
                        return j.prototype.dimValue = rt.Long ? rt.Long.fromBits(0, 0, !1) : 0,
                        j.prototype.dimParam = "",
                        j.prototype.denotation = "",
                        Object.defineProperty(j.prototype, "value", {
                            get: rt.oneOfGetter(it = ["dimValue", "dimParam"]),
                            set: rt.oneOfSetter(it)
                        }),
                        j.create = function(st) {
                            return new j(st)
                        }
                        ,
                        j.encode = function(st, at) {
                            return at || (at = nt.create()),
                            st.dimValue != null && st.hasOwnProperty("dimValue") && at.uint32(8).int64(st.dimValue),
                            st.dimParam != null && st.hasOwnProperty("dimParam") && at.uint32(18).string(st.dimParam),
                            st.denotation != null && st.hasOwnProperty("denotation") && at.uint32(26).string(st.denotation),
                            at
                        }
                        ,
                        j.encodeDelimited = function(st, at) {
                            return this.encode(st, at).ldelim()
                        }
                        ,
                        j.decode = function(st, at) {
                            st instanceof tt || (st = tt.create(st));
                            for (var lt = at === void 0 ? st.len : st.pos + at, ct = new ot.onnx.TensorShapeProto.Dimension; st.pos < lt; ) {
                                var ut = st.uint32();
                                switch (ut >>> 3) {
                                case 1:
                                    ct.dimValue = st.int64();
                                    break;
                                case 2:
                                    ct.dimParam = st.string();
                                    break;
                                case 3:
                                    ct.denotation = st.string();
                                    break;
                                default:
                                    st.skipType(7 & ut)
                                }
                            }
                            return ct
                        }
                        ,
                        j.decodeDelimited = function(st) {
                            return st instanceof tt || (st = new tt(st)),
                            this.decode(st, st.uint32())
                        }
                        ,
                        j.verify = function(st) {
                            if (typeof st != "object" || st === null)
                                return "object expected";
                            var at = {};
                            if (st.dimValue != null && st.hasOwnProperty("dimValue") && (at.value = 1,
                            !(rt.isInteger(st.dimValue) || st.dimValue && rt.isInteger(st.dimValue.low) && rt.isInteger(st.dimValue.high))))
                                return "dimValue: integer|Long expected";
                            if (st.dimParam != null && st.hasOwnProperty("dimParam")) {
                                if (at.value === 1)
                                    return "value: multiple values";
                                if (at.value = 1,
                                !rt.isString(st.dimParam))
                                    return "dimParam: string expected"
                            }
                            return st.denotation != null && st.hasOwnProperty("denotation") && !rt.isString(st.denotation) ? "denotation: string expected" : null
                        }
                        ,
                        j.fromObject = function(st) {
                            if (st instanceof ot.onnx.TensorShapeProto.Dimension)
                                return st;
                            var at = new ot.onnx.TensorShapeProto.Dimension;
                            return st.dimValue != null && (rt.Long ? (at.dimValue = rt.Long.fromValue(st.dimValue)).unsigned = !1 : typeof st.dimValue == "string" ? at.dimValue = parseInt(st.dimValue, 10) : typeof st.dimValue == "number" ? at.dimValue = st.dimValue : typeof st.dimValue == "object" && (at.dimValue = new rt.LongBits(st.dimValue.low >>> 0,st.dimValue.high >>> 0).toNumber())),
                            st.dimParam != null && (at.dimParam = String(st.dimParam)),
                            st.denotation != null && (at.denotation = String(st.denotation)),
                            at
                        }
                        ,
                        j.toObject = function(st, at) {
                            at || (at = {});
                            var lt = {};
                            return at.defaults && (lt.denotation = ""),
                            st.dimValue != null && st.hasOwnProperty("dimValue") && (typeof st.dimValue == "number" ? lt.dimValue = at.longs === String ? String(st.dimValue) : st.dimValue : lt.dimValue = at.longs === String ? rt.Long.prototype.toString.call(st.dimValue) : at.longs === Number ? new rt.LongBits(st.dimValue.low >>> 0,st.dimValue.high >>> 0).toNumber() : st.dimValue,
                            at.oneofs && (lt.value = "dimValue")),
                            st.dimParam != null && st.hasOwnProperty("dimParam") && (lt.dimParam = st.dimParam,
                            at.oneofs && (lt.value = "dimParam")),
                            st.denotation != null && st.hasOwnProperty("denotation") && (lt.denotation = st.denotation),
                            lt
                        }
                        ,
                        j.prototype.toJSON = function() {
                            return this.constructor.toObject(this, _e.util.toJSONOptions)
                        }
                        ,
                        j
                    }(),
                    et
                }(),
                $.TypeProto = function() {
                    function et(it) {
                        if (it)
                            for (var st = Object.keys(it), at = 0; at < st.length; ++at)
                                it[st[at]] != null && (this[st[at]] = it[st[at]])
                    }
                    var j;
                    return et.prototype.tensorType = null,
                    et.prototype.denotation = "",
                    Object.defineProperty(et.prototype, "value", {
                        get: rt.oneOfGetter(j = ["tensorType"]),
                        set: rt.oneOfSetter(j)
                    }),
                    et.create = function(it) {
                        return new et(it)
                    }
                    ,
                    et.encode = function(it, st) {
                        return st || (st = nt.create()),
                        it.tensorType != null && it.hasOwnProperty("tensorType") && ot.onnx.TypeProto.Tensor.encode(it.tensorType, st.uint32(10).fork()).ldelim(),
                        it.denotation != null && it.hasOwnProperty("denotation") && st.uint32(50).string(it.denotation),
                        st
                    }
                    ,
                    et.encodeDelimited = function(it, st) {
                        return this.encode(it, st).ldelim()
                    }
                    ,
                    et.decode = function(it, st) {
                        it instanceof tt || (it = tt.create(it));
                        for (var at = st === void 0 ? it.len : it.pos + st, lt = new ot.onnx.TypeProto; it.pos < at; ) {
                            var ct = it.uint32();
                            switch (ct >>> 3) {
                            case 1:
                                lt.tensorType = ot.onnx.TypeProto.Tensor.decode(it, it.uint32());
                                break;
                            case 6:
                                lt.denotation = it.string();
                                break;
                            default:
                                it.skipType(7 & ct)
                            }
                        }
                        return lt
                    }
                    ,
                    et.decodeDelimited = function(it) {
                        return it instanceof tt || (it = new tt(it)),
                        this.decode(it, it.uint32())
                    }
                    ,
                    et.verify = function(it) {
                        if (typeof it != "object" || it === null)
                            return "object expected";
                        if (it.tensorType != null && it.hasOwnProperty("tensorType")) {
                            var st = ot.onnx.TypeProto.Tensor.verify(it.tensorType);
                            if (st)
                                return "tensorType." + st
                        }
                        return it.denotation != null && it.hasOwnProperty("denotation") && !rt.isString(it.denotation) ? "denotation: string expected" : null
                    }
                    ,
                    et.fromObject = function(it) {
                        if (it instanceof ot.onnx.TypeProto)
                            return it;
                        var st = new ot.onnx.TypeProto;
                        if (it.tensorType != null) {
                            if (typeof it.tensorType != "object")
                                throw TypeError(".onnx.TypeProto.tensorType: object expected");
                            st.tensorType = ot.onnx.TypeProto.Tensor.fromObject(it.tensorType)
                        }
                        return it.denotation != null && (st.denotation = String(it.denotation)),
                        st
                    }
                    ,
                    et.toObject = function(it, st) {
                        st || (st = {});
                        var at = {};
                        return st.defaults && (at.denotation = ""),
                        it.tensorType != null && it.hasOwnProperty("tensorType") && (at.tensorType = ot.onnx.TypeProto.Tensor.toObject(it.tensorType, st),
                        st.oneofs && (at.value = "tensorType")),
                        it.denotation != null && it.hasOwnProperty("denotation") && (at.denotation = it.denotation),
                        at
                    }
                    ,
                    et.prototype.toJSON = function() {
                        return this.constructor.toObject(this, _e.util.toJSONOptions)
                    }
                    ,
                    et.Tensor = function() {
                        function it(st) {
                            if (st)
                                for (var at = Object.keys(st), lt = 0; lt < at.length; ++lt)
                                    st[at[lt]] != null && (this[at[lt]] = st[at[lt]])
                        }
                        return it.prototype.elemType = 0,
                        it.prototype.shape = null,
                        it.create = function(st) {
                            return new it(st)
                        }
                        ,
                        it.encode = function(st, at) {
                            return at || (at = nt.create()),
                            st.elemType != null && st.hasOwnProperty("elemType") && at.uint32(8).int32(st.elemType),
                            st.shape != null && st.hasOwnProperty("shape") && ot.onnx.TensorShapeProto.encode(st.shape, at.uint32(18).fork()).ldelim(),
                            at
                        }
                        ,
                        it.encodeDelimited = function(st, at) {
                            return this.encode(st, at).ldelim()
                        }
                        ,
                        it.decode = function(st, at) {
                            st instanceof tt || (st = tt.create(st));
                            for (var lt = at === void 0 ? st.len : st.pos + at, ct = new ot.onnx.TypeProto.Tensor; st.pos < lt; ) {
                                var ut = st.uint32();
                                switch (ut >>> 3) {
                                case 1:
                                    ct.elemType = st.int32();
                                    break;
                                case 2:
                                    ct.shape = ot.onnx.TensorShapeProto.decode(st, st.uint32());
                                    break;
                                default:
                                    st.skipType(7 & ut)
                                }
                            }
                            return ct
                        }
                        ,
                        it.decodeDelimited = function(st) {
                            return st instanceof tt || (st = new tt(st)),
                            this.decode(st, st.uint32())
                        }
                        ,
                        it.verify = function(st) {
                            if (typeof st != "object" || st === null)
                                return "object expected";
                            if (st.elemType != null && st.hasOwnProperty("elemType") && !rt.isInteger(st.elemType))
                                return "elemType: integer expected";
                            if (st.shape != null && st.hasOwnProperty("shape")) {
                                var at = ot.onnx.TensorShapeProto.verify(st.shape);
                                if (at)
                                    return "shape." + at
                            }
                            return null
                        }
                        ,
                        it.fromObject = function(st) {
                            if (st instanceof ot.onnx.TypeProto.Tensor)
                                return st;
                            var at = new ot.onnx.TypeProto.Tensor;
                            if (st.elemType != null && (at.elemType = 0 | st.elemType),
                            st.shape != null) {
                                if (typeof st.shape != "object")
                                    throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");
                                at.shape = ot.onnx.TensorShapeProto.fromObject(st.shape)
                            }
                            return at
                        }
                        ,
                        it.toObject = function(st, at) {
                            at || (at = {});
                            var lt = {};
                            return at.defaults && (lt.elemType = 0,
                            lt.shape = null),
                            st.elemType != null && st.hasOwnProperty("elemType") && (lt.elemType = st.elemType),
                            st.shape != null && st.hasOwnProperty("shape") && (lt.shape = ot.onnx.TensorShapeProto.toObject(st.shape, at)),
                            lt
                        }
                        ,
                        it.prototype.toJSON = function() {
                            return this.constructor.toObject(this, _e.util.toJSONOptions)
                        }
                        ,
                        it
                    }(),
                    et
                }(),
                $.OperatorSetIdProto = function() {
                    function et(j) {
                        if (j)
                            for (var it = Object.keys(j), st = 0; st < it.length; ++st)
                                j[it[st]] != null && (this[it[st]] = j[it[st]])
                    }
                    return et.prototype.domain = "",
                    et.prototype.version = rt.Long ? rt.Long.fromBits(0, 0, !1) : 0,
                    et.create = function(j) {
                        return new et(j)
                    }
                    ,
                    et.encode = function(j, it) {
                        return it || (it = nt.create()),
                        j.domain != null && j.hasOwnProperty("domain") && it.uint32(10).string(j.domain),
                        j.version != null && j.hasOwnProperty("version") && it.uint32(16).int64(j.version),
                        it
                    }
                    ,
                    et.encodeDelimited = function(j, it) {
                        return this.encode(j, it).ldelim()
                    }
                    ,
                    et.decode = function(j, it) {
                        j instanceof tt || (j = tt.create(j));
                        for (var st = it === void 0 ? j.len : j.pos + it, at = new ot.onnx.OperatorSetIdProto; j.pos < st; ) {
                            var lt = j.uint32();
                            switch (lt >>> 3) {
                            case 1:
                                at.domain = j.string();
                                break;
                            case 2:
                                at.version = j.int64();
                                break;
                            default:
                                j.skipType(7 & lt)
                            }
                        }
                        return at
                    }
                    ,
                    et.decodeDelimited = function(j) {
                        return j instanceof tt || (j = new tt(j)),
                        this.decode(j, j.uint32())
                    }
                    ,
                    et.verify = function(j) {
                        return typeof j != "object" || j === null ? "object expected" : j.domain != null && j.hasOwnProperty("domain") && !rt.isString(j.domain) ? "domain: string expected" : j.version != null && j.hasOwnProperty("version") && !(rt.isInteger(j.version) || j.version && rt.isInteger(j.version.low) && rt.isInteger(j.version.high)) ? "version: integer|Long expected" : null
                    }
                    ,
                    et.fromObject = function(j) {
                        if (j instanceof ot.onnx.OperatorSetIdProto)
                            return j;
                        var it = new ot.onnx.OperatorSetIdProto;
                        return j.domain != null && (it.domain = String(j.domain)),
                        j.version != null && (rt.Long ? (it.version = rt.Long.fromValue(j.version)).unsigned = !1 : typeof j.version == "string" ? it.version = parseInt(j.version, 10) : typeof j.version == "number" ? it.version = j.version : typeof j.version == "object" && (it.version = new rt.LongBits(j.version.low >>> 0,j.version.high >>> 0).toNumber())),
                        it
                    }
                    ,
                    et.toObject = function(j, it) {
                        it || (it = {});
                        var st = {};
                        if (it.defaults)
                            if (st.domain = "",
                            rt.Long) {
                                var at = new rt.Long(0,0,!1);
                                st.version = it.longs === String ? at.toString() : it.longs === Number ? at.toNumber() : at
                            } else
                                st.version = it.longs === String ? "0" : 0;
                        return j.domain != null && j.hasOwnProperty("domain") && (st.domain = j.domain),
                        j.version != null && j.hasOwnProperty("version") && (typeof j.version == "number" ? st.version = it.longs === String ? String(j.version) : j.version : st.version = it.longs === String ? rt.Long.prototype.toString.call(j.version) : it.longs === Number ? new rt.LongBits(j.version.low >>> 0,j.version.high >>> 0).toNumber() : j.version),
                        st
                    }
                    ,
                    et.prototype.toJSON = function() {
                        return this.constructor.toObject(this, _e.util.toJSONOptions)
                    }
                    ,
                    et
                }(),
                $),
                o.exports = ot
            }
            ,
            2100: (o, i, s) => {
                o.exports = s(9482)
            }
            ,
            9482: (o, i, s) => {
                var a = i;
                function _() {
                    a.util._configure(),
                    a.Writer._configure(a.BufferWriter),
                    a.Reader._configure(a.BufferReader)
                }
                a.build = "minimal",
                a.Writer = s(1173),
                a.BufferWriter = s(3155),
                a.Reader = s(1408),
                a.BufferReader = s(593),
                a.util = s(9693),
                a.rpc = s(5994),
                a.roots = s(5054),
                a.configure = _,
                _()
            }
            ,
            1408: (o, i, s) => {
                o.exports = nt;
                var a, _ = s(9693), $ = _.LongBits, _e = _.utf8;
                function tt(at, lt) {
                    return RangeError("index out of range: " + at.pos + " + " + (lt || 1) + " > " + at.len)
                }
                function nt(at) {
                    this.buf = at,
                    this.pos = 0,
                    this.len = at.length
                }
                var rt, ot = typeof Uint8Array < "u" ? function(at) {
                    if (at instanceof Uint8Array || Array.isArray(at))
                        return new nt(at);
                    throw Error("illegal buffer")
                }
                : function(at) {
                    if (Array.isArray(at))
                        return new nt(at);
                    throw Error("illegal buffer")
                }
                , et = function() {
                    return _.Buffer ? function(at) {
                        return (nt.create = function(lt) {
                            return _.Buffer.isBuffer(lt) ? new a(lt) : ot(lt)
                        }
                        )(at)
                    }
                    : ot
                };
                function j() {
                    var at = new $(0,0)
                      , lt = 0;
                    if (!(this.len - this.pos > 4)) {
                        for (; lt < 3; ++lt) {
                            if (this.pos >= this.len)
                                throw tt(this);
                            if (at.lo = (at.lo | (127 & this.buf[this.pos]) << 7 * lt) >>> 0,
                            this.buf[this.pos++] < 128)
                                return at
                        }
                        return at.lo = (at.lo | (127 & this.buf[this.pos++]) << 7 * lt) >>> 0,
                        at
                    }
                    for (; lt < 4; ++lt)
                        if (at.lo = (at.lo | (127 & this.buf[this.pos]) << 7 * lt) >>> 0,
                        this.buf[this.pos++] < 128)
                            return at;
                    if (at.lo = (at.lo | (127 & this.buf[this.pos]) << 28) >>> 0,
                    at.hi = (at.hi | (127 & this.buf[this.pos]) >> 4) >>> 0,
                    this.buf[this.pos++] < 128)
                        return at;
                    if (lt = 0,
                    this.len - this.pos > 4) {
                        for (; lt < 5; ++lt)
                            if (at.hi = (at.hi | (127 & this.buf[this.pos]) << 7 * lt + 3) >>> 0,
                            this.buf[this.pos++] < 128)
                                return at
                    } else
                        for (; lt < 5; ++lt) {
                            if (this.pos >= this.len)
                                throw tt(this);
                            if (at.hi = (at.hi | (127 & this.buf[this.pos]) << 7 * lt + 3) >>> 0,
                            this.buf[this.pos++] < 128)
                                return at
                        }
                    throw Error("invalid varint encoding")
                }
                function it(at, lt) {
                    return (at[lt - 4] | at[lt - 3] << 8 | at[lt - 2] << 16 | at[lt - 1] << 24) >>> 0
                }
                function st() {
                    if (this.pos + 8 > this.len)
                        throw tt(this, 8);
                    return new $(it(this.buf, this.pos += 4),it(this.buf, this.pos += 4))
                }
                nt.create = et(),
                nt.prototype._slice = _.Array.prototype.subarray || _.Array.prototype.slice,
                nt.prototype.uint32 = (rt = 4294967295,
                function() {
                    if (rt = (127 & this.buf[this.pos]) >>> 0,
                    this.buf[this.pos++] < 128 || (rt = (rt | (127 & this.buf[this.pos]) << 7) >>> 0,
                    this.buf[this.pos++] < 128) || (rt = (rt | (127 & this.buf[this.pos]) << 14) >>> 0,
                    this.buf[this.pos++] < 128) || (rt = (rt | (127 & this.buf[this.pos]) << 21) >>> 0,
                    this.buf[this.pos++] < 128) || (rt = (rt | (15 & this.buf[this.pos]) << 28) >>> 0,
                    this.buf[this.pos++] < 128))
                        return rt;
                    if ((this.pos += 5) > this.len)
                        throw this.pos = this.len,
                        tt(this, 10);
                    return rt
                }
                ),
                nt.prototype.int32 = function() {
                    return 0 | this.uint32()
                }
                ,
                nt.prototype.sint32 = function() {
                    var at = this.uint32();
                    return at >>> 1 ^ -(1 & at) | 0
                }
                ,
                nt.prototype.bool = function() {
                    return this.uint32() !== 0
                }
                ,
                nt.prototype.fixed32 = function() {
                    if (this.pos + 4 > this.len)
                        throw tt(this, 4);
                    return it(this.buf, this.pos += 4)
                }
                ,
                nt.prototype.sfixed32 = function() {
                    if (this.pos + 4 > this.len)
                        throw tt(this, 4);
                    return 0 | it(this.buf, this.pos += 4)
                }
                ,
                nt.prototype.float = function() {
                    if (this.pos + 4 > this.len)
                        throw tt(this, 4);
                    var at = _.float.readFloatLE(this.buf, this.pos);
                    return this.pos += 4,
                    at
                }
                ,
                nt.prototype.double = function() {
                    if (this.pos + 8 > this.len)
                        throw tt(this, 4);
                    var at = _.float.readDoubleLE(this.buf, this.pos);
                    return this.pos += 8,
                    at
                }
                ,
                nt.prototype.bytes = function() {
                    var at = this.uint32()
                      , lt = this.pos
                      , ct = this.pos + at;
                    if (ct > this.len)
                        throw tt(this, at);
                    return this.pos += at,
                    Array.isArray(this.buf) ? this.buf.slice(lt, ct) : lt === ct ? new this.buf.constructor(0) : this._slice.call(this.buf, lt, ct)
                }
                ,
                nt.prototype.string = function() {
                    var at = this.bytes();
                    return _e.read(at, 0, at.length)
                }
                ,
                nt.prototype.skip = function(at) {
                    if (typeof at == "number") {
                        if (this.pos + at > this.len)
                            throw tt(this, at);
                        this.pos += at
                    } else
                        do
                            if (this.pos >= this.len)
                                throw tt(this);
                        while (128 & this.buf[this.pos++]);
                    return this
                }
                ,
                nt.prototype.skipType = function(at) {
                    switch (at) {
                    case 0:
                        this.skip();
                        break;
                    case 1:
                        this.skip(8);
                        break;
                    case 2:
                        this.skip(this.uint32());
                        break;
                    case 3:
                        for (; (at = 7 & this.uint32()) != 4; )
                            this.skipType(at);
                        break;
                    case 5:
                        this.skip(4);
                        break;
                    default:
                        throw Error("invalid wire type " + at + " at offset " + this.pos)
                    }
                    return this
                }
                ,
                nt._configure = function(at) {
                    a = at,
                    nt.create = et(),
                    a._configure();
                    var lt = _.Long ? "toLong" : "toNumber";
                    _.merge(nt.prototype, {
                        int64: function() {
                            return j.call(this)[lt](!1)
                        },
                        uint64: function() {
                            return j.call(this)[lt](!0)
                        },
                        sint64: function() {
                            return j.call(this).zzDecode()[lt](!1)
                        },
                        fixed64: function() {
                            return st.call(this)[lt](!0)
                        },
                        sfixed64: function() {
                            return st.call(this)[lt](!1)
                        }
                    })
                }
            }
            ,
            593: (o, i, s) => {
                o.exports = $;
                var a = s(1408);
                ($.prototype = Object.create(a.prototype)).constructor = $;
                var _ = s(9693);
                function $(_e) {
                    a.call(this, _e)
                }
                $._configure = function() {
                    _.Buffer && ($.prototype._slice = _.Buffer.prototype.slice)
                }
                ,
                $.prototype.string = function() {
                    var _e = this.uint32();
                    return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + _e, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + _e, this.len))
                }
                ,
                $._configure()
            }
            ,
            5054: o => {
                o.exports = {}
            }
            ,
            5994: (o, i, s) => {
                i.Service = s(7948)
            }
            ,
            7948: (o, i, s) => {
                o.exports = _;
                var a = s(9693);
                function _($, _e, tt) {
                    if (typeof $ != "function")
                        throw TypeError("rpcImpl must be a function");
                    a.EventEmitter.call(this),
                    this.rpcImpl = $,
                    this.requestDelimited = !!_e,
                    this.responseDelimited = !!tt
                }
                (_.prototype = Object.create(a.EventEmitter.prototype)).constructor = _,
                _.prototype.rpcCall = function $(_e, tt, nt, rt, ot) {
                    if (!rt)
                        throw TypeError("request must be specified");
                    var et = this;
                    if (!ot)
                        return a.asPromise($, et, _e, tt, nt, rt);
                    if (et.rpcImpl)
                        try {
                            return et.rpcImpl(_e, tt[et.requestDelimited ? "encodeDelimited" : "encode"](rt).finish(), function(j, it) {
                                if (j)
                                    return et.emit("error", j, _e),
                                    ot(j);
                                if (it !== null) {
                                    if (!(it instanceof nt))
                                        try {
                                            it = nt[et.responseDelimited ? "decodeDelimited" : "decode"](it)
                                        } catch (st) {
                                            return et.emit("error", st, _e),
                                            ot(st)
                                        }
                                    return et.emit("data", it, _e),
                                    ot(null, it)
                                }
                                et.end(!0)
                            })
                        } catch (j) {
                            return et.emit("error", j, _e),
                            void setTimeout(function() {
                                ot(j)
                            }, 0)
                        }
                    else
                        setTimeout(function() {
                            ot(Error("already ended"))
                        }, 0)
                }
                ,
                _.prototype.end = function($) {
                    return this.rpcImpl && ($ || this.rpcImpl(null, null, null),
                    this.rpcImpl = null,
                    this.emit("end").off()),
                    this
                }
            }
            ,
            1945: (o, i, s) => {
                o.exports = _;
                var a = s(9693);
                function _(nt, rt) {
                    this.lo = nt >>> 0,
                    this.hi = rt >>> 0
                }
                var $ = _.zero = new _(0,0);
                $.toNumber = function() {
                    return 0
                }
                ,
                $.zzEncode = $.zzDecode = function() {
                    return this
                }
                ,
                $.length = function() {
                    return 1
                }
                ;
                var _e = _.zeroHash = "\0\0\0\0\0\0\0\0";
                _.fromNumber = function(nt) {
                    if (nt === 0)
                        return $;
                    var rt = nt < 0;
                    rt && (nt = -nt);
                    var ot = nt >>> 0
                      , et = (nt - ot) / 4294967296 >>> 0;
                    return rt && (et = ~et >>> 0,
                    ot = ~ot >>> 0,
                    ++ot > 4294967295 && (ot = 0,
                    ++et > 4294967295 && (et = 0))),
                    new _(ot,et)
                }
                ,
                _.from = function(nt) {
                    if (typeof nt == "number")
                        return _.fromNumber(nt);
                    if (a.isString(nt)) {
                        if (!a.Long)
                            return _.fromNumber(parseInt(nt, 10));
                        nt = a.Long.fromString(nt)
                    }
                    return nt.low || nt.high ? new _(nt.low >>> 0,nt.high >>> 0) : $
                }
                ,
                _.prototype.toNumber = function(nt) {
                    if (!nt && this.hi >>> 31) {
                        var rt = 1 + ~this.lo >>> 0
                          , ot = ~this.hi >>> 0;
                        return rt || (ot = ot + 1 >>> 0),
                        -(rt + 4294967296 * ot)
                    }
                    return this.lo + 4294967296 * this.hi
                }
                ,
                _.prototype.toLong = function(nt) {
                    return a.Long ? new a.Long(0 | this.lo,0 | this.hi,!!nt) : {
                        low: 0 | this.lo,
                        high: 0 | this.hi,
                        unsigned: !!nt
                    }
                }
                ;
                var tt = String.prototype.charCodeAt;
                _.fromHash = function(nt) {
                    return nt === _e ? $ : new _((tt.call(nt, 0) | tt.call(nt, 1) << 8 | tt.call(nt, 2) << 16 | tt.call(nt, 3) << 24) >>> 0,(tt.call(nt, 4) | tt.call(nt, 5) << 8 | tt.call(nt, 6) << 16 | tt.call(nt, 7) << 24) >>> 0)
                }
                ,
                _.prototype.toHash = function() {
                    return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24)
                }
                ,
                _.prototype.zzEncode = function() {
                    var nt = this.hi >> 31;
                    return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ nt) >>> 0,
                    this.lo = (this.lo << 1 ^ nt) >>> 0,
                    this
                }
                ,
                _.prototype.zzDecode = function() {
                    var nt = -(1 & this.lo);
                    return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ nt) >>> 0,
                    this.hi = (this.hi >>> 1 ^ nt) >>> 0,
                    this
                }
                ,
                _.prototype.length = function() {
                    var nt = this.lo
                      , rt = (this.lo >>> 28 | this.hi << 4) >>> 0
                      , ot = this.hi >>> 24;
                    return ot === 0 ? rt === 0 ? nt < 16384 ? nt < 128 ? 1 : 2 : nt < 2097152 ? 3 : 4 : rt < 16384 ? rt < 128 ? 5 : 6 : rt < 2097152 ? 7 : 8 : ot < 128 ? 9 : 10
                }
            }
            ,
            9693: function(o, i, s) {
                var a = i;
                function _(_e, tt, nt) {
                    for (var rt = Object.keys(tt), ot = 0; ot < rt.length; ++ot)
                        _e[rt[ot]] !== void 0 && nt || (_e[rt[ot]] = tt[rt[ot]]);
                    return _e
                }
                function $(_e) {
                    function tt(nt, rt) {
                        if (!(this instanceof tt))
                            return new tt(nt,rt);
                        Object.defineProperty(this, "message", {
                            get: function() {
                                return nt
                            }
                        }),
                        Error.captureStackTrace ? Error.captureStackTrace(this, tt) : Object.defineProperty(this, "stack", {
                            value: new Error().stack || ""
                        }),
                        rt && _(this, rt)
                    }
                    return (tt.prototype = Object.create(Error.prototype)).constructor = tt,
                    Object.defineProperty(tt.prototype, "name", {
                        get: function() {
                            return _e
                        }
                    }),
                    tt.prototype.toString = function() {
                        return this.name + ": " + this.message
                    }
                    ,
                    tt
                }
                a.asPromise = s(4537),
                a.base64 = s(7419),
                a.EventEmitter = s(9211),
                a.float = s(945),
                a.inquire = s(7199),
                a.utf8 = s(4997),
                a.pool = s(6662),
                a.LongBits = s(1945),
                a.isNode = !!(s.g !== void 0 && s.g && s.g.process && s.g.process.versions && s.g.process.versions.node),
                a.global = a.isNode && s.g || typeof window < "u" && window || typeof self < "u" && self || this,
                a.emptyArray = Object.freeze ? Object.freeze([]) : [],
                a.emptyObject = Object.freeze ? Object.freeze({}) : {},
                a.isInteger = Number.isInteger || function(_e) {
                    return typeof _e == "number" && isFinite(_e) && Math.floor(_e) === _e
                }
                ,
                a.isString = function(_e) {
                    return typeof _e == "string" || _e instanceof String
                }
                ,
                a.isObject = function(_e) {
                    return _e && typeof _e == "object"
                }
                ,
                a.isset = a.isSet = function(_e, tt) {
                    var nt = _e[tt];
                    return !(nt == null || !_e.hasOwnProperty(tt)) && (typeof nt != "object" || (Array.isArray(nt) ? nt.length : Object.keys(nt).length) > 0)
                }
                ,
                a.Buffer = function() {
                    try {
                        var _e = a.inquire("buffer").Buffer;
                        return _e.prototype.utf8Write ? _e : null
                    } catch {
                        return null
                    }
                }(),
                a._Buffer_from = null,
                a._Buffer_allocUnsafe = null,
                a.newBuffer = function(_e) {
                    return typeof _e == "number" ? a.Buffer ? a._Buffer_allocUnsafe(_e) : new a.Array(_e) : a.Buffer ? a._Buffer_from(_e) : typeof Uint8Array > "u" ? _e : new Uint8Array(_e)
                }
                ,
                a.Array = typeof Uint8Array < "u" ? Uint8Array : Array,
                a.Long = a.global.dcodeIO && a.global.dcodeIO.Long || a.global.Long || a.inquire("long"),
                a.key2Re = /^true|false|0|1$/,
                a.key32Re = /^-?(?:0|[1-9][0-9]*)$/,
                a.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/,
                a.longToHash = function(_e) {
                    return _e ? a.LongBits.from(_e).toHash() : a.LongBits.zeroHash
                }
                ,
                a.longFromHash = function(_e, tt) {
                    var nt = a.LongBits.fromHash(_e);
                    return a.Long ? a.Long.fromBits(nt.lo, nt.hi, tt) : nt.toNumber(!!tt)
                }
                ,
                a.merge = _,
                a.lcFirst = function(_e) {
                    return _e.charAt(0).toLowerCase() + _e.substring(1)
                }
                ,
                a.newError = $,
                a.ProtocolError = $("ProtocolError"),
                a.oneOfGetter = function(_e) {
                    for (var tt = {}, nt = 0; nt < _e.length; ++nt)
                        tt[_e[nt]] = 1;
                    return function() {
                        for (var rt = Object.keys(this), ot = rt.length - 1; ot > -1; --ot)
                            if (tt[rt[ot]] === 1 && this[rt[ot]] !== void 0 && this[rt[ot]] !== null)
                                return rt[ot]
                    }
                }
                ,
                a.oneOfSetter = function(_e) {
                    return function(tt) {
                        for (var nt = 0; nt < _e.length; ++nt)
                            _e[nt] !== tt && delete this[_e[nt]]
                    }
                }
                ,
                a.toJSONOptions = {
                    longs: String,
                    enums: String,
                    bytes: String,
                    json: !0
                },
                a._configure = function() {
                    var _e = a.Buffer;
                    _e ? (a._Buffer_from = _e.from !== Uint8Array.from && _e.from || function(tt, nt) {
                        return new _e(tt,nt)
                    }
                    ,
                    a._Buffer_allocUnsafe = _e.allocUnsafe || function(tt) {
                        return new _e(tt)
                    }
                    ) : a._Buffer_from = a._Buffer_allocUnsafe = null
                }
            },
            1173: (o, i, s) => {
                o.exports = et;
                var a, _ = s(9693), $ = _.LongBits, _e = _.base64, tt = _.utf8;
                function nt(ut, dt, ft) {
                    this.fn = ut,
                    this.len = dt,
                    this.next = void 0,
                    this.val = ft
                }
                function rt() {}
                function ot(ut) {
                    this.head = ut.head,
                    this.tail = ut.tail,
                    this.len = ut.len,
                    this.next = ut.states
                }
                function et() {
                    this.len = 0,
                    this.head = new nt(rt,0,0),
                    this.tail = this.head,
                    this.states = null
                }
                var j = function() {
                    return _.Buffer ? function() {
                        return (et.create = function() {
                            return new a
                        }
                        )()
                    }
                    : function() {
                        return new et
                    }
                };
                function it(ut, dt, ft) {
                    dt[ft] = 255 & ut
                }
                function st(ut, dt) {
                    this.len = ut,
                    this.next = void 0,
                    this.val = dt
                }
                function at(ut, dt, ft) {
                    for (; ut.hi; )
                        dt[ft++] = 127 & ut.lo | 128,
                        ut.lo = (ut.lo >>> 7 | ut.hi << 25) >>> 0,
                        ut.hi >>>= 7;
                    for (; ut.lo > 127; )
                        dt[ft++] = 127 & ut.lo | 128,
                        ut.lo = ut.lo >>> 7;
                    dt[ft++] = ut.lo
                }
                function lt(ut, dt, ft) {
                    dt[ft] = 255 & ut,
                    dt[ft + 1] = ut >>> 8 & 255,
                    dt[ft + 2] = ut >>> 16 & 255,
                    dt[ft + 3] = ut >>> 24
                }
                et.create = j(),
                et.alloc = function(ut) {
                    return new _.Array(ut)
                }
                ,
                _.Array !== Array && (et.alloc = _.pool(et.alloc, _.Array.prototype.subarray)),
                et.prototype._push = function(ut, dt, ft) {
                    return this.tail = this.tail.next = new nt(ut,dt,ft),
                    this.len += dt,
                    this
                }
                ,
                st.prototype = Object.create(nt.prototype),
                st.prototype.fn = function(ut, dt, ft) {
                    for (; ut > 127; )
                        dt[ft++] = 127 & ut | 128,
                        ut >>>= 7;
                    dt[ft] = ut
                }
                ,
                et.prototype.uint32 = function(ut) {
                    return this.len += (this.tail = this.tail.next = new st((ut >>>= 0) < 128 ? 1 : ut < 16384 ? 2 : ut < 2097152 ? 3 : ut < 268435456 ? 4 : 5,ut)).len,
                    this
                }
                ,
                et.prototype.int32 = function(ut) {
                    return ut < 0 ? this._push(at, 10, $.fromNumber(ut)) : this.uint32(ut)
                }
                ,
                et.prototype.sint32 = function(ut) {
                    return this.uint32((ut << 1 ^ ut >> 31) >>> 0)
                }
                ,
                et.prototype.uint64 = function(ut) {
                    var dt = $.from(ut);
                    return this._push(at, dt.length(), dt)
                }
                ,
                et.prototype.int64 = et.prototype.uint64,
                et.prototype.sint64 = function(ut) {
                    var dt = $.from(ut).zzEncode();
                    return this._push(at, dt.length(), dt)
                }
                ,
                et.prototype.bool = function(ut) {
                    return this._push(it, 1, ut ? 1 : 0)
                }
                ,
                et.prototype.fixed32 = function(ut) {
                    return this._push(lt, 4, ut >>> 0)
                }
                ,
                et.prototype.sfixed32 = et.prototype.fixed32,
                et.prototype.fixed64 = function(ut) {
                    var dt = $.from(ut);
                    return this._push(lt, 4, dt.lo)._push(lt, 4, dt.hi)
                }
                ,
                et.prototype.sfixed64 = et.prototype.fixed64,
                et.prototype.float = function(ut) {
                    return this._push(_.float.writeFloatLE, 4, ut)
                }
                ,
                et.prototype.double = function(ut) {
                    return this._push(_.float.writeDoubleLE, 8, ut)
                }
                ;
                var ct = _.Array.prototype.set ? function(ut, dt, ft) {
                    dt.set(ut, ft)
                }
                : function(ut, dt, ft) {
                    for (var ht = 0; ht < ut.length; ++ht)
                        dt[ft + ht] = ut[ht]
                }
                ;
                et.prototype.bytes = function(ut) {
                    var dt = ut.length >>> 0;
                    if (!dt)
                        return this._push(it, 1, 0);
                    if (_.isString(ut)) {
                        var ft = et.alloc(dt = _e.length(ut));
                        _e.decode(ut, ft, 0),
                        ut = ft
                    }
                    return this.uint32(dt)._push(ct, dt, ut)
                }
                ,
                et.prototype.string = function(ut) {
                    var dt = tt.length(ut);
                    return dt ? this.uint32(dt)._push(tt.write, dt, ut) : this._push(it, 1, 0)
                }
                ,
                et.prototype.fork = function() {
                    return this.states = new ot(this),
                    this.head = this.tail = new nt(rt,0,0),
                    this.len = 0,
                    this
                }
                ,
                et.prototype.reset = function() {
                    return this.states ? (this.head = this.states.head,
                    this.tail = this.states.tail,
                    this.len = this.states.len,
                    this.states = this.states.next) : (this.head = this.tail = new nt(rt,0,0),
                    this.len = 0),
                    this
                }
                ,
                et.prototype.ldelim = function() {
                    var ut = this.head
                      , dt = this.tail
                      , ft = this.len;
                    return this.reset().uint32(ft),
                    ft && (this.tail.next = ut.next,
                    this.tail = dt,
                    this.len += ft),
                    this
                }
                ,
                et.prototype.finish = function() {
                    for (var ut = this.head.next, dt = this.constructor.alloc(this.len), ft = 0; ut; )
                        ut.fn(ut.val, dt, ft),
                        ft += ut.len,
                        ut = ut.next;
                    return dt
                }
                ,
                et._configure = function(ut) {
                    a = ut,
                    et.create = j(),
                    a._configure()
                }
            }
            ,
            3155: (o, i, s) => {
                o.exports = $;
                var a = s(1173);
                ($.prototype = Object.create(a.prototype)).constructor = $;
                var _ = s(9693);
                function $() {
                    a.call(this)
                }
                function _e(tt, nt, rt) {
                    tt.length < 40 ? _.utf8.write(tt, nt, rt) : nt.utf8Write ? nt.utf8Write(tt, rt) : nt.write(tt, rt)
                }
                $._configure = function() {
                    $.alloc = _._Buffer_allocUnsafe,
                    $.writeBytesBuffer = _.Buffer && _.Buffer.prototype instanceof Uint8Array && _.Buffer.prototype.set.name === "set" ? function(tt, nt, rt) {
                        nt.set(tt, rt)
                    }
                    : function(tt, nt, rt) {
                        if (tt.copy)
                            tt.copy(nt, rt, 0, tt.length);
                        else
                            for (var ot = 0; ot < tt.length; )
                                nt[rt++] = tt[ot++]
                    }
                }
                ,
                $.prototype.bytes = function(tt) {
                    _.isString(tt) && (tt = _._Buffer_from(tt, "base64"));
                    var nt = tt.length >>> 0;
                    return this.uint32(nt),
                    nt && this._push($.writeBytesBuffer, nt, tt),
                    this
                }
                ,
                $.prototype.string = function(tt) {
                    var nt = _.Buffer.byteLength(tt);
                    return this.uint32(nt),
                    nt && this._push(_e, nt, tt),
                    this
                }
                ,
                $._configure()
            }
            ,
            4154: o => {
                o.exports = `"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};
`
            }
            ,
            7067: () => {}
            ,
            1296: () => {}
            ,
            760: () => {}
            ,
            1384: () => {}
            ,
            3993: () => {}
            ,
            908: () => {}
            ,
            6953: () => {}
            ,
            9925: () => {}
            ,
            2806: () => {}
            ,
            6449: () => {}
            ,
            2850: () => {}
            ,
            5381: () => {}
            ,
            5686: (o, i, s) => {
                s.r(i),
                s.d(i, {
                    flatbuffers: () => a
                });
                var a = {};
                a.Offset,
                a.Table,
                a.SIZEOF_SHORT = 2,
                a.SIZEOF_INT = 4,
                a.FILE_IDENTIFIER_LENGTH = 4,
                a.SIZE_PREFIX_LENGTH = 4,
                a.Encoding = {
                    UTF8_BYTES: 1,
                    UTF16_STRING: 2
                },
                a.int32 = new Int32Array(2),
                a.float32 = new Float32Array(a.int32.buffer),
                a.float64 = new Float64Array(a.int32.buffer),
                a.isLittleEndian = new Uint16Array(new Uint8Array([1, 0]).buffer)[0] === 1,
                a.Long = function(_, $) {
                    this.low = 0 | _,
                    this.high = 0 | $
                }
                ,
                a.Long.create = function(_, $) {
                    return _ == 0 && $ == 0 ? a.Long.ZERO : new a.Long(_,$)
                }
                ,
                a.Long.prototype.toFloat64 = function() {
                    return (this.low >>> 0) + 4294967296 * this.high
                }
                ,
                a.Long.prototype.equals = function(_) {
                    return this.low == _.low && this.high == _.high
                }
                ,
                a.Long.ZERO = new a.Long(0,0),
                a.Builder = function(_) {
                    if (_)
                        $ = _;
                    else
                        var $ = 1024;
                    this.bb = a.ByteBuffer.allocate($),
                    this.space = $,
                    this.minalign = 1,
                    this.vtable = null,
                    this.vtable_in_use = 0,
                    this.isNested = !1,
                    this.object_start = 0,
                    this.vtables = [],
                    this.vector_num_elems = 0,
                    this.force_defaults = !1
                }
                ,
                a.Builder.prototype.clear = function() {
                    this.bb.clear(),
                    this.space = this.bb.capacity(),
                    this.minalign = 1,
                    this.vtable = null,
                    this.vtable_in_use = 0,
                    this.isNested = !1,
                    this.object_start = 0,
                    this.vtables = [],
                    this.vector_num_elems = 0,
                    this.force_defaults = !1
                }
                ,
                a.Builder.prototype.forceDefaults = function(_) {
                    this.force_defaults = _
                }
                ,
                a.Builder.prototype.dataBuffer = function() {
                    return this.bb
                }
                ,
                a.Builder.prototype.asUint8Array = function() {
                    return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset())
                }
                ,
                a.Builder.prototype.prep = function(_, $) {
                    _ > this.minalign && (this.minalign = _);
                    for (var _e = 1 + ~(this.bb.capacity() - this.space + $) & _ - 1; this.space < _e + _ + $; ) {
                        var tt = this.bb.capacity();
                        this.bb = a.Builder.growByteBuffer(this.bb),
                        this.space += this.bb.capacity() - tt
                    }
                    this.pad(_e)
                }
                ,
                a.Builder.prototype.pad = function(_) {
                    for (var $ = 0; $ < _; $++)
                        this.bb.writeInt8(--this.space, 0)
                }
                ,
                a.Builder.prototype.writeInt8 = function(_) {
                    this.bb.writeInt8(this.space -= 1, _)
                }
                ,
                a.Builder.prototype.writeInt16 = function(_) {
                    this.bb.writeInt16(this.space -= 2, _)
                }
                ,
                a.Builder.prototype.writeInt32 = function(_) {
                    this.bb.writeInt32(this.space -= 4, _)
                }
                ,
                a.Builder.prototype.writeInt64 = function(_) {
                    this.bb.writeInt64(this.space -= 8, _)
                }
                ,
                a.Builder.prototype.writeFloat32 = function(_) {
                    this.bb.writeFloat32(this.space -= 4, _)
                }
                ,
                a.Builder.prototype.writeFloat64 = function(_) {
                    this.bb.writeFloat64(this.space -= 8, _)
                }
                ,
                a.Builder.prototype.addInt8 = function(_) {
                    this.prep(1, 0),
                    this.writeInt8(_)
                }
                ,
                a.Builder.prototype.addInt16 = function(_) {
                    this.prep(2, 0),
                    this.writeInt16(_)
                }
                ,
                a.Builder.prototype.addInt32 = function(_) {
                    this.prep(4, 0),
                    this.writeInt32(_)
                }
                ,
                a.Builder.prototype.addInt64 = function(_) {
                    this.prep(8, 0),
                    this.writeInt64(_)
                }
                ,
                a.Builder.prototype.addFloat32 = function(_) {
                    this.prep(4, 0),
                    this.writeFloat32(_)
                }
                ,
                a.Builder.prototype.addFloat64 = function(_) {
                    this.prep(8, 0),
                    this.writeFloat64(_)
                }
                ,
                a.Builder.prototype.addFieldInt8 = function(_, $, _e) {
                    (this.force_defaults || $ != _e) && (this.addInt8($),
                    this.slot(_))
                }
                ,
                a.Builder.prototype.addFieldInt16 = function(_, $, _e) {
                    (this.force_defaults || $ != _e) && (this.addInt16($),
                    this.slot(_))
                }
                ,
                a.Builder.prototype.addFieldInt32 = function(_, $, _e) {
                    (this.force_defaults || $ != _e) && (this.addInt32($),
                    this.slot(_))
                }
                ,
                a.Builder.prototype.addFieldInt64 = function(_, $, _e) {
                    !this.force_defaults && $.equals(_e) || (this.addInt64($),
                    this.slot(_))
                }
                ,
                a.Builder.prototype.addFieldFloat32 = function(_, $, _e) {
                    (this.force_defaults || $ != _e) && (this.addFloat32($),
                    this.slot(_))
                }
                ,
                a.Builder.prototype.addFieldFloat64 = function(_, $, _e) {
                    (this.force_defaults || $ != _e) && (this.addFloat64($),
                    this.slot(_))
                }
                ,
                a.Builder.prototype.addFieldOffset = function(_, $, _e) {
                    (this.force_defaults || $ != _e) && (this.addOffset($),
                    this.slot(_))
                }
                ,
                a.Builder.prototype.addFieldStruct = function(_, $, _e) {
                    $ != _e && (this.nested($),
                    this.slot(_))
                }
                ,
                a.Builder.prototype.nested = function(_) {
                    if (_ != this.offset())
                        throw new Error("FlatBuffers: struct must be serialized inline.")
                }
                ,
                a.Builder.prototype.notNested = function() {
                    if (this.isNested)
                        throw new Error("FlatBuffers: object serialization must not be nested.")
                }
                ,
                a.Builder.prototype.slot = function(_) {
                    this.vtable[_] = this.offset()
                }
                ,
                a.Builder.prototype.offset = function() {
                    return this.bb.capacity() - this.space
                }
                ,
                a.Builder.growByteBuffer = function(_) {
                    var $ = _.capacity();
                    if (3221225472 & $)
                        throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
                    var _e = $ << 1
                      , tt = a.ByteBuffer.allocate(_e);
                    return tt.setPosition(_e - $),
                    tt.bytes().set(_.bytes(), _e - $),
                    tt
                }
                ,
                a.Builder.prototype.addOffset = function(_) {
                    this.prep(a.SIZEOF_INT, 0),
                    this.writeInt32(this.offset() - _ + a.SIZEOF_INT)
                }
                ,
                a.Builder.prototype.startObject = function(_) {
                    this.notNested(),
                    this.vtable == null && (this.vtable = []),
                    this.vtable_in_use = _;
                    for (var $ = 0; $ < _; $++)
                        this.vtable[$] = 0;
                    this.isNested = !0,
                    this.object_start = this.offset()
                }
                ,
                a.Builder.prototype.endObject = function() {
                    if (this.vtable == null || !this.isNested)
                        throw new Error("FlatBuffers: endObject called without startObject");
                    this.addInt32(0);
                    for (var _ = this.offset(), $ = this.vtable_in_use - 1; $ >= 0 && this.vtable[$] == 0; $--)
                        ;
                    for (var _e = $ + 1; $ >= 0; $--)
                        this.addInt16(this.vtable[$] != 0 ? _ - this.vtable[$] : 0);
                    this.addInt16(_ - this.object_start);
                    var tt = (_e + 2) * a.SIZEOF_SHORT;
                    this.addInt16(tt);
                    var nt = 0
                      , rt = this.space;
                    e: for ($ = 0; $ < this.vtables.length; $++) {
                        var ot = this.bb.capacity() - this.vtables[$];
                        if (tt == this.bb.readInt16(ot)) {
                            for (var et = a.SIZEOF_SHORT; et < tt; et += a.SIZEOF_SHORT)
                                if (this.bb.readInt16(rt + et) != this.bb.readInt16(ot + et))
                                    continue e;
                            nt = this.vtables[$];
                            break
                        }
                    }
                    return nt ? (this.space = this.bb.capacity() - _,
                    this.bb.writeInt32(this.space, nt - _)) : (this.vtables.push(this.offset()),
                    this.bb.writeInt32(this.bb.capacity() - _, this.offset() - _)),
                    this.isNested = !1,
                    _
                }
                ,
                a.Builder.prototype.finish = function(_, $, _e) {
                    var tt = _e ? a.SIZE_PREFIX_LENGTH : 0;
                    if ($) {
                        var nt = $;
                        if (this.prep(this.minalign, a.SIZEOF_INT + a.FILE_IDENTIFIER_LENGTH + tt),
                        nt.length != a.FILE_IDENTIFIER_LENGTH)
                            throw new Error("FlatBuffers: file identifier must be length " + a.FILE_IDENTIFIER_LENGTH);
                        for (var rt = a.FILE_IDENTIFIER_LENGTH - 1; rt >= 0; rt--)
                            this.writeInt8(nt.charCodeAt(rt))
                    }
                    this.prep(this.minalign, a.SIZEOF_INT + tt),
                    this.addOffset(_),
                    tt && this.addInt32(this.bb.capacity() - this.space),
                    this.bb.setPosition(this.space)
                }
                ,
                a.Builder.prototype.finishSizePrefixed = function(_, $) {
                    this.finish(_, $, !0)
                }
                ,
                a.Builder.prototype.requiredField = function(_, $) {
                    var _e = this.bb.capacity() - _
                      , tt = _e - this.bb.readInt32(_e);
                    if (this.bb.readInt16(tt + $) == 0)
                        throw new Error("FlatBuffers: field " + $ + " must be set")
                }
                ,
                a.Builder.prototype.startVector = function(_, $, _e) {
                    this.notNested(),
                    this.vector_num_elems = $,
                    this.prep(a.SIZEOF_INT, _ * $),
                    this.prep(_e, _ * $)
                }
                ,
                a.Builder.prototype.endVector = function() {
                    return this.writeInt32(this.vector_num_elems),
                    this.offset()
                }
                ,
                a.Builder.prototype.createString = function(_) {
                    if (_ instanceof Uint8Array)
                        var $ = _;
                    else {
                        $ = [];
                        for (var _e = 0; _e < _.length; ) {
                            var tt, nt = _.charCodeAt(_e++);
                            (tt = nt < 55296 || nt >= 56320 ? nt : (nt << 10) + _.charCodeAt(_e++) + -56613888) < 128 ? $.push(tt) : (tt < 2048 ? $.push(tt >> 6 & 31 | 192) : (tt < 65536 ? $.push(tt >> 12 & 15 | 224) : $.push(tt >> 18 & 7 | 240, tt >> 12 & 63 | 128),
                            $.push(tt >> 6 & 63 | 128)),
                            $.push(63 & tt | 128))
                        }
                    }
                    this.addInt8(0),
                    this.startVector(1, $.length, 1),
                    this.bb.setPosition(this.space -= $.length),
                    _e = 0;
                    for (var rt = this.space, ot = this.bb.bytes(); _e < $.length; _e++)
                        ot[rt++] = $[_e];
                    return this.endVector()
                }
                ,
                a.Builder.prototype.createLong = function(_, $) {
                    return a.Long.create(_, $)
                }
                ,
                a.ByteBuffer = function(_) {
                    this.bytes_ = _,
                    this.position_ = 0
                }
                ,
                a.ByteBuffer.allocate = function(_) {
                    return new a.ByteBuffer(new Uint8Array(_))
                }
                ,
                a.ByteBuffer.prototype.clear = function() {
                    this.position_ = 0
                }
                ,
                a.ByteBuffer.prototype.bytes = function() {
                    return this.bytes_
                }
                ,
                a.ByteBuffer.prototype.position = function() {
                    return this.position_
                }
                ,
                a.ByteBuffer.prototype.setPosition = function(_) {
                    this.position_ = _
                }
                ,
                a.ByteBuffer.prototype.capacity = function() {
                    return this.bytes_.length
                }
                ,
                a.ByteBuffer.prototype.readInt8 = function(_) {
                    return this.readUint8(_) << 24 >> 24
                }
                ,
                a.ByteBuffer.prototype.readUint8 = function(_) {
                    return this.bytes_[_]
                }
                ,
                a.ByteBuffer.prototype.readInt16 = function(_) {
                    return this.readUint16(_) << 16 >> 16
                }
                ,
                a.ByteBuffer.prototype.readUint16 = function(_) {
                    return this.bytes_[_] | this.bytes_[_ + 1] << 8
                }
                ,
                a.ByteBuffer.prototype.readInt32 = function(_) {
                    return this.bytes_[_] | this.bytes_[_ + 1] << 8 | this.bytes_[_ + 2] << 16 | this.bytes_[_ + 3] << 24
                }
                ,
                a.ByteBuffer.prototype.readUint32 = function(_) {
                    return this.readInt32(_) >>> 0
                }
                ,
                a.ByteBuffer.prototype.readInt64 = function(_) {
                    return new a.Long(this.readInt32(_),this.readInt32(_ + 4))
                }
                ,
                a.ByteBuffer.prototype.readUint64 = function(_) {
                    return new a.Long(this.readUint32(_),this.readUint32(_ + 4))
                }
                ,
                a.ByteBuffer.prototype.readFloat32 = function(_) {
                    return a.int32[0] = this.readInt32(_),
                    a.float32[0]
                }
                ,
                a.ByteBuffer.prototype.readFloat64 = function(_) {
                    return a.int32[a.isLittleEndian ? 0 : 1] = this.readInt32(_),
                    a.int32[a.isLittleEndian ? 1 : 0] = this.readInt32(_ + 4),
                    a.float64[0]
                }
                ,
                a.ByteBuffer.prototype.writeInt8 = function(_, $) {
                    this.bytes_[_] = $
                }
                ,
                a.ByteBuffer.prototype.writeUint8 = function(_, $) {
                    this.bytes_[_] = $
                }
                ,
                a.ByteBuffer.prototype.writeInt16 = function(_, $) {
                    this.bytes_[_] = $,
                    this.bytes_[_ + 1] = $ >> 8
                }
                ,
                a.ByteBuffer.prototype.writeUint16 = function(_, $) {
                    this.bytes_[_] = $,
                    this.bytes_[_ + 1] = $ >> 8
                }
                ,
                a.ByteBuffer.prototype.writeInt32 = function(_, $) {
                    this.bytes_[_] = $,
                    this.bytes_[_ + 1] = $ >> 8,
                    this.bytes_[_ + 2] = $ >> 16,
                    this.bytes_[_ + 3] = $ >> 24
                }
                ,
                a.ByteBuffer.prototype.writeUint32 = function(_, $) {
                    this.bytes_[_] = $,
                    this.bytes_[_ + 1] = $ >> 8,
                    this.bytes_[_ + 2] = $ >> 16,
                    this.bytes_[_ + 3] = $ >> 24
                }
                ,
                a.ByteBuffer.prototype.writeInt64 = function(_, $) {
                    this.writeInt32(_, $.low),
                    this.writeInt32(_ + 4, $.high)
                }
                ,
                a.ByteBuffer.prototype.writeUint64 = function(_, $) {
                    this.writeUint32(_, $.low),
                    this.writeUint32(_ + 4, $.high)
                }
                ,
                a.ByteBuffer.prototype.writeFloat32 = function(_, $) {
                    a.float32[0] = $,
                    this.writeInt32(_, a.int32[0])
                }
                ,
                a.ByteBuffer.prototype.writeFloat64 = function(_, $) {
                    a.float64[0] = $,
                    this.writeInt32(_, a.int32[a.isLittleEndian ? 0 : 1]),
                    this.writeInt32(_ + 4, a.int32[a.isLittleEndian ? 1 : 0])
                }
                ,
                a.ByteBuffer.prototype.getBufferIdentifier = function() {
                    if (this.bytes_.length < this.position_ + a.SIZEOF_INT + a.FILE_IDENTIFIER_LENGTH)
                        throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
                    for (var _ = "", $ = 0; $ < a.FILE_IDENTIFIER_LENGTH; $++)
                        _ += String.fromCharCode(this.readInt8(this.position_ + a.SIZEOF_INT + $));
                    return _
                }
                ,
                a.ByteBuffer.prototype.__offset = function(_, $) {
                    var _e = _ - this.readInt32(_);
                    return $ < this.readInt16(_e) ? this.readInt16(_e + $) : 0
                }
                ,
                a.ByteBuffer.prototype.__union = function(_, $) {
                    return _.bb_pos = $ + this.readInt32($),
                    _.bb = this,
                    _
                }
                ,
                a.ByteBuffer.prototype.__string = function(_, $) {
                    _ += this.readInt32(_);
                    var _e = this.readInt32(_)
                      , tt = ""
                      , nt = 0;
                    if (_ += a.SIZEOF_INT,
                    $ === a.Encoding.UTF8_BYTES)
                        return this.bytes_.subarray(_, _ + _e);
                    for (; nt < _e; ) {
                        var rt, ot = this.readUint8(_ + nt++);
                        if (ot < 192)
                            rt = ot;
                        else {
                            var et = this.readUint8(_ + nt++);
                            if (ot < 224)
                                rt = (31 & ot) << 6 | 63 & et;
                            else {
                                var j = this.readUint8(_ + nt++);
                                rt = ot < 240 ? (15 & ot) << 12 | (63 & et) << 6 | 63 & j : (7 & ot) << 18 | (63 & et) << 12 | (63 & j) << 6 | 63 & this.readUint8(_ + nt++)
                            }
                        }
                        rt < 65536 ? tt += String.fromCharCode(rt) : (rt -= 65536,
                        tt += String.fromCharCode(55296 + (rt >> 10), 56320 + (1023 & rt)))
                    }
                    return tt
                }
                ,
                a.ByteBuffer.prototype.__indirect = function(_) {
                    return _ + this.readInt32(_)
                }
                ,
                a.ByteBuffer.prototype.__vector = function(_) {
                    return _ + this.readInt32(_) + a.SIZEOF_INT
                }
                ,
                a.ByteBuffer.prototype.__vector_len = function(_) {
                    return this.readInt32(_ + this.readInt32(_))
                }
                ,
                a.ByteBuffer.prototype.__has_identifier = function(_) {
                    if (_.length != a.FILE_IDENTIFIER_LENGTH)
                        throw new Error("FlatBuffers: file identifier must be length " + a.FILE_IDENTIFIER_LENGTH);
                    for (var $ = 0; $ < a.FILE_IDENTIFIER_LENGTH; $++)
                        if (_.charCodeAt($) != this.readInt8(this.position_ + a.SIZEOF_INT + $))
                            return !1;
                    return !0
                }
                ,
                a.ByteBuffer.prototype.createLong = function(_, $) {
                    return a.Long.create(_, $)
                }
            }
        }
          , __webpack_module_cache__ = {};
        function __webpack_require__(o) {
            var i = __webpack_module_cache__[o];
            if (i !== void 0)
                return i.exports;
            var s = __webpack_module_cache__[o] = {
                exports: {}
            };
            return __webpack_modules__[o].call(s.exports, s, s.exports, __webpack_require__),
            s.exports
        }
        __webpack_require__.n = o => {
            var i = o && o.__esModule ? () => o.default : () => o;
            return __webpack_require__.d(i, {
                a: i
            }),
            i
        }
        ,
        __webpack_require__.d = (o, i) => {
            for (var s in i)
                __webpack_require__.o(i, s) && !__webpack_require__.o(o, s) && Object.defineProperty(o, s, {
                    enumerable: !0,
                    get: i[s]
                })
        }
        ,
        __webpack_require__.g = function() {
            if (typeof globalThis == "object")
                return globalThis;
            try {
                return this || new Function("return this")()
            } catch {
                if (typeof window == "object")
                    return window
            }
        }(),
        __webpack_require__.o = (o, i) => Object.prototype.hasOwnProperty.call(o, i),
        __webpack_require__.r = o => {
            typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(o, Symbol.toStringTag, {
                value: "Module"
            }),
            Object.defineProperty(o, "__esModule", {
                value: !0
            })
        }
        ;
        var __webpack_exports__ = __webpack_require__(1057);
        return __webpack_exports__
    }
    )())
}
)(ort_min);
var ort_minExports = ort_min.exports;
const UPLOAD_IMAGE_SIZE = 1024
  , EMBEDDINGS_GENERATOR_ENDPOINT = "https://model-zoo.metademolab.com/predictions/segment_everything_box_model";
function ccw(o, i, s, a, _, $) {
    const _e = ($ - i) * (s - o) - (a - i) * (_ - o);
    return _e > 0 ? !0 : !(_e < 0)
}
function intersect$1(o, i) {
    const s = o[0][0]
      , a = o[0][1]
      , _ = o[1][0]
      , $ = o[1][1]
      , _e = i[0][0]
      , tt = i[0][1]
      , nt = i[1][0]
      , rt = i[1][1];
    return ccw(s, a, _e, tt, nt, rt) !== ccw(_, $, _e, tt, nt, rt) && ccw(s, a, _, $, _e, tt) !== ccw(s, a, _, $, nt, rt)
}
var intersect_1 = intersect$1;
function Grid(o, i) {
    this._cells = [],
    this._cellSize = i,
    this._reverseCellSize = 1 / i;
    for (let s = 0; s < o.length; s++) {
        const a = o[s]
          , _ = this.coordToCellNum(a[0])
          , $ = this.coordToCellNum(a[1]);
        if (this._cells[_])
            this._cells[_][$] ? this._cells[_][$].push(a) : this._cells[_][$] = [a];
        else {
            const _e = [];
            _e[$] = [a],
            this._cells[_] = _e
        }
    }
}
Grid.prototype = {
    cellPoints: function(o, i) {
        return this._cells[o] !== void 0 && this._cells[o][i] !== void 0 ? this._cells[o][i] : []
    },
    rangePoints: function(o) {
        const i = this.coordToCellNum(o[0])
          , s = this.coordToCellNum(o[1])
          , a = this.coordToCellNum(o[2])
          , _ = this.coordToCellNum(o[3])
          , $ = [];
        for (let _e = i; _e <= a; _e++)
            for (let tt = s; tt <= _; tt++)
                for (let nt = 0; nt < this.cellPoints(_e, tt).length; nt++)
                    $.push(this.cellPoints(_e, tt)[nt]);
        return $
    },
    removePoint: function(o) {
        const i = this.coordToCellNum(o[0])
          , s = this.coordToCellNum(o[1])
          , a = this._cells[i][s];
        let _;
        for (let $ = 0; $ < a.length; $++)
            if (a[$][0] === o[0] && a[$][1] === o[1]) {
                _ = $;
                break
            }
        return a.splice(_, 1),
        a
    },
    trunc: Math.trunc || function(o) {
        return o - o % 1
    }
    ,
    coordToCellNum: function(o) {
        return this.trunc(o * this._reverseCellSize)
    },
    extendBbox: function(o, i) {
        return [o[0] - i * this._cellSize, o[1] - i * this._cellSize, o[2] + i * this._cellSize, o[3] + i * this._cellSize]
    }
};
function grid$1(o, i) {
    return new Grid(o,i)
}
var grid_1 = grid$1
  , format = {
    toXy: function(o, i) {
        return i === void 0 ? o.slice() : o.map(function(s) {
            return new Function("pt","return [pt" + i[0] + ",pt" + i[1] + "];")(s)
        })
    },
    fromXy: function(o, i) {
        return i === void 0 ? o.slice() : o.map(function(s) {
            return new Function("pt","const o = {}; o" + i[0] + "= pt[0]; o" + i[1] + "= pt[1]; return o;")(s)
        })
    }
};
function _cross(o, i, s) {
    return (i[0] - o[0]) * (s[1] - o[1]) - (i[1] - o[1]) * (s[0] - o[0])
}
function _upperTangent(o) {
    const i = [];
    for (let s = 0; s < o.length; s++) {
        for (; i.length >= 2 && _cross(i[i.length - 2], i[i.length - 1], o[s]) <= 0; )
            i.pop();
        i.push(o[s])
    }
    return i.pop(),
    i
}
function _lowerTangent(o) {
    const i = o.reverse()
      , s = [];
    for (let a = 0; a < i.length; a++) {
        for (; s.length >= 2 && _cross(s[s.length - 2], s[s.length - 1], i[a]) <= 0; )
            s.pop();
        s.push(i[a])
    }
    return s.pop(),
    s
}
function convex(o) {
    const i = _upperTangent(o)
      , a = _lowerTangent(o).concat(i);
    return a.push(o[0]),
    a
}
var convex_1 = convex;
const intersect = intersect_1
  , grid = grid_1
  , formatUtil = format
  , convexHull = convex_1;
function _filterDuplicates(o) {
    const i = [o[0]];
    let s = o[0];
    for (let a = 1; a < o.length; a++) {
        const _ = o[a];
        (s[0] !== _[0] || s[1] !== _[1]) && i.push(_),
        s = _
    }
    return i
}
function _sortByX(o) {
    return o.sort(function(i, s) {
        return i[0] - s[0] || i[1] - s[1]
    })
}
function _sqLength(o, i) {
    return Math.pow(i[0] - o[0], 2) + Math.pow(i[1] - o[1], 2)
}
function _cos(o, i, s) {
    const a = [i[0] - o[0], i[1] - o[1]]
      , _ = [s[0] - o[0], s[1] - o[1]]
      , $ = _sqLength(o, i)
      , _e = _sqLength(o, s);
    return (a[0] * _[0] + a[1] * _[1]) / Math.sqrt($ * _e)
}
function _intersect(o, i) {
    for (let s = 0; s < i.length - 1; s++) {
        const a = [i[s], i[s + 1]];
        if (!(o[0][0] === a[0][0] && o[0][1] === a[0][1] || o[0][0] === a[1][0] && o[0][1] === a[1][1]) && intersect(o, a))
            return !0
    }
    return !1
}
function _occupiedArea(o) {
    let i = 1 / 0
      , s = 1 / 0
      , a = -1 / 0
      , _ = -1 / 0;
    for (let $ = o.length - 1; $ >= 0; $--)
        o[$][0] < i && (i = o[$][0]),
        o[$][1] < s && (s = o[$][1]),
        o[$][0] > a && (a = o[$][0]),
        o[$][1] > _ && (_ = o[$][1]);
    return [a - i, _ - s]
}
function _bBoxAround(o) {
    return [Math.min(o[0][0], o[1][0]), Math.min(o[0][1], o[1][1]), Math.max(o[0][0], o[1][0]), Math.max(o[0][1], o[1][1])]
}
function _midPoint(o, i, s) {
    let a = null, _ = MAX_CONCAVE_ANGLE_COS, $ = MAX_CONCAVE_ANGLE_COS, _e, tt;
    for (let nt = 0; nt < i.length; nt++)
        _e = _cos(o[0], o[1], i[nt]),
        tt = _cos(o[1], o[0], i[nt]),
        _e > _ && tt > $ && !_intersect([o[0], i[nt]], s) && !_intersect([o[1], i[nt]], s) && (_ = _e,
        $ = tt,
        a = i[nt]);
    return a
}
function _concave(o, i, s, a, _) {
    let $ = !1;
    for (let _e = 0; _e < o.length - 1; _e++) {
        const tt = [o[_e], o[_e + 1]]
          , nt = tt[0][0] + "," + tt[0][1] + "," + tt[1][0] + "," + tt[1][1];
        if (_sqLength(tt[0], tt[1]) < i || _.has(nt))
            continue;
        let rt = 0, ot = _bBoxAround(tt), et, j, it;
        do
            ot = a.extendBbox(ot, rt),
            et = ot[2] - ot[0],
            j = ot[3] - ot[1],
            it = _midPoint(tt, a.rangePoints(ot), o),
            rt++;
        while (it === null && (s[0] > et || s[1] > j));
        et >= s[0] && j >= s[1] && _.add(nt),
        it !== null && (o.splice(_e + 1, 0, it),
        a.removePoint(it),
        $ = !0)
    }
    return $ ? _concave(o, i, s, a, _) : o
}
function hull(o, i, s) {
    let a = i || 20;
    const _ = _filterDuplicates(_sortByX(formatUtil.toXy(o, s)));
    if (_.length < 4) {
        const et = _.concat([_[0]]);
        return s ? formatUtil.fromXy(et, s) : et
    }
    const $ = _occupiedArea(_)
      , _e = [$[0] * MAX_SEARCH_BBOX_SIZE_PERCENT, $[1] * MAX_SEARCH_BBOX_SIZE_PERCENT]
      , tt = convexHull(_)
      , nt = _.filter(function(et) {
        return tt.indexOf(et) < 0
    })
      , rt = Math.ceil(1 / (_.length / ($[0] * $[1])))
      , ot = _concave(tt, Math.pow(a, 2), _e, grid(nt, rt), new Set);
    return s ? formatUtil.fromXy(ot, s) : ot
}
const MAX_CONCAVE_ANGLE_COS = Math.cos(90 / (180 / Math.PI))
  , MAX_SEARCH_BBOX_SIZE_PERCENT = .6;
var hull_1 = hull;
const hull$1 = getDefaultExportFromCjs(hull_1);
function arrayToPolygon(o, i) {
    const s = [];
    for (let a = 0; a < o.length; a++) {
        if (o[a] < 0)
            continue;
        const _ = a % i
          , $ = Math.floor(a / i)
          , _e = {
            x: _,
            y: $
        };
        s.push([_e.x, _e.y])
    }
    return hull$1(s, 0)
}
const modelDataFromPoints = ({clicks: o, tensor: i, modelScale: s, inferenceType: a}) => {
    const _ = i;
    let $, _e, tt, nt;
    if (o) {
        const j = o.length;
        $ = new Float32Array(2 * (j + 1)),
        _e = new Float32Array(j + 1);
        const it = o.map(st => ({
            x: Math.floor(st.x * s.redrawScale),
            y: Math.floor(st.y * s.redrawScale),
            clickType: st.clickType
        }));
        for (let st = 0; st < j; st++)
            $[2 * st] = it[st].x,
            $[2 * st + 1] = it[st].y,
            _e[st] = it[st].clickType;
        a === InferenceType.SinglePoint && ($[2 * j] = 0,
        $[2 * j + 1] = 0,
        _e[j] = -1),
        tt = new ort_minExports.Tensor("float32",$,[1, j + 1, 2]),
        nt = new ort_minExports.Tensor("float32",_e,[1, j + 1])
    }
    const rt = new ort_minExports.Tensor("float32",[s.height, s.width]);
    if (tt === void 0 || nt === void 0)
        return;
    const ot = new ort_minExports.Tensor("float32",new Float32Array(256 * 256),[1, 1, 256, 256])
      , et = new ort_minExports.Tensor("float32",[0]);
    return {
        low_res_embedding: _,
        point_coords: tt,
        point_labels: nt,
        image_size: rt,
        last_pred_mask: ot,
        has_last_pred: et
    }
}
  , modelDataForBox = ({inferenceRequest: o, tensor: i, modelScale: s}) => {
    const a = i
      , _ = new Float32Array(4)
      , $ = new Float32Array(2);
    $[0] = 2,
    $[1] = 3;
    const _e = {
        x: Math.floor(o.topLeft.x * s.redrawScale),
        y: Math.floor(o.topLeft.y * s.redrawScale)
    }
      , tt = {
        x: Math.floor(o.bottomRight.x * s.redrawScale),
        y: Math.floor(o.bottomRight.y * s.redrawScale)
    };
    _[0] = _e.x,
    _[1] = tt.y,
    _[2] = tt.x,
    _[3] = _e.y;
    const nt = new ort_minExports.Tensor("float32",_,[1, 2, 2])
      , rt = new ort_minExports.Tensor("float32",$,[1, 2])
      , ot = new ort_minExports.Tensor("float32",[s.height, s.width])
      , et = new ort_minExports.Tensor("float32",new Float32Array(256 * 256),[1, 1, 256, 256])
      , j = new ort_minExports.Tensor("float32",[0]);
    return {
        low_res_embedding: a,
        point_coords: nt,
        point_labels: rt,
        image_size: ot,
        last_pred_mask: et,
        has_last_pred: j
    }
}
;
var InferenceType = (o => (o[o.SinglePoint = 0] = "SinglePoint",
o[o.BoundingBox = 1] = "BoundingBox",
o))(InferenceType || {});
const segmentAnythingModel = async o => {
    const i = await ort_minExports.InferenceSession.create(o);
    async function s($, _e, tt) {
        const nt = UPLOAD_IMAGE_SIZE / Math.max($.width, $.height)
          , rt = Math.round($.width * nt)
          , ot = Math.round($.height * nt)
          , et = UPLOAD_IMAGE_SIZE / Math.max(_e, tt)
          , j = new OffscreenCanvas(rt,ot)
          , it = j.getContext("2d");
        if (it === null)
            throw new Error("Could not get context");
        it.drawImage($, 0, 0, rt, ot);
        const at = await (await j.convertToBlob()).arrayBuffer()
          , ct = await (await fetch(EMBEDDINGS_GENERATOR_ENDPOINT, {
            method: "POST",
            body: at
        })).json()
          , ut = Uint8Array.from(atob(ct[0]), pt => pt.charCodeAt(0))
          , dt = new Float32Array(ut.buffer)
          , ft = new ort_minExports.Tensor("float32",dt,[1, 256, 64, 64]);
        return {
            scale: {
                height: j.height,
                width: j.width,
                samScale: nt,
                redrawScale: et,
                originalHeight: $.height,
                originalWidth: $.width
            },
            embeddings: ft
        }
    }
    async function a($, _e, tt) {
        let nt = [];
        if (tt.type === 0)
            nt = [{
                x: tt.point.x,
                y: tt.point.y,
                clickType: 1
            }];
        else if (tt.type === 1) {
            const at = {
                x: tt.topLeft.x,
                y: tt.topLeft.y,
                clickType: 1
            }
              , lt = {
                x: tt.bottomRight.x,
                y: tt.bottomRight.y,
                clickType: 1
            };
            nt = [at, lt]
        }
        const rt = {
            clicks: nt,
            tensor: _e.embeddings,
            modelScale: _e.scale,
            inferenceType: tt.type
        }
          , ot = tt.type === 0 ? modelDataFromPoints(rt) : modelDataForBox({
            tensor: _e.embeddings,
            modelScale: _e.scale,
            inferenceRequest: {
                topLeft: tt.topLeft,
                bottomRight: tt.bottomRight,
                type: tt.type
            }
        });
        if (ot === void 0)
            return [];
        const j = (await $.run(ot))[$.outputNames[0]];
        return arrayToPolygon(j.data, _e.scale.width).map(at => [at[0] / _e.scale.redrawScale, at[1] / _e.scale.redrawScale])
    }
    async function _($, _e, tt, nt) {
        const rt = await s($, _e, tt);
        return await Promise.all(nt.map(et => a(i, rt, et)))
    }
    return {
        getInferenceMasks: _
    }
}
  , MODEL_DIR = "/model/interactive_module_quantized_592547_2023_03_19_sam6_long_uncertain.onnx";
var ModelLoadingState = (o => (o[o.Loading = 0] = "Loading",
o[o.Loaded = 1] = "Loaded",
o[o.Error = 2] = "Error",
o))(ModelLoadingState || {});
const SegmentAnythingModelContext = reactExports.createContext({
    state: ModelLoadingState.Loading
})
  , SegmentAnythingContextProvider = ({children: o}) => {
    const [i,s] = reactExports.useState({
        state: ModelLoadingState.Loading
    });
    return reactExports.useEffect( () => {
        (async () => {
            const _ = await segmentAnythingModel(MODEL_DIR);
            s({
                state: ModelLoadingState.Loaded,
                model: _
            }),
            console.log("Segment Anything Model Loaded")
        }
        )().catch(_ => {
            console.error(_),
            s({
                state: ModelLoadingState.Error
            })
        }
        )
    }
    , []),
    jsxRuntimeExports.jsx(SegmentAnythingModelContext.Provider, {
        value: i,
        children: o
    })
}
;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const stringToByteArray$1 = function(o) {
    const i = [];
    let s = 0;
    for (let a = 0; a < o.length; a++) {
        let _ = o.charCodeAt(a);
        _ < 128 ? i[s++] = _ : _ < 2048 ? (i[s++] = _ >> 6 | 192,
        i[s++] = _ & 63 | 128) : (_ & 64512) === 55296 && a + 1 < o.length && (o.charCodeAt(a + 1) & 64512) === 56320 ? (_ = 65536 + ((_ & 1023) << 10) + (o.charCodeAt(++a) & 1023),
        i[s++] = _ >> 18 | 240,
        i[s++] = _ >> 12 & 63 | 128,
        i[s++] = _ >> 6 & 63 | 128,
        i[s++] = _ & 63 | 128) : (i[s++] = _ >> 12 | 224,
        i[s++] = _ >> 6 & 63 | 128,
        i[s++] = _ & 63 | 128)
    }
    return i
}
  , byteArrayToString = function(o) {
    const i = [];
    let s = 0
      , a = 0;
    for (; s < o.length; ) {
        const _ = o[s++];
        if (_ < 128)
            i[a++] = String.fromCharCode(_);
        else if (_ > 191 && _ < 224) {
            const $ = o[s++];
            i[a++] = String.fromCharCode((_ & 31) << 6 | $ & 63)
        } else if (_ > 239 && _ < 365) {
            const $ = o[s++]
              , _e = o[s++]
              , tt = o[s++]
              , nt = ((_ & 7) << 18 | ($ & 63) << 12 | (_e & 63) << 6 | tt & 63) - 65536;
            i[a++] = String.fromCharCode(55296 + (nt >> 10)),
            i[a++] = String.fromCharCode(56320 + (nt & 1023))
        } else {
            const $ = o[s++]
              , _e = o[s++];
            i[a++] = String.fromCharCode((_ & 15) << 12 | ($ & 63) << 6 | _e & 63)
        }
    }
    return i.join("")
}
  , base64 = {
    byteToCharMap_: null,
    charToByteMap_: null,
    byteToCharMapWebSafe_: null,
    charToByteMapWebSafe_: null,
    ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
    get ENCODED_VALS() {
        return this.ENCODED_VALS_BASE + "+/="
    },
    get ENCODED_VALS_WEBSAFE() {
        return this.ENCODED_VALS_BASE + "-_."
    },
    HAS_NATIVE_SUPPORT: typeof atob == "function",
    encodeByteArray(o, i) {
        if (!Array.isArray(o))
            throw Error("encodeByteArray takes an array as a parameter");
        this.init_();
        const s = i ? this.byteToCharMapWebSafe_ : this.byteToCharMap_
          , a = [];
        for (let _ = 0; _ < o.length; _ += 3) {
            const $ = o[_]
              , _e = _ + 1 < o.length
              , tt = _e ? o[_ + 1] : 0
              , nt = _ + 2 < o.length
              , rt = nt ? o[_ + 2] : 0
              , ot = $ >> 2
              , et = ($ & 3) << 4 | tt >> 4;
            let j = (tt & 15) << 2 | rt >> 6
              , it = rt & 63;
            nt || (it = 64,
            _e || (j = 64)),
            a.push(s[ot], s[et], s[j], s[it])
        }
        return a.join("")
    },
    encodeString(o, i) {
        return this.HAS_NATIVE_SUPPORT && !i ? btoa(o) : this.encodeByteArray(stringToByteArray$1(o), i)
    },
    decodeString(o, i) {
        return this.HAS_NATIVE_SUPPORT && !i ? atob(o) : byteArrayToString(this.decodeStringToByteArray(o, i))
    },
    decodeStringToByteArray(o, i) {
        this.init_();
        const s = i ? this.charToByteMapWebSafe_ : this.charToByteMap_
          , a = [];
        for (let _ = 0; _ < o.length; ) {
            const $ = s[o.charAt(_++)]
              , tt = _ < o.length ? s[o.charAt(_)] : 0;
            ++_;
            const rt = _ < o.length ? s[o.charAt(_)] : 64;
            ++_;
            const et = _ < o.length ? s[o.charAt(_)] : 64;
            if (++_,
            $ == null || tt == null || rt == null || et == null)
                throw new DecodeBase64StringError;
            const j = $ << 2 | tt >> 4;
            if (a.push(j),
            rt !== 64) {
                const it = tt << 4 & 240 | rt >> 2;
                if (a.push(it),
                et !== 64) {
                    const st = rt << 6 & 192 | et;
                    a.push(st)
                }
            }
        }
        return a
    },
    init_() {
        if (!this.byteToCharMap_) {
            this.byteToCharMap_ = {},
            this.charToByteMap_ = {},
            this.byteToCharMapWebSafe_ = {},
            this.charToByteMapWebSafe_ = {};
            for (let o = 0; o < this.ENCODED_VALS.length; o++)
                this.byteToCharMap_[o] = this.ENCODED_VALS.charAt(o),
                this.charToByteMap_[this.byteToCharMap_[o]] = o,
                this.byteToCharMapWebSafe_[o] = this.ENCODED_VALS_WEBSAFE.charAt(o),
                this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[o]] = o,
                o >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(o)] = o,
                this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(o)] = o)
        }
    }
};
class DecodeBase64StringError extends Error {
    constructor() {
        super(...arguments),
        this.name = "DecodeBase64StringError"
    }
}
const base64Encode = function(o) {
    const i = stringToByteArray$1(o);
    return base64.encodeByteArray(i, !0)
}
  , base64urlEncodeWithoutPadding = function(o) {
    return base64Encode(o).replace(/\./g, "")
}
  , base64Decode = function(o) {
    try {
        return base64.decodeString(o, !0)
    } catch (i) {
        console.error("base64Decode failed: ", i)
    }
    return null
};
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getGlobal() {
    if (typeof self < "u")
        return self;
    if (typeof window < "u")
        return window;
    if (typeof global < "u")
        return global;
    throw new Error("Unable to locate global object.")
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const getDefaultsFromGlobal = () => getGlobal().__FIREBASE_DEFAULTS__
  , getDefaultsFromEnvVariable = () => {
    if (typeof process > "u" || typeof process.env > "u")
        return;
    const o = {}.__FIREBASE_DEFAULTS__;
    if (o)
        return JSON.parse(o)
}
  , getDefaultsFromCookie = () => {
    if (typeof document > "u")
        return;
    let o;
    try {
        o = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/)
    } catch {
        return
    }
    const i = o && base64Decode(o[1]);
    return i && JSON.parse(i)
}
  , getDefaults = () => {
    try {
        return getDefaultsFromGlobal() || getDefaultsFromEnvVariable() || getDefaultsFromCookie()
    } catch (o) {
        console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${o}`);
        return
    }
}
  , getDefaultEmulatorHost = o => {
    var i, s;
    return (s = (i = getDefaults()) === null || i === void 0 ? void 0 : i.emulatorHosts) === null || s === void 0 ? void 0 : s[o]
}
  , getDefaultAppConfig = () => {
    var o;
    return (o = getDefaults()) === null || o === void 0 ? void 0 : o.config
}
  , getExperimentalSetting = o => {
    var i;
    return (i = getDefaults()) === null || i === void 0 ? void 0 : i[`_${o}`]
}
;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Deferred {
    constructor() {
        this.reject = () => {}
        ,
        this.resolve = () => {}
        ,
        this.promise = new Promise( (i, s) => {
            this.resolve = i,
            this.reject = s
        }
        )
    }
    wrapCallback(i) {
        return (s, a) => {
            s ? this.reject(s) : this.resolve(a),
            typeof i == "function" && (this.promise.catch( () => {}
            ),
            i.length === 1 ? i(s) : i(s, a))
        }
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getUA() {
    return typeof navigator < "u" && typeof navigator.userAgent == "string" ? navigator.userAgent : ""
}
function isMobileCordova() {
    return typeof window < "u" && !!(window.cordova || window.phonegap || window.PhoneGap) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA())
}
function isBrowserExtension() {
    const o = typeof chrome == "object" ? chrome.runtime : typeof browser == "object" ? browser.runtime : void 0;
    return typeof o == "object" && o.id !== void 0
}
function isReactNative() {
    return typeof navigator == "object" && navigator.product === "ReactNative"
}
function isIE() {
    const o = getUA();
    return o.indexOf("MSIE ") >= 0 || o.indexOf("Trident/") >= 0
}
function isIndexedDBAvailable() {
    try {
        return typeof indexedDB == "object"
    } catch {
        return !1
    }
}
function validateIndexedDBOpenable() {
    return new Promise( (o, i) => {
        try {
            let s = !0;
            const a = "validate-browser-context-for-indexeddb-analytics-module"
              , _ = self.indexedDB.open(a);
            _.onsuccess = () => {
                _.result.close(),
                s || self.indexedDB.deleteDatabase(a),
                o(!0)
            }
            ,
            _.onupgradeneeded = () => {
                s = !1
            }
            ,
            _.onerror = () => {
                var $;
                i((($ = _.error) === null || $ === void 0 ? void 0 : $.message) || "")
            }
        } catch (s) {
            i(s)
        }
    }
    )
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ERROR_NAME = "FirebaseError";
class FirebaseError extends Error {
    constructor(i, s, a) {
        super(s),
        this.code = i,
        this.customData = a,
        this.name = ERROR_NAME,
        Object.setPrototypeOf(this, FirebaseError.prototype),
        Error.captureStackTrace && Error.captureStackTrace(this, ErrorFactory.prototype.create)
    }
}
class ErrorFactory {
    constructor(i, s, a) {
        this.service = i,
        this.serviceName = s,
        this.errors = a
    }
    create(i, ...s) {
        const a = s[0] || {}
          , _ = `${this.service}/${i}`
          , $ = this.errors[i]
          , _e = $ ? replaceTemplate($, a) : "Error"
          , tt = `${this.serviceName}: ${_e} (${_}).`;
        return new FirebaseError(_,tt,a)
    }
}
function replaceTemplate(o, i) {
    return o.replace(PATTERN, (s, a) => {
        const _ = i[a];
        return _ != null ? String(_) : `<${a}?>`
    }
    )
}
const PATTERN = /\{\$([^}]+)}/g;
function isEmpty$2(o) {
    for (const i in o)
        if (Object.prototype.hasOwnProperty.call(o, i))
            return !1;
    return !0
}
function deepEqual(o, i) {
    if (o === i)
        return !0;
    const s = Object.keys(o)
      , a = Object.keys(i);
    for (const _ of s) {
        if (!a.includes(_))
            return !1;
        const $ = o[_]
          , _e = i[_];
        if (isObject($) && isObject(_e)) {
            if (!deepEqual($, _e))
                return !1
        } else if ($ !== _e)
            return !1
    }
    for (const _ of a)
        if (!s.includes(_))
            return !1;
    return !0
}
function isObject(o) {
    return o !== null && typeof o == "object"
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function querystring(o) {
    const i = [];
    for (const [s,a] of Object.entries(o))
        Array.isArray(a) ? a.forEach(_ => {
            i.push(encodeURIComponent(s) + "=" + encodeURIComponent(_))
        }
        ) : i.push(encodeURIComponent(s) + "=" + encodeURIComponent(a));
    return i.length ? "&" + i.join("&") : ""
}
function querystringDecode(o) {
    const i = {};
    return o.replace(/^\?/, "").split("&").forEach(a => {
        if (a) {
            const [_,$] = a.split("=");
            i[decodeURIComponent(_)] = decodeURIComponent($)
        }
    }
    ),
    i
}
function extractQuerystring(o) {
    const i = o.indexOf("?");
    if (!i)
        return "";
    const s = o.indexOf("#", i);
    return o.substring(i, s > 0 ? s : void 0)
}
function createSubscribe(o, i) {
    const s = new ObserverProxy(o,i);
    return s.subscribe.bind(s)
}
class ObserverProxy {
    constructor(i, s) {
        this.observers = [],
        this.unsubscribes = [],
        this.observerCount = 0,
        this.task = Promise.resolve(),
        this.finalized = !1,
        this.onNoObservers = s,
        this.task.then( () => {
            i(this)
        }
        ).catch(a => {
            this.error(a)
        }
        )
    }
    next(i) {
        this.forEachObserver(s => {
            s.next(i)
        }
        )
    }
    error(i) {
        this.forEachObserver(s => {
            s.error(i)
        }
        ),
        this.close(i)
    }
    complete() {
        this.forEachObserver(i => {
            i.complete()
        }
        ),
        this.close()
    }
    subscribe(i, s, a) {
        let _;
        if (i === void 0 && s === void 0 && a === void 0)
            throw new Error("Missing Observer.");
        implementsAnyMethods(i, ["next", "error", "complete"]) ? _ = i : _ = {
            next: i,
            error: s,
            complete: a
        },
        _.next === void 0 && (_.next = noop$1),
        _.error === void 0 && (_.error = noop$1),
        _.complete === void 0 && (_.complete = noop$1);
        const $ = this.unsubscribeOne.bind(this, this.observers.length);
        return this.finalized && this.task.then( () => {
            try {
                this.finalError ? _.error(this.finalError) : _.complete()
            } catch {}
        }
        ),
        this.observers.push(_),
        $
    }
    unsubscribeOne(i) {
        this.observers === void 0 || this.observers[i] === void 0 || (delete this.observers[i],
        this.observerCount -= 1,
        this.observerCount === 0 && this.onNoObservers !== void 0 && this.onNoObservers(this))
    }
    forEachObserver(i) {
        if (!this.finalized)
            for (let s = 0; s < this.observers.length; s++)
                this.sendOne(s, i)
    }
    sendOne(i, s) {
        this.task.then( () => {
            if (this.observers !== void 0 && this.observers[i] !== void 0)
                try {
                    s(this.observers[i])
                } catch (a) {
                    typeof console < "u" && console.error && console.error(a)
                }
        }
        )
    }
    close(i) {
        this.finalized || (this.finalized = !0,
        i !== void 0 && (this.finalError = i),
        this.task.then( () => {
            this.observers = void 0,
            this.onNoObservers = void 0
        }
        ))
    }
}
function implementsAnyMethods(o, i) {
    if (typeof o != "object" || o === null)
        return !1;
    for (const s of i)
        if (s in o && typeof o[s] == "function")
            return !0;
    return !1
}
function noop$1() {}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getModularInstance(o) {
    return o && o._delegate ? o._delegate : o
}
class Component {
    constructor(i, s, a) {
        this.name = i,
        this.instanceFactory = s,
        this.type = a,
        this.multipleInstances = !1,
        this.serviceProps = {},
        this.instantiationMode = "LAZY",
        this.onInstanceCreated = null
    }
    setInstantiationMode(i) {
        return this.instantiationMode = i,
        this
    }
    setMultipleInstances(i) {
        return this.multipleInstances = i,
        this
    }
    setServiceProps(i) {
        return this.serviceProps = i,
        this
    }
    setInstanceCreatedCallback(i) {
        return this.onInstanceCreated = i,
        this
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_ENTRY_NAME$1 = "[DEFAULT]";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Provider {
    constructor(i, s) {
        this.name = i,
        this.container = s,
        this.component = null,
        this.instances = new Map,
        this.instancesDeferred = new Map,
        this.instancesOptions = new Map,
        this.onInitCallbacks = new Map
    }
    get(i) {
        const s = this.normalizeInstanceIdentifier(i);
        if (!this.instancesDeferred.has(s)) {
            const a = new Deferred;
            if (this.instancesDeferred.set(s, a),
            this.isInitialized(s) || this.shouldAutoInitialize())
                try {
                    const _ = this.getOrInitializeService({
                        instanceIdentifier: s
                    });
                    _ && a.resolve(_)
                } catch {}
        }
        return this.instancesDeferred.get(s).promise
    }
    getImmediate(i) {
        var s;
        const a = this.normalizeInstanceIdentifier(i == null ? void 0 : i.identifier)
          , _ = (s = i == null ? void 0 : i.optional) !== null && s !== void 0 ? s : !1;
        if (this.isInitialized(a) || this.shouldAutoInitialize())
            try {
                return this.getOrInitializeService({
                    instanceIdentifier: a
                })
            } catch ($) {
                if (_)
                    return null;
                throw $
            }
        else {
            if (_)
                return null;
            throw Error(`Service ${this.name} is not available`)
        }
    }
    getComponent() {
        return this.component
    }
    setComponent(i) {
        if (i.name !== this.name)
            throw Error(`Mismatching Component ${i.name} for Provider ${this.name}.`);
        if (this.component)
            throw Error(`Component for ${this.name} has already been provided`);
        if (this.component = i,
        !!this.shouldAutoInitialize()) {
            if (isComponentEager(i))
                try {
                    this.getOrInitializeService({
                        instanceIdentifier: DEFAULT_ENTRY_NAME$1
                    })
                } catch {}
            for (const [s,a] of this.instancesDeferred.entries()) {
                const _ = this.normalizeInstanceIdentifier(s);
                try {
                    const $ = this.getOrInitializeService({
                        instanceIdentifier: _
                    });
                    a.resolve($)
                } catch {}
            }
        }
    }
    clearInstance(i=DEFAULT_ENTRY_NAME$1) {
        this.instancesDeferred.delete(i),
        this.instancesOptions.delete(i),
        this.instances.delete(i)
    }
    async delete() {
        const i = Array.from(this.instances.values());
        await Promise.all([...i.filter(s => "INTERNAL"in s).map(s => s.INTERNAL.delete()), ...i.filter(s => "_delete"in s).map(s => s._delete())])
    }
    isComponentSet() {
        return this.component != null
    }
    isInitialized(i=DEFAULT_ENTRY_NAME$1) {
        return this.instances.has(i)
    }
    getOptions(i=DEFAULT_ENTRY_NAME$1) {
        return this.instancesOptions.get(i) || {}
    }
    initialize(i={}) {
        const {options: s={}} = i
          , a = this.normalizeInstanceIdentifier(i.instanceIdentifier);
        if (this.isInitialized(a))
            throw Error(`${this.name}(${a}) has already been initialized`);
        if (!this.isComponentSet())
            throw Error(`Component ${this.name} has not been registered yet`);
        const _ = this.getOrInitializeService({
            instanceIdentifier: a,
            options: s
        });
        for (const [$,_e] of this.instancesDeferred.entries()) {
            const tt = this.normalizeInstanceIdentifier($);
            a === tt && _e.resolve(_)
        }
        return _
    }
    onInit(i, s) {
        var a;
        const _ = this.normalizeInstanceIdentifier(s)
          , $ = (a = this.onInitCallbacks.get(_)) !== null && a !== void 0 ? a : new Set;
        $.add(i),
        this.onInitCallbacks.set(_, $);
        const _e = this.instances.get(_);
        return _e && i(_e, _),
        () => {
            $.delete(i)
        }
    }
    invokeOnInitCallbacks(i, s) {
        const a = this.onInitCallbacks.get(s);
        if (a)
            for (const _ of a)
                try {
                    _(i, s)
                } catch {}
    }
    getOrInitializeService({instanceIdentifier: i, options: s={}}) {
        let a = this.instances.get(i);
        if (!a && this.component && (a = this.component.instanceFactory(this.container, {
            instanceIdentifier: normalizeIdentifierForFactory(i),
            options: s
        }),
        this.instances.set(i, a),
        this.instancesOptions.set(i, s),
        this.invokeOnInitCallbacks(a, i),
        this.component.onInstanceCreated))
            try {
                this.component.onInstanceCreated(this.container, i, a)
            } catch {}
        return a || null
    }
    normalizeInstanceIdentifier(i=DEFAULT_ENTRY_NAME$1) {
        return this.component ? this.component.multipleInstances ? i : DEFAULT_ENTRY_NAME$1 : i
    }
    shouldAutoInitialize() {
        return !!this.component && this.component.instantiationMode !== "EXPLICIT"
    }
}
function normalizeIdentifierForFactory(o) {
    return o === DEFAULT_ENTRY_NAME$1 ? void 0 : o
}
function isComponentEager(o) {
    return o.instantiationMode === "EAGER"
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ComponentContainer {
    constructor(i) {
        this.name = i,
        this.providers = new Map
    }
    addComponent(i) {
        const s = this.getProvider(i.name);
        if (s.isComponentSet())
            throw new Error(`Component ${i.name} has already been registered with ${this.name}`);
        s.setComponent(i)
    }
    addOrOverwriteComponent(i) {
        this.getProvider(i.name).isComponentSet() && this.providers.delete(i.name),
        this.addComponent(i)
    }
    getProvider(i) {
        if (this.providers.has(i))
            return this.providers.get(i);
        const s = new Provider(i,this);
        return this.providers.set(i, s),
        s
    }
    getProviders() {
        return Array.from(this.providers.values())
    }
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var LogLevel;
(function(o) {
    o[o.DEBUG = 0] = "DEBUG",
    o[o.VERBOSE = 1] = "VERBOSE",
    o[o.INFO = 2] = "INFO",
    o[o.WARN = 3] = "WARN",
    o[o.ERROR = 4] = "ERROR",
    o[o.SILENT = 5] = "SILENT"
}
)(LogLevel || (LogLevel = {}));
const levelStringToEnum = {
    debug: LogLevel.DEBUG,
    verbose: LogLevel.VERBOSE,
    info: LogLevel.INFO,
    warn: LogLevel.WARN,
    error: LogLevel.ERROR,
    silent: LogLevel.SILENT
}
  , defaultLogLevel = LogLevel.INFO
  , ConsoleMethod = {
    [LogLevel.DEBUG]: "log",
    [LogLevel.VERBOSE]: "log",
    [LogLevel.INFO]: "info",
    [LogLevel.WARN]: "warn",
    [LogLevel.ERROR]: "error"
}
  , defaultLogHandler = (o, i, ...s) => {
    if (i < o.logLevel)
        return;
    const a = new Date().toISOString()
      , _ = ConsoleMethod[i];
    if (_)
        console[_](`[${a}]  ${o.name}:`, ...s);
    else
        throw new Error(`Attempted to log a message with an invalid logType (value: ${i})`)
}
;
class Logger {
    constructor(i) {
        this.name = i,
        this._logLevel = defaultLogLevel,
        this._logHandler = defaultLogHandler,
        this._userLogHandler = null
    }
    get logLevel() {
        return this._logLevel
    }
    set logLevel(i) {
        if (!(i in LogLevel))
            throw new TypeError(`Invalid value "${i}" assigned to \`logLevel\``);
        this._logLevel = i
    }
    setLogLevel(i) {
        this._logLevel = typeof i == "string" ? levelStringToEnum[i] : i
    }
    get logHandler() {
        return this._logHandler
    }
    set logHandler(i) {
        if (typeof i != "function")
            throw new TypeError("Value assigned to `logHandler` must be a function");
        this._logHandler = i
    }
    get userLogHandler() {
        return this._userLogHandler
    }
    set userLogHandler(i) {
        this._userLogHandler = i
    }
    debug(...i) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.DEBUG, ...i),
        this._logHandler(this, LogLevel.DEBUG, ...i)
    }
    log(...i) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.VERBOSE, ...i),
        this._logHandler(this, LogLevel.VERBOSE, ...i)
    }
    info(...i) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.INFO, ...i),
        this._logHandler(this, LogLevel.INFO, ...i)
    }
    warn(...i) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.WARN, ...i),
        this._logHandler(this, LogLevel.WARN, ...i)
    }
    error(...i) {
        this._userLogHandler && this._userLogHandler(this, LogLevel.ERROR, ...i),
        this._logHandler(this, LogLevel.ERROR, ...i)
    }
}
const instanceOfAny = (o, i) => i.some(s => o instanceof s);
let idbProxyableTypes, cursorAdvanceMethods;
function getIdbProxyableTypes() {
    return idbProxyableTypes || (idbProxyableTypes = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction])
}
function getCursorAdvanceMethods() {
    return cursorAdvanceMethods || (cursorAdvanceMethods = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey])
}
const cursorRequestMap = new WeakMap
  , transactionDoneMap = new WeakMap
  , transactionStoreNamesMap = new WeakMap
  , transformCache = new WeakMap
  , reverseTransformCache = new WeakMap;
function promisifyRequest(o) {
    const i = new Promise( (s, a) => {
        const _ = () => {
            o.removeEventListener("success", $),
            o.removeEventListener("error", _e)
        }
          , $ = () => {
            s(wrap(o.result)),
            _()
        }
          , _e = () => {
            a(o.error),
            _()
        }
        ;
        o.addEventListener("success", $),
        o.addEventListener("error", _e)
    }
    );
    return i.then(s => {
        s instanceof IDBCursor && cursorRequestMap.set(s, o)
    }
    ).catch( () => {}
    ),
    reverseTransformCache.set(i, o),
    i
}
function cacheDonePromiseForTransaction(o) {
    if (transactionDoneMap.has(o))
        return;
    const i = new Promise( (s, a) => {
        const _ = () => {
            o.removeEventListener("complete", $),
            o.removeEventListener("error", _e),
            o.removeEventListener("abort", _e)
        }
          , $ = () => {
            s(),
            _()
        }
          , _e = () => {
            a(o.error || new DOMException("AbortError","AbortError")),
            _()
        }
        ;
        o.addEventListener("complete", $),
        o.addEventListener("error", _e),
        o.addEventListener("abort", _e)
    }
    );
    transactionDoneMap.set(o, i)
}
let idbProxyTraps = {
    get(o, i, s) {
        if (o instanceof IDBTransaction) {
            if (i === "done")
                return transactionDoneMap.get(o);
            if (i === "objectStoreNames")
                return o.objectStoreNames || transactionStoreNamesMap.get(o);
            if (i === "store")
                return s.objectStoreNames[1] ? void 0 : s.objectStore(s.objectStoreNames[0])
        }
        return wrap(o[i])
    },
    set(o, i, s) {
        return o[i] = s,
        !0
    },
    has(o, i) {
        return o instanceof IDBTransaction && (i === "done" || i === "store") ? !0 : i in o
    }
};
function replaceTraps(o) {
    idbProxyTraps = o(idbProxyTraps)
}
function wrapFunction(o) {
    return o === IDBDatabase.prototype.transaction && !("objectStoreNames"in IDBTransaction.prototype) ? function(i, ...s) {
        const a = o.call(unwrap(this), i, ...s);
        return transactionStoreNamesMap.set(a, i.sort ? i.sort() : [i]),
        wrap(a)
    }
    : getCursorAdvanceMethods().includes(o) ? function(...i) {
        return o.apply(unwrap(this), i),
        wrap(cursorRequestMap.get(this))
    }
    : function(...i) {
        return wrap(o.apply(unwrap(this), i))
    }
}
function transformCachableValue(o) {
    return typeof o == "function" ? wrapFunction(o) : (o instanceof IDBTransaction && cacheDonePromiseForTransaction(o),
    instanceOfAny(o, getIdbProxyableTypes()) ? new Proxy(o,idbProxyTraps) : o)
}
function wrap(o) {
    if (o instanceof IDBRequest)
        return promisifyRequest(o);
    if (transformCache.has(o))
        return transformCache.get(o);
    const i = transformCachableValue(o);
    return i !== o && (transformCache.set(o, i),
    reverseTransformCache.set(i, o)),
    i
}
const unwrap = o => reverseTransformCache.get(o);
function openDB(o, i, {blocked: s, upgrade: a, blocking: _, terminated: $}={}) {
    const _e = indexedDB.open(o, i)
      , tt = wrap(_e);
    return a && _e.addEventListener("upgradeneeded", nt => {
        a(wrap(_e.result), nt.oldVersion, nt.newVersion, wrap(_e.transaction), nt)
    }
    ),
    s && _e.addEventListener("blocked", nt => s(nt.oldVersion, nt.newVersion, nt)),
    tt.then(nt => {
        $ && nt.addEventListener("close", () => $()),
        _ && nt.addEventListener("versionchange", rt => _(rt.oldVersion, rt.newVersion, rt))
    }
    ).catch( () => {}
    ),
    tt
}
const readMethods = ["get", "getKey", "getAll", "getAllKeys", "count"]
  , writeMethods = ["put", "add", "delete", "clear"]
  , cachedMethods = new Map;
function getMethod(o, i) {
    if (!(o instanceof IDBDatabase && !(i in o) && typeof i == "string"))
        return;
    if (cachedMethods.get(i))
        return cachedMethods.get(i);
    const s = i.replace(/FromIndex$/, "")
      , a = i !== s
      , _ = writeMethods.includes(s);
    if (!(s in (a ? IDBIndex : IDBObjectStore).prototype) || !(_ || readMethods.includes(s)))
        return;
    const $ = async function(_e, ...tt) {
        const nt = this.transaction(_e, _ ? "readwrite" : "readonly");
        let rt = nt.store;
        return a && (rt = rt.index(tt.shift())),
        (await Promise.all([rt[s](...tt), _ && nt.done]))[0]
    };
    return cachedMethods.set(i, $),
    $
}
replaceTraps(o => ({
    ...o,
    get: (i, s, a) => getMethod(i, s) || o.get(i, s, a),
    has: (i, s) => !!getMethod(i, s) || o.has(i, s)
}));
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PlatformLoggerServiceImpl {
    constructor(i) {
        this.container = i
    }
    getPlatformInfoString() {
        return this.container.getProviders().map(s => {
            if (isVersionServiceProvider(s)) {
                const a = s.getImmediate();
                return `${a.library}/${a.version}`
            } else
                return null
        }
        ).filter(s => s).join(" ")
    }
}
function isVersionServiceProvider(o) {
    const i = o.getComponent();
    return (i == null ? void 0 : i.type) === "VERSION"
}
const name$o = "@firebase/app"
  , version$1$1 = "0.9.15";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const logger = new Logger("@firebase/app")
  , name$n = "@firebase/app-compat"
  , name$m = "@firebase/analytics-compat"
  , name$l = "@firebase/analytics"
  , name$k = "@firebase/app-check-compat"
  , name$j = "@firebase/app-check"
  , name$i = "@firebase/auth"
  , name$h = "@firebase/auth-compat"
  , name$g = "@firebase/database"
  , name$f = "@firebase/database-compat"
  , name$e = "@firebase/functions"
  , name$d = "@firebase/functions-compat"
  , name$c = "@firebase/installations"
  , name$b = "@firebase/installations-compat"
  , name$a = "@firebase/messaging"
  , name$9 = "@firebase/messaging-compat"
  , name$8 = "@firebase/performance"
  , name$7 = "@firebase/performance-compat"
  , name$6 = "@firebase/remote-config"
  , name$5 = "@firebase/remote-config-compat"
  , name$4 = "@firebase/storage"
  , name$3$1 = "@firebase/storage-compat"
  , name$2$1 = "@firebase/firestore"
  , name$1$1 = "@firebase/firestore-compat"
  , name$p = "firebase"
  , version$3 = "10.1.0";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_ENTRY_NAME = "[DEFAULT]"
  , PLATFORM_LOG_STRING = {
    [name$o]: "fire-core",
    [name$n]: "fire-core-compat",
    [name$l]: "fire-analytics",
    [name$m]: "fire-analytics-compat",
    [name$j]: "fire-app-check",
    [name$k]: "fire-app-check-compat",
    [name$i]: "fire-auth",
    [name$h]: "fire-auth-compat",
    [name$g]: "fire-rtdb",
    [name$f]: "fire-rtdb-compat",
    [name$e]: "fire-fn",
    [name$d]: "fire-fn-compat",
    [name$c]: "fire-iid",
    [name$b]: "fire-iid-compat",
    [name$a]: "fire-fcm",
    [name$9]: "fire-fcm-compat",
    [name$8]: "fire-perf",
    [name$7]: "fire-perf-compat",
    [name$6]: "fire-rc",
    [name$5]: "fire-rc-compat",
    [name$4]: "fire-gcs",
    [name$3$1]: "fire-gcs-compat",
    [name$2$1]: "fire-fst",
    [name$1$1]: "fire-fst-compat",
    "fire-js": "fire-js",
    [name$p]: "fire-js-all"
};
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _apps = new Map
  , _components = new Map;
function _addComponent(o, i) {
    try {
        o.container.addComponent(i)
    } catch (s) {
        logger.debug(`Component ${i.name} failed to register with FirebaseApp ${o.name}`, s)
    }
}
function _registerComponent(o) {
    const i = o.name;
    if (_components.has(i))
        return logger.debug(`There were multiple attempts to register component ${i}.`),
        !1;
    _components.set(i, o);
    for (const s of _apps.values())
        _addComponent(s, o);
    return !0
}
function _getProvider(o, i) {
    const s = o.container.getProvider("heartbeat").getImmediate({
        optional: !0
    });
    return s && s.triggerHeartbeat(),
    o.container.getProvider(i)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ERRORS = {
    "no-app": "No Firebase App '{$appName}' has been created - call initializeApp() first",
    "bad-app-name": "Illegal App name: '{$appName}",
    "duplicate-app": "Firebase App named '{$appName}' already exists with different options or config",
    "app-deleted": "Firebase App named '{$appName}' already deleted",
    "no-options": "Need to provide options, when not being deployed to hosting via source.",
    "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance.",
    "invalid-log-argument": "First argument to `onLog` must be null or a function.",
    "idb-open": "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.",
    "idb-get": "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.",
    "idb-set": "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.",
    "idb-delete": "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}."
}
  , ERROR_FACTORY = new ErrorFactory("app","Firebase",ERRORS);
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FirebaseAppImpl {
    constructor(i, s, a) {
        this._isDeleted = !1,
        this._options = Object.assign({}, i),
        this._config = Object.assign({}, s),
        this._name = s.name,
        this._automaticDataCollectionEnabled = s.automaticDataCollectionEnabled,
        this._container = a,
        this.container.addComponent(new Component("app", () => this,"PUBLIC"))
    }
    get automaticDataCollectionEnabled() {
        return this.checkDestroyed(),
        this._automaticDataCollectionEnabled
    }
    set automaticDataCollectionEnabled(i) {
        this.checkDestroyed(),
        this._automaticDataCollectionEnabled = i
    }
    get name() {
        return this.checkDestroyed(),
        this._name
    }
    get options() {
        return this.checkDestroyed(),
        this._options
    }
    get config() {
        return this.checkDestroyed(),
        this._config
    }
    get container() {
        return this._container
    }
    get isDeleted() {
        return this._isDeleted
    }
    set isDeleted(i) {
        this._isDeleted = i
    }
    checkDestroyed() {
        if (this.isDeleted)
            throw ERROR_FACTORY.create("app-deleted", {
                appName: this._name
            })
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const SDK_VERSION = version$3;
function initializeApp(o, i={}) {
    let s = o;
    typeof i != "object" && (i = {
        name: i
    });
    const a = Object.assign({
        name: DEFAULT_ENTRY_NAME,
        automaticDataCollectionEnabled: !1
    }, i)
      , _ = a.name;
    if (typeof _ != "string" || !_)
        throw ERROR_FACTORY.create("bad-app-name", {
            appName: String(_)
        });
    if (s || (s = getDefaultAppConfig()),
    !s)
        throw ERROR_FACTORY.create("no-options");
    const $ = _apps.get(_);
    if ($) {
        if (deepEqual(s, $.options) && deepEqual(a, $.config))
            return $;
        throw ERROR_FACTORY.create("duplicate-app", {
            appName: _
        })
    }
    const _e = new ComponentContainer(_);
    for (const nt of _components.values())
        _e.addComponent(nt);
    const tt = new FirebaseAppImpl(s,a,_e);
    return _apps.set(_, tt),
    tt
}
function getApp(o=DEFAULT_ENTRY_NAME) {
    const i = _apps.get(o);
    if (!i && o === DEFAULT_ENTRY_NAME && getDefaultAppConfig())
        return initializeApp();
    if (!i)
        throw ERROR_FACTORY.create("no-app", {
            appName: o
        });
    return i
}
function registerVersion(o, i, s) {
    var a;
    let _ = (a = PLATFORM_LOG_STRING[o]) !== null && a !== void 0 ? a : o;
    s && (_ += `-${s}`);
    const $ = _.match(/\s|\//)
      , _e = i.match(/\s|\//);
    if ($ || _e) {
        const tt = [`Unable to register library "${_}" with version "${i}":`];
        $ && tt.push(`library name "${_}" contains illegal characters (whitespace or "/")`),
        $ && _e && tt.push("and"),
        _e && tt.push(`version name "${i}" contains illegal characters (whitespace or "/")`),
        logger.warn(tt.join(" "));
        return
    }
    _registerComponent(new Component(`${_}-version`, () => ({
        library: _,
        version: i
    }),"VERSION"))
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DB_NAME$1 = "firebase-heartbeat-database"
  , DB_VERSION$1 = 1
  , STORE_NAME = "firebase-heartbeat-store";
let dbPromise = null;
function getDbPromise() {
    return dbPromise || (dbPromise = openDB(DB_NAME$1, DB_VERSION$1, {
        upgrade: (o, i) => {
            switch (i) {
            case 0:
                o.createObjectStore(STORE_NAME)
            }
        }
    }).catch(o => {
        throw ERROR_FACTORY.create("idb-open", {
            originalErrorMessage: o.message
        })
    }
    )),
    dbPromise
}
async function readHeartbeatsFromIndexedDB(o) {
    try {
        return await (await getDbPromise()).transaction(STORE_NAME).objectStore(STORE_NAME).get(computeKey(o))
    } catch (i) {
        if (i instanceof FirebaseError)
            logger.warn(i.message);
        else {
            const s = ERROR_FACTORY.create("idb-get", {
                originalErrorMessage: i == null ? void 0 : i.message
            });
            logger.warn(s.message)
        }
    }
}
async function writeHeartbeatsToIndexedDB(o, i) {
    try {
        const a = (await getDbPromise()).transaction(STORE_NAME, "readwrite");
        await a.objectStore(STORE_NAME).put(i, computeKey(o)),
        await a.done
    } catch (s) {
        if (s instanceof FirebaseError)
            logger.warn(s.message);
        else {
            const a = ERROR_FACTORY.create("idb-set", {
                originalErrorMessage: s == null ? void 0 : s.message
            });
            logger.warn(a.message)
        }
    }
}
function computeKey(o) {
    return `${o.name}!${o.options.appId}`
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const MAX_HEADER_BYTES = 1024
  , STORED_HEARTBEAT_RETENTION_MAX_MILLIS = 30 * 24 * 60 * 60 * 1e3;
class HeartbeatServiceImpl {
    constructor(i) {
        this.container = i,
        this._heartbeatsCache = null;
        const s = this.container.getProvider("app").getImmediate();
        this._storage = new HeartbeatStorageImpl(s),
        this._heartbeatsCachePromise = this._storage.read().then(a => (this._heartbeatsCache = a,
        a))
    }
    async triggerHeartbeat() {
        const s = this.container.getProvider("platform-logger").getImmediate().getPlatformInfoString()
          , a = getUTCDateString();
        if (this._heartbeatsCache === null && (this._heartbeatsCache = await this._heartbeatsCachePromise),
        !(this._heartbeatsCache.lastSentHeartbeatDate === a || this._heartbeatsCache.heartbeats.some(_ => _.date === a)))
            return this._heartbeatsCache.heartbeats.push({
                date: a,
                agent: s
            }),
            this._heartbeatsCache.heartbeats = this._heartbeatsCache.heartbeats.filter(_ => {
                const $ = new Date(_.date).valueOf();
                return Date.now() - $ <= STORED_HEARTBEAT_RETENTION_MAX_MILLIS
            }
            ),
            this._storage.overwrite(this._heartbeatsCache)
    }
    async getHeartbeatsHeader() {
        if (this._heartbeatsCache === null && await this._heartbeatsCachePromise,
        this._heartbeatsCache === null || this._heartbeatsCache.heartbeats.length === 0)
            return "";
        const i = getUTCDateString()
          , {heartbeatsToSend: s, unsentEntries: a} = extractHeartbeatsForHeader(this._heartbeatsCache.heartbeats)
          , _ = base64urlEncodeWithoutPadding(JSON.stringify({
            version: 2,
            heartbeats: s
        }));
        return this._heartbeatsCache.lastSentHeartbeatDate = i,
        a.length > 0 ? (this._heartbeatsCache.heartbeats = a,
        await this._storage.overwrite(this._heartbeatsCache)) : (this._heartbeatsCache.heartbeats = [],
        this._storage.overwrite(this._heartbeatsCache)),
        _
    }
}
function getUTCDateString() {
    return new Date().toISOString().substring(0, 10)
}
function extractHeartbeatsForHeader(o, i=MAX_HEADER_BYTES) {
    const s = [];
    let a = o.slice();
    for (const _ of o) {
        const $ = s.find(_e => _e.agent === _.agent);
        if ($) {
            if ($.dates.push(_.date),
            countBytes(s) > i) {
                $.dates.pop();
                break
            }
        } else if (s.push({
            agent: _.agent,
            dates: [_.date]
        }),
        countBytes(s) > i) {
            s.pop();
            break
        }
        a = a.slice(1)
    }
    return {
        heartbeatsToSend: s,
        unsentEntries: a
    }
}
class HeartbeatStorageImpl {
    constructor(i) {
        this.app = i,
        this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck()
    }
    async runIndexedDBEnvironmentCheck() {
        return isIndexedDBAvailable() ? validateIndexedDBOpenable().then( () => !0).catch( () => !1) : !1
    }
    async read() {
        return await this._canUseIndexedDBPromise ? await readHeartbeatsFromIndexedDB(this.app) || {
            heartbeats: []
        } : {
            heartbeats: []
        }
    }
    async overwrite(i) {
        var s;
        if (await this._canUseIndexedDBPromise) {
            const _ = await this.read();
            return writeHeartbeatsToIndexedDB(this.app, {
                lastSentHeartbeatDate: (s = i.lastSentHeartbeatDate) !== null && s !== void 0 ? s : _.lastSentHeartbeatDate,
                heartbeats: i.heartbeats
            })
        } else
            return
    }
    async add(i) {
        var s;
        if (await this._canUseIndexedDBPromise) {
            const _ = await this.read();
            return writeHeartbeatsToIndexedDB(this.app, {
                lastSentHeartbeatDate: (s = i.lastSentHeartbeatDate) !== null && s !== void 0 ? s : _.lastSentHeartbeatDate,
                heartbeats: [..._.heartbeats, ...i.heartbeats]
            })
        } else
            return
    }
}
function countBytes(o) {
    return base64urlEncodeWithoutPadding(JSON.stringify({
        version: 2,
        heartbeats: o
    })).length
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function registerCoreComponents(o) {
    _registerComponent(new Component("platform-logger",i => new PlatformLoggerServiceImpl(i),"PRIVATE")),
    _registerComponent(new Component("heartbeat",i => new HeartbeatServiceImpl(i),"PRIVATE")),
    registerVersion(name$o, version$1$1, o),
    registerVersion(name$o, version$1$1, "esm2017"),
    registerVersion("fire-js", "")
}
registerCoreComponents("");
function _prodErrorMap() {
    return {
        "dependent-sdk-initialized-before-auth": "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK."
    }
}
const prodErrorMap = _prodErrorMap
  , _DEFAULT_AUTH_ERROR_FACTORY = new ErrorFactory("auth","Firebase",_prodErrorMap());
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const logClient = new Logger("@firebase/auth");
function _logWarn(o, ...i) {
    logClient.logLevel <= LogLevel.WARN && logClient.warn(`Auth (${SDK_VERSION}): ${o}`, ...i)
}
function _logError(o, ...i) {
    logClient.logLevel <= LogLevel.ERROR && logClient.error(`Auth (${SDK_VERSION}): ${o}`, ...i)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _fail(o, ...i) {
    throw createErrorInternal(o, ...i)
}
function _createError(o, ...i) {
    return createErrorInternal(o, ...i)
}
function _errorWithCustomMessage(o, i, s) {
    const a = Object.assign(Object.assign({}, prodErrorMap()), {
        [i]: s
    });
    return new ErrorFactory("auth","Firebase",a).create(i, {
        appName: o.name
    })
}
function createErrorInternal(o, ...i) {
    if (typeof o != "string") {
        const s = i[0]
          , a = [...i.slice(1)];
        return a[0] && (a[0].appName = o.name),
        o._errorFactory.create(s, ...a)
    }
    return _DEFAULT_AUTH_ERROR_FACTORY.create(o, ...i)
}
function _assert(o, i, ...s) {
    if (!o)
        throw createErrorInternal(i, ...s)
}
function debugFail(o) {
    const i = "INTERNAL ASSERTION FAILED: " + o;
    throw _logError(i),
    new Error(i)
}
function debugAssert(o, i) {
    o || debugFail(i)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _getCurrentUrl() {
    var o;
    return typeof self < "u" && ((o = self.location) === null || o === void 0 ? void 0 : o.href) || ""
}
function _isHttpOrHttps() {
    return _getCurrentScheme() === "http:" || _getCurrentScheme() === "https:"
}
function _getCurrentScheme() {
    var o;
    return typeof self < "u" && ((o = self.location) === null || o === void 0 ? void 0 : o.protocol) || null
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _isOnline() {
    return typeof navigator < "u" && navigator && "onLine"in navigator && typeof navigator.onLine == "boolean" && (_isHttpOrHttps() || isBrowserExtension() || "connection"in navigator) ? navigator.onLine : !0
}
function _getUserLanguage() {
    if (typeof navigator > "u")
        return null;
    const o = navigator;
    return o.languages && o.languages[0] || o.language || null
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Delay {
    constructor(i, s) {
        this.shortDelay = i,
        this.longDelay = s,
        debugAssert(s > i, "Short delay should be less than long delay!"),
        this.isMobile = isMobileCordova() || isReactNative()
    }
    get() {
        return _isOnline() ? this.isMobile ? this.longDelay : this.shortDelay : Math.min(5e3, this.shortDelay)
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _emulatorUrl(o, i) {
    debugAssert(o.emulator, "Emulator should always be set here");
    const {url: s} = o.emulator;
    return i ? `${s}${i.startsWith("/") ? i.slice(1) : i}` : s
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FetchProvider {
    static initialize(i, s, a) {
        this.fetchImpl = i,
        s && (this.headersImpl = s),
        a && (this.responseImpl = a)
    }
    static fetch() {
        if (this.fetchImpl)
            return this.fetchImpl;
        if (typeof self < "u" && "fetch"in self)
            return self.fetch;
        debugFail("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")
    }
    static headers() {
        if (this.headersImpl)
            return this.headersImpl;
        if (typeof self < "u" && "Headers"in self)
            return self.Headers;
        debugFail("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")
    }
    static response() {
        if (this.responseImpl)
            return this.responseImpl;
        if (typeof self < "u" && "Response"in self)
            return self.Response;
        debugFail("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill")
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const SERVER_ERROR_MAP = {
    CREDENTIAL_MISMATCH: "custom-token-mismatch",
    MISSING_CUSTOM_TOKEN: "internal-error",
    INVALID_IDENTIFIER: "invalid-email",
    MISSING_CONTINUE_URI: "internal-error",
    INVALID_PASSWORD: "wrong-password",
    MISSING_PASSWORD: "missing-password",
    EMAIL_EXISTS: "email-already-in-use",
    PASSWORD_LOGIN_DISABLED: "operation-not-allowed",
    INVALID_IDP_RESPONSE: "invalid-credential",
    INVALID_PENDING_TOKEN: "invalid-credential",
    FEDERATED_USER_ID_ALREADY_LINKED: "credential-already-in-use",
    MISSING_REQ_TYPE: "internal-error",
    EMAIL_NOT_FOUND: "user-not-found",
    RESET_PASSWORD_EXCEED_LIMIT: "too-many-requests",
    EXPIRED_OOB_CODE: "expired-action-code",
    INVALID_OOB_CODE: "invalid-action-code",
    MISSING_OOB_CODE: "internal-error",
    CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "requires-recent-login",
    INVALID_ID_TOKEN: "invalid-user-token",
    TOKEN_EXPIRED: "user-token-expired",
    USER_NOT_FOUND: "user-token-expired",
    TOO_MANY_ATTEMPTS_TRY_LATER: "too-many-requests",
    INVALID_CODE: "invalid-verification-code",
    INVALID_SESSION_INFO: "invalid-verification-id",
    INVALID_TEMPORARY_PROOF: "invalid-credential",
    MISSING_SESSION_INFO: "missing-verification-id",
    SESSION_EXPIRED: "code-expired",
    MISSING_ANDROID_PACKAGE_NAME: "missing-android-pkg-name",
    UNAUTHORIZED_DOMAIN: "unauthorized-continue-uri",
    INVALID_OAUTH_CLIENT_ID: "invalid-oauth-client-id",
    ADMIN_ONLY_OPERATION: "admin-restricted-operation",
    INVALID_MFA_PENDING_CREDENTIAL: "invalid-multi-factor-session",
    MFA_ENROLLMENT_NOT_FOUND: "multi-factor-info-not-found",
    MISSING_MFA_ENROLLMENT_ID: "missing-multi-factor-info",
    MISSING_MFA_PENDING_CREDENTIAL: "missing-multi-factor-session",
    SECOND_FACTOR_EXISTS: "second-factor-already-in-use",
    SECOND_FACTOR_LIMIT_EXCEEDED: "maximum-second-factor-count-exceeded",
    BLOCKING_FUNCTION_ERROR_RESPONSE: "internal-error",
    RECAPTCHA_NOT_ENABLED: "recaptcha-not-enabled",
    MISSING_RECAPTCHA_TOKEN: "missing-recaptcha-token",
    INVALID_RECAPTCHA_TOKEN: "invalid-recaptcha-token",
    INVALID_RECAPTCHA_ACTION: "invalid-recaptcha-action",
    MISSING_CLIENT_TYPE: "missing-client-type",
    MISSING_RECAPTCHA_VERSION: "missing-recaptcha-version",
    INVALID_RECAPTCHA_VERSION: "invalid-recaptcha-version",
    INVALID_REQ_TYPE: "invalid-req-type"
};
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_API_TIMEOUT_MS = new Delay(3e4,6e4);
function _addTidIfNecessary(o, i) {
    return o.tenantId && !i.tenantId ? Object.assign(Object.assign({}, i), {
        tenantId: o.tenantId
    }) : i
}
async function _performApiRequest(o, i, s, a, _={}) {
    return _performFetchWithErrorHandling(o, _, async () => {
        let $ = {}
          , _e = {};
        a && (i === "GET" ? _e = a : $ = {
            body: JSON.stringify(a)
        });
        const tt = querystring(Object.assign({
            key: o.config.apiKey
        }, _e)).slice(1)
          , nt = await o._getAdditionalHeaders();
        return nt["Content-Type"] = "application/json",
        o.languageCode && (nt["X-Firebase-Locale"] = o.languageCode),
        FetchProvider.fetch()(_getFinalTarget(o, o.config.apiHost, s, tt), Object.assign({
            method: i,
            headers: nt,
            referrerPolicy: "no-referrer"
        }, $))
    }
    )
}
async function _performFetchWithErrorHandling(o, i, s) {
    o._canInitEmulator = !1;
    const a = Object.assign(Object.assign({}, SERVER_ERROR_MAP), i);
    try {
        const _ = new NetworkTimeout(o)
          , $ = await Promise.race([s(), _.promise]);
        _.clearNetworkTimeout();
        const _e = await $.json();
        if ("needConfirmation"in _e)
            throw _makeTaggedError(o, "account-exists-with-different-credential", _e);
        if ($.ok && !("errorMessage"in _e))
            return _e;
        {
            const tt = $.ok ? _e.errorMessage : _e.error.message
              , [nt,rt] = tt.split(" : ");
            if (nt === "FEDERATED_USER_ID_ALREADY_LINKED")
                throw _makeTaggedError(o, "credential-already-in-use", _e);
            if (nt === "EMAIL_EXISTS")
                throw _makeTaggedError(o, "email-already-in-use", _e);
            if (nt === "USER_DISABLED")
                throw _makeTaggedError(o, "user-disabled", _e);
            const ot = a[nt] || nt.toLowerCase().replace(/[_\s]+/g, "-");
            if (rt)
                throw _errorWithCustomMessage(o, ot, rt);
            _fail(o, ot)
        }
    } catch (_) {
        if (_ instanceof FirebaseError)
            throw _;
        _fail(o, "network-request-failed", {
            message: String(_)
        })
    }
}
async function _performSignInRequest(o, i, s, a, _={}) {
    const $ = await _performApiRequest(o, i, s, a, _);
    return "mfaPendingCredential"in $ && _fail(o, "multi-factor-auth-required", {
        _serverResponse: $
    }),
    $
}
function _getFinalTarget(o, i, s, a) {
    const _ = `${i}${s}?${a}`;
    return o.config.emulator ? _emulatorUrl(o.config, _) : `${o.config.apiScheme}://${_}`
}
class NetworkTimeout {
    constructor(i) {
        this.auth = i,
        this.timer = null,
        this.promise = new Promise( (s, a) => {
            this.timer = setTimeout( () => a(_createError(this.auth, "network-request-failed")), DEFAULT_API_TIMEOUT_MS.get())
        }
        )
    }
    clearNetworkTimeout() {
        clearTimeout(this.timer)
    }
}
function _makeTaggedError(o, i, s) {
    const a = {
        appName: o.name
    };
    s.email && (a.email = s.email),
    s.phoneNumber && (a.phoneNumber = s.phoneNumber);
    const _ = _createError(o, i, a);
    return _.customData._tokenResponse = s,
    _
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function deleteAccount(o, i) {
    return _performApiRequest(o, "POST", "/v1/accounts:delete", i)
}
async function getAccountInfo(o, i) {
    return _performApiRequest(o, "POST", "/v1/accounts:lookup", i)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function utcTimestampToDateString(o) {
    if (o)
        try {
            const i = new Date(Number(o));
            if (!isNaN(i.getTime()))
                return i.toUTCString()
        } catch {}
}
async function getIdTokenResult(o, i=!1) {
    const s = getModularInstance(o)
      , a = await s.getIdToken(i)
      , _ = _parseToken(a);
    _assert(_ && _.exp && _.auth_time && _.iat, s.auth, "internal-error");
    const $ = typeof _.firebase == "object" ? _.firebase : void 0
      , _e = $ == null ? void 0 : $.sign_in_provider;
    return {
        claims: _,
        token: a,
        authTime: utcTimestampToDateString(secondsStringToMilliseconds(_.auth_time)),
        issuedAtTime: utcTimestampToDateString(secondsStringToMilliseconds(_.iat)),
        expirationTime: utcTimestampToDateString(secondsStringToMilliseconds(_.exp)),
        signInProvider: _e || null,
        signInSecondFactor: ($ == null ? void 0 : $.sign_in_second_factor) || null
    }
}
function secondsStringToMilliseconds(o) {
    return Number(o) * 1e3
}
function _parseToken(o) {
    const [i,s,a] = o.split(".");
    if (i === void 0 || s === void 0 || a === void 0)
        return _logError("JWT malformed, contained fewer than 3 sections"),
        null;
    try {
        const _ = base64Decode(s);
        return _ ? JSON.parse(_) : (_logError("Failed to decode base64 JWT payload"),
        null)
    } catch (_) {
        return _logError("Caught error parsing JWT payload as JSON", _ == null ? void 0 : _.toString()),
        null
    }
}
function _tokenExpiresIn(o) {
    const i = _parseToken(o);
    return _assert(i, "internal-error"),
    _assert(typeof i.exp < "u", "internal-error"),
    _assert(typeof i.iat < "u", "internal-error"),
    Number(i.exp) - Number(i.iat)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function _logoutIfInvalidated(o, i, s=!1) {
    if (s)
        return i;
    try {
        return await i
    } catch (a) {
        throw a instanceof FirebaseError && isUserInvalidated(a) && o.auth.currentUser === o && await o.auth.signOut(),
        a
    }
}
function isUserInvalidated({code: o}) {
    return o === "auth/user-disabled" || o === "auth/user-token-expired"
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProactiveRefresh {
    constructor(i) {
        this.user = i,
        this.isRunning = !1,
        this.timerId = null,
        this.errorBackoff = 3e4
    }
    _start() {
        this.isRunning || (this.isRunning = !0,
        this.schedule())
    }
    _stop() {
        this.isRunning && (this.isRunning = !1,
        this.timerId !== null && clearTimeout(this.timerId))
    }
    getInterval(i) {
        var s;
        if (i) {
            const a = this.errorBackoff;
            return this.errorBackoff = Math.min(this.errorBackoff * 2, 96e4),
            a
        } else {
            this.errorBackoff = 3e4;
            const _ = ((s = this.user.stsTokenManager.expirationTime) !== null && s !== void 0 ? s : 0) - Date.now() - 3e5;
            return Math.max(0, _)
        }
    }
    schedule(i=!1) {
        if (!this.isRunning)
            return;
        const s = this.getInterval(i);
        this.timerId = setTimeout(async () => {
            await this.iteration()
        }
        , s)
    }
    async iteration() {
        try {
            await this.user.getIdToken(!0)
        } catch (i) {
            (i == null ? void 0 : i.code) === "auth/network-request-failed" && this.schedule(!0);
            return
        }
        this.schedule()
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UserMetadata {
    constructor(i, s) {
        this.createdAt = i,
        this.lastLoginAt = s,
        this._initializeTime()
    }
    _initializeTime() {
        this.lastSignInTime = utcTimestampToDateString(this.lastLoginAt),
        this.creationTime = utcTimestampToDateString(this.createdAt)
    }
    _copy(i) {
        this.createdAt = i.createdAt,
        this.lastLoginAt = i.lastLoginAt,
        this._initializeTime()
    }
    toJSON() {
        return {
            createdAt: this.createdAt,
            lastLoginAt: this.lastLoginAt
        }
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function _reloadWithoutSaving(o) {
    var i;
    const s = o.auth
      , a = await o.getIdToken()
      , _ = await _logoutIfInvalidated(o, getAccountInfo(s, {
        idToken: a
    }));
    _assert(_ == null ? void 0 : _.users.length, s, "internal-error");
    const $ = _.users[0];
    o._notifyReloadListener($);
    const _e = !((i = $.providerUserInfo) === null || i === void 0) && i.length ? extractProviderData($.providerUserInfo) : []
      , tt = mergeProviderData(o.providerData, _e)
      , nt = o.isAnonymous
      , rt = !(o.email && $.passwordHash) && !(tt != null && tt.length)
      , ot = nt ? rt : !1
      , et = {
        uid: $.localId,
        displayName: $.displayName || null,
        photoURL: $.photoUrl || null,
        email: $.email || null,
        emailVerified: $.emailVerified || !1,
        phoneNumber: $.phoneNumber || null,
        tenantId: $.tenantId || null,
        providerData: tt,
        metadata: new UserMetadata($.createdAt,$.lastLoginAt),
        isAnonymous: ot
    };
    Object.assign(o, et)
}
async function reload(o) {
    const i = getModularInstance(o);
    await _reloadWithoutSaving(i),
    await i.auth._persistUserIfCurrent(i),
    i.auth._notifyListenersIfCurrent(i)
}
function mergeProviderData(o, i) {
    return [...o.filter(a => !i.some(_ => _.providerId === a.providerId)), ...i]
}
function extractProviderData(o) {
    return o.map(i => {
        var {providerId: s} = i
          , a = __rest(i, ["providerId"]);
        return {
            providerId: s,
            uid: a.rawId || "",
            displayName: a.displayName || null,
            email: a.email || null,
            phoneNumber: a.phoneNumber || null,
            photoURL: a.photoUrl || null
        }
    }
    )
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function requestStsToken(o, i) {
    const s = await _performFetchWithErrorHandling(o, {}, async () => {
        const a = querystring({
            grant_type: "refresh_token",
            refresh_token: i
        }).slice(1)
          , {tokenApiHost: _, apiKey: $} = o.config
          , _e = _getFinalTarget(o, _, "/v1/token", `key=${$}`)
          , tt = await o._getAdditionalHeaders();
        return tt["Content-Type"] = "application/x-www-form-urlencoded",
        FetchProvider.fetch()(_e, {
            method: "POST",
            headers: tt,
            body: a
        })
    }
    );
    return {
        accessToken: s.access_token,
        expiresIn: s.expires_in,
        refreshToken: s.refresh_token
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class StsTokenManager {
    constructor() {
        this.refreshToken = null,
        this.accessToken = null,
        this.expirationTime = null
    }
    get isExpired() {
        return !this.expirationTime || Date.now() > this.expirationTime - 3e4
    }
    updateFromServerResponse(i) {
        _assert(i.idToken, "internal-error"),
        _assert(typeof i.idToken < "u", "internal-error"),
        _assert(typeof i.refreshToken < "u", "internal-error");
        const s = "expiresIn"in i && typeof i.expiresIn < "u" ? Number(i.expiresIn) : _tokenExpiresIn(i.idToken);
        this.updateTokensAndExpiration(i.idToken, i.refreshToken, s)
    }
    async getToken(i, s=!1) {
        return _assert(!this.accessToken || this.refreshToken, i, "user-token-expired"),
        !s && this.accessToken && !this.isExpired ? this.accessToken : this.refreshToken ? (await this.refresh(i, this.refreshToken),
        this.accessToken) : null
    }
    clearRefreshToken() {
        this.refreshToken = null
    }
    async refresh(i, s) {
        const {accessToken: a, refreshToken: _, expiresIn: $} = await requestStsToken(i, s);
        this.updateTokensAndExpiration(a, _, Number($))
    }
    updateTokensAndExpiration(i, s, a) {
        this.refreshToken = s || null,
        this.accessToken = i || null,
        this.expirationTime = Date.now() + a * 1e3
    }
    static fromJSON(i, s) {
        const {refreshToken: a, accessToken: _, expirationTime: $} = s
          , _e = new StsTokenManager;
        return a && (_assert(typeof a == "string", "internal-error", {
            appName: i
        }),
        _e.refreshToken = a),
        _ && (_assert(typeof _ == "string", "internal-error", {
            appName: i
        }),
        _e.accessToken = _),
        $ && (_assert(typeof $ == "number", "internal-error", {
            appName: i
        }),
        _e.expirationTime = $),
        _e
    }
    toJSON() {
        return {
            refreshToken: this.refreshToken,
            accessToken: this.accessToken,
            expirationTime: this.expirationTime
        }
    }
    _assign(i) {
        this.accessToken = i.accessToken,
        this.refreshToken = i.refreshToken,
        this.expirationTime = i.expirationTime
    }
    _clone() {
        return Object.assign(new StsTokenManager, this.toJSON())
    }
    _performRefresh() {
        return debugFail("not implemented")
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function assertStringOrUndefined(o, i) {
    _assert(typeof o == "string" || typeof o > "u", "internal-error", {
        appName: i
    })
}
class UserImpl {
    constructor(i) {
        var {uid: s, auth: a, stsTokenManager: _} = i
          , $ = __rest(i, ["uid", "auth", "stsTokenManager"]);
        this.providerId = "firebase",
        this.proactiveRefresh = new ProactiveRefresh(this),
        this.reloadUserInfo = null,
        this.reloadListener = null,
        this.uid = s,
        this.auth = a,
        this.stsTokenManager = _,
        this.accessToken = _.accessToken,
        this.displayName = $.displayName || null,
        this.email = $.email || null,
        this.emailVerified = $.emailVerified || !1,
        this.phoneNumber = $.phoneNumber || null,
        this.photoURL = $.photoURL || null,
        this.isAnonymous = $.isAnonymous || !1,
        this.tenantId = $.tenantId || null,
        this.providerData = $.providerData ? [...$.providerData] : [],
        this.metadata = new UserMetadata($.createdAt || void 0,$.lastLoginAt || void 0)
    }
    async getIdToken(i) {
        const s = await _logoutIfInvalidated(this, this.stsTokenManager.getToken(this.auth, i));
        return _assert(s, this.auth, "internal-error"),
        this.accessToken !== s && (this.accessToken = s,
        await this.auth._persistUserIfCurrent(this),
        this.auth._notifyListenersIfCurrent(this)),
        s
    }
    getIdTokenResult(i) {
        return getIdTokenResult(this, i)
    }
    reload() {
        return reload(this)
    }
    _assign(i) {
        this !== i && (_assert(this.uid === i.uid, this.auth, "internal-error"),
        this.displayName = i.displayName,
        this.photoURL = i.photoURL,
        this.email = i.email,
        this.emailVerified = i.emailVerified,
        this.phoneNumber = i.phoneNumber,
        this.isAnonymous = i.isAnonymous,
        this.tenantId = i.tenantId,
        this.providerData = i.providerData.map(s => Object.assign({}, s)),
        this.metadata._copy(i.metadata),
        this.stsTokenManager._assign(i.stsTokenManager))
    }
    _clone(i) {
        const s = new UserImpl(Object.assign(Object.assign({}, this), {
            auth: i,
            stsTokenManager: this.stsTokenManager._clone()
        }));
        return s.metadata._copy(this.metadata),
        s
    }
    _onReload(i) {
        _assert(!this.reloadListener, this.auth, "internal-error"),
        this.reloadListener = i,
        this.reloadUserInfo && (this._notifyReloadListener(this.reloadUserInfo),
        this.reloadUserInfo = null)
    }
    _notifyReloadListener(i) {
        this.reloadListener ? this.reloadListener(i) : this.reloadUserInfo = i
    }
    _startProactiveRefresh() {
        this.proactiveRefresh._start()
    }
    _stopProactiveRefresh() {
        this.proactiveRefresh._stop()
    }
    async _updateTokensIfNecessary(i, s=!1) {
        let a = !1;
        i.idToken && i.idToken !== this.stsTokenManager.accessToken && (this.stsTokenManager.updateFromServerResponse(i),
        a = !0),
        s && await _reloadWithoutSaving(this),
        await this.auth._persistUserIfCurrent(this),
        a && this.auth._notifyListenersIfCurrent(this)
    }
    async delete() {
        const i = await this.getIdToken();
        return await _logoutIfInvalidated(this, deleteAccount(this.auth, {
            idToken: i
        })),
        this.stsTokenManager.clearRefreshToken(),
        this.auth.signOut()
    }
    toJSON() {
        return Object.assign(Object.assign({
            uid: this.uid,
            email: this.email || void 0,
            emailVerified: this.emailVerified,
            displayName: this.displayName || void 0,
            isAnonymous: this.isAnonymous,
            photoURL: this.photoURL || void 0,
            phoneNumber: this.phoneNumber || void 0,
            tenantId: this.tenantId || void 0,
            providerData: this.providerData.map(i => Object.assign({}, i)),
            stsTokenManager: this.stsTokenManager.toJSON(),
            _redirectEventId: this._redirectEventId
        }, this.metadata.toJSON()), {
            apiKey: this.auth.config.apiKey,
            appName: this.auth.name
        })
    }
    get refreshToken() {
        return this.stsTokenManager.refreshToken || ""
    }
    static _fromJSON(i, s) {
        var a, _, $, _e, tt, nt, rt, ot;
        const et = (a = s.displayName) !== null && a !== void 0 ? a : void 0
          , j = (_ = s.email) !== null && _ !== void 0 ? _ : void 0
          , it = ($ = s.phoneNumber) !== null && $ !== void 0 ? $ : void 0
          , st = (_e = s.photoURL) !== null && _e !== void 0 ? _e : void 0
          , at = (tt = s.tenantId) !== null && tt !== void 0 ? tt : void 0
          , lt = (nt = s._redirectEventId) !== null && nt !== void 0 ? nt : void 0
          , ct = (rt = s.createdAt) !== null && rt !== void 0 ? rt : void 0
          , ut = (ot = s.lastLoginAt) !== null && ot !== void 0 ? ot : void 0
          , {uid: dt, emailVerified: ft, isAnonymous: ht, providerData: pt, stsTokenManager: gt} = s;
        _assert(dt && gt, i, "internal-error");
        const _t = StsTokenManager.fromJSON(this.name, gt);
        _assert(typeof dt == "string", i, "internal-error"),
        assertStringOrUndefined(et, i.name),
        assertStringOrUndefined(j, i.name),
        _assert(typeof ft == "boolean", i, "internal-error"),
        _assert(typeof ht == "boolean", i, "internal-error"),
        assertStringOrUndefined(it, i.name),
        assertStringOrUndefined(st, i.name),
        assertStringOrUndefined(at, i.name),
        assertStringOrUndefined(lt, i.name),
        assertStringOrUndefined(ct, i.name),
        assertStringOrUndefined(ut, i.name);
        const mt = new UserImpl({
            uid: dt,
            auth: i,
            email: j,
            emailVerified: ft,
            displayName: et,
            isAnonymous: ht,
            photoURL: st,
            phoneNumber: it,
            tenantId: at,
            stsTokenManager: _t,
            createdAt: ct,
            lastLoginAt: ut
        });
        return pt && Array.isArray(pt) && (mt.providerData = pt.map(yt => Object.assign({}, yt))),
        lt && (mt._redirectEventId = lt),
        mt
    }
    static async _fromIdTokenResponse(i, s, a=!1) {
        const _ = new StsTokenManager;
        _.updateFromServerResponse(s);
        const $ = new UserImpl({
            uid: s.localId,
            auth: i,
            stsTokenManager: _,
            isAnonymous: a
        });
        return await _reloadWithoutSaving($),
        $
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const instanceCache = new Map;
function _getInstance(o) {
    debugAssert(o instanceof Function, "Expected a class definition");
    let i = instanceCache.get(o);
    return i ? (debugAssert(i instanceof o, "Instance stored in cache mismatched with class"),
    i) : (i = new o,
    instanceCache.set(o, i),
    i)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class InMemoryPersistence {
    constructor() {
        this.type = "NONE",
        this.storage = {}
    }
    async _isAvailable() {
        return !0
    }
    async _set(i, s) {
        this.storage[i] = s
    }
    async _get(i) {
        const s = this.storage[i];
        return s === void 0 ? null : s
    }
    async _remove(i) {
        delete this.storage[i]
    }
    _addListener(i, s) {}
    _removeListener(i, s) {}
}
InMemoryPersistence.type = "NONE";
const inMemoryPersistence = InMemoryPersistence;
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _persistenceKeyName(o, i, s) {
    return `firebase:${o}:${i}:${s}`
}
class PersistenceUserManager {
    constructor(i, s, a) {
        this.persistence = i,
        this.auth = s,
        this.userKey = a;
        const {config: _, name: $} = this.auth;
        this.fullUserKey = _persistenceKeyName(this.userKey, _.apiKey, $),
        this.fullPersistenceKey = _persistenceKeyName("persistence", _.apiKey, $),
        this.boundEventHandler = s._onStorageEvent.bind(s),
        this.persistence._addListener(this.fullUserKey, this.boundEventHandler)
    }
    setCurrentUser(i) {
        return this.persistence._set(this.fullUserKey, i.toJSON())
    }
    async getCurrentUser() {
        const i = await this.persistence._get(this.fullUserKey);
        return i ? UserImpl._fromJSON(this.auth, i) : null
    }
    removeCurrentUser() {
        return this.persistence._remove(this.fullUserKey)
    }
    savePersistenceForRedirect() {
        return this.persistence._set(this.fullPersistenceKey, this.persistence.type)
    }
    async setPersistence(i) {
        if (this.persistence === i)
            return;
        const s = await this.getCurrentUser();
        if (await this.removeCurrentUser(),
        this.persistence = i,
        s)
            return this.setCurrentUser(s)
    }
    delete() {
        this.persistence._removeListener(this.fullUserKey, this.boundEventHandler)
    }
    static async create(i, s, a="authUser") {
        if (!s.length)
            return new PersistenceUserManager(_getInstance(inMemoryPersistence),i,a);
        const _ = (await Promise.all(s.map(async rt => {
            if (await rt._isAvailable())
                return rt
        }
        ))).filter(rt => rt);
        let $ = _[0] || _getInstance(inMemoryPersistence);
        const _e = _persistenceKeyName(a, i.config.apiKey, i.name);
        let tt = null;
        for (const rt of s)
            try {
                const ot = await rt._get(_e);
                if (ot) {
                    const et = UserImpl._fromJSON(i, ot);
                    rt !== $ && (tt = et),
                    $ = rt;
                    break
                }
            } catch {}
        const nt = _.filter(rt => rt._shouldAllowMigration);
        return !$._shouldAllowMigration || !nt.length ? new PersistenceUserManager($,i,a) : ($ = nt[0],
        tt && await $._set(_e, tt.toJSON()),
        await Promise.all(s.map(async rt => {
            if (rt !== $)
                try {
                    await rt._remove(_e)
                } catch {}
        }
        )),
        new PersistenceUserManager($,i,a))
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _getBrowserName(o) {
    const i = o.toLowerCase();
    if (i.includes("opera/") || i.includes("opr/") || i.includes("opios/"))
        return "Opera";
    if (_isIEMobile(i))
        return "IEMobile";
    if (i.includes("msie") || i.includes("trident/"))
        return "IE";
    if (i.includes("edge/"))
        return "Edge";
    if (_isFirefox(i))
        return "Firefox";
    if (i.includes("silk/"))
        return "Silk";
    if (_isBlackBerry(i))
        return "Blackberry";
    if (_isWebOS(i))
        return "Webos";
    if (_isSafari(i))
        return "Safari";
    if ((i.includes("chrome/") || _isChromeIOS(i)) && !i.includes("edge/"))
        return "Chrome";
    if (_isAndroid(i))
        return "Android";
    {
        const s = /([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/
          , a = o.match(s);
        if ((a == null ? void 0 : a.length) === 2)
            return a[1]
    }
    return "Other"
}
function _isFirefox(o=getUA()) {
    return /firefox\//i.test(o)
}
function _isSafari(o=getUA()) {
    const i = o.toLowerCase();
    return i.includes("safari/") && !i.includes("chrome/") && !i.includes("crios/") && !i.includes("android")
}
function _isChromeIOS(o=getUA()) {
    return /crios\//i.test(o)
}
function _isIEMobile(o=getUA()) {
    return /iemobile/i.test(o)
}
function _isAndroid(o=getUA()) {
    return /android/i.test(o)
}
function _isBlackBerry(o=getUA()) {
    return /blackberry/i.test(o)
}
function _isWebOS(o=getUA()) {
    return /webos/i.test(o)
}
function _isIOS(o=getUA()) {
    return /iphone|ipad|ipod/i.test(o) || /macintosh/i.test(o) && /mobile/i.test(o)
}
function _isIOSStandalone(o=getUA()) {
    var i;
    return _isIOS(o) && !!(!((i = window.navigator) === null || i === void 0) && i.standalone)
}
function _isIE10() {
    return isIE() && document.documentMode === 10
}
function _isMobileBrowser(o=getUA()) {
    return _isIOS(o) || _isAndroid(o) || _isWebOS(o) || _isBlackBerry(o) || /windows phone/i.test(o) || _isIEMobile(o)
}
function _isIframe() {
    try {
        return !!(window && window !== window.top)
    } catch {
        return !1
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _getClientVersion(o, i=[]) {
    let s;
    switch (o) {
    case "Browser":
        s = _getBrowserName(getUA());
        break;
    case "Worker":
        s = `${_getBrowserName(getUA())}-${o}`;
        break;
    default:
        s = o
    }
    const a = i.length ? i.join(",") : "FirebaseCore-web";
    return `${s}/JsCore/${SDK_VERSION}/${a}`
}
async function getRecaptchaConfig(o, i) {
    return _performApiRequest(o, "GET", "/v2/recaptchaConfig", _addTidIfNecessary(o, i))
}
function isEnterprise(o) {
    return o !== void 0 && o.enterprise !== void 0
}
class RecaptchaConfig {
    constructor(i) {
        if (this.siteKey = "",
        this.emailPasswordEnabled = !1,
        i.recaptchaKey === void 0)
            throw new Error("recaptchaKey undefined");
        this.siteKey = i.recaptchaKey.split("/")[3],
        this.emailPasswordEnabled = i.recaptchaEnforcementState.some(s => s.provider === "EMAIL_PASSWORD_PROVIDER" && s.enforcementState !== "OFF")
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getScriptParentElement() {
    var o, i;
    return (i = (o = document.getElementsByTagName("head")) === null || o === void 0 ? void 0 : o[0]) !== null && i !== void 0 ? i : document
}
function _loadJS(o) {
    return new Promise( (i, s) => {
        const a = document.createElement("script");
        a.setAttribute("src", o),
        a.onload = i,
        a.onerror = _ => {
            const $ = _createError("internal-error");
            $.customData = _,
            s($)
        }
        ,
        a.type = "text/javascript",
        a.charset = "UTF-8",
        getScriptParentElement().appendChild(a)
    }
    )
}
function _generateCallbackName(o) {
    return `__${o}${Math.floor(Math.random() * 1e6)}`
}
const RECAPTCHA_ENTERPRISE_URL = "https://www.google.com/recaptcha/enterprise.js?render="
  , RECAPTCHA_ENTERPRISE_VERIFIER_TYPE = "recaptcha-enterprise"
  , FAKE_TOKEN = "NO_RECAPTCHA";
class RecaptchaEnterpriseVerifier {
    constructor(i) {
        this.type = RECAPTCHA_ENTERPRISE_VERIFIER_TYPE,
        this.auth = _castAuth(i)
    }
    async verify(i="verify", s=!1) {
        async function a($) {
            if (!s) {
                if ($.tenantId == null && $._agentRecaptchaConfig != null)
                    return $._agentRecaptchaConfig.siteKey;
                if ($.tenantId != null && $._tenantRecaptchaConfigs[$.tenantId] !== void 0)
                    return $._tenantRecaptchaConfigs[$.tenantId].siteKey
            }
            return new Promise(async (_e, tt) => {
                getRecaptchaConfig($, {
                    clientType: "CLIENT_TYPE_WEB",
                    version: "RECAPTCHA_ENTERPRISE"
                }).then(nt => {
                    if (nt.recaptchaKey === void 0)
                        tt(new Error("recaptcha Enterprise site key undefined"));
                    else {
                        const rt = new RecaptchaConfig(nt);
                        return $.tenantId == null ? $._agentRecaptchaConfig = rt : $._tenantRecaptchaConfigs[$.tenantId] = rt,
                        _e(rt.siteKey)
                    }
                }
                ).catch(nt => {
                    tt(nt)
                }
                )
            }
            )
        }
        function _($, _e, tt) {
            const nt = window.grecaptcha;
            isEnterprise(nt) ? nt.enterprise.ready( () => {
                nt.enterprise.execute($, {
                    action: i
                }).then(rt => {
                    _e(rt)
                }
                ).catch( () => {
                    _e(FAKE_TOKEN)
                }
                )
            }
            ) : tt(Error("No reCAPTCHA enterprise script loaded."))
        }
        return new Promise( ($, _e) => {
            a(this.auth).then(tt => {
                if (!s && isEnterprise(window.grecaptcha))
                    _(tt, $, _e);
                else {
                    if (typeof window > "u") {
                        _e(new Error("RecaptchaVerifier is only supported in browser"));
                        return
                    }
                    _loadJS(RECAPTCHA_ENTERPRISE_URL + tt).then( () => {
                        _(tt, $, _e)
                    }
                    ).catch(nt => {
                        _e(nt)
                    }
                    )
                }
            }
            ).catch(tt => {
                _e(tt)
            }
            )
        }
        )
    }
}
async function injectRecaptchaFields(o, i, s, a=!1) {
    const _ = new RecaptchaEnterpriseVerifier(o);
    let $;
    try {
        $ = await _.verify(s)
    } catch {
        $ = await _.verify(s, !0)
    }
    const _e = Object.assign({}, i);
    return a ? Object.assign(_e, {
        captchaResp: $
    }) : Object.assign(_e, {
        captchaResponse: $
    }),
    Object.assign(_e, {
        clientType: "CLIENT_TYPE_WEB"
    }),
    Object.assign(_e, {
        recaptchaVersion: "RECAPTCHA_ENTERPRISE"
    }),
    _e
}
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AuthMiddlewareQueue {
    constructor(i) {
        this.auth = i,
        this.queue = []
    }
    pushCallback(i, s) {
        const a = $ => new Promise( (_e, tt) => {
            try {
                const nt = i($);
                _e(nt)
            } catch (nt) {
                tt(nt)
            }
        }
        );
        a.onAbort = s,
        this.queue.push(a);
        const _ = this.queue.length - 1;
        return () => {
            this.queue[_] = () => Promise.resolve()
        }
    }
    async runMiddleware(i) {
        if (this.auth.currentUser === i)
            return;
        const s = [];
        try {
            for (const a of this.queue)
                await a(i),
                a.onAbort && s.push(a.onAbort)
        } catch (a) {
            s.reverse();
            for (const _ of s)
                try {
                    _()
                } catch {}
            throw this.auth._errorFactory.create("login-blocked", {
                originalMessage: a == null ? void 0 : a.message
            })
        }
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AuthImpl {
    constructor(i, s, a, _) {
        this.app = i,
        this.heartbeatServiceProvider = s,
        this.appCheckServiceProvider = a,
        this.config = _,
        this.currentUser = null,
        this.emulatorConfig = null,
        this.operations = Promise.resolve(),
        this.authStateSubscription = new Subscription(this),
        this.idTokenSubscription = new Subscription(this),
        this.beforeStateQueue = new AuthMiddlewareQueue(this),
        this.redirectUser = null,
        this.isProactiveRefreshEnabled = !1,
        this._canInitEmulator = !0,
        this._isInitialized = !1,
        this._deleted = !1,
        this._initializationPromise = null,
        this._popupRedirectResolver = null,
        this._errorFactory = _DEFAULT_AUTH_ERROR_FACTORY,
        this._agentRecaptchaConfig = null,
        this._tenantRecaptchaConfigs = {},
        this.lastNotifiedUid = void 0,
        this.languageCode = null,
        this.tenantId = null,
        this.settings = {
            appVerificationDisabledForTesting: !1
        },
        this.frameworks = [],
        this.name = i.name,
        this.clientVersion = _.sdkClientVersion
    }
    _initializeWithPersistence(i, s) {
        return s && (this._popupRedirectResolver = _getInstance(s)),
        this._initializationPromise = this.queue(async () => {
            var a, _;
            if (!this._deleted && (this.persistenceManager = await PersistenceUserManager.create(this, i),
            !this._deleted)) {
                if (!((a = this._popupRedirectResolver) === null || a === void 0) && a._shouldInitProactively)
                    try {
                        await this._popupRedirectResolver._initialize(this)
                    } catch {}
                await this.initializeCurrentUser(s),
                this.lastNotifiedUid = ((_ = this.currentUser) === null || _ === void 0 ? void 0 : _.uid) || null,
                !this._deleted && (this._isInitialized = !0)
            }
        }
        ),
        this._initializationPromise
    }
    async _onStorageEvent() {
        if (this._deleted)
            return;
        const i = await this.assertedPersistence.getCurrentUser();
        if (!(!this.currentUser && !i)) {
            if (this.currentUser && i && this.currentUser.uid === i.uid) {
                this._currentUser._assign(i),
                await this.currentUser.getIdToken();
                return
            }
            await this._updateCurrentUser(i, !0)
        }
    }
    async initializeCurrentUser(i) {
        var s;
        const a = await this.assertedPersistence.getCurrentUser();
        let _ = a
          , $ = !1;
        if (i && this.config.authDomain) {
            await this.getOrInitRedirectPersistenceManager();
            const _e = (s = this.redirectUser) === null || s === void 0 ? void 0 : s._redirectEventId
              , tt = _ == null ? void 0 : _._redirectEventId
              , nt = await this.tryRedirectSignIn(i);
            (!_e || _e === tt) && (nt != null && nt.user) && (_ = nt.user,
            $ = !0)
        }
        if (!_)
            return this.directlySetCurrentUser(null);
        if (!_._redirectEventId) {
            if ($)
                try {
                    await this.beforeStateQueue.runMiddleware(_)
                } catch (_e) {
                    _ = a,
                    this._popupRedirectResolver._overrideRedirectResult(this, () => Promise.reject(_e))
                }
            return _ ? this.reloadAndSetCurrentUserOrClear(_) : this.directlySetCurrentUser(null)
        }
        return _assert(this._popupRedirectResolver, this, "argument-error"),
        await this.getOrInitRedirectPersistenceManager(),
        this.redirectUser && this.redirectUser._redirectEventId === _._redirectEventId ? this.directlySetCurrentUser(_) : this.reloadAndSetCurrentUserOrClear(_)
    }
    async tryRedirectSignIn(i) {
        let s = null;
        try {
            s = await this._popupRedirectResolver._completeRedirectFn(this, i, !0)
        } catch {
            await this._setRedirectUser(null)
        }
        return s
    }
    async reloadAndSetCurrentUserOrClear(i) {
        try {
            await _reloadWithoutSaving(i)
        } catch (s) {
            if ((s == null ? void 0 : s.code) !== "auth/network-request-failed")
                return this.directlySetCurrentUser(null)
        }
        return this.directlySetCurrentUser(i)
    }
    useDeviceLanguage() {
        this.languageCode = _getUserLanguage()
    }
    async _delete() {
        this._deleted = !0
    }
    async updateCurrentUser(i) {
        const s = i ? getModularInstance(i) : null;
        return s && _assert(s.auth.config.apiKey === this.config.apiKey, this, "invalid-user-token"),
        this._updateCurrentUser(s && s._clone(this))
    }
    async _updateCurrentUser(i, s=!1) {
        if (!this._deleted)
            return i && _assert(this.tenantId === i.tenantId, this, "tenant-id-mismatch"),
            s || await this.beforeStateQueue.runMiddleware(i),
            this.queue(async () => {
                await this.directlySetCurrentUser(i),
                this.notifyAuthListeners()
            }
            )
    }
    async signOut() {
        return await this.beforeStateQueue.runMiddleware(null),
        (this.redirectPersistenceManager || this._popupRedirectResolver) && await this._setRedirectUser(null),
        this._updateCurrentUser(null, !0)
    }
    setPersistence(i) {
        return this.queue(async () => {
            await this.assertedPersistence.setPersistence(_getInstance(i))
        }
        )
    }
    async initializeRecaptchaConfig() {
        const i = await getRecaptchaConfig(this, {
            clientType: "CLIENT_TYPE_WEB",
            version: "RECAPTCHA_ENTERPRISE"
        })
          , s = new RecaptchaConfig(i);
        this.tenantId == null ? this._agentRecaptchaConfig = s : this._tenantRecaptchaConfigs[this.tenantId] = s,
        s.emailPasswordEnabled && new RecaptchaEnterpriseVerifier(this).verify()
    }
    _getRecaptchaConfig() {
        return this.tenantId == null ? this._agentRecaptchaConfig : this._tenantRecaptchaConfigs[this.tenantId]
    }
    _getPersistence() {
        return this.assertedPersistence.persistence.type
    }
    _updateErrorMap(i) {
        this._errorFactory = new ErrorFactory("auth","Firebase",i())
    }
    onAuthStateChanged(i, s, a) {
        return this.registerStateListener(this.authStateSubscription, i, s, a)
    }
    beforeAuthStateChanged(i, s) {
        return this.beforeStateQueue.pushCallback(i, s)
    }
    onIdTokenChanged(i, s, a) {
        return this.registerStateListener(this.idTokenSubscription, i, s, a)
    }
    authStateReady() {
        return new Promise( (i, s) => {
            if (this.currentUser)
                i();
            else {
                const a = this.onAuthStateChanged( () => {
                    a(),
                    i()
                }
                , s)
            }
        }
        )
    }
    toJSON() {
        var i;
        return {
            apiKey: this.config.apiKey,
            authDomain: this.config.authDomain,
            appName: this.name,
            currentUser: (i = this._currentUser) === null || i === void 0 ? void 0 : i.toJSON()
        }
    }
    async _setRedirectUser(i, s) {
        const a = await this.getOrInitRedirectPersistenceManager(s);
        return i === null ? a.removeCurrentUser() : a.setCurrentUser(i)
    }
    async getOrInitRedirectPersistenceManager(i) {
        if (!this.redirectPersistenceManager) {
            const s = i && _getInstance(i) || this._popupRedirectResolver;
            _assert(s, this, "argument-error"),
            this.redirectPersistenceManager = await PersistenceUserManager.create(this, [_getInstance(s._redirectPersistence)], "redirectUser"),
            this.redirectUser = await this.redirectPersistenceManager.getCurrentUser()
        }
        return this.redirectPersistenceManager
    }
    async _redirectUserForId(i) {
        var s, a;
        return this._isInitialized && await this.queue(async () => {}
        ),
        ((s = this._currentUser) === null || s === void 0 ? void 0 : s._redirectEventId) === i ? this._currentUser : ((a = this.redirectUser) === null || a === void 0 ? void 0 : a._redirectEventId) === i ? this.redirectUser : null
    }
    async _persistUserIfCurrent(i) {
        if (i === this.currentUser)
            return this.queue(async () => this.directlySetCurrentUser(i))
    }
    _notifyListenersIfCurrent(i) {
        i === this.currentUser && this.notifyAuthListeners()
    }
    _key() {
        return `${this.config.authDomain}:${this.config.apiKey}:${this.name}`
    }
    _startProactiveRefresh() {
        this.isProactiveRefreshEnabled = !0,
        this.currentUser && this._currentUser._startProactiveRefresh()
    }
    _stopProactiveRefresh() {
        this.isProactiveRefreshEnabled = !1,
        this.currentUser && this._currentUser._stopProactiveRefresh()
    }
    get _currentUser() {
        return this.currentUser
    }
    notifyAuthListeners() {
        var i, s;
        if (!this._isInitialized)
            return;
        this.idTokenSubscription.next(this.currentUser);
        const a = (s = (i = this.currentUser) === null || i === void 0 ? void 0 : i.uid) !== null && s !== void 0 ? s : null;
        this.lastNotifiedUid !== a && (this.lastNotifiedUid = a,
        this.authStateSubscription.next(this.currentUser))
    }
    registerStateListener(i, s, a, _) {
        if (this._deleted)
            return () => {}
            ;
        const $ = typeof s == "function" ? s : s.next.bind(s)
          , _e = this._isInitialized ? Promise.resolve() : this._initializationPromise;
        return _assert(_e, this, "internal-error"),
        _e.then( () => $(this.currentUser)),
        typeof s == "function" ? i.addObserver(s, a, _) : i.addObserver(s)
    }
    async directlySetCurrentUser(i) {
        this.currentUser && this.currentUser !== i && this._currentUser._stopProactiveRefresh(),
        i && this.isProactiveRefreshEnabled && i._startProactiveRefresh(),
        this.currentUser = i,
        i ? await this.assertedPersistence.setCurrentUser(i) : await this.assertedPersistence.removeCurrentUser()
    }
    queue(i) {
        return this.operations = this.operations.then(i, i),
        this.operations
    }
    get assertedPersistence() {
        return _assert(this.persistenceManager, this, "internal-error"),
        this.persistenceManager
    }
    _logFramework(i) {
        !i || this.frameworks.includes(i) || (this.frameworks.push(i),
        this.frameworks.sort(),
        this.clientVersion = _getClientVersion(this.config.clientPlatform, this._getFrameworks()))
    }
    _getFrameworks() {
        return this.frameworks
    }
    async _getAdditionalHeaders() {
        var i;
        const s = {
            "X-Client-Version": this.clientVersion
        };
        this.app.options.appId && (s["X-Firebase-gmpid"] = this.app.options.appId);
        const a = await ((i = this.heartbeatServiceProvider.getImmediate({
            optional: !0
        })) === null || i === void 0 ? void 0 : i.getHeartbeatsHeader());
        a && (s["X-Firebase-Client"] = a);
        const _ = await this._getAppCheckToken();
        return _ && (s["X-Firebase-AppCheck"] = _),
        s
    }
    async _getAppCheckToken() {
        var i;
        const s = await ((i = this.appCheckServiceProvider.getImmediate({
            optional: !0
        })) === null || i === void 0 ? void 0 : i.getToken());
        return s != null && s.error && _logWarn(`Error while retrieving App Check token: ${s.error}`),
        s == null ? void 0 : s.token
    }
}
function _castAuth(o) {
    return getModularInstance(o)
}
class Subscription {
    constructor(i) {
        this.auth = i,
        this.observer = null,
        this.addObserver = createSubscribe(s => this.observer = s)
    }
    get next() {
        return _assert(this.observer, this.auth, "internal-error"),
        this.observer.next.bind(this.observer)
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function initializeAuth(o, i) {
    const s = _getProvider(o, "auth");
    if (s.isInitialized()) {
        const _ = s.getImmediate()
          , $ = s.getOptions();
        if (deepEqual($, i ?? {}))
            return _;
        _fail(_, "already-initialized")
    }
    return s.initialize({
        options: i
    })
}
function _initializeAuthInstance(o, i) {
    const s = (i == null ? void 0 : i.persistence) || []
      , a = (Array.isArray(s) ? s : [s]).map(_getInstance);
    i != null && i.errorMap && o._updateErrorMap(i.errorMap),
    o._initializeWithPersistence(a, i == null ? void 0 : i.popupRedirectResolver)
}
function connectAuthEmulator(o, i, s) {
    const a = _castAuth(o);
    _assert(a._canInitEmulator, a, "emulator-config-failed"),
    _assert(/^https?:\/\//.test(i), a, "invalid-emulator-scheme");
    const _ = !!(s != null && s.disableWarnings)
      , $ = extractProtocol(i)
      , {host: _e, port: tt} = extractHostAndPort(i)
      , nt = tt === null ? "" : `:${tt}`;
    a.config.emulator = {
        url: `${$}//${_e}${nt}/`
    },
    a.settings.appVerificationDisabledForTesting = !0,
    a.emulatorConfig = Object.freeze({
        host: _e,
        port: tt,
        protocol: $.replace(":", ""),
        options: Object.freeze({
            disableWarnings: _
        })
    }),
    _ || emitEmulatorWarning()
}
function extractProtocol(o) {
    const i = o.indexOf(":");
    return i < 0 ? "" : o.substr(0, i + 1)
}
function extractHostAndPort(o) {
    const i = extractProtocol(o)
      , s = /(\/\/)?([^?#/]+)/.exec(o.substr(i.length));
    if (!s)
        return {
            host: "",
            port: null
        };
    const a = s[2].split("@").pop() || ""
      , _ = /^(\[[^\]]+\])(:|$)/.exec(a);
    if (_) {
        const $ = _[1];
        return {
            host: $,
            port: parsePort(a.substr($.length + 1))
        }
    } else {
        const [$,_e] = a.split(":");
        return {
            host: $,
            port: parsePort(_e)
        }
    }
}
function parsePort(o) {
    if (!o)
        return null;
    const i = Number(o);
    return isNaN(i) ? null : i
}
function emitEmulatorWarning() {
    function o() {
        const i = document.createElement("p")
          , s = i.style;
        i.innerText = "Running in emulator mode. Do not use with production credentials.",
        s.position = "fixed",
        s.width = "100%",
        s.backgroundColor = "#ffffff",
        s.border = ".1em solid #000000",
        s.color = "#b50000",
        s.bottom = "0px",
        s.left = "0px",
        s.margin = "0px",
        s.zIndex = "10000",
        s.textAlign = "center",
        i.classList.add("firebase-emulator-warning"),
        document.body.appendChild(i)
    }
    typeof console < "u" && typeof console.info == "function" && console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials."),
    typeof window < "u" && typeof document < "u" && (document.readyState === "loading" ? window.addEventListener("DOMContentLoaded", o) : o())
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AuthCredential {
    constructor(i, s) {
        this.providerId = i,
        this.signInMethod = s
    }
    toJSON() {
        return debugFail("not implemented")
    }
    _getIdTokenResponse(i) {
        return debugFail("not implemented")
    }
    _linkToIdToken(i, s) {
        return debugFail("not implemented")
    }
    _getReauthenticationResolver(i) {
        return debugFail("not implemented")
    }
}
async function updateEmailPassword(o, i) {
    return _performApiRequest(o, "POST", "/v1/accounts:update", i)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function signInWithPassword(o, i) {
    return _performSignInRequest(o, "POST", "/v1/accounts:signInWithPassword", _addTidIfNecessary(o, i))
}
async function sendOobCode(o, i) {
    return _performApiRequest(o, "POST", "/v1/accounts:sendOobCode", _addTidIfNecessary(o, i))
}
async function sendPasswordResetEmail$1(o, i) {
    return sendOobCode(o, i)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function signInWithEmailLink$1(o, i) {
    return _performSignInRequest(o, "POST", "/v1/accounts:signInWithEmailLink", _addTidIfNecessary(o, i))
}
async function signInWithEmailLinkForLinking(o, i) {
    return _performSignInRequest(o, "POST", "/v1/accounts:signInWithEmailLink", _addTidIfNecessary(o, i))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EmailAuthCredential extends AuthCredential {
    constructor(i, s, a, _=null) {
        super("password", a),
        this._email = i,
        this._password = s,
        this._tenantId = _
    }
    static _fromEmailAndPassword(i, s) {
        return new EmailAuthCredential(i,s,"password")
    }
    static _fromEmailAndCode(i, s, a=null) {
        return new EmailAuthCredential(i,s,"emailLink",a)
    }
    toJSON() {
        return {
            email: this._email,
            password: this._password,
            signInMethod: this.signInMethod,
            tenantId: this._tenantId
        }
    }
    static fromJSON(i) {
        const s = typeof i == "string" ? JSON.parse(i) : i;
        if (s != null && s.email && (s != null && s.password)) {
            if (s.signInMethod === "password")
                return this._fromEmailAndPassword(s.email, s.password);
            if (s.signInMethod === "emailLink")
                return this._fromEmailAndCode(s.email, s.password, s.tenantId)
        }
        return null
    }
    async _getIdTokenResponse(i) {
        var s;
        switch (this.signInMethod) {
        case "password":
            const a = {
                returnSecureToken: !0,
                email: this._email,
                password: this._password,
                clientType: "CLIENT_TYPE_WEB"
            };
            if (!((s = i._getRecaptchaConfig()) === null || s === void 0) && s.emailPasswordEnabled) {
                const _ = await injectRecaptchaFields(i, a, "signInWithPassword");
                return signInWithPassword(i, _)
            } else
                return signInWithPassword(i, a).catch(async _ => {
                    if (_.code === "auth/missing-recaptcha-token") {
                        console.log("Sign-in with email address and password is protected by reCAPTCHA for this project. Automatically triggering the reCAPTCHA flow and restarting the sign-in flow.");
                        const $ = await injectRecaptchaFields(i, a, "signInWithPassword");
                        return signInWithPassword(i, $)
                    } else
                        return Promise.reject(_)
                }
                );
        case "emailLink":
            return signInWithEmailLink$1(i, {
                email: this._email,
                oobCode: this._password
            });
        default:
            _fail(i, "internal-error")
        }
    }
    async _linkToIdToken(i, s) {
        switch (this.signInMethod) {
        case "password":
            return updateEmailPassword(i, {
                idToken: s,
                returnSecureToken: !0,
                email: this._email,
                password: this._password
            });
        case "emailLink":
            return signInWithEmailLinkForLinking(i, {
                idToken: s,
                email: this._email,
                oobCode: this._password
            });
        default:
            _fail(i, "internal-error")
        }
    }
    _getReauthenticationResolver(i) {
        return this._getIdTokenResponse(i)
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function signInWithIdp(o, i) {
    return _performSignInRequest(o, "POST", "/v1/accounts:signInWithIdp", _addTidIfNecessary(o, i))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const IDP_REQUEST_URI$1 = "http://localhost";
class OAuthCredential extends AuthCredential {
    constructor() {
        super(...arguments),
        this.pendingToken = null
    }
    static _fromParams(i) {
        const s = new OAuthCredential(i.providerId,i.signInMethod);
        return i.idToken || i.accessToken ? (i.idToken && (s.idToken = i.idToken),
        i.accessToken && (s.accessToken = i.accessToken),
        i.nonce && !i.pendingToken && (s.nonce = i.nonce),
        i.pendingToken && (s.pendingToken = i.pendingToken)) : i.oauthToken && i.oauthTokenSecret ? (s.accessToken = i.oauthToken,
        s.secret = i.oauthTokenSecret) : _fail("argument-error"),
        s
    }
    toJSON() {
        return {
            idToken: this.idToken,
            accessToken: this.accessToken,
            secret: this.secret,
            nonce: this.nonce,
            pendingToken: this.pendingToken,
            providerId: this.providerId,
            signInMethod: this.signInMethod
        }
    }
    static fromJSON(i) {
        const s = typeof i == "string" ? JSON.parse(i) : i
          , {providerId: a, signInMethod: _} = s
          , $ = __rest(s, ["providerId", "signInMethod"]);
        if (!a || !_)
            return null;
        const _e = new OAuthCredential(a,_);
        return _e.idToken = $.idToken || void 0,
        _e.accessToken = $.accessToken || void 0,
        _e.secret = $.secret,
        _e.nonce = $.nonce,
        _e.pendingToken = $.pendingToken || null,
        _e
    }
    _getIdTokenResponse(i) {
        const s = this.buildRequest();
        return signInWithIdp(i, s)
    }
    _linkToIdToken(i, s) {
        const a = this.buildRequest();
        return a.idToken = s,
        signInWithIdp(i, a)
    }
    _getReauthenticationResolver(i) {
        const s = this.buildRequest();
        return s.autoCreate = !1,
        signInWithIdp(i, s)
    }
    buildRequest() {
        const i = {
            requestUri: IDP_REQUEST_URI$1,
            returnSecureToken: !0
        };
        if (this.pendingToken)
            i.pendingToken = this.pendingToken;
        else {
            const s = {};
            this.idToken && (s.id_token = this.idToken),
            this.accessToken && (s.access_token = this.accessToken),
            this.secret && (s.oauth_token_secret = this.secret),
            s.providerId = this.providerId,
            this.nonce && !this.pendingToken && (s.nonce = this.nonce),
            i.postBody = querystring(s)
        }
        return i
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function parseMode(o) {
    switch (o) {
    case "recoverEmail":
        return "RECOVER_EMAIL";
    case "resetPassword":
        return "PASSWORD_RESET";
    case "signIn":
        return "EMAIL_SIGNIN";
    case "verifyEmail":
        return "VERIFY_EMAIL";
    case "verifyAndChangeEmail":
        return "VERIFY_AND_CHANGE_EMAIL";
    case "revertSecondFactorAddition":
        return "REVERT_SECOND_FACTOR_ADDITION";
    default:
        return null
    }
}
function parseDeepLink(o) {
    const i = querystringDecode(extractQuerystring(o)).link
      , s = i ? querystringDecode(extractQuerystring(i)).deep_link_id : null
      , a = querystringDecode(extractQuerystring(o)).deep_link_id;
    return (a ? querystringDecode(extractQuerystring(a)).link : null) || a || s || i || o
}
class ActionCodeURL {
    constructor(i) {
        var s, a, _, $, _e, tt;
        const nt = querystringDecode(extractQuerystring(i))
          , rt = (s = nt.apiKey) !== null && s !== void 0 ? s : null
          , ot = (a = nt.oobCode) !== null && a !== void 0 ? a : null
          , et = parseMode((_ = nt.mode) !== null && _ !== void 0 ? _ : null);
        _assert(rt && ot && et, "argument-error"),
        this.apiKey = rt,
        this.operation = et,
        this.code = ot,
        this.continueUrl = ($ = nt.continueUrl) !== null && $ !== void 0 ? $ : null,
        this.languageCode = (_e = nt.languageCode) !== null && _e !== void 0 ? _e : null,
        this.tenantId = (tt = nt.tenantId) !== null && tt !== void 0 ? tt : null
    }
    static parseLink(i) {
        const s = parseDeepLink(i);
        try {
            return new ActionCodeURL(s)
        } catch {
            return null
        }
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EmailAuthProvider {
    constructor() {
        this.providerId = EmailAuthProvider.PROVIDER_ID
    }
    static credential(i, s) {
        return EmailAuthCredential._fromEmailAndPassword(i, s)
    }
    static credentialWithLink(i, s) {
        const a = ActionCodeURL.parseLink(s);
        return _assert(a, "argument-error"),
        EmailAuthCredential._fromEmailAndCode(i, a.code, a.tenantId)
    }
}
EmailAuthProvider.PROVIDER_ID = "password";
EmailAuthProvider.EMAIL_PASSWORD_SIGN_IN_METHOD = "password";
EmailAuthProvider.EMAIL_LINK_SIGN_IN_METHOD = "emailLink";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FederatedAuthProvider {
    constructor(i) {
        this.providerId = i,
        this.defaultLanguageCode = null,
        this.customParameters = {}
    }
    setDefaultLanguage(i) {
        this.defaultLanguageCode = i
    }
    setCustomParameters(i) {
        return this.customParameters = i,
        this
    }
    getCustomParameters() {
        return this.customParameters
    }
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BaseOAuthProvider extends FederatedAuthProvider {
    constructor() {
        super(...arguments),
        this.scopes = []
    }
    addScope(i) {
        return this.scopes.includes(i) || this.scopes.push(i),
        this
    }
    getScopes() {
        return [...this.scopes]
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FacebookAuthProvider extends BaseOAuthProvider {
    constructor() {
        super("facebook.com")
    }
    static credential(i) {
        return OAuthCredential._fromParams({
            providerId: FacebookAuthProvider.PROVIDER_ID,
            signInMethod: FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD,
            accessToken: i
        })
    }
    static credentialFromResult(i) {
        return FacebookAuthProvider.credentialFromTaggedObject(i)
    }
    static credentialFromError(i) {
        return FacebookAuthProvider.credentialFromTaggedObject(i.customData || {})
    }
    static credentialFromTaggedObject({_tokenResponse: i}) {
        if (!i || !("oauthAccessToken"in i) || !i.oauthAccessToken)
            return null;
        try {
            return FacebookAuthProvider.credential(i.oauthAccessToken)
        } catch {
            return null
        }
    }
}
FacebookAuthProvider.FACEBOOK_SIGN_IN_METHOD = "facebook.com";
FacebookAuthProvider.PROVIDER_ID = "facebook.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class GoogleAuthProvider extends BaseOAuthProvider {
    constructor() {
        super("google.com"),
        this.addScope("profile")
    }
    static credential(i, s) {
        return OAuthCredential._fromParams({
            providerId: GoogleAuthProvider.PROVIDER_ID,
            signInMethod: GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD,
            idToken: i,
            accessToken: s
        })
    }
    static credentialFromResult(i) {
        return GoogleAuthProvider.credentialFromTaggedObject(i)
    }
    static credentialFromError(i) {
        return GoogleAuthProvider.credentialFromTaggedObject(i.customData || {})
    }
    static credentialFromTaggedObject({_tokenResponse: i}) {
        if (!i)
            return null;
        const {oauthIdToken: s, oauthAccessToken: a} = i;
        if (!s && !a)
            return null;
        try {
            return GoogleAuthProvider.credential(s, a)
        } catch {
            return null
        }
    }
}
GoogleAuthProvider.GOOGLE_SIGN_IN_METHOD = "google.com";
GoogleAuthProvider.PROVIDER_ID = "google.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class GithubAuthProvider extends BaseOAuthProvider {
    constructor() {
        super("github.com")
    }
    static credential(i) {
        return OAuthCredential._fromParams({
            providerId: GithubAuthProvider.PROVIDER_ID,
            signInMethod: GithubAuthProvider.GITHUB_SIGN_IN_METHOD,
            accessToken: i
        })
    }
    static credentialFromResult(i) {
        return GithubAuthProvider.credentialFromTaggedObject(i)
    }
    static credentialFromError(i) {
        return GithubAuthProvider.credentialFromTaggedObject(i.customData || {})
    }
    static credentialFromTaggedObject({_tokenResponse: i}) {
        if (!i || !("oauthAccessToken"in i) || !i.oauthAccessToken)
            return null;
        try {
            return GithubAuthProvider.credential(i.oauthAccessToken)
        } catch {
            return null
        }
    }
}
GithubAuthProvider.GITHUB_SIGN_IN_METHOD = "github.com";
GithubAuthProvider.PROVIDER_ID = "github.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TwitterAuthProvider extends BaseOAuthProvider {
    constructor() {
        super("twitter.com")
    }
    static credential(i, s) {
        return OAuthCredential._fromParams({
            providerId: TwitterAuthProvider.PROVIDER_ID,
            signInMethod: TwitterAuthProvider.TWITTER_SIGN_IN_METHOD,
            oauthToken: i,
            oauthTokenSecret: s
        })
    }
    static credentialFromResult(i) {
        return TwitterAuthProvider.credentialFromTaggedObject(i)
    }
    static credentialFromError(i) {
        return TwitterAuthProvider.credentialFromTaggedObject(i.customData || {})
    }
    static credentialFromTaggedObject({_tokenResponse: i}) {
        if (!i)
            return null;
        const {oauthAccessToken: s, oauthTokenSecret: a} = i;
        if (!s || !a)
            return null;
        try {
            return TwitterAuthProvider.credential(s, a)
        } catch {
            return null
        }
    }
}
TwitterAuthProvider.TWITTER_SIGN_IN_METHOD = "twitter.com";
TwitterAuthProvider.PROVIDER_ID = "twitter.com";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function signUp(o, i) {
    return _performSignInRequest(o, "POST", "/v1/accounts:signUp", _addTidIfNecessary(o, i))
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UserCredentialImpl {
    constructor(i) {
        this.user = i.user,
        this.providerId = i.providerId,
        this._tokenResponse = i._tokenResponse,
        this.operationType = i.operationType
    }
    static async _fromIdTokenResponse(i, s, a, _=!1) {
        const $ = await UserImpl._fromIdTokenResponse(i, a, _)
          , _e = providerIdForResponse(a);
        return new UserCredentialImpl({
            user: $,
            providerId: _e,
            _tokenResponse: a,
            operationType: s
        })
    }
    static async _forOperation(i, s, a) {
        await i._updateTokensIfNecessary(a, !0);
        const _ = providerIdForResponse(a);
        return new UserCredentialImpl({
            user: i,
            providerId: _,
            _tokenResponse: a,
            operationType: s
        })
    }
}
function providerIdForResponse(o) {
    return o.providerId ? o.providerId : "phoneNumber"in o ? "phone" : null
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MultiFactorError extends FirebaseError {
    constructor(i, s, a, _) {
        var $;
        super(s.code, s.message),
        this.operationType = a,
        this.user = _,
        Object.setPrototypeOf(this, MultiFactorError.prototype),
        this.customData = {
            appName: i.name,
            tenantId: ($ = i.tenantId) !== null && $ !== void 0 ? $ : void 0,
            _serverResponse: s.customData._serverResponse,
            operationType: a
        }
    }
    static _fromErrorAndOperation(i, s, a, _) {
        return new MultiFactorError(i,s,a,_)
    }
}
function _processCredentialSavingMfaContextIfNecessary(o, i, s, a) {
    return (i === "reauthenticate" ? s._getReauthenticationResolver(o) : s._getIdTokenResponse(o)).catch($ => {
        throw $.code === "auth/multi-factor-auth-required" ? MultiFactorError._fromErrorAndOperation(o, $, i, a) : $
    }
    )
}
async function _link$1(o, i, s=!1) {
    const a = await _logoutIfInvalidated(o, i._linkToIdToken(o.auth, await o.getIdToken()), s);
    return UserCredentialImpl._forOperation(o, "link", a)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function _reauthenticate(o, i, s=!1) {
    const {auth: a} = o
      , _ = "reauthenticate";
    try {
        const $ = await _logoutIfInvalidated(o, _processCredentialSavingMfaContextIfNecessary(a, _, i, o), s);
        _assert($.idToken, a, "internal-error");
        const _e = _parseToken($.idToken);
        _assert(_e, a, "internal-error");
        const {sub: tt} = _e;
        return _assert(o.uid === tt, a, "user-mismatch"),
        UserCredentialImpl._forOperation(o, _, $)
    } catch ($) {
        throw ($ == null ? void 0 : $.code) === "auth/user-not-found" && _fail(a, "user-mismatch"),
        $
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function _signInWithCredential(o, i, s=!1) {
    const a = "signIn"
      , _ = await _processCredentialSavingMfaContextIfNecessary(o, a, i)
      , $ = await UserCredentialImpl._fromIdTokenResponse(o, a, _);
    return s || await o._updateCurrentUser($.user),
    $
}
async function signInWithCredential(o, i) {
    return _signInWithCredential(_castAuth(o), i)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _setActionCodeSettingsOnRequest(o, i, s) {
    var a;
    _assert(((a = s.url) === null || a === void 0 ? void 0 : a.length) > 0, o, "invalid-continue-uri"),
    _assert(typeof s.dynamicLinkDomain > "u" || s.dynamicLinkDomain.length > 0, o, "invalid-dynamic-link-domain"),
    i.continueUrl = s.url,
    i.dynamicLinkDomain = s.dynamicLinkDomain,
    i.canHandleCodeInApp = s.handleCodeInApp,
    s.iOS && (_assert(s.iOS.bundleId.length > 0, o, "missing-ios-bundle-id"),
    i.iOSBundleId = s.iOS.bundleId),
    s.android && (_assert(s.android.packageName.length > 0, o, "missing-android-pkg-name"),
    i.androidInstallApp = s.android.installApp,
    i.androidMinimumVersionCode = s.android.minimumVersion,
    i.androidPackageName = s.android.packageName)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function sendPasswordResetEmail(o, i, s) {
    var a;
    const _ = _castAuth(o)
      , $ = {
        requestType: "PASSWORD_RESET",
        email: i,
        clientType: "CLIENT_TYPE_WEB"
    };
    if (!((a = _._getRecaptchaConfig()) === null || a === void 0) && a.emailPasswordEnabled) {
        const _e = await injectRecaptchaFields(_, $, "getOobCode", !0);
        s && _setActionCodeSettingsOnRequest(_, _e, s),
        await sendPasswordResetEmail$1(_, _e)
    } else
        s && _setActionCodeSettingsOnRequest(_, $, s),
        await sendPasswordResetEmail$1(_, $).catch(async _e => {
            if (_e.code === "auth/missing-recaptcha-token") {
                console.log("Password resets are protected by reCAPTCHA for this project. Automatically triggering the reCAPTCHA flow and restarting the password reset flow.");
                const tt = await injectRecaptchaFields(_, $, "getOobCode", !0);
                s && _setActionCodeSettingsOnRequest(_, tt, s),
                await sendPasswordResetEmail$1(_, tt)
            } else
                return Promise.reject(_e)
        }
        )
}
async function createUserWithEmailAndPassword(o, i, s) {
    var a;
    const _ = _castAuth(o)
      , $ = {
        returnSecureToken: !0,
        email: i,
        password: s,
        clientType: "CLIENT_TYPE_WEB"
    };
    let _e;
    if (!((a = _._getRecaptchaConfig()) === null || a === void 0) && a.emailPasswordEnabled) {
        const rt = await injectRecaptchaFields(_, $, "signUpPassword");
        _e = signUp(_, rt)
    } else
        _e = signUp(_, $).catch(async rt => {
            if (rt.code === "auth/missing-recaptcha-token") {
                console.log("Sign-up is protected by reCAPTCHA for this project. Automatically triggering the reCAPTCHA flow and restarting the sign-up flow.");
                const ot = await injectRecaptchaFields(_, $, "signUpPassword");
                return signUp(_, ot)
            } else
                return Promise.reject(rt)
        }
        );
    const tt = await _e.catch(rt => Promise.reject(rt))
      , nt = await UserCredentialImpl._fromIdTokenResponse(_, "signIn", tt);
    return await _._updateCurrentUser(nt.user),
    nt
}
function signInWithEmailAndPassword(o, i, s) {
    return signInWithCredential(getModularInstance(o), EmailAuthProvider.credential(i, s))
}
function onIdTokenChanged(o, i, s, a) {
    return getModularInstance(o).onIdTokenChanged(i, s, a)
}
function beforeAuthStateChanged(o, i, s) {
    return getModularInstance(o).beforeAuthStateChanged(i, s)
}
const STORAGE_AVAILABLE_KEY = "__sak";
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BrowserPersistenceClass {
    constructor(i, s) {
        this.storageRetriever = i,
        this.type = s
    }
    _isAvailable() {
        try {
            return this.storage ? (this.storage.setItem(STORAGE_AVAILABLE_KEY, "1"),
            this.storage.removeItem(STORAGE_AVAILABLE_KEY),
            Promise.resolve(!0)) : Promise.resolve(!1)
        } catch {
            return Promise.resolve(!1)
        }
    }
    _set(i, s) {
        return this.storage.setItem(i, JSON.stringify(s)),
        Promise.resolve()
    }
    _get(i) {
        const s = this.storage.getItem(i);
        return Promise.resolve(s ? JSON.parse(s) : null)
    }
    _remove(i) {
        return this.storage.removeItem(i),
        Promise.resolve()
    }
    get storage() {
        return this.storageRetriever()
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _iframeCannotSyncWebStorage() {
    const o = getUA();
    return _isSafari(o) || _isIOS(o)
}
const _POLLING_INTERVAL_MS$1 = 1e3
  , IE10_LOCAL_STORAGE_SYNC_DELAY = 10;
class BrowserLocalPersistence extends BrowserPersistenceClass {
    constructor() {
        super( () => window.localStorage, "LOCAL"),
        this.boundEventHandler = (i, s) => this.onStorageEvent(i, s),
        this.listeners = {},
        this.localCache = {},
        this.pollTimer = null,
        this.safariLocalStorageNotSynced = _iframeCannotSyncWebStorage() && _isIframe(),
        this.fallbackToPolling = _isMobileBrowser(),
        this._shouldAllowMigration = !0
    }
    forAllChangedKeys(i) {
        for (const s of Object.keys(this.listeners)) {
            const a = this.storage.getItem(s)
              , _ = this.localCache[s];
            a !== _ && i(s, _, a)
        }
    }
    onStorageEvent(i, s=!1) {
        if (!i.key) {
            this.forAllChangedKeys( (_e, tt, nt) => {
                this.notifyListeners(_e, nt)
            }
            );
            return
        }
        const a = i.key;
        if (s ? this.detachListener() : this.stopPolling(),
        this.safariLocalStorageNotSynced) {
            const _e = this.storage.getItem(a);
            if (i.newValue !== _e)
                i.newValue !== null ? this.storage.setItem(a, i.newValue) : this.storage.removeItem(a);
            else if (this.localCache[a] === i.newValue && !s)
                return
        }
        const _ = () => {
            const _e = this.storage.getItem(a);
            !s && this.localCache[a] === _e || this.notifyListeners(a, _e)
        }
          , $ = this.storage.getItem(a);
        _isIE10() && $ !== i.newValue && i.newValue !== i.oldValue ? setTimeout(_, IE10_LOCAL_STORAGE_SYNC_DELAY) : _()
    }
    notifyListeners(i, s) {
        this.localCache[i] = s;
        const a = this.listeners[i];
        if (a)
            for (const _ of Array.from(a))
                _(s && JSON.parse(s))
    }
    startPolling() {
        this.stopPolling(),
        this.pollTimer = setInterval( () => {
            this.forAllChangedKeys( (i, s, a) => {
                this.onStorageEvent(new StorageEvent("storage",{
                    key: i,
                    oldValue: s,
                    newValue: a
                }), !0)
            }
            )
        }
        , _POLLING_INTERVAL_MS$1)
    }
    stopPolling() {
        this.pollTimer && (clearInterval(this.pollTimer),
        this.pollTimer = null)
    }
    attachListener() {
        window.addEventListener("storage", this.boundEventHandler)
    }
    detachListener() {
        window.removeEventListener("storage", this.boundEventHandler)
    }
    _addListener(i, s) {
        Object.keys(this.listeners).length === 0 && (this.fallbackToPolling ? this.startPolling() : this.attachListener()),
        this.listeners[i] || (this.listeners[i] = new Set,
        this.localCache[i] = this.storage.getItem(i)),
        this.listeners[i].add(s)
    }
    _removeListener(i, s) {
        this.listeners[i] && (this.listeners[i].delete(s),
        this.listeners[i].size === 0 && delete this.listeners[i]),
        Object.keys(this.listeners).length === 0 && (this.detachListener(),
        this.stopPolling())
    }
    async _set(i, s) {
        await super._set(i, s),
        this.localCache[i] = JSON.stringify(s)
    }
    async _get(i) {
        const s = await super._get(i);
        return this.localCache[i] = JSON.stringify(s),
        s
    }
    async _remove(i) {
        await super._remove(i),
        delete this.localCache[i]
    }
}
BrowserLocalPersistence.type = "LOCAL";
const browserLocalPersistence = BrowserLocalPersistence;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BrowserSessionPersistence extends BrowserPersistenceClass {
    constructor() {
        super( () => window.sessionStorage, "SESSION")
    }
    _addListener(i, s) {}
    _removeListener(i, s) {}
}
BrowserSessionPersistence.type = "SESSION";
const browserSessionPersistence = BrowserSessionPersistence;
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _allSettled(o) {
    return Promise.all(o.map(async i => {
        try {
            return {
                fulfilled: !0,
                value: await i
            }
        } catch (s) {
            return {
                fulfilled: !1,
                reason: s
            }
        }
    }
    ))
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Receiver {
    constructor(i) {
        this.eventTarget = i,
        this.handlersMap = {},
        this.boundEventHandler = this.handleEvent.bind(this)
    }
    static _getInstance(i) {
        const s = this.receivers.find(_ => _.isListeningto(i));
        if (s)
            return s;
        const a = new Receiver(i);
        return this.receivers.push(a),
        a
    }
    isListeningto(i) {
        return this.eventTarget === i
    }
    async handleEvent(i) {
        const s = i
          , {eventId: a, eventType: _, data: $} = s.data
          , _e = this.handlersMap[_];
        if (!(_e != null && _e.size))
            return;
        s.ports[0].postMessage({
            status: "ack",
            eventId: a,
            eventType: _
        });
        const tt = Array.from(_e).map(async rt => rt(s.origin, $))
          , nt = await _allSettled(tt);
        s.ports[0].postMessage({
            status: "done",
            eventId: a,
            eventType: _,
            response: nt
        })
    }
    _subscribe(i, s) {
        Object.keys(this.handlersMap).length === 0 && this.eventTarget.addEventListener("message", this.boundEventHandler),
        this.handlersMap[i] || (this.handlersMap[i] = new Set),
        this.handlersMap[i].add(s)
    }
    _unsubscribe(i, s) {
        this.handlersMap[i] && s && this.handlersMap[i].delete(s),
        (!s || this.handlersMap[i].size === 0) && delete this.handlersMap[i],
        Object.keys(this.handlersMap).length === 0 && this.eventTarget.removeEventListener("message", this.boundEventHandler)
    }
}
Receiver.receivers = [];
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _generateEventId(o="", i=10) {
    let s = "";
    for (let a = 0; a < i; a++)
        s += Math.floor(Math.random() * 10);
    return o + s
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Sender {
    constructor(i) {
        this.target = i,
        this.handlers = new Set
    }
    removeMessageHandler(i) {
        i.messageChannel && (i.messageChannel.port1.removeEventListener("message", i.onMessage),
        i.messageChannel.port1.close()),
        this.handlers.delete(i)
    }
    async _send(i, s, a=50) {
        const _ = typeof MessageChannel < "u" ? new MessageChannel : null;
        if (!_)
            throw new Error("connection_unavailable");
        let $, _e;
        return new Promise( (tt, nt) => {
            const rt = _generateEventId("", 20);
            _.port1.start();
            const ot = setTimeout( () => {
                nt(new Error("unsupported_event"))
            }
            , a);
            _e = {
                messageChannel: _,
                onMessage(et) {
                    const j = et;
                    if (j.data.eventId === rt)
                        switch (j.data.status) {
                        case "ack":
                            clearTimeout(ot),
                            $ = setTimeout( () => {
                                nt(new Error("timeout"))
                            }
                            , 3e3);
                            break;
                        case "done":
                            clearTimeout($),
                            tt(j.data.response);
                            break;
                        default:
                            clearTimeout(ot),
                            clearTimeout($),
                            nt(new Error("invalid_response"));
                            break
                        }
                }
            },
            this.handlers.add(_e),
            _.port1.addEventListener("message", _e.onMessage),
            this.target.postMessage({
                eventType: i,
                eventId: rt,
                data: s
            }, [_.port2])
        }
        ).finally( () => {
            _e && this.removeMessageHandler(_e)
        }
        )
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _window() {
    return window
}
function _setWindowLocation(o) {
    _window().location.href = o
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _isWorker() {
    return typeof _window().WorkerGlobalScope < "u" && typeof _window().importScripts == "function"
}
async function _getActiveServiceWorker() {
    if (!(navigator != null && navigator.serviceWorker))
        return null;
    try {
        return (await navigator.serviceWorker.ready).active
    } catch {
        return null
    }
}
function _getServiceWorkerController() {
    var o;
    return ((o = navigator == null ? void 0 : navigator.serviceWorker) === null || o === void 0 ? void 0 : o.controller) || null
}
function _getWorkerGlobalScope() {
    return _isWorker() ? self : null
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DB_NAME = "firebaseLocalStorageDb"
  , DB_VERSION = 1
  , DB_OBJECTSTORE_NAME = "firebaseLocalStorage"
  , DB_DATA_KEYPATH = "fbase_key";
class DBPromise {
    constructor(i) {
        this.request = i
    }
    toPromise() {
        return new Promise( (i, s) => {
            this.request.addEventListener("success", () => {
                i(this.request.result)
            }
            ),
            this.request.addEventListener("error", () => {
                s(this.request.error)
            }
            )
        }
        )
    }
}
function getObjectStore(o, i) {
    return o.transaction([DB_OBJECTSTORE_NAME], i ? "readwrite" : "readonly").objectStore(DB_OBJECTSTORE_NAME)
}
function _deleteDatabase() {
    const o = indexedDB.deleteDatabase(DB_NAME);
    return new DBPromise(o).toPromise()
}
function _openDatabase() {
    const o = indexedDB.open(DB_NAME, DB_VERSION);
    return new Promise( (i, s) => {
        o.addEventListener("error", () => {
            s(o.error)
        }
        ),
        o.addEventListener("upgradeneeded", () => {
            const a = o.result;
            try {
                a.createObjectStore(DB_OBJECTSTORE_NAME, {
                    keyPath: DB_DATA_KEYPATH
                })
            } catch (_) {
                s(_)
            }
        }
        ),
        o.addEventListener("success", async () => {
            const a = o.result;
            a.objectStoreNames.contains(DB_OBJECTSTORE_NAME) ? i(a) : (a.close(),
            await _deleteDatabase(),
            i(await _openDatabase()))
        }
        )
    }
    )
}
async function _putObject(o, i, s) {
    const a = getObjectStore(o, !0).put({
        [DB_DATA_KEYPATH]: i,
        value: s
    });
    return new DBPromise(a).toPromise()
}
async function getObject$1(o, i) {
    const s = getObjectStore(o, !1).get(i)
      , a = await new DBPromise(s).toPromise();
    return a === void 0 ? null : a.value
}
function _deleteObject(o, i) {
    const s = getObjectStore(o, !0).delete(i);
    return new DBPromise(s).toPromise()
}
const _POLLING_INTERVAL_MS = 800
  , _TRANSACTION_RETRY_COUNT = 3;
class IndexedDBLocalPersistence {
    constructor() {
        this.type = "LOCAL",
        this._shouldAllowMigration = !0,
        this.listeners = {},
        this.localCache = {},
        this.pollTimer = null,
        this.pendingWrites = 0,
        this.receiver = null,
        this.sender = null,
        this.serviceWorkerReceiverAvailable = !1,
        this.activeServiceWorker = null,
        this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then( () => {}
        , () => {}
        )
    }
    async _openDb() {
        return this.db ? this.db : (this.db = await _openDatabase(),
        this.db)
    }
    async _withRetries(i) {
        let s = 0;
        for (; ; )
            try {
                const a = await this._openDb();
                return await i(a)
            } catch (a) {
                if (s++ > _TRANSACTION_RETRY_COUNT)
                    throw a;
                this.db && (this.db.close(),
                this.db = void 0)
            }
    }
    async initializeServiceWorkerMessaging() {
        return _isWorker() ? this.initializeReceiver() : this.initializeSender()
    }
    async initializeReceiver() {
        this.receiver = Receiver._getInstance(_getWorkerGlobalScope()),
        this.receiver._subscribe("keyChanged", async (i, s) => ({
            keyProcessed: (await this._poll()).includes(s.key)
        })),
        this.receiver._subscribe("ping", async (i, s) => ["keyChanged"])
    }
    async initializeSender() {
        var i, s;
        if (this.activeServiceWorker = await _getActiveServiceWorker(),
        !this.activeServiceWorker)
            return;
        this.sender = new Sender(this.activeServiceWorker);
        const a = await this.sender._send("ping", {}, 800);
        a && !((i = a[0]) === null || i === void 0) && i.fulfilled && !((s = a[0]) === null || s === void 0) && s.value.includes("keyChanged") && (this.serviceWorkerReceiverAvailable = !0)
    }
    async notifyServiceWorker(i) {
        if (!(!this.sender || !this.activeServiceWorker || _getServiceWorkerController() !== this.activeServiceWorker))
            try {
                await this.sender._send("keyChanged", {
                    key: i
                }, this.serviceWorkerReceiverAvailable ? 800 : 50)
            } catch {}
    }
    async _isAvailable() {
        try {
            if (!indexedDB)
                return !1;
            const i = await _openDatabase();
            return await _putObject(i, STORAGE_AVAILABLE_KEY, "1"),
            await _deleteObject(i, STORAGE_AVAILABLE_KEY),
            !0
        } catch {}
        return !1
    }
    async _withPendingWrite(i) {
        this.pendingWrites++;
        try {
            await i()
        } finally {
            this.pendingWrites--
        }
    }
    async _set(i, s) {
        return this._withPendingWrite(async () => (await this._withRetries(a => _putObject(a, i, s)),
        this.localCache[i] = s,
        this.notifyServiceWorker(i)))
    }
    async _get(i) {
        const s = await this._withRetries(a => getObject$1(a, i));
        return this.localCache[i] = s,
        s
    }
    async _remove(i) {
        return this._withPendingWrite(async () => (await this._withRetries(s => _deleteObject(s, i)),
        delete this.localCache[i],
        this.notifyServiceWorker(i)))
    }
    async _poll() {
        const i = await this._withRetries(_ => {
            const $ = getObjectStore(_, !1).getAll();
            return new DBPromise($).toPromise()
        }
        );
        if (!i)
            return [];
        if (this.pendingWrites !== 0)
            return [];
        const s = []
          , a = new Set;
        for (const {fbase_key: _, value: $} of i)
            a.add(_),
            JSON.stringify(this.localCache[_]) !== JSON.stringify($) && (this.notifyListeners(_, $),
            s.push(_));
        for (const _ of Object.keys(this.localCache))
            this.localCache[_] && !a.has(_) && (this.notifyListeners(_, null),
            s.push(_));
        return s
    }
    notifyListeners(i, s) {
        this.localCache[i] = s;
        const a = this.listeners[i];
        if (a)
            for (const _ of Array.from(a))
                _(s)
    }
    startPolling() {
        this.stopPolling(),
        this.pollTimer = setInterval(async () => this._poll(), _POLLING_INTERVAL_MS)
    }
    stopPolling() {
        this.pollTimer && (clearInterval(this.pollTimer),
        this.pollTimer = null)
    }
    _addListener(i, s) {
        Object.keys(this.listeners).length === 0 && this.startPolling(),
        this.listeners[i] || (this.listeners[i] = new Set,
        this._get(i)),
        this.listeners[i].add(s)
    }
    _removeListener(i, s) {
        this.listeners[i] && (this.listeners[i].delete(s),
        this.listeners[i].size === 0 && delete this.listeners[i]),
        Object.keys(this.listeners).length === 0 && this.stopPolling()
    }
}
IndexedDBLocalPersistence.type = "LOCAL";
const indexedDBLocalPersistence = IndexedDBLocalPersistence;
new Delay(3e4,6e4);
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function _withDefaultResolver(o, i) {
    return i ? _getInstance(i) : (_assert(o._popupRedirectResolver, o, "argument-error"),
    o._popupRedirectResolver)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class IdpCredential extends AuthCredential {
    constructor(i) {
        super("custom", "custom"),
        this.params = i
    }
    _getIdTokenResponse(i) {
        return signInWithIdp(i, this._buildIdpRequest())
    }
    _linkToIdToken(i, s) {
        return signInWithIdp(i, this._buildIdpRequest(s))
    }
    _getReauthenticationResolver(i) {
        return signInWithIdp(i, this._buildIdpRequest())
    }
    _buildIdpRequest(i) {
        const s = {
            requestUri: this.params.requestUri,
            sessionId: this.params.sessionId,
            postBody: this.params.postBody,
            tenantId: this.params.tenantId,
            pendingToken: this.params.pendingToken,
            returnSecureToken: !0,
            returnIdpCredential: !0
        };
        return i && (s.idToken = i),
        s
    }
}
function _signIn(o) {
    return _signInWithCredential(o.auth, new IdpCredential(o), o.bypassAuthState)
}
function _reauth(o) {
    const {auth: i, user: s} = o;
    return _assert(s, i, "internal-error"),
    _reauthenticate(s, new IdpCredential(o), o.bypassAuthState)
}
async function _link(o) {
    const {auth: i, user: s} = o;
    return _assert(s, i, "internal-error"),
    _link$1(s, new IdpCredential(o), o.bypassAuthState)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AbstractPopupRedirectOperation {
    constructor(i, s, a, _, $=!1) {
        this.auth = i,
        this.resolver = a,
        this.user = _,
        this.bypassAuthState = $,
        this.pendingPromise = null,
        this.eventManager = null,
        this.filter = Array.isArray(s) ? s : [s]
    }
    execute() {
        return new Promise(async (i, s) => {
            this.pendingPromise = {
                resolve: i,
                reject: s
            };
            try {
                this.eventManager = await this.resolver._initialize(this.auth),
                await this.onExecution(),
                this.eventManager.registerConsumer(this)
            } catch (a) {
                this.reject(a)
            }
        }
        )
    }
    async onAuthEvent(i) {
        const {urlResponse: s, sessionId: a, postBody: _, tenantId: $, error: _e, type: tt} = i;
        if (_e) {
            this.reject(_e);
            return
        }
        const nt = {
            auth: this.auth,
            requestUri: s,
            sessionId: a,
            tenantId: $ || void 0,
            postBody: _ || void 0,
            user: this.user,
            bypassAuthState: this.bypassAuthState
        };
        try {
            this.resolve(await this.getIdpTask(tt)(nt))
        } catch (rt) {
            this.reject(rt)
        }
    }
    onError(i) {
        this.reject(i)
    }
    getIdpTask(i) {
        switch (i) {
        case "signInViaPopup":
        case "signInViaRedirect":
            return _signIn;
        case "linkViaPopup":
        case "linkViaRedirect":
            return _link;
        case "reauthViaPopup":
        case "reauthViaRedirect":
            return _reauth;
        default:
            _fail(this.auth, "internal-error")
        }
    }
    resolve(i) {
        debugAssert(this.pendingPromise, "Pending promise was never set"),
        this.pendingPromise.resolve(i),
        this.unregisterAndCleanUp()
    }
    reject(i) {
        debugAssert(this.pendingPromise, "Pending promise was never set"),
        this.pendingPromise.reject(i),
        this.unregisterAndCleanUp()
    }
    unregisterAndCleanUp() {
        this.eventManager && this.eventManager.unregisterConsumer(this),
        this.pendingPromise = null,
        this.cleanUp()
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const _POLL_WINDOW_CLOSE_TIMEOUT = new Delay(2e3,1e4);
class PopupOperation extends AbstractPopupRedirectOperation {
    constructor(i, s, a, _, $) {
        super(i, s, _, $),
        this.provider = a,
        this.authWindow = null,
        this.pollId = null,
        PopupOperation.currentPopupAction && PopupOperation.currentPopupAction.cancel(),
        PopupOperation.currentPopupAction = this
    }
    async executeNotNull() {
        const i = await this.execute();
        return _assert(i, this.auth, "internal-error"),
        i
    }
    async onExecution() {
        debugAssert(this.filter.length === 1, "Popup operations only handle one event");
        const i = _generateEventId();
        this.authWindow = await this.resolver._openPopup(this.auth, this.provider, this.filter[0], i),
        this.authWindow.associatedEvent = i,
        this.resolver._originValidation(this.auth).catch(s => {
            this.reject(s)
        }
        ),
        this.resolver._isIframeWebStorageSupported(this.auth, s => {
            s || this.reject(_createError(this.auth, "web-storage-unsupported"))
        }
        ),
        this.pollUserCancellation()
    }
    get eventId() {
        var i;
        return ((i = this.authWindow) === null || i === void 0 ? void 0 : i.associatedEvent) || null
    }
    cancel() {
        this.reject(_createError(this.auth, "cancelled-popup-request"))
    }
    cleanUp() {
        this.authWindow && this.authWindow.close(),
        this.pollId && window.clearTimeout(this.pollId),
        this.authWindow = null,
        this.pollId = null,
        PopupOperation.currentPopupAction = null
    }
    pollUserCancellation() {
        const i = () => {
            var s, a;
            if (!((a = (s = this.authWindow) === null || s === void 0 ? void 0 : s.window) === null || a === void 0) && a.closed) {
                this.pollId = window.setTimeout( () => {
                    this.pollId = null,
                    this.reject(_createError(this.auth, "popup-closed-by-user"))
                }
                , 8e3);
                return
            }
            this.pollId = window.setTimeout(i, _POLL_WINDOW_CLOSE_TIMEOUT.get())
        }
        ;
        i()
    }
}
PopupOperation.currentPopupAction = null;
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PENDING_REDIRECT_KEY = "pendingRedirect"
  , redirectOutcomeMap = new Map;
class RedirectAction extends AbstractPopupRedirectOperation {
    constructor(i, s, a=!1) {
        super(i, ["signInViaRedirect", "linkViaRedirect", "reauthViaRedirect", "unknown"], s, void 0, a),
        this.eventId = null
    }
    async execute() {
        let i = redirectOutcomeMap.get(this.auth._key());
        if (!i) {
            try {
                const a = await _getAndClearPendingRedirectStatus(this.resolver, this.auth) ? await super.execute() : null;
                i = () => Promise.resolve(a)
            } catch (s) {
                i = () => Promise.reject(s)
            }
            redirectOutcomeMap.set(this.auth._key(), i)
        }
        return this.bypassAuthState || redirectOutcomeMap.set(this.auth._key(), () => Promise.resolve(null)),
        i()
    }
    async onAuthEvent(i) {
        if (i.type === "signInViaRedirect")
            return super.onAuthEvent(i);
        if (i.type === "unknown") {
            this.resolve(null);
            return
        }
        if (i.eventId) {
            const s = await this.auth._redirectUserForId(i.eventId);
            if (s)
                return this.user = s,
                super.onAuthEvent(i);
            this.resolve(null)
        }
    }
    async onExecution() {}
    cleanUp() {}
}
async function _getAndClearPendingRedirectStatus(o, i) {
    const s = pendingRedirectKey(i)
      , a = resolverPersistence(o);
    if (!await a._isAvailable())
        return !1;
    const _ = await a._get(s) === "true";
    return await a._remove(s),
    _
}
function _overrideRedirectResult(o, i) {
    redirectOutcomeMap.set(o._key(), i)
}
function resolverPersistence(o) {
    return _getInstance(o._redirectPersistence)
}
function pendingRedirectKey(o) {
    return _persistenceKeyName(PENDING_REDIRECT_KEY, o.config.apiKey, o.name)
}
async function _getRedirectResult(o, i, s=!1) {
    const a = _castAuth(o)
      , _ = _withDefaultResolver(a, i)
      , _e = await new RedirectAction(a,_,s).execute();
    return _e && !s && (delete _e.user._redirectEventId,
    await a._persistUserIfCurrent(_e.user),
    await a._setRedirectUser(null, i)),
    _e
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const EVENT_DUPLICATION_CACHE_DURATION_MS = 10 * 60 * 1e3;
class AuthEventManager {
    constructor(i) {
        this.auth = i,
        this.cachedEventUids = new Set,
        this.consumers = new Set,
        this.queuedRedirectEvent = null,
        this.hasHandledPotentialRedirect = !1,
        this.lastProcessedEventTime = Date.now()
    }
    registerConsumer(i) {
        this.consumers.add(i),
        this.queuedRedirectEvent && this.isEventForConsumer(this.queuedRedirectEvent, i) && (this.sendToConsumer(this.queuedRedirectEvent, i),
        this.saveEventToCache(this.queuedRedirectEvent),
        this.queuedRedirectEvent = null)
    }
    unregisterConsumer(i) {
        this.consumers.delete(i)
    }
    onEvent(i) {
        if (this.hasEventBeenHandled(i))
            return !1;
        let s = !1;
        return this.consumers.forEach(a => {
            this.isEventForConsumer(i, a) && (s = !0,
            this.sendToConsumer(i, a),
            this.saveEventToCache(i))
        }
        ),
        this.hasHandledPotentialRedirect || !isRedirectEvent(i) || (this.hasHandledPotentialRedirect = !0,
        s || (this.queuedRedirectEvent = i,
        s = !0)),
        s
    }
    sendToConsumer(i, s) {
        var a;
        if (i.error && !isNullRedirectEvent(i)) {
            const _ = ((a = i.error.code) === null || a === void 0 ? void 0 : a.split("auth/")[1]) || "internal-error";
            s.onError(_createError(this.auth, _))
        } else
            s.onAuthEvent(i)
    }
    isEventForConsumer(i, s) {
        const a = s.eventId === null || !!i.eventId && i.eventId === s.eventId;
        return s.filter.includes(i.type) && a
    }
    hasEventBeenHandled(i) {
        return Date.now() - this.lastProcessedEventTime >= EVENT_DUPLICATION_CACHE_DURATION_MS && this.cachedEventUids.clear(),
        this.cachedEventUids.has(eventUid(i))
    }
    saveEventToCache(i) {
        this.cachedEventUids.add(eventUid(i)),
        this.lastProcessedEventTime = Date.now()
    }
}
function eventUid(o) {
    return [o.type, o.eventId, o.sessionId, o.tenantId].filter(i => i).join("-")
}
function isNullRedirectEvent({type: o, error: i}) {
    return o === "unknown" && (i == null ? void 0 : i.code) === "auth/no-auth-event"
}
function isRedirectEvent(o) {
    switch (o.type) {
    case "signInViaRedirect":
    case "linkViaRedirect":
    case "reauthViaRedirect":
        return !0;
    case "unknown":
        return isNullRedirectEvent(o);
    default:
        return !1
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
async function _getProjectConfig(o, i={}) {
    return _performApiRequest(o, "GET", "/v1/projects", i)
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const IP_ADDRESS_REGEX = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/
  , HTTP_REGEX = /^https?/;
async function _validateOrigin(o) {
    if (o.config.emulator)
        return;
    const {authorizedDomains: i} = await _getProjectConfig(o);
    for (const s of i)
        try {
            if (matchDomain(s))
                return
        } catch {}
    _fail(o, "unauthorized-domain")
}
function matchDomain(o) {
    const i = _getCurrentUrl()
      , {protocol: s, hostname: a} = new URL(i);
    if (o.startsWith("chrome-extension://")) {
        const _e = new URL(o);
        return _e.hostname === "" && a === "" ? s === "chrome-extension:" && o.replace("chrome-extension://", "") === i.replace("chrome-extension://", "") : s === "chrome-extension:" && _e.hostname === a
    }
    if (!HTTP_REGEX.test(s))
        return !1;
    if (IP_ADDRESS_REGEX.test(o))
        return a === o;
    const _ = o.replace(/\./g, "\\.");
    return new RegExp("^(.+\\." + _ + "|" + _ + ")$","i").test(a)
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const NETWORK_TIMEOUT = new Delay(3e4,6e4);
function resetUnloadedGapiModules() {
    const o = _window().___jsl;
    if (o != null && o.H) {
        for (const i of Object.keys(o.H))
            if (o.H[i].r = o.H[i].r || [],
            o.H[i].L = o.H[i].L || [],
            o.H[i].r = [...o.H[i].L],
            o.CP)
                for (let s = 0; s < o.CP.length; s++)
                    o.CP[s] = null
    }
}
function loadGapi(o) {
    return new Promise( (i, s) => {
        var a, _, $;
        function _e() {
            resetUnloadedGapiModules(),
            gapi.load("gapi.iframes", {
                callback: () => {
                    i(gapi.iframes.getContext())
                }
                ,
                ontimeout: () => {
                    resetUnloadedGapiModules(),
                    s(_createError(o, "network-request-failed"))
                }
                ,
                timeout: NETWORK_TIMEOUT.get()
            })
        }
        if (!((_ = (a = _window().gapi) === null || a === void 0 ? void 0 : a.iframes) === null || _ === void 0) && _.Iframe)
            i(gapi.iframes.getContext());
        else if (!(($ = _window().gapi) === null || $ === void 0) && $.load)
            _e();
        else {
            const tt = _generateCallbackName("iframefcb");
            return _window()[tt] = () => {
                gapi.load ? _e() : s(_createError(o, "network-request-failed"))
            }
            ,
            _loadJS(`https://apis.google.com/js/api.js?onload=${tt}`).catch(nt => s(nt))
        }
    }
    ).catch(i => {
        throw cachedGApiLoader = null,
        i
    }
    )
}
let cachedGApiLoader = null;
function _loadGapi(o) {
    return cachedGApiLoader = cachedGApiLoader || loadGapi(o),
    cachedGApiLoader
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PING_TIMEOUT = new Delay(5e3,15e3)
  , IFRAME_PATH = "__/auth/iframe"
  , EMULATED_IFRAME_PATH = "emulator/auth/iframe"
  , IFRAME_ATTRIBUTES = {
    style: {
        position: "absolute",
        top: "-100px",
        width: "1px",
        height: "1px"
    },
    "aria-hidden": "true",
    tabindex: "-1"
}
  , EID_FROM_APIHOST = new Map([["identitytoolkit.googleapis.com", "p"], ["staging-identitytoolkit.sandbox.googleapis.com", "s"], ["test-identitytoolkit.sandbox.googleapis.com", "t"]]);
function getIframeUrl(o) {
    const i = o.config;
    _assert(i.authDomain, o, "auth-domain-config-required");
    const s = i.emulator ? _emulatorUrl(i, EMULATED_IFRAME_PATH) : `https://${o.config.authDomain}/${IFRAME_PATH}`
      , a = {
        apiKey: i.apiKey,
        appName: o.name,
        v: SDK_VERSION
    }
      , _ = EID_FROM_APIHOST.get(o.config.apiHost);
    _ && (a.eid = _);
    const $ = o._getFrameworks();
    return $.length && (a.fw = $.join(",")),
    `${s}?${querystring(a).slice(1)}`
}
async function _openIframe(o) {
    const i = await _loadGapi(o)
      , s = _window().gapi;
    return _assert(s, o, "internal-error"),
    i.open({
        where: document.body,
        url: getIframeUrl(o),
        messageHandlersFilter: s.iframes.CROSS_ORIGIN_IFRAMES_FILTER,
        attributes: IFRAME_ATTRIBUTES,
        dontclear: !0
    }, a => new Promise(async (_, $) => {
        await a.restyle({
            setHideOnLeave: !1
        });
        const _e = _createError(o, "network-request-failed")
          , tt = _window().setTimeout( () => {
            $(_e)
        }
        , PING_TIMEOUT.get());
        function nt() {
            _window().clearTimeout(tt),
            _(a)
        }
        a.ping(nt).then(nt, () => {
            $(_e)
        }
        )
    }
    ))
}
/**
 * @license
 * Copyright 2020 Google LLC.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const BASE_POPUP_OPTIONS = {
    location: "yes",
    resizable: "yes",
    statusbar: "yes",
    toolbar: "no"
}
  , DEFAULT_WIDTH = 500
  , DEFAULT_HEIGHT = 600
  , TARGET_BLANK = "_blank"
  , FIREFOX_EMPTY_URL = "http://localhost";
class AuthPopup {
    constructor(i) {
        this.window = i,
        this.associatedEvent = null
    }
    close() {
        if (this.window)
            try {
                this.window.close()
            } catch {}
    }
}
function _open(o, i, s, a=DEFAULT_WIDTH, _=DEFAULT_HEIGHT) {
    const $ = Math.max((window.screen.availHeight - _) / 2, 0).toString()
      , _e = Math.max((window.screen.availWidth - a) / 2, 0).toString();
    let tt = "";
    const nt = Object.assign(Object.assign({}, BASE_POPUP_OPTIONS), {
        width: a.toString(),
        height: _.toString(),
        top: $,
        left: _e
    })
      , rt = getUA().toLowerCase();
    s && (tt = _isChromeIOS(rt) ? TARGET_BLANK : s),
    _isFirefox(rt) && (i = i || FIREFOX_EMPTY_URL,
    nt.scrollbars = "yes");
    const ot = Object.entries(nt).reduce( (j, [it,st]) => `${j}${it}=${st},`, "");
    if (_isIOSStandalone(rt) && tt !== "_self")
        return openAsNewWindowIOS(i || "", tt),
        new AuthPopup(null);
    const et = window.open(i || "", tt, ot);
    _assert(et, o, "popup-blocked");
    try {
        et.focus()
    } catch {}
    return new AuthPopup(et)
}
function openAsNewWindowIOS(o, i) {
    const s = document.createElement("a");
    s.href = o,
    s.target = i;
    const a = document.createEvent("MouseEvent");
    a.initMouseEvent("click", !0, !0, window, 1, 0, 0, 0, 0, !1, !1, !1, !1, 1, null),
    s.dispatchEvent(a)
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const WIDGET_PATH = "__/auth/handler"
  , EMULATOR_WIDGET_PATH = "emulator/auth/handler"
  , FIREBASE_APP_CHECK_FRAGMENT_ID = encodeURIComponent("fac");
async function _getRedirectUrl(o, i, s, a, _, $) {
    _assert(o.config.authDomain, o, "auth-domain-config-required"),
    _assert(o.config.apiKey, o, "invalid-api-key");
    const _e = {
        apiKey: o.config.apiKey,
        appName: o.name,
        authType: s,
        redirectUrl: a,
        v: SDK_VERSION,
        eventId: _
    };
    if (i instanceof FederatedAuthProvider) {
        i.setDefaultLanguage(o.languageCode),
        _e.providerId = i.providerId || "",
        isEmpty$2(i.getCustomParameters()) || (_e.customParameters = JSON.stringify(i.getCustomParameters()));
        for (const [ot,et] of Object.entries($ || {}))
            _e[ot] = et
    }
    if (i instanceof BaseOAuthProvider) {
        const ot = i.getScopes().filter(et => et !== "");
        ot.length > 0 && (_e.scopes = ot.join(","))
    }
    o.tenantId && (_e.tid = o.tenantId);
    const tt = _e;
    for (const ot of Object.keys(tt))
        tt[ot] === void 0 && delete tt[ot];
    const nt = await o._getAppCheckToken()
      , rt = nt ? `#${FIREBASE_APP_CHECK_FRAGMENT_ID}=${encodeURIComponent(nt)}` : "";
    return `${getHandlerBase(o)}?${querystring(tt).slice(1)}${rt}`
}
function getHandlerBase({config: o}) {
    return o.emulator ? _emulatorUrl(o, EMULATOR_WIDGET_PATH) : `https://${o.authDomain}/${WIDGET_PATH}`
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const WEB_STORAGE_SUPPORT_KEY = "webStorageSupport";
class BrowserPopupRedirectResolver {
    constructor() {
        this.eventManagers = {},
        this.iframes = {},
        this.originValidationPromises = {},
        this._redirectPersistence = browserSessionPersistence,
        this._completeRedirectFn = _getRedirectResult,
        this._overrideRedirectResult = _overrideRedirectResult
    }
    async _openPopup(i, s, a, _) {
        var $;
        debugAssert(($ = this.eventManagers[i._key()]) === null || $ === void 0 ? void 0 : $.manager, "_initialize() not called before _openPopup()");
        const _e = await _getRedirectUrl(i, s, a, _getCurrentUrl(), _);
        return _open(i, _e, _generateEventId())
    }
    async _openRedirect(i, s, a, _) {
        await this._originValidation(i);
        const $ = await _getRedirectUrl(i, s, a, _getCurrentUrl(), _);
        return _setWindowLocation($),
        new Promise( () => {}
        )
    }
    _initialize(i) {
        const s = i._key();
        if (this.eventManagers[s]) {
            const {manager: _, promise: $} = this.eventManagers[s];
            return _ ? Promise.resolve(_) : (debugAssert($, "If manager is not set, promise should be"),
            $)
        }
        const a = this.initAndGetManager(i);
        return this.eventManagers[s] = {
            promise: a
        },
        a.catch( () => {
            delete this.eventManagers[s]
        }
        ),
        a
    }
    async initAndGetManager(i) {
        const s = await _openIframe(i)
          , a = new AuthEventManager(i);
        return s.register("authEvent", _ => (_assert(_ == null ? void 0 : _.authEvent, i, "invalid-auth-event"),
        {
            status: a.onEvent(_.authEvent) ? "ACK" : "ERROR"
        }), gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER),
        this.eventManagers[i._key()] = {
            manager: a
        },
        this.iframes[i._key()] = s,
        a
    }
    _isIframeWebStorageSupported(i, s) {
        this.iframes[i._key()].send(WEB_STORAGE_SUPPORT_KEY, {
            type: WEB_STORAGE_SUPPORT_KEY
        }, _ => {
            var $;
            const _e = ($ = _ == null ? void 0 : _[0]) === null || $ === void 0 ? void 0 : $[WEB_STORAGE_SUPPORT_KEY];
            _e !== void 0 && s(!!_e),
            _fail(i, "internal-error")
        }
        , gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER)
    }
    _originValidation(i) {
        const s = i._key();
        return this.originValidationPromises[s] || (this.originValidationPromises[s] = _validateOrigin(i)),
        this.originValidationPromises[s]
    }
    get _shouldInitProactively() {
        return _isMobileBrowser() || _isSafari() || _isIOS()
    }
}
const browserPopupRedirectResolver = BrowserPopupRedirectResolver;
var name$3 = "@firebase/auth"
  , version$2 = "1.1.0";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AuthInterop {
    constructor(i) {
        this.auth = i,
        this.internalListeners = new Map
    }
    getUid() {
        var i;
        return this.assertAuthConfigured(),
        ((i = this.auth.currentUser) === null || i === void 0 ? void 0 : i.uid) || null
    }
    async getToken(i) {
        return this.assertAuthConfigured(),
        await this.auth._initializationPromise,
        this.auth.currentUser ? {
            accessToken: await this.auth.currentUser.getIdToken(i)
        } : null
    }
    addAuthTokenListener(i) {
        if (this.assertAuthConfigured(),
        this.internalListeners.has(i))
            return;
        const s = this.auth.onIdTokenChanged(a => {
            i((a == null ? void 0 : a.stsTokenManager.accessToken) || null)
        }
        );
        this.internalListeners.set(i, s),
        this.updateProactiveRefresh()
    }
    removeAuthTokenListener(i) {
        this.assertAuthConfigured();
        const s = this.internalListeners.get(i);
        s && (this.internalListeners.delete(i),
        s(),
        this.updateProactiveRefresh())
    }
    assertAuthConfigured() {
        _assert(this.auth._initializationPromise, "dependent-sdk-initialized-before-auth")
    }
    updateProactiveRefresh() {
        this.internalListeners.size > 0 ? this.auth._startProactiveRefresh() : this.auth._stopProactiveRefresh()
    }
}
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getVersionForPlatform(o) {
    switch (o) {
    case "Node":
        return "node";
    case "ReactNative":
        return "rn";
    case "Worker":
        return "webworker";
    case "Cordova":
        return "cordova";
    default:
        return
    }
}
function registerAuth(o) {
    _registerComponent(new Component("auth", (i, {options: s}) => {
        const a = i.getProvider("app").getImmediate()
          , _ = i.getProvider("heartbeat")
          , $ = i.getProvider("app-check-internal")
          , {apiKey: _e, authDomain: tt} = a.options;
        _assert(_e && !_e.includes(":"), "invalid-api-key", {
            appName: a.name
        });
        const nt = {
            apiKey: _e,
            authDomain: tt,
            clientPlatform: o,
            apiHost: "identitytoolkit.googleapis.com",
            tokenApiHost: "securetoken.googleapis.com",
            apiScheme: "https",
            sdkClientVersion: _getClientVersion(o)
        }
          , rt = new AuthImpl(a,_,$,nt);
        return _initializeAuthInstance(rt, s),
        rt
    }
    ,"PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback( (i, s, a) => {
        i.getProvider("auth-internal").initialize()
    }
    )),
    _registerComponent(new Component("auth-internal",i => {
        const s = _castAuth(i.getProvider("auth").getImmediate());
        return (a => new AuthInterop(a))(s)
    }
    ,"PRIVATE").setInstantiationMode("EXPLICIT")),
    registerVersion(name$3, version$2, getVersionForPlatform(o)),
    registerVersion(name$3, version$2, "esm2017")
}
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_ID_TOKEN_MAX_AGE = 5 * 60
  , authIdTokenMaxAge = getExperimentalSetting("authIdTokenMaxAge") || DEFAULT_ID_TOKEN_MAX_AGE;
let lastPostedIdToken = null;
const mintCookieFactory = o => async i => {
    const s = i && await i.getIdTokenResult()
      , a = s && (new Date().getTime() - Date.parse(s.issuedAtTime)) / 1e3;
    if (a && a > authIdTokenMaxAge)
        return;
    const _ = s == null ? void 0 : s.token;
    lastPostedIdToken !== _ && (lastPostedIdToken = _,
    await fetch(o, {
        method: _ ? "POST" : "DELETE",
        headers: _ ? {
            Authorization: `Bearer ${_}`
        } : {}
    }))
}
;
function getAuth(o=getApp()) {
    const i = _getProvider(o, "auth");
    if (i.isInitialized())
        return i.getImmediate();
    const s = initializeAuth(o, {
        popupRedirectResolver: browserPopupRedirectResolver,
        persistence: [indexedDBLocalPersistence, browserLocalPersistence, browserSessionPersistence]
    })
      , a = getExperimentalSetting("authTokenSyncURL");
    if (a) {
        const $ = mintCookieFactory(a);
        beforeAuthStateChanged(s, $, () => $(s.currentUser)),
        onIdTokenChanged(s, _e => $(_e))
    }
    const _ = getDefaultEmulatorHost("auth");
    return _ && connectAuthEmulator(s, `http://${_}`),
    s
}
registerAuth("Browser");
var name$2 = "firebase"
  , version$1 = "10.1.0";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
registerVersion(name$2, version$1, "app");
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_HOST = "firebasestorage.googleapis.com"
  , CONFIG_STORAGE_BUCKET_KEY = "storageBucket"
  , DEFAULT_MAX_OPERATION_RETRY_TIME = 2 * 60 * 1e3
  , DEFAULT_MAX_UPLOAD_RETRY_TIME = 10 * 60 * 1e3;
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class StorageError extends FirebaseError {
    constructor(i, s, a=0) {
        super(prependCode(i), `Firebase Storage: ${s} (${prependCode(i)})`),
        this.status_ = a,
        this.customData = {
            serverResponse: null
        },
        this._baseMessage = this.message,
        Object.setPrototypeOf(this, StorageError.prototype)
    }
    get status() {
        return this.status_
    }
    set status(i) {
        this.status_ = i
    }
    _codeEquals(i) {
        return prependCode(i) === this.code
    }
    get serverResponse() {
        return this.customData.serverResponse
    }
    set serverResponse(i) {
        this.customData.serverResponse = i,
        this.customData.serverResponse ? this.message = `${this._baseMessage}
${this.customData.serverResponse}` : this.message = this._baseMessage
    }
}
var StorageErrorCode;
(function(o) {
    o.UNKNOWN = "unknown",
    o.OBJECT_NOT_FOUND = "object-not-found",
    o.BUCKET_NOT_FOUND = "bucket-not-found",
    o.PROJECT_NOT_FOUND = "project-not-found",
    o.QUOTA_EXCEEDED = "quota-exceeded",
    o.UNAUTHENTICATED = "unauthenticated",
    o.UNAUTHORIZED = "unauthorized",
    o.UNAUTHORIZED_APP = "unauthorized-app",
    o.RETRY_LIMIT_EXCEEDED = "retry-limit-exceeded",
    o.INVALID_CHECKSUM = "invalid-checksum",
    o.CANCELED = "canceled",
    o.INVALID_EVENT_NAME = "invalid-event-name",
    o.INVALID_URL = "invalid-url",
    o.INVALID_DEFAULT_BUCKET = "invalid-default-bucket",
    o.NO_DEFAULT_BUCKET = "no-default-bucket",
    o.CANNOT_SLICE_BLOB = "cannot-slice-blob",
    o.SERVER_FILE_WRONG_SIZE = "server-file-wrong-size",
    o.NO_DOWNLOAD_URL = "no-download-url",
    o.INVALID_ARGUMENT = "invalid-argument",
    o.INVALID_ARGUMENT_COUNT = "invalid-argument-count",
    o.APP_DELETED = "app-deleted",
    o.INVALID_ROOT_OPERATION = "invalid-root-operation",
    o.INVALID_FORMAT = "invalid-format",
    o.INTERNAL_ERROR = "internal-error",
    o.UNSUPPORTED_ENVIRONMENT = "unsupported-environment"
}
)(StorageErrorCode || (StorageErrorCode = {}));
function prependCode(o) {
    return "storage/" + o
}
function unknown() {
    const o = "An unknown error occurred, please check the error payload for server response.";
    return new StorageError(StorageErrorCode.UNKNOWN,o)
}
function retryLimitExceeded() {
    return new StorageError(StorageErrorCode.RETRY_LIMIT_EXCEEDED,"Max retry time for operation exceeded, please try again.")
}
function canceled() {
    return new StorageError(StorageErrorCode.CANCELED,"User canceled the upload/download.")
}
function invalidUrl(o) {
    return new StorageError(StorageErrorCode.INVALID_URL,"Invalid URL '" + o + "'.")
}
function invalidDefaultBucket(o) {
    return new StorageError(StorageErrorCode.INVALID_DEFAULT_BUCKET,"Invalid default bucket '" + o + "'.")
}
function invalidArgument(o) {
    return new StorageError(StorageErrorCode.INVALID_ARGUMENT,o)
}
function appDeleted() {
    return new StorageError(StorageErrorCode.APP_DELETED,"The Firebase app was deleted.")
}
function invalidRootOperation(o) {
    return new StorageError(StorageErrorCode.INVALID_ROOT_OPERATION,"The operation '" + o + "' cannot be performed on a root reference, create a non-root reference using child, such as .child('file.png').")
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Location {
    constructor(i, s) {
        this.bucket = i,
        this.path_ = s
    }
    get path() {
        return this.path_
    }
    get isRoot() {
        return this.path.length === 0
    }
    fullServerUrl() {
        const i = encodeURIComponent;
        return "/b/" + i(this.bucket) + "/o/" + i(this.path)
    }
    bucketOnlyServerUrl() {
        return "/b/" + encodeURIComponent(this.bucket) + "/o"
    }
    static makeFromBucketSpec(i, s) {
        let a;
        try {
            a = Location.makeFromUrl(i, s)
        } catch {
            return new Location(i,"")
        }
        if (a.path === "")
            return a;
        throw invalidDefaultBucket(i)
    }
    static makeFromUrl(i, s) {
        let a = null;
        const _ = "([A-Za-z0-9.\\-_]+)";
        function $(ft) {
            ft.path.charAt(ft.path.length - 1) === "/" && (ft.path_ = ft.path_.slice(0, -1))
        }
        const _e = "(/(.*))?$"
          , tt = new RegExp("^gs://" + _ + _e,"i")
          , nt = {
            bucket: 1,
            path: 3
        };
        function rt(ft) {
            ft.path_ = decodeURIComponent(ft.path)
        }
        const ot = "v[A-Za-z0-9_]+"
          , et = s.replace(/[.]/g, "\\.")
          , j = "(/([^?#]*).*)?$"
          , it = new RegExp(`^https?://${et}/${ot}/b/${_}/o${j}`,"i")
          , st = {
            bucket: 1,
            path: 3
        }
          , at = s === DEFAULT_HOST ? "(?:storage.googleapis.com|storage.cloud.google.com)" : s
          , lt = "([^?#]*)"
          , ct = new RegExp(`^https?://${at}/${_}/${lt}`,"i")
          , dt = [{
            regex: tt,
            indices: nt,
            postModify: $
        }, {
            regex: it,
            indices: st,
            postModify: rt
        }, {
            regex: ct,
            indices: {
                bucket: 1,
                path: 2
            },
            postModify: rt
        }];
        for (let ft = 0; ft < dt.length; ft++) {
            const ht = dt[ft]
              , pt = ht.regex.exec(i);
            if (pt) {
                const gt = pt[ht.indices.bucket];
                let _t = pt[ht.indices.path];
                _t || (_t = ""),
                a = new Location(gt,_t),
                ht.postModify(a);
                break
            }
        }
        if (a == null)
            throw invalidUrl(i);
        return a
    }
}
class FailRequest {
    constructor(i) {
        this.promise_ = Promise.reject(i)
    }
    getPromise() {
        return this.promise_
    }
    cancel(i=!1) {}
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function start(o, i, s) {
    let a = 1
      , _ = null
      , $ = null
      , _e = !1
      , tt = 0;
    function nt() {
        return tt === 2
    }
    let rt = !1;
    function ot(...lt) {
        rt || (rt = !0,
        i.apply(null, lt))
    }
    function et(lt) {
        _ = setTimeout( () => {
            _ = null,
            o(it, nt())
        }
        , lt)
    }
    function j() {
        $ && clearTimeout($)
    }
    function it(lt, ...ct) {
        if (rt) {
            j();
            return
        }
        if (lt) {
            j(),
            ot.call(null, lt, ...ct);
            return
        }
        if (nt() || _e) {
            j(),
            ot.call(null, lt, ...ct);
            return
        }
        a < 64 && (a *= 2);
        let dt;
        tt === 1 ? (tt = 2,
        dt = 0) : dt = (a + Math.random()) * 1e3,
        et(dt)
    }
    let st = !1;
    function at(lt) {
        st || (st = !0,
        j(),
        !rt && (_ !== null ? (lt || (tt = 2),
        clearTimeout(_),
        et(0)) : lt || (tt = 1)))
    }
    return et(0),
    $ = setTimeout( () => {
        _e = !0,
        at(!0)
    }
    , s),
    at
}
function stop(o) {
    o(!1)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function isJustDef(o) {
    return o !== void 0
}
function validateNumber(o, i, s, a) {
    if (a < i)
        throw invalidArgument(`Invalid value for '${o}'. Expected ${i} or greater.`);
    if (a > s)
        throw invalidArgument(`Invalid value for '${o}'. Expected ${s} or less.`)
}
function makeQueryString(o) {
    const i = encodeURIComponent;
    let s = "?";
    for (const a in o)
        if (o.hasOwnProperty(a)) {
            const _ = i(a) + "=" + i(o[a]);
            s = s + _ + "&"
        }
    return s = s.slice(0, -1),
    s
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ErrorCode;
(function(o) {
    o[o.NO_ERROR = 0] = "NO_ERROR",
    o[o.NETWORK_ERROR = 1] = "NETWORK_ERROR",
    o[o.ABORT = 2] = "ABORT"
}
)(ErrorCode || (ErrorCode = {}));
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function isRetryStatusCode(o, i) {
    const s = o >= 500 && o < 600
      , _ = [408, 429].indexOf(o) !== -1
      , $ = i.indexOf(o) !== -1;
    return s || _ || $
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NetworkRequest {
    constructor(i, s, a, _, $, _e, tt, nt, rt, ot, et, j=!0) {
        this.url_ = i,
        this.method_ = s,
        this.headers_ = a,
        this.body_ = _,
        this.successCodes_ = $,
        this.additionalRetryCodes_ = _e,
        this.callback_ = tt,
        this.errorCallback_ = nt,
        this.timeout_ = rt,
        this.progressCallback_ = ot,
        this.connectionFactory_ = et,
        this.retry = j,
        this.pendingConnection_ = null,
        this.backoffId_ = null,
        this.canceled_ = !1,
        this.appDelete_ = !1,
        this.promise_ = new Promise( (it, st) => {
            this.resolve_ = it,
            this.reject_ = st,
            this.start_()
        }
        )
    }
    start_() {
        const i = (a, _) => {
            if (_) {
                a(!1, new RequestEndStatus(!1,null,!0));
                return
            }
            const $ = this.connectionFactory_();
            this.pendingConnection_ = $;
            const _e = tt => {
                const nt = tt.loaded
                  , rt = tt.lengthComputable ? tt.total : -1;
                this.progressCallback_ !== null && this.progressCallback_(nt, rt)
            }
            ;
            this.progressCallback_ !== null && $.addUploadProgressListener(_e),
            $.send(this.url_, this.method_, this.body_, this.headers_).then( () => {
                this.progressCallback_ !== null && $.removeUploadProgressListener(_e),
                this.pendingConnection_ = null;
                const tt = $.getErrorCode() === ErrorCode.NO_ERROR
                  , nt = $.getStatus();
                if (!tt || isRetryStatusCode(nt, this.additionalRetryCodes_) && this.retry) {
                    const ot = $.getErrorCode() === ErrorCode.ABORT;
                    a(!1, new RequestEndStatus(!1,null,ot));
                    return
                }
                const rt = this.successCodes_.indexOf(nt) !== -1;
                a(!0, new RequestEndStatus(rt,$))
            }
            )
        }
          , s = (a, _) => {
            const $ = this.resolve_
              , _e = this.reject_
              , tt = _.connection;
            if (_.wasSuccessCode)
                try {
                    const nt = this.callback_(tt, tt.getResponse());
                    isJustDef(nt) ? $(nt) : $()
                } catch (nt) {
                    _e(nt)
                }
            else if (tt !== null) {
                const nt = unknown();
                nt.serverResponse = tt.getErrorText(),
                this.errorCallback_ ? _e(this.errorCallback_(tt, nt)) : _e(nt)
            } else if (_.canceled) {
                const nt = this.appDelete_ ? appDeleted() : canceled();
                _e(nt)
            } else {
                const nt = retryLimitExceeded();
                _e(nt)
            }
        }
        ;
        this.canceled_ ? s(!1, new RequestEndStatus(!1,null,!0)) : this.backoffId_ = start(i, s, this.timeout_)
    }
    getPromise() {
        return this.promise_
    }
    cancel(i) {
        this.canceled_ = !0,
        this.appDelete_ = i || !1,
        this.backoffId_ !== null && stop(this.backoffId_),
        this.pendingConnection_ !== null && this.pendingConnection_.abort()
    }
}
class RequestEndStatus {
    constructor(i, s, a) {
        this.wasSuccessCode = i,
        this.connection = s,
        this.canceled = !!a
    }
}
function addAuthHeader_(o, i) {
    i !== null && i.length > 0 && (o.Authorization = "Firebase " + i)
}
function addVersionHeader_(o, i) {
    o["X-Firebase-Storage-Version"] = "webjs/" + (i ?? "AppManager")
}
function addGmpidHeader_(o, i) {
    i && (o["X-Firebase-GMPID"] = i)
}
function addAppCheckHeader_(o, i) {
    i !== null && (o["X-Firebase-AppCheck"] = i)
}
function makeRequest(o, i, s, a, _, $, _e=!0) {
    const tt = makeQueryString(o.urlParams)
      , nt = o.url + tt
      , rt = Object.assign({}, o.headers);
    return addGmpidHeader_(rt, i),
    addAuthHeader_(rt, s),
    addVersionHeader_(rt, $),
    addAppCheckHeader_(rt, a),
    new NetworkRequest(nt,o.method,rt,o.body,o.successCodes,o.additionalRetryCodes,o.handler,o.errorHandler,o.timeout,o.progressCallback,_,_e)
}
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function parent(o) {
    if (o.length === 0)
        return null;
    const i = o.lastIndexOf("/");
    return i === -1 ? "" : o.slice(0, i)
}
function lastComponent(o) {
    const i = o.lastIndexOf("/", o.length - 2);
    return i === -1 ? o : o.slice(i + 1)
}
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Reference {
    constructor(i, s) {
        this._service = i,
        s instanceof Location ? this._location = s : this._location = Location.makeFromUrl(s, i.host)
    }
    toString() {
        return "gs://" + this._location.bucket + "/" + this._location.path
    }
    _newRef(i, s) {
        return new Reference(i,s)
    }
    get root() {
        const i = new Location(this._location.bucket,"");
        return this._newRef(this._service, i)
    }
    get bucket() {
        return this._location.bucket
    }
    get fullPath() {
        return this._location.path
    }
    get name() {
        return lastComponent(this._location.path)
    }
    get storage() {
        return this._service
    }
    get parent() {
        const i = parent(this._location.path);
        if (i === null)
            return null;
        const s = new Location(this._location.bucket,i);
        return new Reference(this._service,s)
    }
    _throwIfRoot(i) {
        if (this._location.path === "")
            throw invalidRootOperation(i)
    }
}
function extractBucket(o, i) {
    const s = i == null ? void 0 : i[CONFIG_STORAGE_BUCKET_KEY];
    return s == null ? null : Location.makeFromBucketSpec(s, o)
}
class FirebaseStorageImpl {
    constructor(i, s, a, _, $) {
        this.app = i,
        this._authProvider = s,
        this._appCheckProvider = a,
        this._url = _,
        this._firebaseVersion = $,
        this._bucket = null,
        this._host = DEFAULT_HOST,
        this._protocol = "https",
        this._appId = null,
        this._deleted = !1,
        this._maxOperationRetryTime = DEFAULT_MAX_OPERATION_RETRY_TIME,
        this._maxUploadRetryTime = DEFAULT_MAX_UPLOAD_RETRY_TIME,
        this._requests = new Set,
        _ != null ? this._bucket = Location.makeFromBucketSpec(_, this._host) : this._bucket = extractBucket(this._host, this.app.options)
    }
    get host() {
        return this._host
    }
    set host(i) {
        this._host = i,
        this._url != null ? this._bucket = Location.makeFromBucketSpec(this._url, i) : this._bucket = extractBucket(i, this.app.options)
    }
    get maxUploadRetryTime() {
        return this._maxUploadRetryTime
    }
    set maxUploadRetryTime(i) {
        validateNumber("time", 0, Number.POSITIVE_INFINITY, i),
        this._maxUploadRetryTime = i
    }
    get maxOperationRetryTime() {
        return this._maxOperationRetryTime
    }
    set maxOperationRetryTime(i) {
        validateNumber("time", 0, Number.POSITIVE_INFINITY, i),
        this._maxOperationRetryTime = i
    }
    async _getAuthToken() {
        if (this._overrideAuthToken)
            return this._overrideAuthToken;
        const i = this._authProvider.getImmediate({
            optional: !0
        });
        if (i) {
            const s = await i.getToken();
            if (s !== null)
                return s.accessToken
        }
        return null
    }
    async _getAppCheckToken() {
        const i = this._appCheckProvider.getImmediate({
            optional: !0
        });
        return i ? (await i.getToken()).token : null
    }
    _delete() {
        return this._deleted || (this._deleted = !0,
        this._requests.forEach(i => i.cancel()),
        this._requests.clear()),
        Promise.resolve()
    }
    _makeStorageReference(i) {
        return new Reference(this,i)
    }
    _makeRequest(i, s, a, _, $=!0) {
        if (this._deleted)
            return new FailRequest(appDeleted());
        {
            const _e = makeRequest(i, this._appId, a, _, s, this._firebaseVersion, $);
            return this._requests.add(_e),
            _e.getPromise().then( () => this._requests.delete(_e), () => this._requests.delete(_e)),
            _e
        }
    }
    async makeRequestWithTokens(i, s) {
        const [a,_] = await Promise.all([this._getAuthToken(), this._getAppCheckToken()]);
        return this._makeRequest(i, s, a, _).getPromise()
    }
}
const name$1 = "@firebase/storage"
  , version = "0.11.2";
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const STORAGE_TYPE = "storage";
function factory(o, {instanceIdentifier: i}) {
    const s = o.getProvider("app").getImmediate()
      , a = o.getProvider("auth-internal")
      , _ = o.getProvider("app-check-internal");
    return new FirebaseStorageImpl(s,a,_,i,SDK_VERSION)
}
function registerStorage() {
    _registerComponent(new Component(STORAGE_TYPE,factory,"PUBLIC").setMultipleInstances(!0)),
    registerVersion(name$1, version, ""),
    registerVersion(name$1, version, "esm2017")
}
registerStorage();
const firebaseConfig = {
    apiKey: "AIzaSyDnKCi1mOuPFnetcoNjF4K3M0uskxFm_rw",
    authDomain: "geosegment-299df.firebaseapp.com",
    projectId: "geosegment-299df",
    storageBucket: "geosegment-299df.appspot.com",
    messagingSenderId: "93090080499",
    appId: "1:93090080499:web:129b88c98030fba75b3986",
    measurementId: "G-FPT0741C7Q"
}
  , app = initializeApp(firebaseConfig);
async function firebaseLogin(o, i) {
    return await signInWithEmailAndPassword(getAuth(app), o, i)
}
async function firebaseCreateUserWithEmailAndPassword(o, i) {
    return await createUserWithEmailAndPassword(getAuth(app), o, i)
}
async function firebaseSendResetPasswordRequest(o) {
    return await sendPasswordResetEmail(getAuth(app), o)
}
async function firebaseLogout() {
    return await getAuth(app).signOut()
}
var mapLocations = (o => (o.Fields = "Fields",
o.AgriFarmTiff = "Agriculture (Drone GeoTIFF Import)",
o.FishFarm = "Fish Farm",
o.City = "City",
o.Trees = "Trees",
o.Quarry = "Quarry",
o.HousingEstates = "Housing Estate",
o.Port = "Port",
o))(mapLocations || {})
  , AuthState = (o => (o[o.Pending = 0] = "Pending",
o[o.LoggedIn = 1] = "LoggedIn",
o[o.LoggedOut = 2] = "LoggedOut",
o))(AuthState || {});
const UserContext = reactExports.createContext({
    authState: AuthState.Pending
})
  , AuthProvider = ({children: o}) => {
    const [i,s] = reactExports.useState({
        authState: AuthState.Pending
    });
    return reactExports.useEffect( () => getAuth(app).onAuthStateChanged(_ => {
        s(_ ? {
            user: _,
            authState: AuthState.LoggedIn
        } : {
            user: void 0,
            authState: AuthState.LoggedOut
        })
    }
    ), []),
    jsxRuntimeExports.jsx(UserContext.Provider, {
        value: i,
        children: o
    })
}
  , ProtectedRoute = ({children: o}) => {
    const i = reactExports.useContext(UserContext);
    return i.authState === AuthState.LoggedOut ? jsxRuntimeExports.jsx(Navigate, {
        to: "/login",
        replace: !0
    }) : i.authState === AuthState.Pending ? jsxRuntimeExports.jsx(Box, {
        pos: "absolute",
        w: "100%",
        h: "100%",
        children: jsxRuntimeExports.jsx(LoadingOverlay, {
            visible: !0,
            overlayBlur: 2
        })
    }) : o
}
;
function generateUniqueString() {
    const o = Date.now().toString(36)
      , i = Math.random().toString(36).substr(2, 5);
    return o + i
}
var SegmentRequestType = (o => (o[o.Point = 0] = "Point",
o[o.BoundingBox = 1] = "BoundingBox",
o))(SegmentRequestType || {});
const ol = ""
  , styles$1 = "";
class BaseEvent {
    constructor(i) {
        this.propagationStopped,
        this.defaultPrevented,
        this.type = i,
        this.target = null
    }
    preventDefault() {
        this.defaultPrevented = !0
    }
    stopPropagation() {
        this.propagationStopped = !0
    }
}
const Event$1 = BaseEvent
  , ObjectEventType = {
    PROPERTYCHANGE: "propertychange"
};
class Disposable {
    constructor() {
        this.disposed = !1
    }
    dispose() {
        this.disposed || (this.disposed = !0,
        this.disposeInternal())
    }
    disposeInternal() {}
}
const Disposable$1 = Disposable;
function binarySearch(o, i, s) {
    let a, _;
    s = s || ascending;
    let $ = 0
      , _e = o.length
      , tt = !1;
    for (; $ < _e; )
        a = $ + (_e - $ >> 1),
        _ = +s(o[a], i),
        _ < 0 ? $ = a + 1 : (_e = a,
        tt = !_);
    return tt ? $ : ~$
}
function ascending(o, i) {
    return o > i ? 1 : o < i ? -1 : 0
}
function descending(o, i) {
    return o < i ? 1 : o > i ? -1 : 0
}
function linearFindNearest(o, i, s) {
    if (o[0] <= i)
        return 0;
    const a = o.length;
    if (i <= o[a - 1])
        return a - 1;
    if (typeof s == "function") {
        for (let _ = 1; _ < a; ++_) {
            const $ = o[_];
            if ($ === i)
                return _;
            if ($ < i)
                return s(i, o[_ - 1], $) > 0 ? _ - 1 : _
        }
        return a - 1
    }
    if (s > 0) {
        for (let _ = 1; _ < a; ++_)
            if (o[_] < i)
                return _ - 1;
        return a - 1
    }
    if (s < 0) {
        for (let _ = 1; _ < a; ++_)
            if (o[_] <= i)
                return _;
        return a - 1
    }
    for (let _ = 1; _ < a; ++_) {
        if (o[_] == i)
            return _;
        if (o[_] < i)
            return o[_ - 1] - i < i - o[_] ? _ - 1 : _
    }
    return a - 1
}
function reverseSubArray(o, i, s) {
    for (; i < s; ) {
        const a = o[i];
        o[i] = o[s],
        o[s] = a,
        ++i,
        --s
    }
}
function extend$2(o, i) {
    const s = Array.isArray(i) ? i : [i]
      , a = s.length;
    for (let _ = 0; _ < a; _++)
        o[o.length] = s[_]
}
function equals$2(o, i) {
    const s = o.length;
    if (s !== i.length)
        return !1;
    for (let a = 0; a < s; a++)
        if (o[a] !== i[a])
            return !1;
    return !0
}
function isSorted(o, i, s) {
    const a = i || ascending;
    return o.every(function(_, $) {
        if ($ === 0)
            return !0;
        const _e = a(o[$ - 1], _);
        return !(_e > 0 || s && _e === 0)
    })
}
function TRUE() {
    return !0
}
function FALSE() {
    return !1
}
function VOID() {}
function memoizeOne(o) {
    let i = !1, s, a, _;
    return function() {
        const $ = Array.prototype.slice.call(arguments);
        return (!i || this !== _ || !equals$2($, a)) && (i = !0,
        _ = this,
        a = $,
        s = o.apply(this, arguments)),
        s
    }
}
function toPromise(o) {
    function i() {
        let s;
        try {
            s = o()
        } catch (a) {
            return Promise.reject(a)
        }
        return s instanceof Promise ? s : Promise.resolve(s)
    }
    return i()
}
function clear(o) {
    for (const i in o)
        delete o[i]
}
function isEmpty$1(o) {
    let i;
    for (i in o)
        return !1;
    return !i
}
class Target extends Disposable$1 {
    constructor(i) {
        super(),
        this.eventTarget_ = i,
        this.pendingRemovals_ = null,
        this.dispatching_ = null,
        this.listeners_ = null
    }
    addEventListener(i, s) {
        if (!i || !s)
            return;
        const a = this.listeners_ || (this.listeners_ = {})
          , _ = a[i] || (a[i] = []);
        _.includes(s) || _.push(s)
    }
    dispatchEvent(i) {
        const s = typeof i == "string"
          , a = s ? i : i.type
          , _ = this.listeners_ && this.listeners_[a];
        if (!_)
            return;
        const $ = s ? new Event$1(i) : i;
        $.target || ($.target = this.eventTarget_ || this);
        const _e = this.dispatching_ || (this.dispatching_ = {})
          , tt = this.pendingRemovals_ || (this.pendingRemovals_ = {});
        a in _e || (_e[a] = 0,
        tt[a] = 0),
        ++_e[a];
        let nt;
        for (let rt = 0, ot = _.length; rt < ot; ++rt)
            if ("handleEvent"in _[rt] ? nt = _[rt].handleEvent($) : nt = _[rt].call(this, $),
            nt === !1 || $.propagationStopped) {
                nt = !1;
                break
            }
        if (--_e[a] === 0) {
            let rt = tt[a];
            for (delete tt[a]; rt--; )
                this.removeEventListener(a, VOID);
            delete _e[a]
        }
        return nt
    }
    disposeInternal() {
        this.listeners_ && clear(this.listeners_)
    }
    getListeners(i) {
        return this.listeners_ && this.listeners_[i] || void 0
    }
    hasListener(i) {
        return this.listeners_ ? i ? i in this.listeners_ : Object.keys(this.listeners_).length > 0 : !1
    }
    removeEventListener(i, s) {
        const a = this.listeners_ && this.listeners_[i];
        if (a) {
            const _ = a.indexOf(s);
            _ !== -1 && (this.pendingRemovals_ && i in this.pendingRemovals_ ? (a[_] = VOID,
            ++this.pendingRemovals_[i]) : (a.splice(_, 1),
            a.length === 0 && delete this.listeners_[i]))
        }
    }
}
const EventTarget = Target
  , EventType = {
    CHANGE: "change",
    ERROR: "error",
    BLUR: "blur",
    CLEAR: "clear",
    CONTEXTMENU: "contextmenu",
    CLICK: "click",
    DBLCLICK: "dblclick",
    DRAGENTER: "dragenter",
    DRAGOVER: "dragover",
    DROP: "drop",
    FOCUS: "focus",
    KEYDOWN: "keydown",
    KEYPRESS: "keypress",
    LOAD: "load",
    RESIZE: "resize",
    TOUCHMOVE: "touchmove",
    WHEEL: "wheel"
};
function listen(o, i, s, a, _) {
    if (a && a !== o && (s = s.bind(a)),
    _) {
        const _e = s;
        s = function() {
            o.removeEventListener(i, s),
            _e.apply(this, arguments)
        }
    }
    const $ = {
        target: o,
        type: i,
        listener: s
    };
    return o.addEventListener(i, s),
    $
}
function listenOnce(o, i, s, a) {
    return listen(o, i, s, a, !0)
}
function unlistenByKey(o) {
    o && o.target && (o.target.removeEventListener(o.type, o.listener),
    clear(o))
}
class Observable extends EventTarget {
    constructor() {
        super(),
        this.on = this.onInternal,
        this.once = this.onceInternal,
        this.un = this.unInternal,
        this.revision_ = 0
    }
    changed() {
        ++this.revision_,
        this.dispatchEvent(EventType.CHANGE)
    }
    getRevision() {
        return this.revision_
    }
    onInternal(i, s) {
        if (Array.isArray(i)) {
            const a = i.length
              , _ = new Array(a);
            for (let $ = 0; $ < a; ++$)
                _[$] = listen(this, i[$], s);
            return _
        }
        return listen(this, i, s)
    }
    onceInternal(i, s) {
        let a;
        if (Array.isArray(i)) {
            const _ = i.length;
            a = new Array(_);
            for (let $ = 0; $ < _; ++$)
                a[$] = listenOnce(this, i[$], s)
        } else
            a = listenOnce(this, i, s);
        return s.ol_key = a,
        a
    }
    unInternal(i, s) {
        const a = s.ol_key;
        if (a)
            unByKey(a);
        else if (Array.isArray(i))
            for (let _ = 0, $ = i.length; _ < $; ++_)
                this.removeEventListener(i[_], s);
        else
            this.removeEventListener(i, s)
    }
}
Observable.prototype.on;
Observable.prototype.once;
Observable.prototype.un;
function unByKey(o) {
    if (Array.isArray(o))
        for (let i = 0, s = o.length; i < s; ++i)
            unlistenByKey(o[i]);
    else
        unlistenByKey(o)
}
const Observable$1 = Observable;
function abstract() {
    throw new Error("Unimplemented abstract method.")
}
let uidCounter_ = 0;
function getUid(o) {
    return o.ol_uid || (o.ol_uid = String(++uidCounter_))
}
class ObjectEvent extends Event$1 {
    constructor(i, s, a) {
        super(i),
        this.key = s,
        this.oldValue = a
    }
}
class BaseObject extends Observable$1 {
    constructor(i) {
        super(),
        this.on,
        this.once,
        this.un,
        getUid(this),
        this.values_ = null,
        i !== void 0 && this.setProperties(i)
    }
    get(i) {
        let s;
        return this.values_ && this.values_.hasOwnProperty(i) && (s = this.values_[i]),
        s
    }
    getKeys() {
        return this.values_ && Object.keys(this.values_) || []
    }
    getProperties() {
        return this.values_ && Object.assign({}, this.values_) || {}
    }
    getPropertiesInternal() {
        return this.values_
    }
    hasProperties() {
        return !!this.values_
    }
    notify(i, s) {
        let a;
        a = `change:${i}`,
        this.hasListener(a) && this.dispatchEvent(new ObjectEvent(a,i,s)),
        a = ObjectEventType.PROPERTYCHANGE,
        this.hasListener(a) && this.dispatchEvent(new ObjectEvent(a,i,s))
    }
    addChangeListener(i, s) {
        this.addEventListener(`change:${i}`, s)
    }
    removeChangeListener(i, s) {
        this.removeEventListener(`change:${i}`, s)
    }
    set(i, s, a) {
        const _ = this.values_ || (this.values_ = {});
        if (a)
            _[i] = s;
        else {
            const $ = _[i];
            _[i] = s,
            $ !== s && this.notify(i, $)
        }
    }
    setProperties(i, s) {
        for (const a in i)
            this.set(a, i[a], s)
    }
    applyProperties(i) {
        i.values_ && Object.assign(this.values_ || (this.values_ = {}), i.values_)
    }
    unset(i, s) {
        if (this.values_ && i in this.values_) {
            const a = this.values_[i];
            delete this.values_[i],
            isEmpty$1(this.values_) && (this.values_ = null),
            s || this.notify(i, a)
        }
    }
}
const BaseObject$1 = BaseObject
  , CollectionEventType = {
    ADD: "add",
    REMOVE: "remove"
}
  , Property$2 = {
    LENGTH: "length"
};
class CollectionEvent extends Event$1 {
    constructor(i, s, a) {
        super(i),
        this.element = s,
        this.index = a
    }
}
class Collection extends BaseObject$1 {
    constructor(i, s) {
        if (super(),
        this.on,
        this.once,
        this.un,
        s = s || {},
        this.unique_ = !!s.unique,
        this.array_ = i || [],
        this.unique_)
            for (let a = 0, _ = this.array_.length; a < _; ++a)
                this.assertUnique_(this.array_[a], a);
        this.updateLength_()
    }
    clear() {
        for (; this.getLength() > 0; )
            this.pop()
    }
    extend(i) {
        for (let s = 0, a = i.length; s < a; ++s)
            this.push(i[s]);
        return this
    }
    forEach(i) {
        const s = this.array_;
        for (let a = 0, _ = s.length; a < _; ++a)
            i(s[a], a, s)
    }
    getArray() {
        return this.array_
    }
    item(i) {
        return this.array_[i]
    }
    getLength() {
        return this.get(Property$2.LENGTH)
    }
    insertAt(i, s) {
        if (i < 0 || i > this.getLength())
            throw new Error("Index out of bounds: " + i);
        this.unique_ && this.assertUnique_(s),
        this.array_.splice(i, 0, s),
        this.updateLength_(),
        this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD,s,i))
    }
    pop() {
        return this.removeAt(this.getLength() - 1)
    }
    push(i) {
        this.unique_ && this.assertUnique_(i);
        const s = this.getLength();
        return this.insertAt(s, i),
        this.getLength()
    }
    remove(i) {
        const s = this.array_;
        for (let a = 0, _ = s.length; a < _; ++a)
            if (s[a] === i)
                return this.removeAt(a)
    }
    removeAt(i) {
        if (i < 0 || i >= this.getLength())
            return;
        const s = this.array_[i];
        return this.array_.splice(i, 1),
        this.updateLength_(),
        this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE,s,i)),
        s
    }
    setAt(i, s) {
        const a = this.getLength();
        if (i >= a) {
            this.insertAt(i, s);
            return
        }
        if (i < 0)
            throw new Error("Index out of bounds: " + i);
        this.unique_ && this.assertUnique_(s, i);
        const _ = this.array_[i];
        this.array_[i] = s,
        this.dispatchEvent(new CollectionEvent(CollectionEventType.REMOVE,_,i)),
        this.dispatchEvent(new CollectionEvent(CollectionEventType.ADD,s,i))
    }
    updateLength_() {
        this.set(Property$2.LENGTH, this.array_.length)
    }
    assertUnique_(i, s) {
        for (let a = 0, _ = this.array_.length; a < _; ++a)
            if (this.array_[a] === i && a !== s)
                throw new Error("Duplicate item added to a unique collection")
    }
}
const Collection$1 = Collection
  , ua = typeof navigator < "u" && typeof navigator.userAgent < "u" ? navigator.userAgent.toLowerCase() : ""
  , FIREFOX = ua.includes("firefox")
  , SAFARI = ua.includes("safari") && !ua.includes("chrom")
  , SAFARI_BUG_237906 = SAFARI && (ua.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(ua))
  , WEBKIT = ua.includes("webkit") && !ua.includes("edge")
  , MAC = ua.includes("macintosh")
  , DEVICE_PIXEL_RATIO = typeof devicePixelRatio < "u" ? devicePixelRatio : 1
  , WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope < "u" && typeof OffscreenCanvas < "u" && self instanceof WorkerGlobalScope
  , IMAGE_DECODE = typeof Image < "u" && Image.prototype.decode
  , PASSIVE_EVENT_LISTENERS = function() {
    let o = !1;
    try {
        const i = Object.defineProperty({}, "passive", {
            get: function() {
                o = !0
            }
        });
        window.addEventListener("_", null, i),
        window.removeEventListener("_", null, i)
    } catch {}
    return o
}();
function assert(o, i) {
    if (!o)
        throw new Error(i)
}
const tmp_ = new Array(6);
function create$1() {
    return [1, 0, 0, 1, 0, 0]
}
function reset(o) {
    return set$1(o, 1, 0, 0, 1, 0, 0)
}
function multiply(o, i) {
    const s = o[0]
      , a = o[1]
      , _ = o[2]
      , $ = o[3]
      , _e = o[4]
      , tt = o[5]
      , nt = i[0]
      , rt = i[1]
      , ot = i[2]
      , et = i[3]
      , j = i[4]
      , it = i[5];
    return o[0] = s * nt + _ * rt,
    o[1] = a * nt + $ * rt,
    o[2] = s * ot + _ * et,
    o[3] = a * ot + $ * et,
    o[4] = s * j + _ * it + _e,
    o[5] = a * j + $ * it + tt,
    o
}
function set$1(o, i, s, a, _, $, _e) {
    return o[0] = i,
    o[1] = s,
    o[2] = a,
    o[3] = _,
    o[4] = $,
    o[5] = _e,
    o
}
function setFromArray(o, i) {
    return o[0] = i[0],
    o[1] = i[1],
    o[2] = i[2],
    o[3] = i[3],
    o[4] = i[4],
    o[5] = i[5],
    o
}
function apply(o, i) {
    const s = i[0]
      , a = i[1];
    return i[0] = o[0] * s + o[2] * a + o[4],
    i[1] = o[1] * s + o[3] * a + o[5],
    i
}
function rotate$2(o, i) {
    const s = Math.cos(i)
      , a = Math.sin(i);
    return multiply(o, set$1(tmp_, s, a, -a, s, 0, 0))
}
function scale$3(o, i, s) {
    return multiply(o, set$1(tmp_, i, 0, 0, s, 0, 0))
}
function makeScale(o, i, s) {
    return set$1(o, i, 0, 0, s, 0, 0)
}
function translate$1(o, i, s) {
    return multiply(o, set$1(tmp_, 1, 0, 0, 1, i, s))
}
function compose(o, i, s, a, _, $, _e, tt) {
    const nt = Math.sin($)
      , rt = Math.cos($);
    return o[0] = a * rt,
    o[1] = _ * nt,
    o[2] = -a * nt,
    o[3] = _ * rt,
    o[4] = _e * a * rt - tt * a * nt + i,
    o[5] = _e * _ * nt + tt * _ * rt + s,
    o
}
function makeInverse(o, i) {
    const s = determinant(i);
    assert(s !== 0, "Transformation matrix cannot be inverted");
    const a = i[0]
      , _ = i[1]
      , $ = i[2]
      , _e = i[3]
      , tt = i[4]
      , nt = i[5];
    return o[0] = _e / s,
    o[1] = -_ / s,
    o[2] = -$ / s,
    o[3] = a / s,
    o[4] = ($ * nt - _e * tt) / s,
    o[5] = -(a * nt - _ * tt) / s,
    o
}
function determinant(o) {
    return o[0] * o[3] - o[1] * o[2]
}
let transformStringDiv;
function toString$1(o) {
    const i = "matrix(" + o.join(", ") + ")";
    if (WORKER_OFFSCREEN_CANVAS)
        return i;
    const s = transformStringDiv || (transformStringDiv = document.createElement("div"));
    return s.style.transform = i,
    s.style.transform
}
const Relationship = {
    UNKNOWN: 0,
    INTERSECTING: 1,
    ABOVE: 2,
    RIGHT: 4,
    BELOW: 8,
    LEFT: 16
};
function boundingExtent(o) {
    const i = createEmpty();
    for (let s = 0, a = o.length; s < a; ++s)
        extendCoordinate(i, o[s]);
    return i
}
function _boundingExtentXYs(o, i, s) {
    const a = Math.min.apply(null, o)
      , _ = Math.min.apply(null, i)
      , $ = Math.max.apply(null, o)
      , _e = Math.max.apply(null, i);
    return createOrUpdate$2(a, _, $, _e, s)
}
function buffer$1(o, i, s) {
    return s ? (s[0] = o[0] - i,
    s[1] = o[1] - i,
    s[2] = o[2] + i,
    s[3] = o[3] + i,
    s) : [o[0] - i, o[1] - i, o[2] + i, o[3] + i]
}
function clone(o, i) {
    return i ? (i[0] = o[0],
    i[1] = o[1],
    i[2] = o[2],
    i[3] = o[3],
    i) : o.slice()
}
function closestSquaredDistanceXY(o, i, s) {
    let a, _;
    return i < o[0] ? a = o[0] - i : o[2] < i ? a = i - o[2] : a = 0,
    s < o[1] ? _ = o[1] - s : o[3] < s ? _ = s - o[3] : _ = 0,
    a * a + _ * _
}
function containsCoordinate(o, i) {
    return containsXY(o, i[0], i[1])
}
function containsExtent(o, i) {
    return o[0] <= i[0] && i[2] <= o[2] && o[1] <= i[1] && i[3] <= o[3]
}
function containsXY(o, i, s) {
    return o[0] <= i && i <= o[2] && o[1] <= s && s <= o[3]
}
function coordinateRelationship(o, i) {
    const s = o[0]
      , a = o[1]
      , _ = o[2]
      , $ = o[3]
      , _e = i[0]
      , tt = i[1];
    let nt = Relationship.UNKNOWN;
    return _e < s ? nt = nt | Relationship.LEFT : _e > _ && (nt = nt | Relationship.RIGHT),
    tt < a ? nt = nt | Relationship.BELOW : tt > $ && (nt = nt | Relationship.ABOVE),
    nt === Relationship.UNKNOWN && (nt = Relationship.INTERSECTING),
    nt
}
function createEmpty() {
    return [1 / 0, 1 / 0, -1 / 0, -1 / 0]
}
function createOrUpdate$2(o, i, s, a, _) {
    return _ ? (_[0] = o,
    _[1] = i,
    _[2] = s,
    _[3] = a,
    _) : [o, i, s, a]
}
function createOrUpdateEmpty(o) {
    return createOrUpdate$2(1 / 0, 1 / 0, -1 / 0, -1 / 0, o)
}
function createOrUpdateFromCoordinate(o, i) {
    const s = o[0]
      , a = o[1];
    return createOrUpdate$2(s, a, s, a, i)
}
function createOrUpdateFromFlatCoordinates(o, i, s, a, _) {
    const $ = createOrUpdateEmpty(_);
    return extendFlatCoordinates($, o, i, s, a)
}
function equals$1(o, i) {
    return o[0] == i[0] && o[2] == i[2] && o[1] == i[1] && o[3] == i[3]
}
function extend$1(o, i) {
    return i[0] < o[0] && (o[0] = i[0]),
    i[2] > o[2] && (o[2] = i[2]),
    i[1] < o[1] && (o[1] = i[1]),
    i[3] > o[3] && (o[3] = i[3]),
    o
}
function extendCoordinate(o, i) {
    i[0] < o[0] && (o[0] = i[0]),
    i[0] > o[2] && (o[2] = i[0]),
    i[1] < o[1] && (o[1] = i[1]),
    i[1] > o[3] && (o[3] = i[1])
}
function extendFlatCoordinates(o, i, s, a, _) {
    for (; s < a; s += _)
        extendXY(o, i[s], i[s + 1]);
    return o
}
function extendXY(o, i, s) {
    o[0] = Math.min(o[0], i),
    o[1] = Math.min(o[1], s),
    o[2] = Math.max(o[2], i),
    o[3] = Math.max(o[3], s)
}
function forEachCorner(o, i) {
    let s;
    return s = i(getBottomLeft(o)),
    s || (s = i(getBottomRight(o)),
    s) || (s = i(getTopRight(o)),
    s) || (s = i(getTopLeft(o)),
    s) ? s : !1
}
function getArea(o) {
    let i = 0;
    return isEmpty(o) || (i = getWidth(o) * getHeight(o)),
    i
}
function getBottomLeft(o) {
    return [o[0], o[1]]
}
function getBottomRight(o) {
    return [o[2], o[1]]
}
function getCenter(o) {
    return [(o[0] + o[2]) / 2, (o[1] + o[3]) / 2]
}
function getCorner(o, i) {
    let s;
    if (i === "bottom-left")
        s = getBottomLeft(o);
    else if (i === "bottom-right")
        s = getBottomRight(o);
    else if (i === "top-left")
        s = getTopLeft(o);
    else if (i === "top-right")
        s = getTopRight(o);
    else
        throw new Error("Invalid corner");
    return s
}
function getForViewAndSize(o, i, s, a, _) {
    const [$,_e,tt,nt,rt,ot,et,j] = getRotatedViewport(o, i, s, a);
    return createOrUpdate$2(Math.min($, tt, rt, et), Math.min(_e, nt, ot, j), Math.max($, tt, rt, et), Math.max(_e, nt, ot, j), _)
}
function getRotatedViewport(o, i, s, a) {
    const _ = i * a[0] / 2
      , $ = i * a[1] / 2
      , _e = Math.cos(s)
      , tt = Math.sin(s)
      , nt = _ * _e
      , rt = _ * tt
      , ot = $ * _e
      , et = $ * tt
      , j = o[0]
      , it = o[1];
    return [j - nt + et, it - rt - ot, j - nt - et, it - rt + ot, j + nt - et, it + rt + ot, j + nt + et, it + rt - ot, j - nt + et, it - rt - ot]
}
function getHeight(o) {
    return o[3] - o[1]
}
function getIntersection(o, i, s) {
    const a = s || createEmpty();
    return intersects$1(o, i) ? (o[0] > i[0] ? a[0] = o[0] : a[0] = i[0],
    o[1] > i[1] ? a[1] = o[1] : a[1] = i[1],
    o[2] < i[2] ? a[2] = o[2] : a[2] = i[2],
    o[3] < i[3] ? a[3] = o[3] : a[3] = i[3]) : createOrUpdateEmpty(a),
    a
}
function getTopLeft(o) {
    return [o[0], o[3]]
}
function getTopRight(o) {
    return [o[2], o[3]]
}
function getWidth(o) {
    return o[2] - o[0]
}
function intersects$1(o, i) {
    return o[0] <= i[2] && o[2] >= i[0] && o[1] <= i[3] && o[3] >= i[1]
}
function isEmpty(o) {
    return o[2] < o[0] || o[3] < o[1]
}
function returnOrUpdate(o, i) {
    return i ? (i[0] = o[0],
    i[1] = o[1],
    i[2] = o[2],
    i[3] = o[3],
    i) : o
}
function intersectsSegment(o, i, s) {
    let a = !1;
    const _ = coordinateRelationship(o, i)
      , $ = coordinateRelationship(o, s);
    if (_ === Relationship.INTERSECTING || $ === Relationship.INTERSECTING)
        a = !0;
    else {
        const _e = o[0]
          , tt = o[1]
          , nt = o[2]
          , rt = o[3]
          , ot = i[0]
          , et = i[1]
          , j = s[0]
          , it = s[1]
          , st = (it - et) / (j - ot);
        let at, lt;
        $ & Relationship.ABOVE && !(_ & Relationship.ABOVE) && (at = j - (it - rt) / st,
        a = at >= _e && at <= nt),
        !a && $ & Relationship.RIGHT && !(_ & Relationship.RIGHT) && (lt = it - (j - nt) * st,
        a = lt >= tt && lt <= rt),
        !a && $ & Relationship.BELOW && !(_ & Relationship.BELOW) && (at = j - (it - tt) / st,
        a = at >= _e && at <= nt),
        !a && $ & Relationship.LEFT && !(_ & Relationship.LEFT) && (lt = it - (j - _e) * st,
        a = lt >= tt && lt <= rt)
    }
    return a
}
function applyTransform(o, i, s, a) {
    if (isEmpty(o))
        return createOrUpdateEmpty(s);
    let _ = [];
    if (a > 1) {
        const tt = o[2] - o[0]
          , nt = o[3] - o[1];
        for (let rt = 0; rt < a; ++rt)
            _.push(o[0] + tt * rt / a, o[1], o[2], o[1] + nt * rt / a, o[2] - tt * rt / a, o[3], o[0], o[3] - nt * rt / a)
    } else
        _ = [o[0], o[1], o[2], o[1], o[2], o[3], o[0], o[3]];
    i(_, _, 2);
    const $ = []
      , _e = [];
    for (let tt = 0, nt = _.length; tt < nt; tt += 2)
        $.push(_[tt]),
        _e.push(_[tt + 1]);
    return _boundingExtentXYs($, _e, s)
}
function wrapX$2(o, i) {
    const s = i.getExtent()
      , a = getCenter(o);
    if (i.canWrapX() && (a[0] < s[0] || a[0] >= s[2])) {
        const _ = getWidth(s)
          , _e = Math.floor((a[0] - s[0]) / _) * _;
        o[0] -= _e,
        o[2] -= _e
    }
    return o
}
function wrapAndSliceX(o, i) {
    if (i.canWrapX()) {
        const s = i.getExtent();
        if (!isFinite(o[0]) || !isFinite(o[2]))
            return [[s[0], o[1], s[2], o[3]]];
        wrapX$2(o, i);
        const a = getWidth(s);
        if (getWidth(o) > a)
            return [[s[0], o[1], s[2], o[3]]];
        if (o[0] < s[0])
            return [[o[0] + a, o[1], s[2], o[3]], [s[0], o[1], o[2], o[3]]];
        if (o[2] > s[2])
            return [[o[0], o[1], s[2], o[3]], [s[0], o[1], o[2] - a, o[3]]]
    }
    return [o]
}
function clamp(o, i, s) {
    return Math.min(Math.max(o, i), s)
}
function squaredSegmentDistance(o, i, s, a, _, $) {
    const _e = _ - s
      , tt = $ - a;
    if (_e !== 0 || tt !== 0) {
        const nt = ((o - s) * _e + (i - a) * tt) / (_e * _e + tt * tt);
        nt > 1 ? (s = _,
        a = $) : nt > 0 && (s += _e * nt,
        a += tt * nt)
    }
    return squaredDistance$1(o, i, s, a)
}
function squaredDistance$1(o, i, s, a) {
    const _ = s - o
      , $ = a - i;
    return _ * _ + $ * $
}
function solveLinearSystem(o) {
    const i = o.length;
    for (let a = 0; a < i; a++) {
        let _ = a
          , $ = Math.abs(o[a][a]);
        for (let tt = a + 1; tt < i; tt++) {
            const nt = Math.abs(o[tt][a]);
            nt > $ && ($ = nt,
            _ = tt)
        }
        if ($ === 0)
            return null;
        const _e = o[_];
        o[_] = o[a],
        o[a] = _e;
        for (let tt = a + 1; tt < i; tt++) {
            const nt = -o[tt][a] / o[a][a];
            for (let rt = a; rt < i + 1; rt++)
                a == rt ? o[tt][rt] = 0 : o[tt][rt] += nt * o[a][rt]
        }
    }
    const s = new Array(i);
    for (let a = i - 1; a >= 0; a--) {
        s[a] = o[a][i] / o[a][a];
        for (let _ = a - 1; _ >= 0; _--)
            o[_][i] -= o[_][a] * s[a]
    }
    return s
}
function toRadians(o) {
    return o * Math.PI / 180
}
function modulo(o, i) {
    const s = o % i;
    return s * i < 0 ? s + i : s
}
function lerp$1(o, i, s) {
    return o + s * (i - o)
}
function toFixed(o, i) {
    const s = Math.pow(10, i);
    return Math.round(o * s) / s
}
function round(o, i) {
    return Math.round(toFixed(o, i))
}
function floor(o, i) {
    return Math.floor(toFixed(o, i))
}
function ceil(o, i) {
    return Math.ceil(toFixed(o, i))
}
const HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i
  , NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\(.*\)$/i;
function asString(o) {
    return typeof o == "string" ? o : toString(o)
}
function fromNamed(o) {
    const i = document.createElement("div");
    if (i.style.color = o,
    i.style.color !== "") {
        document.body.appendChild(i);
        const s = getComputedStyle(i).color;
        return document.body.removeChild(i),
        s
    }
    return ""
}
const fromString = function() {
    const i = {};
    let s = 0;
    return function(a) {
        let _;
        if (i.hasOwnProperty(a))
            _ = i[a];
        else {
            if (s >= 1024) {
                let $ = 0;
                for (const _e in i)
                    $++ & 3 || (delete i[_e],
                    --s)
            }
            _ = fromStringInternal_(a),
            i[a] = _,
            ++s
        }
        return _
    }
}();
function asArray(o) {
    return Array.isArray(o) ? o : fromString(o)
}
function fromStringInternal_(o) {
    let i, s, a, _, $;
    if (NAMED_COLOR_RE_.exec(o) && (o = fromNamed(o)),
    HEX_COLOR_RE_.exec(o)) {
        const _e = o.length - 1;
        let tt;
        _e <= 4 ? tt = 1 : tt = 2;
        const nt = _e === 4 || _e === 8;
        i = parseInt(o.substr(1 + 0 * tt, tt), 16),
        s = parseInt(o.substr(1 + 1 * tt, tt), 16),
        a = parseInt(o.substr(1 + 2 * tt, tt), 16),
        nt ? _ = parseInt(o.substr(1 + 3 * tt, tt), 16) : _ = 255,
        tt == 1 && (i = (i << 4) + i,
        s = (s << 4) + s,
        a = (a << 4) + a,
        nt && (_ = (_ << 4) + _)),
        $ = [i, s, a, _ / 255]
    } else if (o.startsWith("rgba("))
        $ = o.slice(5, -1).split(",").map(Number),
        normalize($);
    else if (o.startsWith("rgb("))
        $ = o.slice(4, -1).split(",").map(Number),
        $.push(1),
        normalize($);
    else
        throw new Error("Invalid color");
    return $
}
function normalize(o) {
    return o[0] = clamp(o[0] + .5 | 0, 0, 255),
    o[1] = clamp(o[1] + .5 | 0, 0, 255),
    o[2] = clamp(o[2] + .5 | 0, 0, 255),
    o[3] = clamp(o[3], 0, 1),
    o
}
function toString(o) {
    let i = o[0];
    i != (i | 0) && (i = i + .5 | 0);
    let s = o[1];
    s != (s | 0) && (s = s + .5 | 0);
    let a = o[2];
    a != (a | 0) && (a = a + .5 | 0);
    const _ = o[3] === void 0 ? 1 : Math.round(o[3] * 100) / 100;
    return "rgba(" + i + "," + s + "," + a + "," + _ + ")"
}
function isStringColor(o) {
    return NAMED_COLOR_RE_.test(o) && (o = fromNamed(o)),
    HEX_COLOR_RE_.test(o) || o.startsWith("rgba(") || o.startsWith("rgb(")
}
class IconImageCache {
    constructor() {
        this.cache_ = {},
        this.cacheSize_ = 0,
        this.maxCacheSize_ = 32
    }
    clear() {
        this.cache_ = {},
        this.cacheSize_ = 0
    }
    canExpireCache() {
        return this.cacheSize_ > this.maxCacheSize_
    }
    expire() {
        if (this.canExpireCache()) {
            let i = 0;
            for (const s in this.cache_) {
                const a = this.cache_[s];
                !(i++ & 3) && !a.hasListener() && (delete this.cache_[s],
                --this.cacheSize_)
            }
        }
    }
    get(i, s, a) {
        const _ = getKey$1(i, s, a);
        return _ in this.cache_ ? this.cache_[_] : null
    }
    set(i, s, a, _) {
        const $ = getKey$1(i, s, a);
        this.cache_[$] = _,
        ++this.cacheSize_
    }
    setSize(i) {
        this.maxCacheSize_ = i,
        this.expire()
    }
}
function getKey$1(o, i, s) {
    const a = s ? asString(s) : "null";
    return i + ":" + o + ":" + a
}
const shared = new IconImageCache
  , LayerProperty = {
    OPACITY: "opacity",
    VISIBLE: "visible",
    EXTENT: "extent",
    Z_INDEX: "zIndex",
    MAX_RESOLUTION: "maxResolution",
    MIN_RESOLUTION: "minResolution",
    MAX_ZOOM: "maxZoom",
    MIN_ZOOM: "minZoom",
    SOURCE: "source",
    MAP: "map"
};
class BaseLayer extends BaseObject$1 {
    constructor(i) {
        super(),
        this.on,
        this.once,
        this.un,
        this.background_ = i.background;
        const s = Object.assign({}, i);
        typeof i.properties == "object" && (delete s.properties,
        Object.assign(s, i.properties)),
        s[LayerProperty.OPACITY] = i.opacity !== void 0 ? i.opacity : 1,
        assert(typeof s[LayerProperty.OPACITY] == "number", "Layer opacity must be a number"),
        s[LayerProperty.VISIBLE] = i.visible !== void 0 ? i.visible : !0,
        s[LayerProperty.Z_INDEX] = i.zIndex,
        s[LayerProperty.MAX_RESOLUTION] = i.maxResolution !== void 0 ? i.maxResolution : 1 / 0,
        s[LayerProperty.MIN_RESOLUTION] = i.minResolution !== void 0 ? i.minResolution : 0,
        s[LayerProperty.MIN_ZOOM] = i.minZoom !== void 0 ? i.minZoom : -1 / 0,
        s[LayerProperty.MAX_ZOOM] = i.maxZoom !== void 0 ? i.maxZoom : 1 / 0,
        this.className_ = s.className !== void 0 ? s.className : "ol-layer",
        delete s.className,
        this.setProperties(s),
        this.state_ = null
    }
    getBackground() {
        return this.background_
    }
    getClassName() {
        return this.className_
    }
    getLayerState(i) {
        const s = this.state_ || {
            layer: this,
            managed: i === void 0 ? !0 : i
        }
          , a = this.getZIndex();
        return s.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1),
        s.visible = this.getVisible(),
        s.extent = this.getExtent(),
        s.zIndex = a === void 0 && !s.managed ? 1 / 0 : a,
        s.maxResolution = this.getMaxResolution(),
        s.minResolution = Math.max(this.getMinResolution(), 0),
        s.minZoom = this.getMinZoom(),
        s.maxZoom = this.getMaxZoom(),
        this.state_ = s,
        s
    }
    getLayersArray(i) {
        return abstract()
    }
    getLayerStatesArray(i) {
        return abstract()
    }
    getExtent() {
        return this.get(LayerProperty.EXTENT)
    }
    getMaxResolution() {
        return this.get(LayerProperty.MAX_RESOLUTION)
    }
    getMinResolution() {
        return this.get(LayerProperty.MIN_RESOLUTION)
    }
    getMinZoom() {
        return this.get(LayerProperty.MIN_ZOOM)
    }
    getMaxZoom() {
        return this.get(LayerProperty.MAX_ZOOM)
    }
    getOpacity() {
        return this.get(LayerProperty.OPACITY)
    }
    getSourceState() {
        return abstract()
    }
    getVisible() {
        return this.get(LayerProperty.VISIBLE)
    }
    getZIndex() {
        return this.get(LayerProperty.Z_INDEX)
    }
    setBackground(i) {
        this.background_ = i,
        this.changed()
    }
    setExtent(i) {
        this.set(LayerProperty.EXTENT, i)
    }
    setMaxResolution(i) {
        this.set(LayerProperty.MAX_RESOLUTION, i)
    }
    setMinResolution(i) {
        this.set(LayerProperty.MIN_RESOLUTION, i)
    }
    setMaxZoom(i) {
        this.set(LayerProperty.MAX_ZOOM, i)
    }
    setMinZoom(i) {
        this.set(LayerProperty.MIN_ZOOM, i)
    }
    setOpacity(i) {
        assert(typeof i == "number", "Layer opacity must be a number"),
        this.set(LayerProperty.OPACITY, i)
    }
    setVisible(i) {
        this.set(LayerProperty.VISIBLE, i)
    }
    setZIndex(i) {
        this.set(LayerProperty.Z_INDEX, i)
    }
    disposeInternal() {
        this.state_ && (this.state_.layer = null,
        this.state_ = null),
        super.disposeInternal()
    }
}
const BaseLayer$1 = BaseLayer
  , RenderEventType = {
    PRERENDER: "prerender",
    POSTRENDER: "postrender",
    PRECOMPOSE: "precompose",
    POSTCOMPOSE: "postcompose",
    RENDERCOMPLETE: "rendercomplete"
}
  , ViewHint = {
    ANIMATING: 0,
    INTERACTING: 1
}
  , ViewProperty = {
    CENTER: "center",
    RESOLUTION: "resolution",
    ROTATION: "rotation"
}
  , DEFAULT_MAX_ZOOM = 42
  , DEFAULT_TILE_SIZE = 256
  , unitByCode = {
    9001: "m",
    9002: "ft",
    9003: "us-ft",
    9101: "radians",
    9102: "degrees"
};
function fromCode(o) {
    return unitByCode[o]
}
const METERS_PER_UNIT$1 = {
    radians: 6370997 / (2 * Math.PI),
    degrees: 2 * Math.PI * 6370997 / 360,
    ft: .3048,
    m: 1,
    "us-ft": 1200 / 3937
};
class Projection {
    constructor(i) {
        this.code_ = i.code,
        this.units_ = i.units,
        this.extent_ = i.extent !== void 0 ? i.extent : null,
        this.worldExtent_ = i.worldExtent !== void 0 ? i.worldExtent : null,
        this.axisOrientation_ = i.axisOrientation !== void 0 ? i.axisOrientation : "enu",
        this.global_ = i.global !== void 0 ? i.global : !1,
        this.canWrapX_ = !!(this.global_ && this.extent_),
        this.getPointResolutionFunc_ = i.getPointResolution,
        this.defaultTileGrid_ = null,
        this.metersPerUnit_ = i.metersPerUnit
    }
    canWrapX() {
        return this.canWrapX_
    }
    getCode() {
        return this.code_
    }
    getExtent() {
        return this.extent_
    }
    getUnits() {
        return this.units_
    }
    getMetersPerUnit() {
        return this.metersPerUnit_ || METERS_PER_UNIT$1[this.units_]
    }
    getWorldExtent() {
        return this.worldExtent_
    }
    getAxisOrientation() {
        return this.axisOrientation_
    }
    isGlobal() {
        return this.global_
    }
    setGlobal(i) {
        this.global_ = i,
        this.canWrapX_ = !!(i && this.extent_)
    }
    getDefaultTileGrid() {
        return this.defaultTileGrid_
    }
    setDefaultTileGrid(i) {
        this.defaultTileGrid_ = i
    }
    setExtent(i) {
        this.extent_ = i,
        this.canWrapX_ = !!(this.global_ && i)
    }
    setWorldExtent(i) {
        this.worldExtent_ = i
    }
    setGetPointResolution(i) {
        this.getPointResolutionFunc_ = i
    }
    getPointResolutionFunc() {
        return this.getPointResolutionFunc_
    }
}
const Projection$1 = Projection
  , RADIUS$1 = 6378137
  , HALF_SIZE = Math.PI * RADIUS$1
  , EXTENT$1 = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE]
  , WORLD_EXTENT = [-180, -85, 180, 85]
  , MAX_SAFE_Y = RADIUS$1 * Math.log(Math.tan(Math.PI / 2));
class EPSG3857Projection extends Projection$1 {
    constructor(i) {
        super({
            code: i,
            units: "m",
            extent: EXTENT$1,
            global: !0,
            worldExtent: WORLD_EXTENT,
            getPointResolution: function(s, a) {
                return s / Math.cosh(a[1] / RADIUS$1)
            }
        })
    }
}
const PROJECTIONS$1 = [new EPSG3857Projection("EPSG:3857"), new EPSG3857Projection("EPSG:102100"), new EPSG3857Projection("EPSG:102113"), new EPSG3857Projection("EPSG:900913"), new EPSG3857Projection("http://www.opengis.net/def/crs/EPSG/0/3857"), new EPSG3857Projection("http://www.opengis.net/gml/srs/epsg.xml#3857")];
function fromEPSG4326(o, i, s) {
    const a = o.length;
    s = s > 1 ? s : 2,
    i === void 0 && (s > 2 ? i = o.slice() : i = new Array(a));
    for (let _ = 0; _ < a; _ += s) {
        i[_] = HALF_SIZE * o[_] / 180;
        let $ = RADIUS$1 * Math.log(Math.tan(Math.PI * (+o[_ + 1] + 90) / 360));
        $ > MAX_SAFE_Y ? $ = MAX_SAFE_Y : $ < -MAX_SAFE_Y && ($ = -MAX_SAFE_Y),
        i[_ + 1] = $
    }
    return i
}
function toEPSG4326(o, i, s) {
    const a = o.length;
    s = s > 1 ? s : 2,
    i === void 0 && (s > 2 ? i = o.slice() : i = new Array(a));
    for (let _ = 0; _ < a; _ += s)
        i[_] = 180 * o[_] / HALF_SIZE,
        i[_ + 1] = 360 * Math.atan(Math.exp(o[_ + 1] / RADIUS$1)) / Math.PI - 90;
    return i
}
const RADIUS = 6378137
  , EXTENT = [-180, -90, 180, 90]
  , METERS_PER_UNIT = Math.PI * RADIUS / 180;
class EPSG4326Projection extends Projection$1 {
    constructor(i, s) {
        super({
            code: i,
            units: "degrees",
            extent: EXTENT,
            axisOrientation: s,
            global: !0,
            metersPerUnit: METERS_PER_UNIT,
            worldExtent: EXTENT
        })
    }
}
const PROJECTIONS = [new EPSG4326Projection("CRS:84"), new EPSG4326Projection("EPSG:4326","neu"), new EPSG4326Projection("urn:ogc:def:crs:OGC:1.3:CRS84"), new EPSG4326Projection("urn:ogc:def:crs:OGC:2:84"), new EPSG4326Projection("http://www.opengis.net/def/crs/OGC/1.3/CRS84"), new EPSG4326Projection("http://www.opengis.net/gml/srs/epsg.xml#4326","neu"), new EPSG4326Projection("http://www.opengis.net/def/crs/EPSG/0/4326","neu")];
let cache = {};
function get$3(o) {
    return cache[o] || cache[o.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null
}
function add$2(o, i) {
    cache[o] = i
}
let transforms$1 = {};
function add$1(o, i, s) {
    const a = o.getCode()
      , _ = i.getCode();
    a in transforms$1 || (transforms$1[a] = {}),
    transforms$1[a][_] = s
}
function get$2(o, i) {
    let s;
    return o in transforms$1 && i in transforms$1[o] && (s = transforms$1[o][i]),
    s
}
function compareVersions(o, i) {
    const s = ("" + o).split(".")
      , a = ("" + i).split(".");
    for (let _ = 0; _ < Math.max(s.length, a.length); _++) {
        const $ = parseInt(s[_] || "0", 10)
          , _e = parseInt(a[_] || "0", 10);
        if ($ > _e)
            return 1;
        if (_e > $)
            return -1
    }
    return 0
}
function add(o, i) {
    return o[0] += +i[0],
    o[1] += +i[1],
    o
}
function equals(o, i) {
    let s = !0;
    for (let a = o.length - 1; a >= 0; --a)
        if (o[a] != i[a]) {
            s = !1;
            break
        }
    return s
}
function rotate$1(o, i) {
    const s = Math.cos(i)
      , a = Math.sin(i)
      , _ = o[0] * s - o[1] * a
      , $ = o[1] * s + o[0] * a;
    return o[0] = _,
    o[1] = $,
    o
}
function scale$2(o, i) {
    return o[0] *= i,
    o[1] *= i,
    o
}
function squaredDistance(o, i) {
    const s = o[0] - i[0]
      , a = o[1] - i[1];
    return s * s + a * a
}
function distance(o, i) {
    return Math.sqrt(squaredDistance(o, i))
}
function wrapX$1(o, i) {
    if (i.canWrapX()) {
        const s = getWidth(i.getExtent())
          , a = getWorldsAway(o, i, s);
        a && (o[0] -= a * s)
    }
    return o
}
function getWorldsAway(o, i, s) {
    const a = i.getExtent();
    let _ = 0;
    return i.canWrapX() && (o[0] < a[0] || o[0] > a[2]) && (s = s || getWidth(a),
    _ = Math.floor((o[0] - a[0]) / s)),
    _
}
const DEFAULT_RADIUS = 63710088e-1;
function getDistance(o, i, s) {
    s = s || DEFAULT_RADIUS;
    const a = toRadians(o[1])
      , _ = toRadians(i[1])
      , $ = (_ - a) / 2
      , _e = toRadians(i[0] - o[0]) / 2
      , tt = Math.sin($) * Math.sin($) + Math.sin(_e) * Math.sin(_e) * Math.cos(a) * Math.cos(_);
    return 2 * s * Math.atan2(Math.sqrt(tt), Math.sqrt(1 - tt))
}
const levels = {
    info: 1,
    warn: 2,
    error: 3,
    none: 4
};
let level = levels.info;
function warn(...o) {
    level > levels.warn || console.warn(...o)
}
function error(...o) {
    console.error(...o)
}
let showCoordinateWarning = !0;
function disableCoordinateWarning(o) {
    showCoordinateWarning = !(o === void 0 ? !0 : o)
}
function cloneTransform(o, i) {
    if (i !== void 0) {
        for (let s = 0, a = o.length; s < a; ++s)
            i[s] = o[s];
        i = i
    } else
        i = o.slice();
    return i
}
function identityTransform(o, i) {
    if (i !== void 0 && o !== i) {
        for (let s = 0, a = o.length; s < a; ++s)
            i[s] = o[s];
        o = i
    }
    return o
}
function addProjection(o) {
    add$2(o.getCode(), o),
    add$1(o, o, cloneTransform)
}
function addProjections(o) {
    o.forEach(addProjection)
}
function get$1(o) {
    return typeof o == "string" ? get$3(o) : o || null
}
function getPointResolution(o, i, s, a) {
    o = get$1(o);
    let _;
    const $ = o.getPointResolutionFunc();
    if ($) {
        if (_ = $(i, s),
        a && a !== o.getUnits()) {
            const _e = o.getMetersPerUnit();
            _e && (_ = _ * _e / METERS_PER_UNIT$1[a])
        }
    } else {
        const _e = o.getUnits();
        if (_e == "degrees" && !a || a == "degrees")
            _ = i;
        else {
            const tt = getTransformFromProjections(o, get$1("EPSG:4326"));
            if (tt === identityTransform && _e !== "degrees")
                _ = i * o.getMetersPerUnit();
            else {
                let rt = [s[0] - i / 2, s[1], s[0] + i / 2, s[1], s[0], s[1] - i / 2, s[0], s[1] + i / 2];
                rt = tt(rt, rt, 2);
                const ot = getDistance(rt.slice(0, 2), rt.slice(2, 4))
                  , et = getDistance(rt.slice(4, 6), rt.slice(6, 8));
                _ = (ot + et) / 2
            }
            const nt = a ? METERS_PER_UNIT$1[a] : o.getMetersPerUnit();
            nt !== void 0 && (_ /= nt)
        }
    }
    return _
}
function addEquivalentProjections(o) {
    addProjections(o),
    o.forEach(function(i) {
        o.forEach(function(s) {
            i !== s && add$1(i, s, cloneTransform)
        })
    })
}
function addEquivalentTransforms(o, i, s, a) {
    o.forEach(function(_) {
        i.forEach(function($) {
            add$1(_, $, s),
            add$1($, _, a)
        })
    })
}
function createProjection(o, i) {
    return o ? typeof o == "string" ? get$1(o) : o : get$1(i)
}
function fromLonLat(o, i) {
    return disableCoordinateWarning(),
    transform(o, "EPSG:4326", i !== void 0 ? i : "EPSG:3857")
}
function equivalent(o, i) {
    if (o === i)
        return !0;
    const s = o.getUnits() === i.getUnits();
    return (o.getCode() === i.getCode() || getTransformFromProjections(o, i) === cloneTransform) && s
}
function getTransformFromProjections(o, i) {
    const s = o.getCode()
      , a = i.getCode();
    let _ = get$2(s, a);
    return _ || (_ = identityTransform),
    _
}
function getTransform(o, i) {
    const s = get$1(o)
      , a = get$1(i);
    return getTransformFromProjections(s, a)
}
function transform(o, i, s) {
    return getTransform(i, s)(o, void 0, o.length)
}
function transformExtent(o, i, s, a) {
    const _ = getTransform(i, s);
    return applyTransform(o, _, void 0, a)
}
function toUserCoordinate(o, i) {
    return o
}
function fromUserCoordinate(o, i) {
    return showCoordinateWarning && !equals(o, [0, 0]) && o[0] >= -180 && o[0] <= 180 && o[1] >= -90 && o[1] <= 90 && (showCoordinateWarning = !1,
    warn("Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates.")),
    o
}
function toUserExtent(o, i) {
    return o
}
function fromUserExtent(o, i) {
    return o
}
function addCommon() {
    addEquivalentProjections(PROJECTIONS$1),
    addEquivalentProjections(PROJECTIONS),
    addEquivalentTransforms(PROJECTIONS, PROJECTIONS$1, fromEPSG4326, toEPSG4326)
}
addCommon();
function createExtent(o, i, s) {
    return function(a, _, $, _e, tt) {
        if (!a)
            return;
        if (!_ && !i)
            return a;
        const nt = i ? 0 : $[0] * _
          , rt = i ? 0 : $[1] * _
          , ot = tt ? tt[0] : 0
          , et = tt ? tt[1] : 0;
        let j = o[0] + nt / 2 + ot
          , it = o[2] - nt / 2 + ot
          , st = o[1] + rt / 2 + et
          , at = o[3] - rt / 2 + et;
        j > it && (j = (it + j) / 2,
        it = j),
        st > at && (st = (at + st) / 2,
        at = st);
        let lt = clamp(a[0], j, it)
          , ct = clamp(a[1], st, at);
        if (_e && s && _) {
            const ut = 30 * _;
            lt += -ut * Math.log(1 + Math.max(0, j - a[0]) / ut) + ut * Math.log(1 + Math.max(0, a[0] - it) / ut),
            ct += -ut * Math.log(1 + Math.max(0, st - a[1]) / ut) + ut * Math.log(1 + Math.max(0, a[1] - at) / ut)
        }
        return [lt, ct]
    }
}
function none$1(o) {
    return o
}
function getViewportClampedResolution(o, i, s, a) {
    const _ = getWidth(i) / s[0]
      , $ = getHeight(i) / s[1];
    return a ? Math.min(o, Math.max(_, $)) : Math.min(o, Math.min(_, $))
}
function getSmoothClampedResolution(o, i, s) {
    let a = Math.min(o, i);
    const _ = 50;
    return a *= Math.log(1 + _ * Math.max(0, o / i - 1)) / _ + 1,
    s && (a = Math.max(a, s),
    a /= Math.log(1 + _ * Math.max(0, s / o - 1)) / _ + 1),
    clamp(a, s / 2, i * 2)
}
function createSnapToResolutions(o, i, s, a) {
    return i = i !== void 0 ? i : !0,
    function(_, $, _e, tt) {
        if (_ !== void 0) {
            const nt = o[0]
              , rt = o[o.length - 1]
              , ot = s ? getViewportClampedResolution(nt, s, _e, a) : nt;
            if (tt)
                return i ? getSmoothClampedResolution(_, ot, rt) : clamp(_, rt, ot);
            const et = Math.min(ot, _)
              , j = Math.floor(linearFindNearest(o, et, $));
            return o[j] > ot && j < o.length - 1 ? o[j + 1] : o[j]
        }
    }
}
function createSnapToPower(o, i, s, a, _, $) {
    return a = a !== void 0 ? a : !0,
    s = s !== void 0 ? s : 0,
    function(_e, tt, nt, rt) {
        if (_e !== void 0) {
            const ot = _ ? getViewportClampedResolution(i, _, nt, $) : i;
            if (rt)
                return a ? getSmoothClampedResolution(_e, ot, s) : clamp(_e, s, ot);
            const et = 1e-9
              , j = Math.ceil(Math.log(i / ot) / Math.log(o) - et)
              , it = -tt * (.5 - et) + .5
              , st = Math.min(ot, _e)
              , at = Math.floor(Math.log(i / st) / Math.log(o) + it)
              , lt = Math.max(j, at)
              , ct = i / Math.pow(o, lt);
            return clamp(ct, s, ot)
        }
    }
}
function createMinMaxResolution(o, i, s, a, _) {
    return s = s !== void 0 ? s : !0,
    function($, _e, tt, nt) {
        if ($ !== void 0) {
            const rt = a ? getViewportClampedResolution(o, a, tt, _) : o;
            return !s || !nt ? clamp($, i, rt) : getSmoothClampedResolution($, rt, i)
        }
    }
}
function disable(o) {
    if (o !== void 0)
        return 0
}
function none(o) {
    if (o !== void 0)
        return o
}
function createSnapToN(o) {
    const i = 2 * Math.PI / o;
    return function(s, a) {
        if (a)
            return s;
        if (s !== void 0)
            return s = Math.floor(s / i + .5) * i,
            s
    }
}
function createSnapToZero(o) {
    return o = o || toRadians(5),
    function(i, s) {
        if (s)
            return i;
        if (i !== void 0)
            return Math.abs(i) <= o ? 0 : i
    }
}
function easeIn(o) {
    return Math.pow(o, 3)
}
function easeOut(o) {
    return 1 - easeIn(1 - o)
}
function inAndOut(o) {
    return 3 * o * o - 2 * o * o * o
}
function linear(o) {
    return o
}
function transform2D(o, i, s, a, _, $) {
    $ = $ || [];
    let _e = 0;
    for (let tt = i; tt < s; tt += a) {
        const nt = o[tt]
          , rt = o[tt + 1];
        $[_e++] = _[0] * nt + _[2] * rt + _[4],
        $[_e++] = _[1] * nt + _[3] * rt + _[5]
    }
    return $ && $.length != _e && ($.length = _e),
    $
}
function rotate(o, i, s, a, _, $, _e) {
    _e = _e || [];
    const tt = Math.cos(_)
      , nt = Math.sin(_)
      , rt = $[0]
      , ot = $[1];
    let et = 0;
    for (let j = i; j < s; j += a) {
        const it = o[j] - rt
          , st = o[j + 1] - ot;
        _e[et++] = rt + it * tt - st * nt,
        _e[et++] = ot + it * nt + st * tt;
        for (let at = j + 2; at < j + a; ++at)
            _e[et++] = o[at]
    }
    return _e && _e.length != et && (_e.length = et),
    _e
}
function scale$1(o, i, s, a, _, $, _e, tt) {
    tt = tt || [];
    const nt = _e[0]
      , rt = _e[1];
    let ot = 0;
    for (let et = i; et < s; et += a) {
        const j = o[et] - nt
          , it = o[et + 1] - rt;
        tt[ot++] = nt + _ * j,
        tt[ot++] = rt + $ * it;
        for (let st = et + 2; st < et + a; ++st)
            tt[ot++] = o[st]
    }
    return tt && tt.length != ot && (tt.length = ot),
    tt
}
function translate(o, i, s, a, _, $, _e) {
    _e = _e || [];
    let tt = 0;
    for (let nt = i; nt < s; nt += a) {
        _e[tt++] = o[nt] + _,
        _e[tt++] = o[nt + 1] + $;
        for (let rt = nt + 2; rt < nt + a; ++rt)
            _e[tt++] = o[rt]
    }
    return _e && _e.length != tt && (_e.length = tt),
    _e
}
const tmpTransform = create$1();
class Geometry extends BaseObject$1 {
    constructor() {
        super(),
        this.extent_ = createEmpty(),
        this.extentRevision_ = -1,
        this.simplifiedGeometryMaxMinSquaredTolerance = 0,
        this.simplifiedGeometryRevision = 0,
        this.simplifyTransformedInternal = memoizeOne(function(i, s, a) {
            if (!a)
                return this.getSimplifiedGeometry(s);
            const _ = this.clone();
            return _.applyTransform(a),
            _.getSimplifiedGeometry(s)
        })
    }
    simplifyTransformed(i, s) {
        return this.simplifyTransformedInternal(this.getRevision(), i, s)
    }
    clone() {
        return abstract()
    }
    closestPointXY(i, s, a, _) {
        return abstract()
    }
    containsXY(i, s) {
        const a = this.getClosestPoint([i, s]);
        return a[0] === i && a[1] === s
    }
    getClosestPoint(i, s) {
        return s = s || [NaN, NaN],
        this.closestPointXY(i[0], i[1], s, 1 / 0),
        s
    }
    intersectsCoordinate(i) {
        return this.containsXY(i[0], i[1])
    }
    computeExtent(i) {
        return abstract()
    }
    getExtent(i) {
        if (this.extentRevision_ != this.getRevision()) {
            const s = this.computeExtent(this.extent_);
            (isNaN(s[0]) || isNaN(s[1])) && createOrUpdateEmpty(s),
            this.extentRevision_ = this.getRevision()
        }
        return returnOrUpdate(this.extent_, i)
    }
    rotate(i, s) {
        abstract()
    }
    scale(i, s, a) {
        abstract()
    }
    simplify(i) {
        return this.getSimplifiedGeometry(i * i)
    }
    getSimplifiedGeometry(i) {
        return abstract()
    }
    getType() {
        return abstract()
    }
    applyTransform(i) {
        abstract()
    }
    intersectsExtent(i) {
        return abstract()
    }
    translate(i, s) {
        abstract()
    }
    transform(i, s) {
        const a = get$1(i)
          , _ = a.getUnits() == "tile-pixels" ? function($, _e, tt) {
            const nt = a.getExtent()
              , rt = a.getWorldExtent()
              , ot = getHeight(rt) / getHeight(nt);
            return compose(tmpTransform, rt[0], rt[3], ot, -ot, 0, 0, 0),
            transform2D($, 0, $.length, tt, tmpTransform, _e),
            getTransform(a, s)($, _e, tt)
        }
        : getTransform(a, s);
        return this.applyTransform(_),
        this
    }
}
const Geometry$1 = Geometry;
class SimpleGeometry extends Geometry$1 {
    constructor() {
        super(),
        this.layout = "XY",
        this.stride = 2,
        this.flatCoordinates = null
    }
    computeExtent(i) {
        return createOrUpdateFromFlatCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, i)
    }
    getCoordinates() {
        return abstract()
    }
    getFirstCoordinate() {
        return this.flatCoordinates.slice(0, this.stride)
    }
    getFlatCoordinates() {
        return this.flatCoordinates
    }
    getLastCoordinate() {
        return this.flatCoordinates.slice(this.flatCoordinates.length - this.stride)
    }
    getLayout() {
        return this.layout
    }
    getSimplifiedGeometry(i) {
        if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0,
        this.simplifiedGeometryRevision = this.getRevision()),
        i < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && i <= this.simplifiedGeometryMaxMinSquaredTolerance)
            return this;
        const s = this.getSimplifiedGeometryInternal(i);
        return s.getFlatCoordinates().length < this.flatCoordinates.length ? s : (this.simplifiedGeometryMaxMinSquaredTolerance = i,
        this)
    }
    getSimplifiedGeometryInternal(i) {
        return this
    }
    getStride() {
        return this.stride
    }
    setFlatCoordinates(i, s) {
        this.stride = getStrideForLayout(i),
        this.layout = i,
        this.flatCoordinates = s
    }
    setCoordinates(i, s) {
        abstract()
    }
    setLayout(i, s, a) {
        let _;
        if (i)
            _ = getStrideForLayout(i);
        else {
            for (let $ = 0; $ < a; ++$) {
                if (s.length === 0) {
                    this.layout = "XY",
                    this.stride = 2;
                    return
                }
                s = s[0]
            }
            _ = s.length,
            i = getLayoutForStride(_)
        }
        this.layout = i,
        this.stride = _
    }
    applyTransform(i) {
        this.flatCoordinates && (i(this.flatCoordinates, this.flatCoordinates, this.stride),
        this.changed())
    }
    rotate(i, s) {
        const a = this.getFlatCoordinates();
        if (a) {
            const _ = this.getStride();
            rotate(a, 0, a.length, _, i, s, a),
            this.changed()
        }
    }
    scale(i, s, a) {
        s === void 0 && (s = i),
        a || (a = getCenter(this.getExtent()));
        const _ = this.getFlatCoordinates();
        if (_) {
            const $ = this.getStride();
            scale$1(_, 0, _.length, $, i, s, a, _),
            this.changed()
        }
    }
    translate(i, s) {
        const a = this.getFlatCoordinates();
        if (a) {
            const _ = this.getStride();
            translate(a, 0, a.length, _, i, s, a),
            this.changed()
        }
    }
}
function getLayoutForStride(o) {
    let i;
    return o == 2 ? i = "XY" : o == 3 ? i = "XYZ" : o == 4 && (i = "XYZM"),
    i
}
function getStrideForLayout(o) {
    let i;
    return o == "XY" ? i = 2 : o == "XYZ" || o == "XYM" ? i = 3 : o == "XYZM" && (i = 4),
    i
}
function transformGeom2D(o, i, s) {
    const a = o.getFlatCoordinates();
    if (!a)
        return null;
    const _ = o.getStride();
    return transform2D(a, 0, a.length, _, i, s)
}
function assignClosest(o, i, s, a, _, $, _e) {
    const tt = o[i]
      , nt = o[i + 1]
      , rt = o[s] - tt
      , ot = o[s + 1] - nt;
    let et;
    if (rt === 0 && ot === 0)
        et = i;
    else {
        const j = ((_ - tt) * rt + ($ - nt) * ot) / (rt * rt + ot * ot);
        if (j > 1)
            et = s;
        else if (j > 0) {
            for (let it = 0; it < a; ++it)
                _e[it] = lerp$1(o[i + it], o[s + it], j);
            _e.length = a;
            return
        } else
            et = i
    }
    for (let j = 0; j < a; ++j)
        _e[j] = o[et + j];
    _e.length = a
}
function maxSquaredDelta(o, i, s, a, _) {
    let $ = o[i]
      , _e = o[i + 1];
    for (i += a; i < s; i += a) {
        const tt = o[i]
          , nt = o[i + 1]
          , rt = squaredDistance$1($, _e, tt, nt);
        rt > _ && (_ = rt),
        $ = tt,
        _e = nt
    }
    return _
}
function arrayMaxSquaredDelta(o, i, s, a, _) {
    for (let $ = 0, _e = s.length; $ < _e; ++$) {
        const tt = s[$];
        _ = maxSquaredDelta(o, i, tt, a, _),
        i = tt
    }
    return _
}
function multiArrayMaxSquaredDelta(o, i, s, a, _) {
    for (let $ = 0, _e = s.length; $ < _e; ++$) {
        const tt = s[$];
        _ = arrayMaxSquaredDelta(o, i, tt, a, _),
        i = tt[tt.length - 1]
    }
    return _
}
function assignClosestPoint(o, i, s, a, _, $, _e, tt, nt, rt, ot) {
    if (i == s)
        return rt;
    let et, j;
    if (_ === 0) {
        if (j = squaredDistance$1(_e, tt, o[i], o[i + 1]),
        j < rt) {
            for (et = 0; et < a; ++et)
                nt[et] = o[i + et];
            return nt.length = a,
            j
        }
        return rt
    }
    ot = ot || [NaN, NaN];
    let it = i + a;
    for (; it < s; )
        if (assignClosest(o, it - a, it, a, _e, tt, ot),
        j = squaredDistance$1(_e, tt, ot[0], ot[1]),
        j < rt) {
            for (rt = j,
            et = 0; et < a; ++et)
                nt[et] = ot[et];
            nt.length = a,
            it += a
        } else
            it += a * Math.max((Math.sqrt(j) - Math.sqrt(rt)) / _ | 0, 1);
    if ($ && (assignClosest(o, s - a, i, a, _e, tt, ot),
    j = squaredDistance$1(_e, tt, ot[0], ot[1]),
    j < rt)) {
        for (rt = j,
        et = 0; et < a; ++et)
            nt[et] = ot[et];
        nt.length = a
    }
    return rt
}
function assignClosestArrayPoint(o, i, s, a, _, $, _e, tt, nt, rt, ot) {
    ot = ot || [NaN, NaN];
    for (let et = 0, j = s.length; et < j; ++et) {
        const it = s[et];
        rt = assignClosestPoint(o, i, it, a, _, $, _e, tt, nt, rt, ot),
        i = it
    }
    return rt
}
function assignClosestMultiArrayPoint(o, i, s, a, _, $, _e, tt, nt, rt, ot) {
    ot = ot || [NaN, NaN];
    for (let et = 0, j = s.length; et < j; ++et) {
        const it = s[et];
        rt = assignClosestArrayPoint(o, i, it, a, _, $, _e, tt, nt, rt, ot),
        i = it[it.length - 1]
    }
    return rt
}
function deflateCoordinate(o, i, s, a) {
    for (let _ = 0, $ = s.length; _ < $; ++_)
        o[i++] = s[_];
    return i
}
function deflateCoordinates(o, i, s, a) {
    for (let _ = 0, $ = s.length; _ < $; ++_) {
        const _e = s[_];
        for (let tt = 0; tt < a; ++tt)
            o[i++] = _e[tt]
    }
    return i
}
function deflateCoordinatesArray(o, i, s, a, _) {
    _ = _ || [];
    let $ = 0;
    for (let _e = 0, tt = s.length; _e < tt; ++_e) {
        const nt = deflateCoordinates(o, i, s[_e], a);
        _[$++] = nt,
        i = nt
    }
    return _.length = $,
    _
}
function deflateMultiCoordinatesArray(o, i, s, a, _) {
    _ = _ || [];
    let $ = 0;
    for (let _e = 0, tt = s.length; _e < tt; ++_e) {
        const nt = deflateCoordinatesArray(o, i, s[_e], a, _[$]);
        nt.length === 0 && (nt[0] = i),
        _[$++] = nt,
        i = nt[nt.length - 1]
    }
    return _.length = $,
    _
}
function douglasPeucker(o, i, s, a, _, $, _e) {
    const tt = (s - i) / a;
    if (tt < 3) {
        for (; i < s; i += a)
            $[_e++] = o[i],
            $[_e++] = o[i + 1];
        return _e
    }
    const nt = new Array(tt);
    nt[0] = 1,
    nt[tt - 1] = 1;
    const rt = [i, s - a];
    let ot = 0;
    for (; rt.length > 0; ) {
        const et = rt.pop()
          , j = rt.pop();
        let it = 0;
        const st = o[j]
          , at = o[j + 1]
          , lt = o[et]
          , ct = o[et + 1];
        for (let ut = j + a; ut < et; ut += a) {
            const dt = o[ut]
              , ft = o[ut + 1]
              , ht = squaredSegmentDistance(dt, ft, st, at, lt, ct);
            ht > it && (ot = ut,
            it = ht)
        }
        it > _ && (nt[(ot - i) / a] = 1,
        j + a < ot && rt.push(j, ot),
        ot + a < et && rt.push(ot, et))
    }
    for (let et = 0; et < tt; ++et)
        nt[et] && ($[_e++] = o[i + et * a],
        $[_e++] = o[i + et * a + 1]);
    return _e
}
function douglasPeuckerArray(o, i, s, a, _, $, _e, tt) {
    for (let nt = 0, rt = s.length; nt < rt; ++nt) {
        const ot = s[nt];
        _e = douglasPeucker(o, i, ot, a, _, $, _e),
        tt.push(_e),
        i = ot
    }
    return _e
}
function snap(o, i) {
    return i * Math.round(o / i)
}
function quantize(o, i, s, a, _, $, _e) {
    if (i == s)
        return _e;
    let tt = snap(o[i], _)
      , nt = snap(o[i + 1], _);
    i += a,
    $[_e++] = tt,
    $[_e++] = nt;
    let rt, ot;
    do
        if (rt = snap(o[i], _),
        ot = snap(o[i + 1], _),
        i += a,
        i == s)
            return $[_e++] = rt,
            $[_e++] = ot,
            _e;
    while (rt == tt && ot == nt);
    for (; i < s; ) {
        const et = snap(o[i], _)
          , j = snap(o[i + 1], _);
        if (i += a,
        et == rt && j == ot)
            continue;
        const it = rt - tt
          , st = ot - nt
          , at = et - tt
          , lt = j - nt;
        if (it * lt == st * at && (it < 0 && at < it || it == at || it > 0 && at > it) && (st < 0 && lt < st || st == lt || st > 0 && lt > st)) {
            rt = et,
            ot = j;
            continue
        }
        $[_e++] = rt,
        $[_e++] = ot,
        tt = rt,
        nt = ot,
        rt = et,
        ot = j
    }
    return $[_e++] = rt,
    $[_e++] = ot,
    _e
}
function quantizeArray(o, i, s, a, _, $, _e, tt) {
    for (let nt = 0, rt = s.length; nt < rt; ++nt) {
        const ot = s[nt];
        _e = quantize(o, i, ot, a, _, $, _e),
        tt.push(_e),
        i = ot
    }
    return _e
}
function quantizeMultiArray(o, i, s, a, _, $, _e, tt) {
    for (let nt = 0, rt = s.length; nt < rt; ++nt) {
        const ot = s[nt]
          , et = [];
        _e = quantizeArray(o, i, ot, a, _, $, _e, et),
        tt.push(et),
        i = ot[ot.length - 1]
    }
    return _e
}
function inflateCoordinates(o, i, s, a, _) {
    _ = _ !== void 0 ? _ : [];
    let $ = 0;
    for (let _e = i; _e < s; _e += a)
        _[$++] = o.slice(_e, _e + a);
    return _.length = $,
    _
}
function inflateCoordinatesArray(o, i, s, a, _) {
    _ = _ !== void 0 ? _ : [];
    let $ = 0;
    for (let _e = 0, tt = s.length; _e < tt; ++_e) {
        const nt = s[_e];
        _[$++] = inflateCoordinates(o, i, nt, a, _[$]),
        i = nt
    }
    return _.length = $,
    _
}
function inflateMultiCoordinatesArray(o, i, s, a, _) {
    _ = _ !== void 0 ? _ : [];
    let $ = 0;
    for (let _e = 0, tt = s.length; _e < tt; ++_e) {
        const nt = s[_e];
        _[$++] = nt.length === 1 && nt[0] === i ? [] : inflateCoordinatesArray(o, i, nt, a, _[$]),
        i = nt[nt.length - 1]
    }
    return _.length = $,
    _
}
function linearRing(o, i, s, a) {
    let _ = 0
      , $ = o[s - a]
      , _e = o[s - a + 1];
    for (; i < s; i += a) {
        const tt = o[i]
          , nt = o[i + 1];
        _ += _e * tt - $ * nt,
        $ = tt,
        _e = nt
    }
    return _ / 2
}
function linearRings(o, i, s, a) {
    let _ = 0;
    for (let $ = 0, _e = s.length; $ < _e; ++$) {
        const tt = s[$];
        _ += linearRing(o, i, tt, a),
        i = tt
    }
    return _
}
function linearRingss$1(o, i, s, a) {
    let _ = 0;
    for (let $ = 0, _e = s.length; $ < _e; ++$) {
        const tt = s[$];
        _ += linearRings(o, i, tt, a),
        i = tt[tt.length - 1]
    }
    return _
}
class LinearRing extends SimpleGeometry {
    constructor(i, s) {
        super(),
        this.maxDelta_ = -1,
        this.maxDeltaRevision_ = -1,
        s !== void 0 && !Array.isArray(i[0]) ? this.setFlatCoordinates(s, i) : this.setCoordinates(i, s)
    }
    clone() {
        return new LinearRing(this.flatCoordinates.slice(),this.layout)
    }
    closestPointXY(i, s, a, _) {
        return _ < closestSquaredDistanceXY(this.getExtent(), i, s) ? _ : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0)),
        this.maxDeltaRevision_ = this.getRevision()),
        assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, !0, i, s, a, _))
    }
    getArea() {
        return linearRing(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride)
    }
    getCoordinates() {
        return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride)
    }
    getSimplifiedGeometryInternal(i) {
        const s = [];
        return s.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, i, s, 0),
        new LinearRing(s,"XY")
    }
    getType() {
        return "LinearRing"
    }
    intersectsExtent(i) {
        return !1
    }
    setCoordinates(i, s) {
        this.setLayout(s, i, 1),
        this.flatCoordinates || (this.flatCoordinates = []),
        this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, i, this.stride),
        this.changed()
    }
}
const LinearRing$1 = LinearRing;
class Point extends SimpleGeometry {
    constructor(i, s) {
        super(),
        this.setCoordinates(i, s)
    }
    clone() {
        const i = new Point(this.flatCoordinates.slice(),this.layout);
        return i.applyProperties(this),
        i
    }
    closestPointXY(i, s, a, _) {
        const $ = this.flatCoordinates
          , _e = squaredDistance$1(i, s, $[0], $[1]);
        if (_e < _) {
            const tt = this.stride;
            for (let nt = 0; nt < tt; ++nt)
                a[nt] = $[nt];
            return a.length = tt,
            _e
        }
        return _
    }
    getCoordinates() {
        return this.flatCoordinates ? this.flatCoordinates.slice() : []
    }
    computeExtent(i) {
        return createOrUpdateFromCoordinate(this.flatCoordinates, i)
    }
    getType() {
        return "Point"
    }
    intersectsExtent(i) {
        return containsXY(i, this.flatCoordinates[0], this.flatCoordinates[1])
    }
    setCoordinates(i, s) {
        this.setLayout(s, i, 0),
        this.flatCoordinates || (this.flatCoordinates = []),
        this.flatCoordinates.length = deflateCoordinate(this.flatCoordinates, 0, i, this.stride),
        this.changed()
    }
}
const Point$1 = Point;
function linearRingContainsExtent(o, i, s, a, _) {
    return !forEachCorner(_, function(_e) {
        return !linearRingContainsXY(o, i, s, a, _e[0], _e[1])
    })
}
function linearRingContainsXY(o, i, s, a, _, $) {
    let _e = 0
      , tt = o[s - a]
      , nt = o[s - a + 1];
    for (; i < s; i += a) {
        const rt = o[i]
          , ot = o[i + 1];
        nt <= $ ? ot > $ && (rt - tt) * ($ - nt) - (_ - tt) * (ot - nt) > 0 && _e++ : ot <= $ && (rt - tt) * ($ - nt) - (_ - tt) * (ot - nt) < 0 && _e--,
        tt = rt,
        nt = ot
    }
    return _e !== 0
}
function linearRingsContainsXY(o, i, s, a, _, $) {
    if (s.length === 0 || !linearRingContainsXY(o, i, s[0], a, _, $))
        return !1;
    for (let _e = 1, tt = s.length; _e < tt; ++_e)
        if (linearRingContainsXY(o, s[_e - 1], s[_e], a, _, $))
            return !1;
    return !0
}
function linearRingssContainsXY(o, i, s, a, _, $) {
    if (s.length === 0)
        return !1;
    for (let _e = 0, tt = s.length; _e < tt; ++_e) {
        const nt = s[_e];
        if (linearRingsContainsXY(o, i, nt, a, _, $))
            return !0;
        i = nt[nt.length - 1]
    }
    return !1
}
function getInteriorPointOfArray(o, i, s, a, _, $, _e) {
    let tt, nt, rt, ot, et, j, it;
    const st = _[$ + 1]
      , at = [];
    for (let ut = 0, dt = s.length; ut < dt; ++ut) {
        const ft = s[ut];
        for (ot = o[ft - a],
        j = o[ft - a + 1],
        tt = i; tt < ft; tt += a)
            et = o[tt],
            it = o[tt + 1],
            (st <= j && it <= st || j <= st && st <= it) && (rt = (st - j) / (it - j) * (et - ot) + ot,
            at.push(rt)),
            ot = et,
            j = it
    }
    let lt = NaN
      , ct = -1 / 0;
    for (at.sort(ascending),
    ot = at[0],
    tt = 1,
    nt = at.length; tt < nt; ++tt) {
        et = at[tt];
        const ut = Math.abs(et - ot);
        ut > ct && (rt = (ot + et) / 2,
        linearRingsContainsXY(o, i, s, a, rt, st) && (lt = rt,
        ct = ut)),
        ot = et
    }
    return isNaN(lt) && (lt = _[$]),
    _e ? (_e.push(lt, st, ct),
    _e) : [lt, st, ct]
}
function getInteriorPointsOfMultiArray(o, i, s, a, _) {
    let $ = [];
    for (let _e = 0, tt = s.length; _e < tt; ++_e) {
        const nt = s[_e];
        $ = getInteriorPointOfArray(o, i, nt, a, _, 2 * _e, $),
        i = nt[nt.length - 1]
    }
    return $
}
function forEach(o, i, s, a, _) {
    let $;
    for (i += a; i < s; i += a)
        if ($ = _(o.slice(i - a, i), o.slice(i, i + a)),
        $)
            return $;
    return !1
}
function intersectsLineString(o, i, s, a, _) {
    const $ = extendFlatCoordinates(createEmpty(), o, i, s, a);
    return intersects$1(_, $) ? containsExtent(_, $) || $[0] >= _[0] && $[2] <= _[2] || $[1] >= _[1] && $[3] <= _[3] ? !0 : forEach(o, i, s, a, function(_e, tt) {
        return intersectsSegment(_, _e, tt)
    }) : !1
}
function intersectsLineStringArray(o, i, s, a, _) {
    for (let $ = 0, _e = s.length; $ < _e; ++$) {
        if (intersectsLineString(o, i, s[$], a, _))
            return !0;
        i = s[$]
    }
    return !1
}
function intersectsLinearRing(o, i, s, a, _) {
    return !!(intersectsLineString(o, i, s, a, _) || linearRingContainsXY(o, i, s, a, _[0], _[1]) || linearRingContainsXY(o, i, s, a, _[0], _[3]) || linearRingContainsXY(o, i, s, a, _[2], _[1]) || linearRingContainsXY(o, i, s, a, _[2], _[3]))
}
function intersectsLinearRingArray(o, i, s, a, _) {
    if (!intersectsLinearRing(o, i, s[0], a, _))
        return !1;
    if (s.length === 1)
        return !0;
    for (let $ = 1, _e = s.length; $ < _e; ++$)
        if (linearRingContainsExtent(o, s[$ - 1], s[$], a, _) && !intersectsLineString(o, s[$ - 1], s[$], a, _))
            return !1;
    return !0
}
function intersectsLinearRingMultiArray(o, i, s, a, _) {
    for (let $ = 0, _e = s.length; $ < _e; ++$) {
        const tt = s[$];
        if (intersectsLinearRingArray(o, i, tt, a, _))
            return !0;
        i = tt[tt.length - 1]
    }
    return !1
}
function coordinates(o, i, s, a) {
    for (; i < s - a; ) {
        for (let _ = 0; _ < a; ++_) {
            const $ = o[i + _];
            o[i + _] = o[s - a + _],
            o[s - a + _] = $
        }
        i += a,
        s -= a
    }
}
function linearRingIsClockwise(o, i, s, a) {
    let _ = 0
      , $ = o[s - a]
      , _e = o[s - a + 1];
    for (; i < s; i += a) {
        const tt = o[i]
          , nt = o[i + 1];
        _ += (tt - $) * (nt + _e),
        $ = tt,
        _e = nt
    }
    return _ === 0 ? void 0 : _ > 0
}
function linearRingsAreOriented(o, i, s, a, _) {
    _ = _ !== void 0 ? _ : !1;
    for (let $ = 0, _e = s.length; $ < _e; ++$) {
        const tt = s[$]
          , nt = linearRingIsClockwise(o, i, tt, a);
        if ($ === 0) {
            if (_ && nt || !_ && !nt)
                return !1
        } else if (_ && !nt || !_ && nt)
            return !1;
        i = tt
    }
    return !0
}
function linearRingssAreOriented(o, i, s, a, _) {
    for (let $ = 0, _e = s.length; $ < _e; ++$) {
        const tt = s[$];
        if (!linearRingsAreOriented(o, i, tt, a, _))
            return !1;
        tt.length && (i = tt[tt.length - 1])
    }
    return !0
}
function orientLinearRings(o, i, s, a, _) {
    _ = _ !== void 0 ? _ : !1;
    for (let $ = 0, _e = s.length; $ < _e; ++$) {
        const tt = s[$]
          , nt = linearRingIsClockwise(o, i, tt, a);
        ($ === 0 ? _ && nt || !_ && !nt : _ && !nt || !_ && nt) && coordinates(o, i, tt, a),
        i = tt
    }
    return i
}
function orientLinearRingsArray(o, i, s, a, _) {
    for (let $ = 0, _e = s.length; $ < _e; ++$)
        i = orientLinearRings(o, i, s[$], a, _);
    return i
}
class Polygon extends SimpleGeometry {
    constructor(i, s, a) {
        super(),
        this.ends_ = [],
        this.flatInteriorPointRevision_ = -1,
        this.flatInteriorPoint_ = null,
        this.maxDelta_ = -1,
        this.maxDeltaRevision_ = -1,
        this.orientedRevision_ = -1,
        this.orientedFlatCoordinates_ = null,
        s !== void 0 && a ? (this.setFlatCoordinates(s, i),
        this.ends_ = a) : this.setCoordinates(i, s)
    }
    appendLinearRing(i) {
        this.flatCoordinates ? extend$2(this.flatCoordinates, i.getFlatCoordinates()) : this.flatCoordinates = i.getFlatCoordinates().slice(),
        this.ends_.push(this.flatCoordinates.length),
        this.changed()
    }
    clone() {
        const i = new Polygon(this.flatCoordinates.slice(),this.layout,this.ends_.slice());
        return i.applyProperties(this),
        i
    }
    closestPointXY(i, s, a, _) {
        return _ < closestSquaredDistanceXY(this.getExtent(), i, s) ? _ : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0)),
        this.maxDeltaRevision_ = this.getRevision()),
        assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, !0, i, s, a, _))
    }
    containsXY(i, s) {
        return linearRingsContainsXY(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, i, s)
    }
    getArea() {
        return linearRings(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride)
    }
    getCoordinates(i) {
        let s;
        return i !== void 0 ? (s = this.getOrientedFlatCoordinates().slice(),
        orientLinearRings(s, 0, this.ends_, this.stride, i)) : s = this.flatCoordinates,
        inflateCoordinatesArray(s, 0, this.ends_, this.stride)
    }
    getEnds() {
        return this.ends_
    }
    getFlatInteriorPoint() {
        if (this.flatInteriorPointRevision_ != this.getRevision()) {
            const i = getCenter(this.getExtent());
            this.flatInteriorPoint_ = getInteriorPointOfArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, i, 0),
            this.flatInteriorPointRevision_ = this.getRevision()
        }
        return this.flatInteriorPoint_
    }
    getInteriorPoint() {
        return new Point$1(this.getFlatInteriorPoint(),"XYM")
    }
    getLinearRingCount() {
        return this.ends_.length
    }
    getLinearRing(i) {
        return i < 0 || this.ends_.length <= i ? null : new LinearRing$1(this.flatCoordinates.slice(i === 0 ? 0 : this.ends_[i - 1], this.ends_[i]),this.layout)
    }
    getLinearRings() {
        const i = this.layout
          , s = this.flatCoordinates
          , a = this.ends_
          , _ = [];
        let $ = 0;
        for (let _e = 0, tt = a.length; _e < tt; ++_e) {
            const nt = a[_e]
              , rt = new LinearRing$1(s.slice($, nt),i);
            _.push(rt),
            $ = nt
        }
        return _
    }
    getOrientedFlatCoordinates() {
        if (this.orientedRevision_ != this.getRevision()) {
            const i = this.flatCoordinates;
            linearRingsAreOriented(i, 0, this.ends_, this.stride) ? this.orientedFlatCoordinates_ = i : (this.orientedFlatCoordinates_ = i.slice(),
            this.orientedFlatCoordinates_.length = orientLinearRings(this.orientedFlatCoordinates_, 0, this.ends_, this.stride)),
            this.orientedRevision_ = this.getRevision()
        }
        return this.orientedFlatCoordinates_
    }
    getSimplifiedGeometryInternal(i) {
        const s = []
          , a = [];
        return s.length = quantizeArray(this.flatCoordinates, 0, this.ends_, this.stride, Math.sqrt(i), s, 0, a),
        new Polygon(s,"XY",a)
    }
    getType() {
        return "Polygon"
    }
    intersectsExtent(i) {
        return intersectsLinearRingArray(this.getOrientedFlatCoordinates(), 0, this.ends_, this.stride, i)
    }
    setCoordinates(i, s) {
        this.setLayout(s, i, 2),
        this.flatCoordinates || (this.flatCoordinates = []);
        const a = deflateCoordinatesArray(this.flatCoordinates, 0, i, this.stride, this.ends_);
        this.flatCoordinates.length = a.length === 0 ? 0 : a[a.length - 1],
        this.changed()
    }
}
const Polygon$1 = Polygon;
function fromExtent(o) {
    if (isEmpty(o))
        throw new Error("Cannot create polygon from empty extent");
    const i = o[0]
      , s = o[1]
      , a = o[2]
      , _ = o[3]
      , $ = [i, s, i, _, a, _, a, s, i, s];
    return new Polygon($,"XY",[$.length])
}
const DEFAULT_MIN_ZOOM = 0;
class View extends BaseObject$1 {
    constructor(i) {
        super(),
        this.on,
        this.once,
        this.un,
        i = Object.assign({}, i),
        this.hints_ = [0, 0],
        this.animations_ = [],
        this.updateAnimationKey_,
        this.projection_ = createProjection(i.projection, "EPSG:3857"),
        this.viewportSize_ = [100, 100],
        this.targetCenter_ = null,
        this.targetResolution_,
        this.targetRotation_,
        this.nextCenter_ = null,
        this.nextResolution_,
        this.nextRotation_,
        this.cancelAnchor_ = void 0,
        i.projection && disableCoordinateWarning(),
        i.center && (i.center = fromUserCoordinate(i.center, this.projection_)),
        i.extent && (i.extent = fromUserExtent(i.extent, this.projection_)),
        this.applyOptions_(i)
    }
    applyOptions_(i) {
        const s = Object.assign({}, i);
        for (const tt in ViewProperty)
            delete s[tt];
        this.setProperties(s, !0);
        const a = createResolutionConstraint(i);
        this.maxResolution_ = a.maxResolution,
        this.minResolution_ = a.minResolution,
        this.zoomFactor_ = a.zoomFactor,
        this.resolutions_ = i.resolutions,
        this.padding_ = i.padding,
        this.minZoom_ = a.minZoom;
        const _ = createCenterConstraint(i)
          , $ = a.constraint
          , _e = createRotationConstraint(i);
        this.constraints_ = {
            center: _,
            resolution: $,
            rotation: _e
        },
        this.setRotation(i.rotation !== void 0 ? i.rotation : 0),
        this.setCenterInternal(i.center !== void 0 ? i.center : null),
        i.resolution !== void 0 ? this.setResolution(i.resolution) : i.zoom !== void 0 && this.setZoom(i.zoom)
    }
    get padding() {
        return this.padding_
    }
    set padding(i) {
        let s = this.padding_;
        this.padding_ = i;
        const a = this.getCenterInternal();
        if (a) {
            const _ = i || [0, 0, 0, 0];
            s = s || [0, 0, 0, 0];
            const $ = this.getResolution()
              , _e = $ / 2 * (_[3] - s[3] + s[1] - _[1])
              , tt = $ / 2 * (_[0] - s[0] + s[2] - _[2]);
            this.setCenterInternal([a[0] + _e, a[1] - tt])
        }
    }
    getUpdatedOptions_(i) {
        const s = this.getProperties();
        return s.resolution !== void 0 ? s.resolution = this.getResolution() : s.zoom = this.getZoom(),
        s.center = this.getCenterInternal(),
        s.rotation = this.getRotation(),
        Object.assign({}, s, i)
    }
    animate(i) {
        this.isDef() && !this.getAnimating() && this.resolveConstraints(0);
        const s = new Array(arguments.length);
        for (let a = 0; a < s.length; ++a) {
            let _ = arguments[a];
            _.center && (_ = Object.assign({}, _),
            _.center = fromUserCoordinate(_.center, this.getProjection())),
            _.anchor && (_ = Object.assign({}, _),
            _.anchor = fromUserCoordinate(_.anchor, this.getProjection())),
            s[a] = _
        }
        this.animateInternal.apply(this, s)
    }
    animateInternal(i) {
        let s = arguments.length, a;
        s > 1 && typeof arguments[s - 1] == "function" && (a = arguments[s - 1],
        --s);
        let _ = 0;
        for (; _ < s && !this.isDef(); ++_) {
            const ot = arguments[_];
            ot.center && this.setCenterInternal(ot.center),
            ot.zoom !== void 0 ? this.setZoom(ot.zoom) : ot.resolution && this.setResolution(ot.resolution),
            ot.rotation !== void 0 && this.setRotation(ot.rotation)
        }
        if (_ === s) {
            a && animationCallback(a, !0);
            return
        }
        let $ = Date.now()
          , _e = this.targetCenter_.slice()
          , tt = this.targetResolution_
          , nt = this.targetRotation_;
        const rt = [];
        for (; _ < s; ++_) {
            const ot = arguments[_]
              , et = {
                start: $,
                complete: !1,
                anchor: ot.anchor,
                duration: ot.duration !== void 0 ? ot.duration : 1e3,
                easing: ot.easing || inAndOut,
                callback: a
            };
            if (ot.center && (et.sourceCenter = _e,
            et.targetCenter = ot.center.slice(),
            _e = et.targetCenter),
            ot.zoom !== void 0 ? (et.sourceResolution = tt,
            et.targetResolution = this.getResolutionForZoom(ot.zoom),
            tt = et.targetResolution) : ot.resolution && (et.sourceResolution = tt,
            et.targetResolution = ot.resolution,
            tt = et.targetResolution),
            ot.rotation !== void 0) {
                et.sourceRotation = nt;
                const j = modulo(ot.rotation - nt + Math.PI, 2 * Math.PI) - Math.PI;
                et.targetRotation = nt + j,
                nt = et.targetRotation
            }
            isNoopAnimation(et) ? et.complete = !0 : $ += et.duration,
            rt.push(et)
        }
        this.animations_.push(rt),
        this.setHint(ViewHint.ANIMATING, 1),
        this.updateAnimations_()
    }
    getAnimating() {
        return this.hints_[ViewHint.ANIMATING] > 0
    }
    getInteracting() {
        return this.hints_[ViewHint.INTERACTING] > 0
    }
    cancelAnimations() {
        this.setHint(ViewHint.ANIMATING, -this.hints_[ViewHint.ANIMATING]);
        let i;
        for (let s = 0, a = this.animations_.length; s < a; ++s) {
            const _ = this.animations_[s];
            if (_[0].callback && animationCallback(_[0].callback, !1),
            !i)
                for (let $ = 0, _e = _.length; $ < _e; ++$) {
                    const tt = _[$];
                    if (!tt.complete) {
                        i = tt.anchor;
                        break
                    }
                }
        }
        this.animations_.length = 0,
        this.cancelAnchor_ = i,
        this.nextCenter_ = null,
        this.nextResolution_ = NaN,
        this.nextRotation_ = NaN
    }
    updateAnimations_() {
        if (this.updateAnimationKey_ !== void 0 && (cancelAnimationFrame(this.updateAnimationKey_),
        this.updateAnimationKey_ = void 0),
        !this.getAnimating())
            return;
        const i = Date.now();
        let s = !1;
        for (let a = this.animations_.length - 1; a >= 0; --a) {
            const _ = this.animations_[a];
            let $ = !0;
            for (let _e = 0, tt = _.length; _e < tt; ++_e) {
                const nt = _[_e];
                if (nt.complete)
                    continue;
                const rt = i - nt.start;
                let ot = nt.duration > 0 ? rt / nt.duration : 1;
                ot >= 1 ? (nt.complete = !0,
                ot = 1) : $ = !1;
                const et = nt.easing(ot);
                if (nt.sourceCenter) {
                    const j = nt.sourceCenter[0]
                      , it = nt.sourceCenter[1]
                      , st = nt.targetCenter[0]
                      , at = nt.targetCenter[1];
                    this.nextCenter_ = nt.targetCenter;
                    const lt = j + et * (st - j)
                      , ct = it + et * (at - it);
                    this.targetCenter_ = [lt, ct]
                }
                if (nt.sourceResolution && nt.targetResolution) {
                    const j = et === 1 ? nt.targetResolution : nt.sourceResolution + et * (nt.targetResolution - nt.sourceResolution);
                    if (nt.anchor) {
                        const it = this.getViewportSize_(this.getRotation())
                          , st = this.constraints_.resolution(j, 0, it, !0);
                        this.targetCenter_ = this.calculateCenterZoom(st, nt.anchor)
                    }
                    this.nextResolution_ = nt.targetResolution,
                    this.targetResolution_ = j,
                    this.applyTargetState_(!0)
                }
                if (nt.sourceRotation !== void 0 && nt.targetRotation !== void 0) {
                    const j = et === 1 ? modulo(nt.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : nt.sourceRotation + et * (nt.targetRotation - nt.sourceRotation);
                    if (nt.anchor) {
                        const it = this.constraints_.rotation(j, !0);
                        this.targetCenter_ = this.calculateCenterRotate(it, nt.anchor)
                    }
                    this.nextRotation_ = nt.targetRotation,
                    this.targetRotation_ = j
                }
                if (this.applyTargetState_(!0),
                s = !0,
                !nt.complete)
                    break
            }
            if ($) {
                this.animations_[a] = null,
                this.setHint(ViewHint.ANIMATING, -1),
                this.nextCenter_ = null,
                this.nextResolution_ = NaN,
                this.nextRotation_ = NaN;
                const _e = _[0].callback;
                _e && animationCallback(_e, !0)
            }
        }
        this.animations_ = this.animations_.filter(Boolean),
        s && this.updateAnimationKey_ === void 0 && (this.updateAnimationKey_ = requestAnimationFrame(this.updateAnimations_.bind(this)))
    }
    calculateCenterRotate(i, s) {
        let a;
        const _ = this.getCenterInternal();
        return _ !== void 0 && (a = [_[0] - s[0], _[1] - s[1]],
        rotate$1(a, i - this.getRotation()),
        add(a, s)),
        a
    }
    calculateCenterZoom(i, s) {
        let a;
        const _ = this.getCenterInternal()
          , $ = this.getResolution();
        if (_ !== void 0 && $ !== void 0) {
            const _e = s[0] - i * (s[0] - _[0]) / $
              , tt = s[1] - i * (s[1] - _[1]) / $;
            a = [_e, tt]
        }
        return a
    }
    getViewportSize_(i) {
        const s = this.viewportSize_;
        if (i) {
            const a = s[0]
              , _ = s[1];
            return [Math.abs(a * Math.cos(i)) + Math.abs(_ * Math.sin(i)), Math.abs(a * Math.sin(i)) + Math.abs(_ * Math.cos(i))]
        }
        return s
    }
    setViewportSize(i) {
        this.viewportSize_ = Array.isArray(i) ? i.slice() : [100, 100],
        this.getAnimating() || this.resolveConstraints(0)
    }
    getCenter() {
        const i = this.getCenterInternal();
        return i && toUserCoordinate(i, this.getProjection())
    }
    getCenterInternal() {
        return this.get(ViewProperty.CENTER)
    }
    getConstraints() {
        return this.constraints_
    }
    getConstrainResolution() {
        return this.get("constrainResolution")
    }
    getHints(i) {
        return i !== void 0 ? (i[0] = this.hints_[0],
        i[1] = this.hints_[1],
        i) : this.hints_.slice()
    }
    calculateExtent(i) {
        const s = this.calculateExtentInternal(i);
        return toUserExtent(s, this.getProjection())
    }
    calculateExtentInternal(i) {
        i = i || this.getViewportSizeMinusPadding_();
        const s = this.getCenterInternal();
        assert(s, "The view center is not defined");
        const a = this.getResolution();
        assert(a !== void 0, "The view resolution is not defined");
        const _ = this.getRotation();
        return assert(_ !== void 0, "The view rotation is not defined"),
        getForViewAndSize(s, a, _, i)
    }
    getMaxResolution() {
        return this.maxResolution_
    }
    getMinResolution() {
        return this.minResolution_
    }
    getMaxZoom() {
        return this.getZoomForResolution(this.minResolution_)
    }
    setMaxZoom(i) {
        this.applyOptions_(this.getUpdatedOptions_({
            maxZoom: i
        }))
    }
    getMinZoom() {
        return this.getZoomForResolution(this.maxResolution_)
    }
    setMinZoom(i) {
        this.applyOptions_(this.getUpdatedOptions_({
            minZoom: i
        }))
    }
    setConstrainResolution(i) {
        this.applyOptions_(this.getUpdatedOptions_({
            constrainResolution: i
        }))
    }
    getProjection() {
        return this.projection_
    }
    getResolution() {
        return this.get(ViewProperty.RESOLUTION)
    }
    getResolutions() {
        return this.resolutions_
    }
    getResolutionForExtent(i, s) {
        return this.getResolutionForExtentInternal(fromUserExtent(i, this.getProjection()), s)
    }
    getResolutionForExtentInternal(i, s) {
        s = s || this.getViewportSizeMinusPadding_();
        const a = getWidth(i) / s[0]
          , _ = getHeight(i) / s[1];
        return Math.max(a, _)
    }
    getResolutionForValueFunction(i) {
        i = i || 2;
        const s = this.getConstrainedResolution(this.maxResolution_)
          , a = this.minResolution_
          , _ = Math.log(s / a) / Math.log(i);
        return function($) {
            return s / Math.pow(i, $ * _)
        }
    }
    getRotation() {
        return this.get(ViewProperty.ROTATION)
    }
    getValueForResolutionFunction(i) {
        const s = Math.log(i || 2)
          , a = this.getConstrainedResolution(this.maxResolution_)
          , _ = this.minResolution_
          , $ = Math.log(a / _) / s;
        return function(_e) {
            return Math.log(a / _e) / s / $
        }
    }
    getViewportSizeMinusPadding_(i) {
        let s = this.getViewportSize_(i);
        const a = this.padding_;
        return a && (s = [s[0] - a[1] - a[3], s[1] - a[0] - a[2]]),
        s
    }
    getState() {
        const i = this.getProjection()
          , s = this.getResolution()
          , a = this.getRotation();
        let _ = this.getCenterInternal();
        const $ = this.padding_;
        if ($) {
            const _e = this.getViewportSizeMinusPadding_();
            _ = calculateCenterOn(_, this.getViewportSize_(), [_e[0] / 2 + $[3], _e[1] / 2 + $[0]], s, a)
        }
        return {
            center: _.slice(0),
            projection: i !== void 0 ? i : null,
            resolution: s,
            nextCenter: this.nextCenter_,
            nextResolution: this.nextResolution_,
            nextRotation: this.nextRotation_,
            rotation: a,
            zoom: this.getZoom()
        }
    }
    getViewStateAndExtent() {
        return {
            viewState: this.getState(),
            extent: this.calculateExtent()
        }
    }
    getZoom() {
        let i;
        const s = this.getResolution();
        return s !== void 0 && (i = this.getZoomForResolution(s)),
        i
    }
    getZoomForResolution(i) {
        let s = this.minZoom_ || 0, a, _;
        if (this.resolutions_) {
            const $ = linearFindNearest(this.resolutions_, i, 1);
            s = $,
            a = this.resolutions_[$],
            $ == this.resolutions_.length - 1 ? _ = 2 : _ = a / this.resolutions_[$ + 1]
        } else
            a = this.maxResolution_,
            _ = this.zoomFactor_;
        return s + Math.log(a / i) / Math.log(_)
    }
    getResolutionForZoom(i) {
        if (this.resolutions_) {
            if (this.resolutions_.length <= 1)
                return 0;
            const s = clamp(Math.floor(i), 0, this.resolutions_.length - 2)
              , a = this.resolutions_[s] / this.resolutions_[s + 1];
            return this.resolutions_[s] / Math.pow(a, clamp(i - s, 0, 1))
        }
        return this.maxResolution_ / Math.pow(this.zoomFactor_, i - this.minZoom_)
    }
    fit(i, s) {
        let a;
        if (assert(Array.isArray(i) || typeof i.getSimplifiedGeometry == "function", "Invalid extent or geometry provided as `geometry`"),
        Array.isArray(i)) {
            assert(!isEmpty(i), "Cannot fit empty extent provided as `geometry`");
            const _ = fromUserExtent(i, this.getProjection());
            a = fromExtent(_)
        } else if (i.getType() === "Circle") {
            const _ = fromUserExtent(i.getExtent(), this.getProjection());
            a = fromExtent(_),
            a.rotate(this.getRotation(), getCenter(_))
        } else
            a = i;
        this.fitInternal(a, s)
    }
    rotatedExtentForGeometry(i) {
        const s = this.getRotation()
          , a = Math.cos(s)
          , _ = Math.sin(-s)
          , $ = i.getFlatCoordinates()
          , _e = i.getStride();
        let tt = 1 / 0
          , nt = 1 / 0
          , rt = -1 / 0
          , ot = -1 / 0;
        for (let et = 0, j = $.length; et < j; et += _e) {
            const it = $[et] * a - $[et + 1] * _
              , st = $[et] * _ + $[et + 1] * a;
            tt = Math.min(tt, it),
            nt = Math.min(nt, st),
            rt = Math.max(rt, it),
            ot = Math.max(ot, st)
        }
        return [tt, nt, rt, ot]
    }
    fitInternal(i, s) {
        s = s || {};
        let a = s.size;
        a || (a = this.getViewportSizeMinusPadding_());
        const _ = s.padding !== void 0 ? s.padding : [0, 0, 0, 0]
          , $ = s.nearest !== void 0 ? s.nearest : !1;
        let _e;
        s.minResolution !== void 0 ? _e = s.minResolution : s.maxZoom !== void 0 ? _e = this.getResolutionForZoom(s.maxZoom) : _e = 0;
        const tt = this.rotatedExtentForGeometry(i);
        let nt = this.getResolutionForExtentInternal(tt, [a[0] - _[1] - _[3], a[1] - _[0] - _[2]]);
        nt = isNaN(nt) ? _e : Math.max(nt, _e),
        nt = this.getConstrainedResolution(nt, $ ? 0 : 1);
        const rt = this.getRotation()
          , ot = Math.sin(rt)
          , et = Math.cos(rt)
          , j = getCenter(tt);
        j[0] += (_[1] - _[3]) / 2 * nt,
        j[1] += (_[0] - _[2]) / 2 * nt;
        const it = j[0] * et - j[1] * ot
          , st = j[1] * et + j[0] * ot
          , at = this.getConstrainedCenter([it, st], nt)
          , lt = s.callback ? s.callback : VOID;
        s.duration !== void 0 ? this.animateInternal({
            resolution: nt,
            center: at,
            duration: s.duration,
            easing: s.easing
        }, lt) : (this.targetResolution_ = nt,
        this.targetCenter_ = at,
        this.applyTargetState_(!1, !0),
        animationCallback(lt, !0))
    }
    centerOn(i, s, a) {
        this.centerOnInternal(fromUserCoordinate(i, this.getProjection()), s, a)
    }
    centerOnInternal(i, s, a) {
        this.setCenterInternal(calculateCenterOn(i, s, a, this.getResolution(), this.getRotation()))
    }
    calculateCenterShift(i, s, a, _) {
        let $;
        const _e = this.padding_;
        if (_e && i) {
            const tt = this.getViewportSizeMinusPadding_(-a)
              , nt = calculateCenterOn(i, _, [tt[0] / 2 + _e[3], tt[1] / 2 + _e[0]], s, a);
            $ = [i[0] - nt[0], i[1] - nt[1]]
        }
        return $
    }
    isDef() {
        return !!this.getCenterInternal() && this.getResolution() !== void 0
    }
    adjustCenter(i) {
        const s = toUserCoordinate(this.targetCenter_, this.getProjection());
        this.setCenter([s[0] + i[0], s[1] + i[1]])
    }
    adjustCenterInternal(i) {
        const s = this.targetCenter_;
        this.setCenterInternal([s[0] + i[0], s[1] + i[1]])
    }
    adjustResolution(i, s) {
        s = s && fromUserCoordinate(s, this.getProjection()),
        this.adjustResolutionInternal(i, s)
    }
    adjustResolutionInternal(i, s) {
        const a = this.getAnimating() || this.getInteracting()
          , _ = this.getViewportSize_(this.getRotation())
          , $ = this.constraints_.resolution(this.targetResolution_ * i, 0, _, a);
        s && (this.targetCenter_ = this.calculateCenterZoom($, s)),
        this.targetResolution_ *= i,
        this.applyTargetState_()
    }
    adjustZoom(i, s) {
        this.adjustResolution(Math.pow(this.zoomFactor_, -i), s)
    }
    adjustRotation(i, s) {
        s && (s = fromUserCoordinate(s, this.getProjection())),
        this.adjustRotationInternal(i, s)
    }
    adjustRotationInternal(i, s) {
        const a = this.getAnimating() || this.getInteracting()
          , _ = this.constraints_.rotation(this.targetRotation_ + i, a);
        s && (this.targetCenter_ = this.calculateCenterRotate(_, s)),
        this.targetRotation_ += i,
        this.applyTargetState_()
    }
    setCenter(i) {
        this.setCenterInternal(i && fromUserCoordinate(i, this.getProjection()))
    }
    setCenterInternal(i) {
        this.targetCenter_ = i,
        this.applyTargetState_()
    }
    setHint(i, s) {
        return this.hints_[i] += s,
        this.changed(),
        this.hints_[i]
    }
    setResolution(i) {
        this.targetResolution_ = i,
        this.applyTargetState_()
    }
    setRotation(i) {
        this.targetRotation_ = i,
        this.applyTargetState_()
    }
    setZoom(i) {
        this.setResolution(this.getResolutionForZoom(i))
    }
    applyTargetState_(i, s) {
        const a = this.getAnimating() || this.getInteracting() || s
          , _ = this.constraints_.rotation(this.targetRotation_, a)
          , $ = this.getViewportSize_(_)
          , _e = this.constraints_.resolution(this.targetResolution_, 0, $, a)
          , tt = this.constraints_.center(this.targetCenter_, _e, $, a, this.calculateCenterShift(this.targetCenter_, _e, _, $));
        this.get(ViewProperty.ROTATION) !== _ && this.set(ViewProperty.ROTATION, _),
        this.get(ViewProperty.RESOLUTION) !== _e && (this.set(ViewProperty.RESOLUTION, _e),
        this.set("zoom", this.getZoom(), !0)),
        (!tt || !this.get(ViewProperty.CENTER) || !equals(this.get(ViewProperty.CENTER), tt)) && this.set(ViewProperty.CENTER, tt),
        this.getAnimating() && !i && this.cancelAnimations(),
        this.cancelAnchor_ = void 0
    }
    resolveConstraints(i, s, a) {
        i = i !== void 0 ? i : 200;
        const _ = s || 0
          , $ = this.constraints_.rotation(this.targetRotation_)
          , _e = this.getViewportSize_($)
          , tt = this.constraints_.resolution(this.targetResolution_, _, _e)
          , nt = this.constraints_.center(this.targetCenter_, tt, _e, !1, this.calculateCenterShift(this.targetCenter_, tt, $, _e));
        if (i === 0 && !this.cancelAnchor_) {
            this.targetResolution_ = tt,
            this.targetRotation_ = $,
            this.targetCenter_ = nt,
            this.applyTargetState_();
            return
        }
        a = a || (i === 0 ? this.cancelAnchor_ : void 0),
        this.cancelAnchor_ = void 0,
        (this.getResolution() !== tt || this.getRotation() !== $ || !this.getCenterInternal() || !equals(this.getCenterInternal(), nt)) && (this.getAnimating() && this.cancelAnimations(),
        this.animateInternal({
            rotation: $,
            center: nt,
            resolution: tt,
            duration: i,
            easing: easeOut,
            anchor: a
        }))
    }
    beginInteraction() {
        this.resolveConstraints(0),
        this.setHint(ViewHint.INTERACTING, 1)
    }
    endInteraction(i, s, a) {
        a = a && fromUserCoordinate(a, this.getProjection()),
        this.endInteractionInternal(i, s, a)
    }
    endInteractionInternal(i, s, a) {
        this.getInteracting() && (this.setHint(ViewHint.INTERACTING, -1),
        this.resolveConstraints(i, s, a))
    }
    getConstrainedCenter(i, s) {
        const a = this.getViewportSize_(this.getRotation());
        return this.constraints_.center(i, s || this.getResolution(), a)
    }
    getConstrainedZoom(i, s) {
        const a = this.getResolutionForZoom(i);
        return this.getZoomForResolution(this.getConstrainedResolution(a, s))
    }
    getConstrainedResolution(i, s) {
        s = s || 0;
        const a = this.getViewportSize_(this.getRotation());
        return this.constraints_.resolution(i, s, a)
    }
}
function animationCallback(o, i) {
    setTimeout(function() {
        o(i)
    }, 0)
}
function createCenterConstraint(o) {
    if (o.extent !== void 0) {
        const s = o.smoothExtentConstraint !== void 0 ? o.smoothExtentConstraint : !0;
        return createExtent(o.extent, o.constrainOnlyCenter, s)
    }
    const i = createProjection(o.projection, "EPSG:3857");
    if (o.multiWorld !== !0 && i.isGlobal()) {
        const s = i.getExtent().slice();
        return s[0] = -1 / 0,
        s[2] = 1 / 0,
        createExtent(s, !1, !1)
    }
    return none$1
}
function createResolutionConstraint(o) {
    let i, s, a, _e = o.minZoom !== void 0 ? o.minZoom : DEFAULT_MIN_ZOOM, tt = o.maxZoom !== void 0 ? o.maxZoom : 28;
    const nt = o.zoomFactor !== void 0 ? o.zoomFactor : 2
      , rt = o.multiWorld !== void 0 ? o.multiWorld : !1
      , ot = o.smoothResolutionConstraint !== void 0 ? o.smoothResolutionConstraint : !0
      , et = o.showFullExtent !== void 0 ? o.showFullExtent : !1
      , j = createProjection(o.projection, "EPSG:3857")
      , it = j.getExtent();
    let st = o.constrainOnlyCenter
      , at = o.extent;
    if (!rt && !at && j.isGlobal() && (st = !1,
    at = it),
    o.resolutions !== void 0) {
        const lt = o.resolutions;
        s = lt[_e],
        a = lt[tt] !== void 0 ? lt[tt] : lt[lt.length - 1],
        o.constrainResolution ? i = createSnapToResolutions(lt, ot, !st && at, et) : i = createMinMaxResolution(s, a, ot, !st && at, et)
    } else {
        const ct = (it ? Math.max(getWidth(it), getHeight(it)) : 360 * METERS_PER_UNIT$1.degrees / j.getMetersPerUnit()) / DEFAULT_TILE_SIZE / Math.pow(2, DEFAULT_MIN_ZOOM)
          , ut = ct / Math.pow(2, 28 - DEFAULT_MIN_ZOOM);
        s = o.maxResolution,
        s !== void 0 ? _e = 0 : s = ct / Math.pow(nt, _e),
        a = o.minResolution,
        a === void 0 && (o.maxZoom !== void 0 ? o.maxResolution !== void 0 ? a = s / Math.pow(nt, tt) : a = ct / Math.pow(nt, tt) : a = ut),
        tt = _e + Math.floor(Math.log(s / a) / Math.log(nt)),
        a = s / Math.pow(nt, tt - _e),
        o.constrainResolution ? i = createSnapToPower(nt, s, a, ot, !st && at, et) : i = createMinMaxResolution(s, a, ot, !st && at, et)
    }
    return {
        constraint: i,
        maxResolution: s,
        minResolution: a,
        minZoom: _e,
        zoomFactor: nt
    }
}
function createRotationConstraint(o) {
    if (o.enableRotation !== void 0 ? o.enableRotation : !0) {
        const s = o.constrainRotation;
        return s === void 0 || s === !0 ? createSnapToZero() : s === !1 ? none : typeof s == "number" ? createSnapToN(s) : none
    }
    return disable
}
function isNoopAnimation(o) {
    return !(o.sourceCenter && o.targetCenter && !equals(o.sourceCenter, o.targetCenter) || o.sourceResolution !== o.targetResolution || o.sourceRotation !== o.targetRotation)
}
function calculateCenterOn(o, i, s, a, _) {
    const $ = Math.cos(-_);
    let _e = Math.sin(-_)
      , tt = o[0] * $ - o[1] * _e
      , nt = o[1] * $ + o[0] * _e;
    tt += (i[0] / 2 - s[0]) * a,
    nt += (s[1] - i[1] / 2) * a,
    _e = -_e;
    const rt = tt * $ - nt * _e
      , ot = nt * $ + tt * _e;
    return [rt, ot]
}
const View$1 = View;
class Layer extends BaseLayer$1 {
    constructor(i) {
        const s = Object.assign({}, i);
        delete s.source,
        super(s),
        this.on,
        this.once,
        this.un,
        this.mapPrecomposeKey_ = null,
        this.mapRenderKey_ = null,
        this.sourceChangeKey_ = null,
        this.renderer_ = null,
        this.sourceReady_ = !1,
        this.rendered = !1,
        i.render && (this.render = i.render),
        i.map && this.setMap(i.map),
        this.addChangeListener(LayerProperty.SOURCE, this.handleSourcePropertyChange_);
        const a = i.source ? i.source : null;
        this.setSource(a)
    }
    getLayersArray(i) {
        return i = i || [],
        i.push(this),
        i
    }
    getLayerStatesArray(i) {
        return i = i || [],
        i.push(this.getLayerState()),
        i
    }
    getSource() {
        return this.get(LayerProperty.SOURCE) || null
    }
    getRenderSource() {
        return this.getSource()
    }
    getSourceState() {
        const i = this.getSource();
        return i ? i.getState() : "undefined"
    }
    handleSourceChange_() {
        this.changed(),
        !(this.sourceReady_ || this.getSource().getState() !== "ready") && (this.sourceReady_ = !0,
        this.dispatchEvent("sourceready"))
    }
    handleSourcePropertyChange_() {
        this.sourceChangeKey_ && (unlistenByKey(this.sourceChangeKey_),
        this.sourceChangeKey_ = null),
        this.sourceReady_ = !1;
        const i = this.getSource();
        i && (this.sourceChangeKey_ = listen(i, EventType.CHANGE, this.handleSourceChange_, this),
        i.getState() === "ready" && (this.sourceReady_ = !0,
        setTimeout( () => {
            this.dispatchEvent("sourceready")
        }
        , 0))),
        this.changed()
    }
    getFeatures(i) {
        return this.renderer_ ? this.renderer_.getFeatures(i) : Promise.resolve([])
    }
    getData(i) {
        return !this.renderer_ || !this.rendered ? null : this.renderer_.getData(i)
    }
    isVisible(i) {
        let s;
        const a = this.getMapInternal();
        !i && a && (i = a.getView()),
        i instanceof View$1 ? s = {
            viewState: i.getState(),
            extent: i.calculateExtent()
        } : s = i,
        !s.layerStatesArray && a && (s.layerStatesArray = a.getLayerGroup().getLayerStatesArray());
        let _;
        s.layerStatesArray ? _ = s.layerStatesArray.find(_e => _e.layer === this) : _ = this.getLayerState();
        const $ = this.getExtent();
        return inView(_, s.viewState) && (!$ || intersects$1($, s.extent))
    }
    getAttributions(i) {
        if (!this.isVisible(i))
            return [];
        let s;
        const a = this.getSource();
        if (a && (s = a.getAttributions()),
        !s)
            return [];
        const _ = i instanceof View$1 ? i.getViewStateAndExtent() : i;
        let $ = s(_);
        return Array.isArray($) || ($ = [$]),
        $
    }
    render(i, s) {
        const a = this.getRenderer();
        return a.prepareFrame(i) ? (this.rendered = !0,
        a.renderFrame(i, s)) : null
    }
    unrender() {
        this.rendered = !1
    }
    setMapInternal(i) {
        i || this.unrender(),
        this.set(LayerProperty.MAP, i)
    }
    getMapInternal() {
        return this.get(LayerProperty.MAP)
    }
    setMap(i) {
        this.mapPrecomposeKey_ && (unlistenByKey(this.mapPrecomposeKey_),
        this.mapPrecomposeKey_ = null),
        i || this.changed(),
        this.mapRenderKey_ && (unlistenByKey(this.mapRenderKey_),
        this.mapRenderKey_ = null),
        i && (this.mapPrecomposeKey_ = listen(i, RenderEventType.PRECOMPOSE, function(s) {
            const _ = s.frameState.layerStatesArray
              , $ = this.getLayerState(!1);
            assert(!_.some(function(_e) {
                return _e.layer === $.layer
            }), "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both."),
            _.push($)
        }, this),
        this.mapRenderKey_ = listen(this, EventType.CHANGE, i.render, i),
        this.changed())
    }
    setSource(i) {
        this.set(LayerProperty.SOURCE, i)
    }
    getRenderer() {
        return this.renderer_ || (this.renderer_ = this.createRenderer()),
        this.renderer_
    }
    hasRenderer() {
        return !!this.renderer_
    }
    createRenderer() {
        return null
    }
    disposeInternal() {
        this.renderer_ && (this.renderer_.dispose(),
        delete this.renderer_),
        this.setSource(null),
        super.disposeInternal()
    }
}
function inView(o, i) {
    if (!o.visible)
        return !1;
    const s = i.resolution;
    if (s < o.minResolution || s >= o.maxResolution)
        return !1;
    const a = i.zoom;
    return a > o.minZoom && a <= o.maxZoom
}
const Layer$1 = Layer;
class MapRenderer extends Disposable$1 {
    constructor(i) {
        super(),
        this.map_ = i
    }
    dispatchRenderEvent(i, s) {
        abstract()
    }
    calculateMatrices2D(i) {
        const s = i.viewState
          , a = i.coordinateToPixelTransform
          , _ = i.pixelToCoordinateTransform;
        compose(a, i.size[0] / 2, i.size[1] / 2, 1 / s.resolution, -1 / s.resolution, -s.rotation, -s.center[0], -s.center[1]),
        makeInverse(_, a)
    }
    forEachFeatureAtCoordinate(i, s, a, _, $, _e, tt, nt) {
        let rt;
        const ot = s.viewState;
        function et(ft, ht, pt, gt) {
            return $.call(_e, ht, ft ? pt : null, gt)
        }
        const j = ot.projection
          , it = wrapX$1(i.slice(), j)
          , st = [[0, 0]];
        if (j.canWrapX() && _) {
            const ft = j.getExtent()
              , ht = getWidth(ft);
            st.push([-ht, 0], [ht, 0])
        }
        const at = s.layerStatesArray
          , lt = at.length
          , ct = []
          , ut = [];
        for (let ft = 0; ft < st.length; ft++)
            for (let ht = lt - 1; ht >= 0; --ht) {
                const pt = at[ht]
                  , gt = pt.layer;
                if (gt.hasRenderer() && inView(pt, ot) && tt.call(nt, gt)) {
                    const _t = gt.getRenderer()
                      , mt = gt.getSource();
                    if (_t && mt) {
                        const yt = mt.getWrapX() ? it : i
                          , bt = et.bind(null, pt.managed);
                        ut[0] = yt[0] + st[ft][0],
                        ut[1] = yt[1] + st[ft][1],
                        rt = _t.forEachFeatureAtCoordinate(ut, s, a, bt, ct)
                    }
                    if (rt)
                        return rt
                }
            }
        if (ct.length === 0)
            return;
        const dt = 1 / ct.length;
        return ct.forEach( (ft, ht) => ft.distanceSq += ht * dt),
        ct.sort( (ft, ht) => ft.distanceSq - ht.distanceSq),
        ct.some(ft => rt = ft.callback(ft.feature, ft.layer, ft.geometry)),
        rt
    }
    hasFeatureAtCoordinate(i, s, a, _, $, _e) {
        return this.forEachFeatureAtCoordinate(i, s, a, _, TRUE, this, $, _e) !== void 0
    }
    getMap() {
        return this.map_
    }
    renderFrame(i) {
        abstract()
    }
    flushDeclutterItems(i) {}
    scheduleExpireIconCache(i) {
        shared.canExpireCache() && i.postRenderFunctions.push(expireIconCache)
    }
}
function expireIconCache(o, i) {
    shared.expire()
}
const MapRenderer$1 = MapRenderer;
class RenderEvent extends Event$1 {
    constructor(i, s, a, _) {
        super(i),
        this.inversePixelTransform = s,
        this.frameState = a,
        this.context = _
    }
}
const RenderEvent$1 = RenderEvent
  , CLASS_HIDDEN = "ol-hidden"
  , CLASS_UNSELECTABLE = "ol-unselectable"
  , CLASS_CONTROL = "ol-control"
  , CLASS_COLLAPSED = "ol-collapsed"
  , fontRegEx = new RegExp(["^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)", "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)", "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)", "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?", "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))", "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))", `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`].join(""),"i")
  , fontRegExMatchIndex = ["style", "variant", "weight", "size", "lineHeight", "family"]
  , getFontParameters = function(o) {
    const i = o.match(fontRegEx);
    if (!i)
        return null;
    const s = {
        lineHeight: "normal",
        size: "1.2em",
        style: "normal",
        weight: "normal",
        variant: "normal"
    };
    for (let a = 0, _ = fontRegExMatchIndex.length; a < _; ++a) {
        const $ = i[a + 1];
        $ !== void 0 && (s[fontRegExMatchIndex[a]] = $)
    }
    return s.families = s.family.split(/,\s?/),
    s
};
function createCanvasContext2D(o, i, s, a) {
    let _;
    return s && s.length ? _ = s.shift() : WORKER_OFFSCREEN_CANVAS ? _ = new OffscreenCanvas(o || 300,i || 300) : _ = document.createElement("canvas"),
    o && (_.width = o),
    i && (_.height = i),
    _.getContext("2d", a)
}
function releaseCanvas$1(o) {
    const i = o.canvas;
    i.width = 1,
    i.height = 1,
    o.clearRect(0, 0, 1, 1)
}
function replaceNode(o, i) {
    const s = i.parentNode;
    s && s.replaceChild(o, i)
}
function removeNode(o) {
    return o && o.parentNode ? o.parentNode.removeChild(o) : null
}
function removeChildren(o) {
    for (; o.lastChild; )
        o.removeChild(o.lastChild)
}
function replaceChildren(o, i) {
    const s = o.childNodes;
    for (let a = 0; ; ++a) {
        const _ = s[a]
          , $ = i[a];
        if (!_ && !$)
            break;
        if (_ !== $) {
            if (!_) {
                o.appendChild($);
                continue
            }
            if (!$) {
                o.removeChild(_),
                --a;
                continue
            }
            o.insertBefore($, _)
        }
    }
}
const defaultFont = "10px sans-serif"
  , defaultFillStyle = "#000"
  , defaultLineCap = "round"
  , defaultLineDash = []
  , defaultLineDashOffset = 0
  , defaultLineJoin = "round"
  , defaultMiterLimit = 10
  , defaultStrokeStyle = "#000"
  , defaultTextAlign = "center"
  , defaultTextBaseline = "middle"
  , defaultPadding = [0, 0, 0, 0]
  , defaultLineWidth = 1
  , checkedFonts = new BaseObject$1;
let measureContext = null, measureFont;
const textHeights = {}
  , registerFont = function() {
    const i = "32px "
      , s = ["monospace", "serif"]
      , a = s.length
      , _ = "wmytzilWMYTZIL@#/&?$%10";
    let $, _e;
    function tt(rt, ot, et) {
        let j = !0;
        for (let it = 0; it < a; ++it) {
            const st = s[it];
            if (_e = measureTextWidth(rt + " " + ot + " " + i + st, _),
            et != st) {
                const at = measureTextWidth(rt + " " + ot + " " + i + et + "," + st, _);
                j = j && at != _e
            }
        }
        return !!j
    }
    function nt() {
        let rt = !0;
        const ot = checkedFonts.getKeys();
        for (let et = 0, j = ot.length; et < j; ++et) {
            const it = ot[et];
            checkedFonts.get(it) < 100 && (tt.apply(this, it.split(`
`)) ? (clear(textHeights),
            measureContext = null,
            measureFont = void 0,
            checkedFonts.set(it, 100)) : (checkedFonts.set(it, checkedFonts.get(it) + 1, !0),
            rt = !1))
        }
        rt && (clearInterval($),
        $ = void 0)
    }
    return function(rt) {
        const ot = getFontParameters(rt);
        if (!ot)
            return;
        const et = ot.families;
        for (let j = 0, it = et.length; j < it; ++j) {
            const st = et[j]
              , at = ot.style + `
` + ot.weight + `
` + st;
            checkedFonts.get(at) === void 0 && (checkedFonts.set(at, 100, !0),
            tt(ot.style, ot.weight, st) || (checkedFonts.set(at, 0, !0),
            $ === void 0 && ($ = setInterval(nt, 32))))
        }
    }
}()
  , measureTextHeight = function() {
    let o;
    return function(i) {
        let s = textHeights[i];
        if (s == null) {
            if (WORKER_OFFSCREEN_CANVAS) {
                const a = getFontParameters(i)
                  , _ = measureText(i, "Žg");
                s = (isNaN(Number(a.lineHeight)) ? 1.2 : Number(a.lineHeight)) * (_.actualBoundingBoxAscent + _.actualBoundingBoxDescent)
            } else
                o || (o = document.createElement("div"),
                o.innerHTML = "M",
                o.style.minHeight = "0",
                o.style.maxHeight = "none",
                o.style.height = "auto",
                o.style.padding = "0",
                o.style.border = "none",
                o.style.position = "absolute",
                o.style.display = "block",
                o.style.left = "-99999px"),
                o.style.font = i,
                document.body.appendChild(o),
                s = o.offsetHeight,
                document.body.removeChild(o);
            textHeights[i] = s
        }
        return s
    }
}();
function measureText(o, i) {
    return measureContext || (measureContext = createCanvasContext2D(1, 1)),
    o != measureFont && (measureContext.font = o,
    measureFont = measureContext.font),
    measureContext.measureText(i)
}
function measureTextWidth(o, i) {
    return measureText(o, i).width
}
function measureAndCacheTextWidth(o, i, s) {
    if (i in s)
        return s[i];
    const a = i.split(`
`).reduce( (_, $) => Math.max(_, measureTextWidth(o, $)), 0);
    return s[i] = a,
    a
}
function getTextDimensions(o, i) {
    const s = []
      , a = []
      , _ = [];
    let $ = 0
      , _e = 0
      , tt = 0
      , nt = 0;
    for (let rt = 0, ot = i.length; rt <= ot; rt += 2) {
        const et = i[rt];
        if (et === `
` || rt === ot) {
            $ = Math.max($, _e),
            _.push(_e),
            _e = 0,
            tt += nt;
            continue
        }
        const j = i[rt + 1] || o.font
          , it = measureTextWidth(j, et);
        s.push(it),
        _e += it;
        const st = measureTextHeight(j);
        a.push(st),
        nt = Math.max(nt, st)
    }
    return {
        width: $,
        height: tt,
        widths: s,
        heights: a,
        lineWidths: _
    }
}
function drawImageOrLabel(o, i, s, a, _, $, _e, tt, nt, rt, ot) {
    o.save(),
    s !== 1 && (o.globalAlpha *= s),
    i && o.transform.apply(o, i),
    a.contextInstructions ? (o.translate(nt, rt),
    o.scale(ot[0], ot[1]),
    executeLabelInstructions(a, o)) : ot[0] < 0 || ot[1] < 0 ? (o.translate(nt, rt),
    o.scale(ot[0], ot[1]),
    o.drawImage(a, _, $, _e, tt, 0, 0, _e, tt)) : o.drawImage(a, _, $, _e, tt, nt, rt, _e * ot[0], tt * ot[1]),
    o.restore()
}
function executeLabelInstructions(o, i) {
    const s = o.contextInstructions;
    for (let a = 0, _ = s.length; a < _; a += 2)
        Array.isArray(s[a + 1]) ? i[s[a]].apply(i, s[a + 1]) : i[s[a]] = s[a + 1]
}
class CompositeMapRenderer extends MapRenderer$1 {
    constructor(i) {
        super(i),
        this.fontChangeListenerKey_ = listen(checkedFonts, ObjectEventType.PROPERTYCHANGE, i.redrawText.bind(i)),
        this.element_ = document.createElement("div");
        const s = this.element_.style;
        s.position = "absolute",
        s.width = "100%",
        s.height = "100%",
        s.zIndex = "0",
        this.element_.className = CLASS_UNSELECTABLE + " ol-layers";
        const a = i.getViewport();
        a.insertBefore(this.element_, a.firstChild || null),
        this.children_ = [],
        this.renderedVisible_ = !0,
        this.declutterLayers_ = []
    }
    dispatchRenderEvent(i, s) {
        const a = this.getMap();
        if (a.hasListener(i)) {
            const _ = new RenderEvent$1(i,void 0,s);
            a.dispatchEvent(_)
        }
    }
    disposeInternal() {
        unlistenByKey(this.fontChangeListenerKey_),
        this.element_.parentNode.removeChild(this.element_),
        super.disposeInternal()
    }
    renderFrame(i) {
        if (!i) {
            this.renderedVisible_ && (this.element_.style.display = "none",
            this.renderedVisible_ = !1);
            return
        }
        this.calculateMatrices2D(i),
        this.dispatchRenderEvent(RenderEventType.PRECOMPOSE, i);
        const s = i.layerStatesArray.sort(function(_e, tt) {
            return _e.zIndex - tt.zIndex
        })
          , a = i.viewState;
        this.children_.length = 0;
        const _ = this.declutterLayers_;
        _.length = 0;
        let $ = null;
        for (let _e = 0, tt = s.length; _e < tt; ++_e) {
            const nt = s[_e];
            i.layerIndex = _e;
            const rt = nt.layer
              , ot = rt.getSourceState();
            if (!inView(nt, a) || ot != "ready" && ot != "undefined") {
                rt.unrender();
                continue
            }
            const et = rt.render(i, $);
            et && (et !== $ && (this.children_.push(et),
            $ = et),
            "getDeclutter"in rt && _.push(rt))
        }
        this.flushDeclutterItems(i),
        replaceChildren(this.element_, this.children_),
        this.dispatchRenderEvent(RenderEventType.POSTCOMPOSE, i),
        this.renderedVisible_ || (this.element_.style.display = "",
        this.renderedVisible_ = !0),
        this.scheduleExpireIconCache(i)
    }
    flushDeclutterItems(i) {
        const s = this.declutterLayers_;
        for (let a = s.length - 1; a >= 0; --a)
            s[a].renderDeclutter(i);
        s.length = 0
    }
}
const CompositeMapRenderer$1 = CompositeMapRenderer;
class GroupEvent extends Event$1 {
    constructor(i, s) {
        super(i),
        this.layer = s
    }
}
const Property$1 = {
    LAYERS: "layers"
};
class LayerGroup extends BaseLayer$1 {
    constructor(i) {
        i = i || {};
        const s = Object.assign({}, i);
        delete s.layers;
        let a = i.layers;
        super(s),
        this.on,
        this.once,
        this.un,
        this.layersListenerKeys_ = [],
        this.listenerKeys_ = {},
        this.addChangeListener(Property$1.LAYERS, this.handleLayersChanged_),
        a ? Array.isArray(a) ? a = new Collection$1(a.slice(),{
            unique: !0
        }) : assert(typeof a.getArray == "function", "Expected `layers` to be an array or a `Collection`") : a = new Collection$1(void 0,{
            unique: !0
        }),
        this.setLayers(a)
    }
    handleLayerChange_() {
        this.changed()
    }
    handleLayersChanged_() {
        this.layersListenerKeys_.forEach(unlistenByKey),
        this.layersListenerKeys_.length = 0;
        const i = this.getLayers();
        this.layersListenerKeys_.push(listen(i, CollectionEventType.ADD, this.handleLayersAdd_, this), listen(i, CollectionEventType.REMOVE, this.handleLayersRemove_, this));
        for (const a in this.listenerKeys_)
            this.listenerKeys_[a].forEach(unlistenByKey);
        clear(this.listenerKeys_);
        const s = i.getArray();
        for (let a = 0, _ = s.length; a < _; a++) {
            const $ = s[a];
            this.registerLayerListeners_($),
            this.dispatchEvent(new GroupEvent("addlayer",$))
        }
        this.changed()
    }
    registerLayerListeners_(i) {
        const s = [listen(i, ObjectEventType.PROPERTYCHANGE, this.handleLayerChange_, this), listen(i, EventType.CHANGE, this.handleLayerChange_, this)];
        i instanceof LayerGroup && s.push(listen(i, "addlayer", this.handleLayerGroupAdd_, this), listen(i, "removelayer", this.handleLayerGroupRemove_, this)),
        this.listenerKeys_[getUid(i)] = s
    }
    handleLayerGroupAdd_(i) {
        this.dispatchEvent(new GroupEvent("addlayer",i.layer))
    }
    handleLayerGroupRemove_(i) {
        this.dispatchEvent(new GroupEvent("removelayer",i.layer))
    }
    handleLayersAdd_(i) {
        const s = i.element;
        this.registerLayerListeners_(s),
        this.dispatchEvent(new GroupEvent("addlayer",s)),
        this.changed()
    }
    handleLayersRemove_(i) {
        const s = i.element
          , a = getUid(s);
        this.listenerKeys_[a].forEach(unlistenByKey),
        delete this.listenerKeys_[a],
        this.dispatchEvent(new GroupEvent("removelayer",s)),
        this.changed()
    }
    getLayers() {
        return this.get(Property$1.LAYERS)
    }
    setLayers(i) {
        const s = this.getLayers();
        if (s) {
            const a = s.getArray();
            for (let _ = 0, $ = a.length; _ < $; ++_)
                this.dispatchEvent(new GroupEvent("removelayer",a[_]))
        }
        this.set(Property$1.LAYERS, i)
    }
    getLayersArray(i) {
        return i = i !== void 0 ? i : [],
        this.getLayers().forEach(function(s) {
            s.getLayersArray(i)
        }),
        i
    }
    getLayerStatesArray(i) {
        const s = i !== void 0 ? i : []
          , a = s.length;
        this.getLayers().forEach(function(_e) {
            _e.getLayerStatesArray(s)
        });
        const _ = this.getLayerState();
        let $ = _.zIndex;
        !i && _.zIndex === void 0 && ($ = 0);
        for (let _e = a, tt = s.length; _e < tt; _e++) {
            const nt = s[_e];
            nt.opacity *= _.opacity,
            nt.visible = nt.visible && _.visible,
            nt.maxResolution = Math.min(nt.maxResolution, _.maxResolution),
            nt.minResolution = Math.max(nt.minResolution, _.minResolution),
            nt.minZoom = Math.max(nt.minZoom, _.minZoom),
            nt.maxZoom = Math.min(nt.maxZoom, _.maxZoom),
            _.extent !== void 0 && (nt.extent !== void 0 ? nt.extent = getIntersection(nt.extent, _.extent) : nt.extent = _.extent),
            nt.zIndex === void 0 && (nt.zIndex = $)
        }
        return s
    }
    getSourceState() {
        return "ready"
    }
}
const LayerGroup$1 = LayerGroup;
class MapEvent extends Event$1 {
    constructor(i, s, a) {
        super(i),
        this.map = s,
        this.frameState = a !== void 0 ? a : null
    }
}
const MapEvent$1 = MapEvent;
class MapBrowserEvent extends MapEvent$1 {
    constructor(i, s, a, _, $, _e) {
        super(i, s, $),
        this.originalEvent = a,
        this.pixel_ = null,
        this.coordinate_ = null,
        this.dragging = _ !== void 0 ? _ : !1,
        this.activePointers = _e
    }
    get pixel() {
        return this.pixel_ || (this.pixel_ = this.map.getEventPixel(this.originalEvent)),
        this.pixel_
    }
    set pixel(i) {
        this.pixel_ = i
    }
    get coordinate() {
        return this.coordinate_ || (this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel)),
        this.coordinate_
    }
    set coordinate(i) {
        this.coordinate_ = i
    }
    preventDefault() {
        super.preventDefault(),
        "preventDefault"in this.originalEvent && this.originalEvent.preventDefault()
    }
    stopPropagation() {
        super.stopPropagation(),
        "stopPropagation"in this.originalEvent && this.originalEvent.stopPropagation()
    }
}
const MapBrowserEvent$1 = MapBrowserEvent
  , MapBrowserEventType = {
    SINGLECLICK: "singleclick",
    CLICK: EventType.CLICK,
    DBLCLICK: EventType.DBLCLICK,
    POINTERDRAG: "pointerdrag",
    POINTERMOVE: "pointermove",
    POINTERDOWN: "pointerdown",
    POINTERUP: "pointerup",
    POINTEROVER: "pointerover",
    POINTEROUT: "pointerout",
    POINTERENTER: "pointerenter",
    POINTERLEAVE: "pointerleave",
    POINTERCANCEL: "pointercancel"
}
  , PointerEventType = {
    POINTERMOVE: "pointermove",
    POINTERDOWN: "pointerdown",
    POINTERUP: "pointerup",
    POINTEROVER: "pointerover",
    POINTEROUT: "pointerout",
    POINTERENTER: "pointerenter",
    POINTERLEAVE: "pointerleave",
    POINTERCANCEL: "pointercancel"
};
class MapBrowserEventHandler extends EventTarget {
    constructor(i, s) {
        super(i),
        this.map_ = i,
        this.clickTimeoutId_,
        this.emulateClicks_ = !1,
        this.dragging_ = !1,
        this.dragListenerKeys_ = [],
        this.moveTolerance_ = s === void 0 ? 1 : s,
        this.down_ = null;
        const a = this.map_.getViewport();
        this.activePointers_ = [],
        this.trackedTouches_ = {},
        this.element_ = a,
        this.pointerdownListenerKey_ = listen(a, PointerEventType.POINTERDOWN, this.handlePointerDown_, this),
        this.originalPointerMoveEvent_,
        this.relayedListenerKey_ = listen(a, PointerEventType.POINTERMOVE, this.relayMoveEvent_, this),
        this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this),
        this.element_.addEventListener(EventType.TOUCHMOVE, this.boundHandleTouchMove_, PASSIVE_EVENT_LISTENERS ? {
            passive: !1
        } : !1)
    }
    emulateClick_(i) {
        let s = new MapBrowserEvent$1(MapBrowserEventType.CLICK,this.map_,i);
        this.dispatchEvent(s),
        this.clickTimeoutId_ !== void 0 ? (clearTimeout(this.clickTimeoutId_),
        this.clickTimeoutId_ = void 0,
        s = new MapBrowserEvent$1(MapBrowserEventType.DBLCLICK,this.map_,i),
        this.dispatchEvent(s)) : this.clickTimeoutId_ = setTimeout( () => {
            this.clickTimeoutId_ = void 0;
            const a = new MapBrowserEvent$1(MapBrowserEventType.SINGLECLICK,this.map_,i);
            this.dispatchEvent(a)
        }
        , 250)
    }
    updateActivePointers_(i) {
        const s = i
          , a = s.pointerId;
        if (s.type == MapBrowserEventType.POINTERUP || s.type == MapBrowserEventType.POINTERCANCEL) {
            delete this.trackedTouches_[a];
            for (const _ in this.trackedTouches_)
                if (this.trackedTouches_[_].target !== s.target) {
                    delete this.trackedTouches_[_];
                    break
                }
        } else
            (s.type == MapBrowserEventType.POINTERDOWN || s.type == MapBrowserEventType.POINTERMOVE) && (this.trackedTouches_[a] = s);
        this.activePointers_ = Object.values(this.trackedTouches_)
    }
    handlePointerUp_(i) {
        this.updateActivePointers_(i);
        const s = new MapBrowserEvent$1(MapBrowserEventType.POINTERUP,this.map_,i,void 0,void 0,this.activePointers_);
        this.dispatchEvent(s),
        this.emulateClicks_ && !s.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(i) && this.emulateClick_(this.down_),
        this.activePointers_.length === 0 && (this.dragListenerKeys_.forEach(unlistenByKey),
        this.dragListenerKeys_.length = 0,
        this.dragging_ = !1,
        this.down_ = null)
    }
    isMouseActionButton_(i) {
        return i.button === 0
    }
    handlePointerDown_(i) {
        this.emulateClicks_ = this.activePointers_.length === 0,
        this.updateActivePointers_(i);
        const s = new MapBrowserEvent$1(MapBrowserEventType.POINTERDOWN,this.map_,i,void 0,void 0,this.activePointers_);
        if (this.dispatchEvent(s),
        this.down_ = new PointerEvent(i.type,i),
        Object.defineProperty(this.down_, "target", {
            writable: !1,
            value: i.target
        }),
        this.dragListenerKeys_.length === 0) {
            const a = this.map_.getOwnerDocument();
            this.dragListenerKeys_.push(listen(a, MapBrowserEventType.POINTERMOVE, this.handlePointerMove_, this), listen(a, MapBrowserEventType.POINTERUP, this.handlePointerUp_, this), listen(this.element_, MapBrowserEventType.POINTERCANCEL, this.handlePointerUp_, this)),
            this.element_.getRootNode && this.element_.getRootNode() !== a && this.dragListenerKeys_.push(listen(this.element_.getRootNode(), MapBrowserEventType.POINTERUP, this.handlePointerUp_, this))
        }
    }
    handlePointerMove_(i) {
        if (this.isMoving_(i)) {
            this.updateActivePointers_(i),
            this.dragging_ = !0;
            const s = new MapBrowserEvent$1(MapBrowserEventType.POINTERDRAG,this.map_,i,this.dragging_,void 0,this.activePointers_);
            this.dispatchEvent(s)
        }
    }
    relayMoveEvent_(i) {
        this.originalPointerMoveEvent_ = i;
        const s = !!(this.down_ && this.isMoving_(i));
        this.dispatchEvent(new MapBrowserEvent$1(MapBrowserEventType.POINTERMOVE,this.map_,i,s))
    }
    handleTouchMove_(i) {
        const s = this.originalPointerMoveEvent_;
        (!s || s.defaultPrevented) && (typeof i.cancelable != "boolean" || i.cancelable === !0) && i.preventDefault()
    }
    isMoving_(i) {
        return this.dragging_ || Math.abs(i.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(i.clientY - this.down_.clientY) > this.moveTolerance_
    }
    disposeInternal() {
        this.relayedListenerKey_ && (unlistenByKey(this.relayedListenerKey_),
        this.relayedListenerKey_ = null),
        this.element_.removeEventListener(EventType.TOUCHMOVE, this.boundHandleTouchMove_),
        this.pointerdownListenerKey_ && (unlistenByKey(this.pointerdownListenerKey_),
        this.pointerdownListenerKey_ = null),
        this.dragListenerKeys_.forEach(unlistenByKey),
        this.dragListenerKeys_.length = 0,
        this.element_ = null,
        super.disposeInternal()
    }
}
const MapBrowserEventHandler$1 = MapBrowserEventHandler
  , MapEventType = {
    POSTRENDER: "postrender",
    MOVESTART: "movestart",
    MOVEEND: "moveend",
    LOADSTART: "loadstart",
    LOADEND: "loadend"
}
  , MapProperty = {
    LAYERGROUP: "layergroup",
    SIZE: "size",
    TARGET: "target",
    VIEW: "view"
}
  , DROP = 1 / 0;
class PriorityQueue {
    constructor(i, s) {
        this.priorityFunction_ = i,
        this.keyFunction_ = s,
        this.elements_ = [],
        this.priorities_ = [],
        this.queuedElements_ = {}
    }
    clear() {
        this.elements_.length = 0,
        this.priorities_.length = 0,
        clear(this.queuedElements_)
    }
    dequeue() {
        const i = this.elements_
          , s = this.priorities_
          , a = i[0];
        i.length == 1 ? (i.length = 0,
        s.length = 0) : (i[0] = i.pop(),
        s[0] = s.pop(),
        this.siftUp_(0));
        const _ = this.keyFunction_(a);
        return delete this.queuedElements_[_],
        a
    }
    enqueue(i) {
        assert(!(this.keyFunction_(i)in this.queuedElements_), "Tried to enqueue an `element` that was already added to the queue");
        const s = this.priorityFunction_(i);
        return s != DROP ? (this.elements_.push(i),
        this.priorities_.push(s),
        this.queuedElements_[this.keyFunction_(i)] = !0,
        this.siftDown_(0, this.elements_.length - 1),
        !0) : !1
    }
    getCount() {
        return this.elements_.length
    }
    getLeftChildIndex_(i) {
        return i * 2 + 1
    }
    getRightChildIndex_(i) {
        return i * 2 + 2
    }
    getParentIndex_(i) {
        return i - 1 >> 1
    }
    heapify_() {
        let i;
        for (i = (this.elements_.length >> 1) - 1; i >= 0; i--)
            this.siftUp_(i)
    }
    isEmpty() {
        return this.elements_.length === 0
    }
    isKeyQueued(i) {
        return i in this.queuedElements_
    }
    isQueued(i) {
        return this.isKeyQueued(this.keyFunction_(i))
    }
    siftUp_(i) {
        const s = this.elements_
          , a = this.priorities_
          , _ = s.length
          , $ = s[i]
          , _e = a[i]
          , tt = i;
        for (; i < _ >> 1; ) {
            const nt = this.getLeftChildIndex_(i)
              , rt = this.getRightChildIndex_(i)
              , ot = rt < _ && a[rt] < a[nt] ? rt : nt;
            s[i] = s[ot],
            a[i] = a[ot],
            i = ot
        }
        s[i] = $,
        a[i] = _e,
        this.siftDown_(tt, i)
    }
    siftDown_(i, s) {
        const a = this.elements_
          , _ = this.priorities_
          , $ = a[s]
          , _e = _[s];
        for (; s > i; ) {
            const tt = this.getParentIndex_(s);
            if (_[tt] > _e)
                a[s] = a[tt],
                _[s] = _[tt],
                s = tt;
            else
                break
        }
        a[s] = $,
        _[s] = _e
    }
    reprioritize() {
        const i = this.priorityFunction_
          , s = this.elements_
          , a = this.priorities_;
        let _ = 0;
        const $ = s.length;
        let _e, tt, nt;
        for (tt = 0; tt < $; ++tt)
            _e = s[tt],
            nt = i(_e),
            nt == DROP ? delete this.queuedElements_[this.keyFunction_(_e)] : (a[_] = nt,
            s[_++] = _e);
        s.length = _,
        a.length = _,
        this.heapify_()
    }
}
const PriorityQueue$1 = PriorityQueue
  , TileState = {
    IDLE: 0,
    LOADING: 1,
    LOADED: 2,
    ERROR: 3,
    EMPTY: 4
};
class TileQueue extends PriorityQueue$1 {
    constructor(i, s) {
        super(function(a) {
            return i.apply(null, a)
        }, function(a) {
            return a[0].getKey()
        }),
        this.boundHandleTileChange_ = this.handleTileChange.bind(this),
        this.tileChangeCallback_ = s,
        this.tilesLoading_ = 0,
        this.tilesLoadingKeys_ = {}
    }
    enqueue(i) {
        const s = super.enqueue(i);
        return s && i[0].addEventListener(EventType.CHANGE, this.boundHandleTileChange_),
        s
    }
    getTilesLoading() {
        return this.tilesLoading_
    }
    handleTileChange(i) {
        const s = i.target
          , a = s.getState();
        if (a === TileState.LOADED || a === TileState.ERROR || a === TileState.EMPTY) {
            a !== TileState.ERROR && s.removeEventListener(EventType.CHANGE, this.boundHandleTileChange_);
            const _ = s.getKey();
            _ in this.tilesLoadingKeys_ && (delete this.tilesLoadingKeys_[_],
            --this.tilesLoading_),
            this.tileChangeCallback_()
        }
    }
    loadMoreTiles(i, s) {
        let a = 0, _, $, _e;
        for (; this.tilesLoading_ < i && a < s && this.getCount() > 0; )
            $ = this.dequeue()[0],
            _e = $.getKey(),
            _ = $.getState(),
            _ === TileState.IDLE && !(_e in this.tilesLoadingKeys_) && (this.tilesLoadingKeys_[_e] = !0,
            ++this.tilesLoading_,
            ++a,
            $.load())
    }
}
const TileQueue$1 = TileQueue;
function getTilePriority(o, i, s, a, _) {
    if (!o || !(s in o.wantedTiles) || !o.wantedTiles[s][i.getKey()])
        return DROP;
    const $ = o.viewState.center
      , _e = a[0] - $[0]
      , tt = a[1] - $[1];
    return 65536 * Math.log(_) + Math.sqrt(_e * _e + tt * tt) / _
}
class Control extends BaseObject$1 {
    constructor(i) {
        super();
        const s = i.element;
        s && !i.target && !s.style.pointerEvents && (s.style.pointerEvents = "auto"),
        this.element = s || null,
        this.target_ = null,
        this.map_ = null,
        this.listenerKeys = [],
        i.render && (this.render = i.render),
        i.target && this.setTarget(i.target)
    }
    disposeInternal() {
        removeNode(this.element),
        super.disposeInternal()
    }
    getMap() {
        return this.map_
    }
    setMap(i) {
        this.map_ && removeNode(this.element);
        for (let s = 0, a = this.listenerKeys.length; s < a; ++s)
            unlistenByKey(this.listenerKeys[s]);
        this.listenerKeys.length = 0,
        this.map_ = i,
        i && ((this.target_ ? this.target_ : i.getOverlayContainerStopEvent()).appendChild(this.element),
        this.render !== VOID && this.listenerKeys.push(listen(i, MapEventType.POSTRENDER, this.render, this)),
        i.render())
    }
    render(i) {}
    setTarget(i) {
        this.target_ = typeof i == "string" ? document.getElementById(i) : i
    }
}
const Control$1 = Control;
class Attribution extends Control$1 {
    constructor(i) {
        i = i || {},
        super({
            element: document.createElement("div"),
            render: i.render,
            target: i.target
        }),
        this.ulElement_ = document.createElement("ul"),
        this.collapsed_ = i.collapsed !== void 0 ? i.collapsed : !0,
        this.userCollapsed_ = this.collapsed_,
        this.overrideCollapsible_ = i.collapsible !== void 0,
        this.collapsible_ = i.collapsible !== void 0 ? i.collapsible : !0,
        this.collapsible_ || (this.collapsed_ = !1);
        const s = i.className !== void 0 ? i.className : "ol-attribution"
          , a = i.tipLabel !== void 0 ? i.tipLabel : "Attributions"
          , _ = i.expandClassName !== void 0 ? i.expandClassName : s + "-expand"
          , $ = i.collapseLabel !== void 0 ? i.collapseLabel : "›"
          , _e = i.collapseClassName !== void 0 ? i.collapseClassName : s + "-collapse";
        typeof $ == "string" ? (this.collapseLabel_ = document.createElement("span"),
        this.collapseLabel_.textContent = $,
        this.collapseLabel_.className = _e) : this.collapseLabel_ = $;
        const tt = i.label !== void 0 ? i.label : "i";
        typeof tt == "string" ? (this.label_ = document.createElement("span"),
        this.label_.textContent = tt,
        this.label_.className = _) : this.label_ = tt;
        const nt = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
        this.toggleButton_ = document.createElement("button"),
        this.toggleButton_.setAttribute("type", "button"),
        this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_)),
        this.toggleButton_.title = a,
        this.toggleButton_.appendChild(nt),
        this.toggleButton_.addEventListener(EventType.CLICK, this.handleClick_.bind(this), !1);
        const rt = s + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL + (this.collapsed_ && this.collapsible_ ? " " + CLASS_COLLAPSED : "") + (this.collapsible_ ? "" : " ol-uncollapsible")
          , ot = this.element;
        ot.className = rt,
        ot.appendChild(this.toggleButton_),
        ot.appendChild(this.ulElement_),
        this.renderedAttributions_ = [],
        this.renderedVisible_ = !0
    }
    collectSourceAttributions_(i) {
        const s = Array.from(new Set(this.getMap().getAllLayers().flatMap(_ => _.getAttributions(i))))
          , a = !this.getMap().getAllLayers().some(_ => _.getSource() && _.getSource().getAttributionsCollapsible() === !1);
        return this.overrideCollapsible_ || this.setCollapsible(a),
        s
    }
    updateElement_(i) {
        if (!i) {
            this.renderedVisible_ && (this.element.style.display = "none",
            this.renderedVisible_ = !1);
            return
        }
        const s = this.collectSourceAttributions_(i)
          , a = s.length > 0;
        if (this.renderedVisible_ != a && (this.element.style.display = a ? "" : "none",
        this.renderedVisible_ = a),
        !equals$2(s, this.renderedAttributions_)) {
            removeChildren(this.ulElement_);
            for (let _ = 0, $ = s.length; _ < $; ++_) {
                const _e = document.createElement("li");
                _e.innerHTML = s[_],
                this.ulElement_.appendChild(_e)
            }
            this.renderedAttributions_ = s
        }
    }
    handleClick_(i) {
        i.preventDefault(),
        this.handleToggle_(),
        this.userCollapsed_ = this.collapsed_
    }
    handleToggle_() {
        this.element.classList.toggle(CLASS_COLLAPSED),
        this.collapsed_ ? replaceNode(this.collapseLabel_, this.label_) : replaceNode(this.label_, this.collapseLabel_),
        this.collapsed_ = !this.collapsed_,
        this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_))
    }
    getCollapsible() {
        return this.collapsible_
    }
    setCollapsible(i) {
        this.collapsible_ !== i && (this.collapsible_ = i,
        this.element.classList.toggle("ol-uncollapsible"),
        this.userCollapsed_ && this.handleToggle_())
    }
    setCollapsed(i) {
        this.userCollapsed_ = i,
        !(!this.collapsible_ || this.collapsed_ === i) && this.handleToggle_()
    }
    getCollapsed() {
        return this.collapsed_
    }
    render(i) {
        this.updateElement_(i.frameState)
    }
}
const Attribution$1 = Attribution;
class Rotate extends Control$1 {
    constructor(i) {
        i = i || {},
        super({
            element: document.createElement("div"),
            render: i.render,
            target: i.target
        });
        const s = i.className !== void 0 ? i.className : "ol-rotate"
          , a = i.label !== void 0 ? i.label : "⇧"
          , _ = i.compassClassName !== void 0 ? i.compassClassName : "ol-compass";
        this.label_ = null,
        typeof a == "string" ? (this.label_ = document.createElement("span"),
        this.label_.className = _,
        this.label_.textContent = a) : (this.label_ = a,
        this.label_.classList.add(_));
        const $ = i.tipLabel ? i.tipLabel : "Reset rotation"
          , _e = document.createElement("button");
        _e.className = s + "-reset",
        _e.setAttribute("type", "button"),
        _e.title = $,
        _e.appendChild(this.label_),
        _e.addEventListener(EventType.CLICK, this.handleClick_.bind(this), !1);
        const tt = s + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL
          , nt = this.element;
        nt.className = tt,
        nt.appendChild(_e),
        this.callResetNorth_ = i.resetNorth ? i.resetNorth : void 0,
        this.duration_ = i.duration !== void 0 ? i.duration : 250,
        this.autoHide_ = i.autoHide !== void 0 ? i.autoHide : !0,
        this.rotation_ = void 0,
        this.autoHide_ && this.element.classList.add(CLASS_HIDDEN)
    }
    handleClick_(i) {
        i.preventDefault(),
        this.callResetNorth_ !== void 0 ? this.callResetNorth_() : this.resetNorth_()
    }
    resetNorth_() {
        const s = this.getMap().getView();
        if (!s)
            return;
        const a = s.getRotation();
        a !== void 0 && (this.duration_ > 0 && a % (2 * Math.PI) !== 0 ? s.animate({
            rotation: 0,
            duration: this.duration_,
            easing: easeOut
        }) : s.setRotation(0))
    }
    render(i) {
        const s = i.frameState;
        if (!s)
            return;
        const a = s.viewState.rotation;
        if (a != this.rotation_) {
            const _ = "rotate(" + a + "rad)";
            if (this.autoHide_) {
                const $ = this.element.classList.contains(CLASS_HIDDEN);
                !$ && a === 0 ? this.element.classList.add(CLASS_HIDDEN) : $ && a !== 0 && this.element.classList.remove(CLASS_HIDDEN)
            }
            this.label_.style.transform = _
        }
        this.rotation_ = a
    }
}
const Rotate$1 = Rotate;
class Zoom extends Control$1 {
    constructor(i) {
        i = i || {},
        super({
            element: document.createElement("div"),
            target: i.target
        });
        const s = i.className !== void 0 ? i.className : "ol-zoom"
          , a = i.delta !== void 0 ? i.delta : 1
          , _ = i.zoomInClassName !== void 0 ? i.zoomInClassName : s + "-in"
          , $ = i.zoomOutClassName !== void 0 ? i.zoomOutClassName : s + "-out"
          , _e = i.zoomInLabel !== void 0 ? i.zoomInLabel : "+"
          , tt = i.zoomOutLabel !== void 0 ? i.zoomOutLabel : "–"
          , nt = i.zoomInTipLabel !== void 0 ? i.zoomInTipLabel : "Zoom in"
          , rt = i.zoomOutTipLabel !== void 0 ? i.zoomOutTipLabel : "Zoom out"
          , ot = document.createElement("button");
        ot.className = _,
        ot.setAttribute("type", "button"),
        ot.title = nt,
        ot.appendChild(typeof _e == "string" ? document.createTextNode(_e) : _e),
        ot.addEventListener(EventType.CLICK, this.handleClick_.bind(this, a), !1);
        const et = document.createElement("button");
        et.className = $,
        et.setAttribute("type", "button"),
        et.title = rt,
        et.appendChild(typeof tt == "string" ? document.createTextNode(tt) : tt),
        et.addEventListener(EventType.CLICK, this.handleClick_.bind(this, -a), !1);
        const j = s + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL
          , it = this.element;
        it.className = j,
        it.appendChild(ot),
        it.appendChild(et),
        this.duration_ = i.duration !== void 0 ? i.duration : 250
    }
    handleClick_(i, s) {
        s.preventDefault(),
        this.zoomByDelta_(i)
    }
    zoomByDelta_(i) {
        const a = this.getMap().getView();
        if (!a)
            return;
        const _ = a.getZoom();
        if (_ !== void 0) {
            const $ = a.getConstrainedZoom(_ + i);
            this.duration_ > 0 ? (a.getAnimating() && a.cancelAnimations(),
            a.animate({
                zoom: $,
                duration: this.duration_,
                easing: easeOut
            })) : a.setZoom($)
        }
    }
}
const Zoom$1 = Zoom;
function defaults$1(o) {
    o = o || {};
    const i = new Collection$1;
    return (o.zoom !== void 0 ? o.zoom : !0) && i.push(new Zoom$1(o.zoomOptions)),
    (o.rotate !== void 0 ? o.rotate : !0) && i.push(new Rotate$1(o.rotateOptions)),
    (o.attribution !== void 0 ? o.attribution : !0) && i.push(new Attribution$1(o.attributionOptions)),
    i
}
const InteractionProperty = {
    ACTIVE: "active"
};
class Interaction extends BaseObject$1 {
    constructor(i) {
        super(),
        this.on,
        this.once,
        this.un,
        i && i.handleEvent && (this.handleEvent = i.handleEvent),
        this.map_ = null,
        this.setActive(!0)
    }
    getActive() {
        return this.get(InteractionProperty.ACTIVE)
    }
    getMap() {
        return this.map_
    }
    handleEvent(i) {
        return !0
    }
    setActive(i) {
        this.set(InteractionProperty.ACTIVE, i)
    }
    setMap(i) {
        this.map_ = i
    }
}
function pan(o, i, s) {
    const a = o.getCenterInternal();
    if (a) {
        const _ = [a[0] + i[0], a[1] + i[1]];
        o.animateInternal({
            duration: s !== void 0 ? s : 250,
            easing: linear,
            center: o.getConstrainedCenter(_)
        })
    }
}
function zoomByDelta(o, i, s, a) {
    const _ = o.getZoom();
    if (_ === void 0)
        return;
    const $ = o.getConstrainedZoom(_ + i)
      , _e = o.getResolutionForZoom($);
    o.getAnimating() && o.cancelAnimations(),
    o.animate({
        resolution: _e,
        anchor: s,
        duration: a !== void 0 ? a : 250,
        easing: easeOut
    })
}
const Interaction$1 = Interaction;
class DoubleClickZoom extends Interaction$1 {
    constructor(i) {
        super(),
        i = i || {},
        this.delta_ = i.delta ? i.delta : 1,
        this.duration_ = i.duration !== void 0 ? i.duration : 250
    }
    handleEvent(i) {
        let s = !1;
        if (i.type == MapBrowserEventType.DBLCLICK) {
            const a = i.originalEvent
              , _ = i.map
              , $ = i.coordinate
              , _e = a.shiftKey ? -this.delta_ : this.delta_
              , tt = _.getView();
            zoomByDelta(tt, _e, $, this.duration_),
            a.preventDefault(),
            s = !0
        }
        return !s
    }
}
const DoubleClickZoom$1 = DoubleClickZoom;
class PointerInteraction extends Interaction$1 {
    constructor(i) {
        i = i || {},
        super(i),
        i.handleDownEvent && (this.handleDownEvent = i.handleDownEvent),
        i.handleDragEvent && (this.handleDragEvent = i.handleDragEvent),
        i.handleMoveEvent && (this.handleMoveEvent = i.handleMoveEvent),
        i.handleUpEvent && (this.handleUpEvent = i.handleUpEvent),
        i.stopDown && (this.stopDown = i.stopDown),
        this.handlingDownUpSequence = !1,
        this.targetPointers = []
    }
    getPointerCount() {
        return this.targetPointers.length
    }
    handleDownEvent(i) {
        return !1
    }
    handleDragEvent(i) {}
    handleEvent(i) {
        if (!i.originalEvent)
            return !0;
        let s = !1;
        if (this.updateTrackedPointers_(i),
        this.handlingDownUpSequence) {
            if (i.type == MapBrowserEventType.POINTERDRAG)
                this.handleDragEvent(i),
                i.originalEvent.preventDefault();
            else if (i.type == MapBrowserEventType.POINTERUP) {
                const a = this.handleUpEvent(i);
                this.handlingDownUpSequence = a && this.targetPointers.length > 0
            }
        } else if (i.type == MapBrowserEventType.POINTERDOWN) {
            const a = this.handleDownEvent(i);
            this.handlingDownUpSequence = a,
            s = this.stopDown(a)
        } else
            i.type == MapBrowserEventType.POINTERMOVE && this.handleMoveEvent(i);
        return !s
    }
    handleMoveEvent(i) {}
    handleUpEvent(i) {
        return !1
    }
    stopDown(i) {
        return i
    }
    updateTrackedPointers_(i) {
        i.activePointers && (this.targetPointers = i.activePointers)
    }
}
function centroid(o) {
    const i = o.length;
    let s = 0
      , a = 0;
    for (let _ = 0; _ < i; _++)
        s += o[_].clientX,
        a += o[_].clientY;
    return {
        clientX: s / i,
        clientY: a / i
    }
}
const PointerInteraction$1 = PointerInteraction;
function all$1(o) {
    const i = arguments;
    return function(s) {
        let a = !0;
        for (let _ = 0, $ = i.length; _ < $ && (a = a && i[_](s),
        !!a); ++_)
            ;
        return a
    }
}
const altShiftKeysOnly = function(o) {
    const i = o.originalEvent;
    return i.altKey && !(i.metaKey || i.ctrlKey) && i.shiftKey
}
  , focus = function(o) {
    const i = o.map.getTargetElement()
      , s = o.map.getOwnerDocument().activeElement;
    return i.contains(s)
}
  , focusWithTabindex = function(o) {
    return o.map.getTargetElement().hasAttribute("tabindex") ? focus(o) : !0
}
  , always$1 = TRUE
  , mouseActionButton = function(o) {
    const i = o.originalEvent;
    return i.button == 0 && !(WEBKIT && MAC && i.ctrlKey)
}
  , never = FALSE
  , noModifierKeys = function(o) {
    const i = o.originalEvent;
    return !i.altKey && !(i.metaKey || i.ctrlKey) && !i.shiftKey
}
  , platformModifierKey = function(o) {
    const i = o.originalEvent;
    return MAC ? i.metaKey : i.ctrlKey
}
  , shiftKeyOnly = function(o) {
    const i = o.originalEvent;
    return !i.altKey && !(i.metaKey || i.ctrlKey) && i.shiftKey
}
  , targetNotEditable = function(o) {
    const i = o.originalEvent
      , s = i.target.tagName;
    return s !== "INPUT" && s !== "SELECT" && s !== "TEXTAREA" && !i.target.isContentEditable
}
  , mouseOnly = function(o) {
    const i = o.originalEvent;
    return assert(i !== void 0, "mapBrowserEvent must originate from a pointer event"),
    i.pointerType == "mouse"
}
  , primaryAction = function(o) {
    const i = o.originalEvent;
    return assert(i !== void 0, "mapBrowserEvent must originate from a pointer event"),
    i.isPrimary && i.button === 0
};
class DragPan extends PointerInteraction$1 {
    constructor(i) {
        super({
            stopDown: FALSE
        }),
        i = i || {},
        this.kinetic_ = i.kinetic,
        this.lastCentroid = null,
        this.lastPointersCount_,
        this.panning_ = !1;
        const s = i.condition ? i.condition : all$1(noModifierKeys, primaryAction);
        this.condition_ = i.onFocusOnly ? all$1(focusWithTabindex, s) : s,
        this.noKinetic_ = !1
    }
    handleDragEvent(i) {
        const s = i.map;
        this.panning_ || (this.panning_ = !0,
        s.getView().beginInteraction());
        const a = this.targetPointers
          , _ = s.getEventPixel(centroid(a));
        if (a.length == this.lastPointersCount_) {
            if (this.kinetic_ && this.kinetic_.update(_[0], _[1]),
            this.lastCentroid) {
                const $ = [this.lastCentroid[0] - _[0], _[1] - this.lastCentroid[1]]
                  , tt = i.map.getView();
                scale$2($, tt.getResolution()),
                rotate$1($, tt.getRotation()),
                tt.adjustCenterInternal($)
            }
        } else
            this.kinetic_ && this.kinetic_.begin();
        this.lastCentroid = _,
        this.lastPointersCount_ = a.length,
        i.originalEvent.preventDefault()
    }
    handleUpEvent(i) {
        const s = i.map
          , a = s.getView();
        if (this.targetPointers.length === 0) {
            if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
                const _ = this.kinetic_.getDistance()
                  , $ = this.kinetic_.getAngle()
                  , _e = a.getCenterInternal()
                  , tt = s.getPixelFromCoordinateInternal(_e)
                  , nt = s.getCoordinateFromPixelInternal([tt[0] - _ * Math.cos($), tt[1] - _ * Math.sin($)]);
                a.animateInternal({
                    center: a.getConstrainedCenter(nt),
                    duration: 500,
                    easing: easeOut
                })
            }
            return this.panning_ && (this.panning_ = !1,
            a.endInteraction()),
            !1
        }
        return this.kinetic_ && this.kinetic_.begin(),
        this.lastCentroid = null,
        !0
    }
    handleDownEvent(i) {
        if (this.targetPointers.length > 0 && this.condition_(i)) {
            const a = i.map.getView();
            return this.lastCentroid = null,
            a.getAnimating() && a.cancelAnimations(),
            this.kinetic_ && this.kinetic_.begin(),
            this.noKinetic_ = this.targetPointers.length > 1,
            !0
        }
        return !1
    }
}
const DragPan$1 = DragPan;
class DragRotate extends PointerInteraction$1 {
    constructor(i) {
        i = i || {},
        super({
            stopDown: FALSE
        }),
        this.condition_ = i.condition ? i.condition : altShiftKeysOnly,
        this.lastAngle_ = void 0,
        this.duration_ = i.duration !== void 0 ? i.duration : 250
    }
    handleDragEvent(i) {
        if (!mouseOnly(i))
            return;
        const s = i.map
          , a = s.getView();
        if (a.getConstraints().rotation === disable)
            return;
        const _ = s.getSize()
          , $ = i.pixel
          , _e = Math.atan2(_[1] / 2 - $[1], $[0] - _[0] / 2);
        if (this.lastAngle_ !== void 0) {
            const tt = _e - this.lastAngle_;
            a.adjustRotationInternal(-tt)
        }
        this.lastAngle_ = _e
    }
    handleUpEvent(i) {
        return mouseOnly(i) ? (i.map.getView().endInteraction(this.duration_),
        !1) : !0
    }
    handleDownEvent(i) {
        return mouseOnly(i) && mouseActionButton(i) && this.condition_(i) ? (i.map.getView().beginInteraction(),
        this.lastAngle_ = void 0,
        !0) : !1
    }
}
const DragRotate$1 = DragRotate;
class RenderBox extends Disposable$1 {
    constructor(i) {
        super(),
        this.geometry_ = null,
        this.element_ = document.createElement("div"),
        this.element_.style.position = "absolute",
        this.element_.style.pointerEvents = "auto",
        this.element_.className = "ol-box " + i,
        this.map_ = null,
        this.startPixel_ = null,
        this.endPixel_ = null
    }
    disposeInternal() {
        this.setMap(null)
    }
    render_() {
        const i = this.startPixel_
          , s = this.endPixel_
          , a = "px"
          , _ = this.element_.style;
        _.left = Math.min(i[0], s[0]) + a,
        _.top = Math.min(i[1], s[1]) + a,
        _.width = Math.abs(s[0] - i[0]) + a,
        _.height = Math.abs(s[1] - i[1]) + a
    }
    setMap(i) {
        if (this.map_) {
            this.map_.getOverlayContainer().removeChild(this.element_);
            const s = this.element_.style;
            s.left = "inherit",
            s.top = "inherit",
            s.width = "inherit",
            s.height = "inherit"
        }
        this.map_ = i,
        this.map_ && this.map_.getOverlayContainer().appendChild(this.element_)
    }
    setPixels(i, s) {
        this.startPixel_ = i,
        this.endPixel_ = s,
        this.createOrUpdateGeometry(),
        this.render_()
    }
    createOrUpdateGeometry() {
        const i = this.startPixel_
          , s = this.endPixel_
          , _ = [i, [i[0], s[1]], s, [s[0], i[1]]].map(this.map_.getCoordinateFromPixelInternal, this.map_);
        _[4] = _[0].slice(),
        this.geometry_ ? this.geometry_.setCoordinates([_]) : this.geometry_ = new Polygon$1([_])
    }
    getGeometry() {
        return this.geometry_
    }
}
const RenderBox$1 = RenderBox
  , DragBoxEventType = {
    BOXSTART: "boxstart",
    BOXDRAG: "boxdrag",
    BOXEND: "boxend",
    BOXCANCEL: "boxcancel"
};
class DragBoxEvent extends Event$1 {
    constructor(i, s, a) {
        super(i),
        this.coordinate = s,
        this.mapBrowserEvent = a
    }
}
class DragBox extends PointerInteraction$1 {
    constructor(i) {
        super(),
        this.on,
        this.once,
        this.un,
        i = i || {},
        this.box_ = new RenderBox$1(i.className || "ol-dragbox"),
        this.minArea_ = i.minArea !== void 0 ? i.minArea : 64,
        i.onBoxEnd && (this.onBoxEnd = i.onBoxEnd),
        this.startPixel_ = null,
        this.condition_ = i.condition ? i.condition : mouseActionButton,
        this.boxEndCondition_ = i.boxEndCondition ? i.boxEndCondition : this.defaultBoxEndCondition
    }
    defaultBoxEndCondition(i, s, a) {
        const _ = a[0] - s[0]
          , $ = a[1] - s[1];
        return _ * _ + $ * $ >= this.minArea_
    }
    getGeometry() {
        return this.box_.getGeometry()
    }
    handleDragEvent(i) {
        this.box_.setPixels(this.startPixel_, i.pixel),
        this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXDRAG,i.coordinate,i))
    }
    handleUpEvent(i) {
        this.box_.setMap(null);
        const s = this.boxEndCondition_(i, this.startPixel_, i.pixel);
        return s && this.onBoxEnd(i),
        this.dispatchEvent(new DragBoxEvent(s ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL,i.coordinate,i)),
        !1
    }
    handleDownEvent(i) {
        return this.condition_(i) ? (this.startPixel_ = i.pixel,
        this.box_.setMap(i.map),
        this.box_.setPixels(this.startPixel_, this.startPixel_),
        this.dispatchEvent(new DragBoxEvent(DragBoxEventType.BOXSTART,i.coordinate,i)),
        !0) : !1
    }
    onBoxEnd(i) {}
}
const DragBox$1 = DragBox;
class DragZoom extends DragBox$1 {
    constructor(i) {
        i = i || {};
        const s = i.condition ? i.condition : shiftKeyOnly;
        super({
            condition: s,
            className: i.className || "ol-dragzoom",
            minArea: i.minArea
        }),
        this.duration_ = i.duration !== void 0 ? i.duration : 200,
        this.out_ = i.out !== void 0 ? i.out : !1
    }
    onBoxEnd(i) {
        const a = this.getMap().getView();
        let _ = this.getGeometry();
        if (this.out_) {
            const $ = a.rotatedExtentForGeometry(_)
              , _e = a.getResolutionForExtentInternal($)
              , tt = a.getResolution() / _e;
            _ = _.clone(),
            _.scale(tt * tt)
        }
        a.fitInternal(_, {
            duration: this.duration_,
            easing: easeOut
        })
    }
}
const DragZoom$1 = DragZoom
  , Key = {
    LEFT: "ArrowLeft",
    UP: "ArrowUp",
    RIGHT: "ArrowRight",
    DOWN: "ArrowDown"
};
class KeyboardPan extends Interaction$1 {
    constructor(i) {
        super(),
        i = i || {},
        this.defaultCondition_ = function(s) {
            return noModifierKeys(s) && targetNotEditable(s)
        }
        ,
        this.condition_ = i.condition !== void 0 ? i.condition : this.defaultCondition_,
        this.duration_ = i.duration !== void 0 ? i.duration : 100,
        this.pixelDelta_ = i.pixelDelta !== void 0 ? i.pixelDelta : 128
    }
    handleEvent(i) {
        let s = !1;
        if (i.type == EventType.KEYDOWN) {
            const a = i.originalEvent
              , _ = a.key;
            if (this.condition_(i) && (_ == Key.DOWN || _ == Key.LEFT || _ == Key.RIGHT || _ == Key.UP)) {
                const _e = i.map.getView()
                  , tt = _e.getResolution() * this.pixelDelta_;
                let nt = 0
                  , rt = 0;
                _ == Key.DOWN ? rt = -tt : _ == Key.LEFT ? nt = -tt : _ == Key.RIGHT ? nt = tt : rt = tt;
                const ot = [nt, rt];
                rotate$1(ot, _e.getRotation()),
                pan(_e, ot, this.duration_),
                a.preventDefault(),
                s = !0
            }
        }
        return !s
    }
}
const KeyboardPan$1 = KeyboardPan;
class KeyboardZoom extends Interaction$1 {
    constructor(i) {
        super(),
        i = i || {},
        this.condition_ = i.condition ? i.condition : function(s) {
            return !platformModifierKey(s) && targetNotEditable(s)
        }
        ,
        this.delta_ = i.delta ? i.delta : 1,
        this.duration_ = i.duration !== void 0 ? i.duration : 100
    }
    handleEvent(i) {
        let s = !1;
        if (i.type == EventType.KEYDOWN || i.type == EventType.KEYPRESS) {
            const a = i.originalEvent
              , _ = a.key;
            if (this.condition_(i) && (_ === "+" || _ === "-")) {
                const $ = i.map
                  , _e = _ === "+" ? this.delta_ : -this.delta_
                  , tt = $.getView();
                zoomByDelta(tt, _e, void 0, this.duration_),
                a.preventDefault(),
                s = !0
            }
        }
        return !s
    }
}
const KeyboardZoom$1 = KeyboardZoom;
class Kinetic {
    constructor(i, s, a) {
        this.decay_ = i,
        this.minVelocity_ = s,
        this.delay_ = a,
        this.points_ = [],
        this.angle_ = 0,
        this.initialVelocity_ = 0
    }
    begin() {
        this.points_.length = 0,
        this.angle_ = 0,
        this.initialVelocity_ = 0
    }
    update(i, s) {
        this.points_.push(i, s, Date.now())
    }
    end() {
        if (this.points_.length < 6)
            return !1;
        const i = Date.now() - this.delay_
          , s = this.points_.length - 3;
        if (this.points_[s + 2] < i)
            return !1;
        let a = s - 3;
        for (; a > 0 && this.points_[a + 2] > i; )
            a -= 3;
        const _ = this.points_[s + 2] - this.points_[a + 2];
        if (_ < 1e3 / 60)
            return !1;
        const $ = this.points_[s] - this.points_[a]
          , _e = this.points_[s + 1] - this.points_[a + 1];
        return this.angle_ = Math.atan2(_e, $),
        this.initialVelocity_ = Math.sqrt($ * $ + _e * _e) / _,
        this.initialVelocity_ > this.minVelocity_
    }
    getDistance() {
        return (this.minVelocity_ - this.initialVelocity_) / this.decay_
    }
    getAngle() {
        return this.angle_
    }
}
const Kinetic$1 = Kinetic;
class MouseWheelZoom extends Interaction$1 {
    constructor(i) {
        i = i || {},
        super(i),
        this.totalDelta_ = 0,
        this.lastDelta_ = 0,
        this.maxDelta_ = i.maxDelta !== void 0 ? i.maxDelta : 1,
        this.duration_ = i.duration !== void 0 ? i.duration : 250,
        this.timeout_ = i.timeout !== void 0 ? i.timeout : 80,
        this.useAnchor_ = i.useAnchor !== void 0 ? i.useAnchor : !0,
        this.constrainResolution_ = i.constrainResolution !== void 0 ? i.constrainResolution : !1;
        const s = i.condition ? i.condition : always$1;
        this.condition_ = i.onFocusOnly ? all$1(focusWithTabindex, s) : s,
        this.lastAnchor_ = null,
        this.startTime_ = void 0,
        this.timeoutId_,
        this.mode_ = void 0,
        this.trackpadEventGap_ = 400,
        this.trackpadTimeoutId_,
        this.deltaPerZoom_ = 300
    }
    endInteraction_() {
        this.trackpadTimeoutId_ = void 0;
        const i = this.getMap();
        if (!i)
            return;
        i.getView().endInteraction(void 0, this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0, this.lastAnchor_)
    }
    handleEvent(i) {
        if (!this.condition_(i) || i.type !== EventType.WHEEL)
            return !0;
        const a = i.map
          , _ = i.originalEvent;
        _.preventDefault(),
        this.useAnchor_ && (this.lastAnchor_ = i.coordinate);
        let $;
        if (i.type == EventType.WHEEL && ($ = _.deltaY,
        FIREFOX && _.deltaMode === WheelEvent.DOM_DELTA_PIXEL && ($ /= DEVICE_PIXEL_RATIO),
        _.deltaMode === WheelEvent.DOM_DELTA_LINE && ($ *= 40)),
        $ === 0)
            return !1;
        this.lastDelta_ = $;
        const _e = Date.now();
        this.startTime_ === void 0 && (this.startTime_ = _e),
        (!this.mode_ || _e - this.startTime_ > this.trackpadEventGap_) && (this.mode_ = Math.abs($) < 4 ? "trackpad" : "wheel");
        const tt = a.getView();
        if (this.mode_ === "trackpad" && !(tt.getConstrainResolution() || this.constrainResolution_))
            return this.trackpadTimeoutId_ ? clearTimeout(this.trackpadTimeoutId_) : (tt.getAnimating() && tt.cancelAnimations(),
            tt.beginInteraction()),
            this.trackpadTimeoutId_ = setTimeout(this.endInteraction_.bind(this), this.timeout_),
            tt.adjustZoom(-$ / this.deltaPerZoom_, this.lastAnchor_),
            this.startTime_ = _e,
            !1;
        this.totalDelta_ += $;
        const nt = Math.max(this.timeout_ - (_e - this.startTime_), 0);
        return clearTimeout(this.timeoutId_),
        this.timeoutId_ = setTimeout(this.handleWheelZoom_.bind(this, a), nt),
        !1
    }
    handleWheelZoom_(i) {
        const s = i.getView();
        s.getAnimating() && s.cancelAnimations();
        let a = -clamp(this.totalDelta_, -this.maxDelta_ * this.deltaPerZoom_, this.maxDelta_ * this.deltaPerZoom_) / this.deltaPerZoom_;
        (s.getConstrainResolution() || this.constrainResolution_) && (a = a ? a > 0 ? 1 : -1 : 0),
        zoomByDelta(s, a, this.lastAnchor_, this.duration_),
        this.mode_ = void 0,
        this.totalDelta_ = 0,
        this.lastAnchor_ = null,
        this.startTime_ = void 0,
        this.timeoutId_ = void 0
    }
    setMouseAnchor(i) {
        this.useAnchor_ = i,
        i || (this.lastAnchor_ = null)
    }
}
const MouseWheelZoom$1 = MouseWheelZoom;
class PinchRotate extends PointerInteraction$1 {
    constructor(i) {
        i = i || {};
        const s = i;
        s.stopDown || (s.stopDown = FALSE),
        super(s),
        this.anchor_ = null,
        this.lastAngle_ = void 0,
        this.rotating_ = !1,
        this.rotationDelta_ = 0,
        this.threshold_ = i.threshold !== void 0 ? i.threshold : .3,
        this.duration_ = i.duration !== void 0 ? i.duration : 250
    }
    handleDragEvent(i) {
        let s = 0;
        const a = this.targetPointers[0]
          , _ = this.targetPointers[1]
          , $ = Math.atan2(_.clientY - a.clientY, _.clientX - a.clientX);
        if (this.lastAngle_ !== void 0) {
            const nt = $ - this.lastAngle_;
            this.rotationDelta_ += nt,
            !this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_ && (this.rotating_ = !0),
            s = nt
        }
        this.lastAngle_ = $;
        const _e = i.map
          , tt = _e.getView();
        tt.getConstraints().rotation !== disable && (this.anchor_ = _e.getCoordinateFromPixelInternal(_e.getEventPixel(centroid(this.targetPointers))),
        this.rotating_ && (_e.render(),
        tt.adjustRotationInternal(s, this.anchor_)))
    }
    handleUpEvent(i) {
        return this.targetPointers.length < 2 ? (i.map.getView().endInteraction(this.duration_),
        !1) : !0
    }
    handleDownEvent(i) {
        if (this.targetPointers.length >= 2) {
            const s = i.map;
            return this.anchor_ = null,
            this.lastAngle_ = void 0,
            this.rotating_ = !1,
            this.rotationDelta_ = 0,
            this.handlingDownUpSequence || s.getView().beginInteraction(),
            !0
        }
        return !1
    }
}
const PinchRotate$1 = PinchRotate;
class PinchZoom extends PointerInteraction$1 {
    constructor(i) {
        i = i || {};
        const s = i;
        s.stopDown || (s.stopDown = FALSE),
        super(s),
        this.anchor_ = null,
        this.duration_ = i.duration !== void 0 ? i.duration : 400,
        this.lastDistance_ = void 0,
        this.lastScaleDelta_ = 1
    }
    handleDragEvent(i) {
        let s = 1;
        const a = this.targetPointers[0]
          , _ = this.targetPointers[1]
          , $ = a.clientX - _.clientX
          , _e = a.clientY - _.clientY
          , tt = Math.sqrt($ * $ + _e * _e);
        this.lastDistance_ !== void 0 && (s = this.lastDistance_ / tt),
        this.lastDistance_ = tt;
        const nt = i.map
          , rt = nt.getView();
        s != 1 && (this.lastScaleDelta_ = s),
        this.anchor_ = nt.getCoordinateFromPixelInternal(nt.getEventPixel(centroid(this.targetPointers))),
        nt.render(),
        rt.adjustResolutionInternal(s, this.anchor_)
    }
    handleUpEvent(i) {
        if (this.targetPointers.length < 2) {
            const a = i.map.getView()
              , _ = this.lastScaleDelta_ > 1 ? 1 : -1;
            return a.endInteraction(this.duration_, _),
            !1
        }
        return !0
    }
    handleDownEvent(i) {
        if (this.targetPointers.length >= 2) {
            const s = i.map;
            return this.anchor_ = null,
            this.lastDistance_ = void 0,
            this.lastScaleDelta_ = 1,
            this.handlingDownUpSequence || s.getView().beginInteraction(),
            !0
        }
        return !1
    }
}
const PinchZoom$1 = PinchZoom;
function defaults(o) {
    o = o || {};
    const i = new Collection$1
      , s = new Kinetic$1(-.005,.05,100);
    return (o.altShiftDragRotate !== void 0 ? o.altShiftDragRotate : !0) && i.push(new DragRotate$1),
    (o.doubleClickZoom !== void 0 ? o.doubleClickZoom : !0) && i.push(new DoubleClickZoom$1({
        delta: o.zoomDelta,
        duration: o.zoomDuration
    })),
    (o.dragPan !== void 0 ? o.dragPan : !0) && i.push(new DragPan$1({
        onFocusOnly: o.onFocusOnly,
        kinetic: s
    })),
    (o.pinchRotate !== void 0 ? o.pinchRotate : !0) && i.push(new PinchRotate$1),
    (o.pinchZoom !== void 0 ? o.pinchZoom : !0) && i.push(new PinchZoom$1({
        duration: o.zoomDuration
    })),
    (o.keyboard !== void 0 ? o.keyboard : !0) && (i.push(new KeyboardPan$1),
    i.push(new KeyboardZoom$1({
        delta: o.zoomDelta,
        duration: o.zoomDuration
    }))),
    (o.mouseWheelZoom !== void 0 ? o.mouseWheelZoom : !0) && i.push(new MouseWheelZoom$1({
        onFocusOnly: o.onFocusOnly,
        duration: o.zoomDuration
    })),
    (o.shiftDragZoom !== void 0 ? o.shiftDragZoom : !0) && i.push(new DragZoom$1({
        duration: o.zoomDuration
    })),
    i
}
function hasArea(o) {
    return o[0] > 0 && o[1] > 0
}
function scale(o, i, s) {
    return s === void 0 && (s = [0, 0]),
    s[0] = o[0] * i + .5 | 0,
    s[1] = o[1] * i + .5 | 0,
    s
}
function toSize(o, i) {
    return Array.isArray(o) ? o : (i === void 0 ? i = [o, o] : (i[0] = o,
    i[1] = o),
    i)
}
function removeLayerMapProperty(o) {
    if (o instanceof Layer$1) {
        o.setMapInternal(null);
        return
    }
    o instanceof LayerGroup$1 && o.getLayers().forEach(removeLayerMapProperty)
}
function setLayerMapProperty(o, i) {
    if (o instanceof Layer$1) {
        o.setMapInternal(i);
        return
    }
    if (o instanceof LayerGroup$1) {
        const s = o.getLayers().getArray();
        for (let a = 0, _ = s.length; a < _; ++a)
            setLayerMapProperty(s[a], i)
    }
}
let Map$1 = class extends BaseObject$1 {
    constructor(i) {
        super(),
        i = i || {},
        this.on,
        this.once,
        this.un;
        const s = createOptionsInternal(i);
        this.renderComplete_,
        this.loaded_ = !0,
        this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this),
        this.maxTilesLoading_ = i.maxTilesLoading !== void 0 ? i.maxTilesLoading : 16,
        this.pixelRatio_ = i.pixelRatio !== void 0 ? i.pixelRatio : DEVICE_PIXEL_RATIO,
        this.postRenderTimeoutHandle_,
        this.animationDelayKey_,
        this.animationDelay_ = this.animationDelay_.bind(this),
        this.coordinateToPixelTransform_ = create$1(),
        this.pixelToCoordinateTransform_ = create$1(),
        this.frameIndex_ = 0,
        this.frameState_ = null,
        this.previousExtent_ = null,
        this.viewPropertyListenerKey_ = null,
        this.viewChangeListenerKey_ = null,
        this.layerGroupPropertyListenerKeys_ = null,
        this.viewport_ = document.createElement("div"),
        this.viewport_.className = "ol-viewport" + ("ontouchstart"in window ? " ol-touch" : ""),
        this.viewport_.style.position = "relative",
        this.viewport_.style.overflow = "hidden",
        this.viewport_.style.width = "100%",
        this.viewport_.style.height = "100%",
        this.overlayContainer_ = document.createElement("div"),
        this.overlayContainer_.style.position = "absolute",
        this.overlayContainer_.style.zIndex = "0",
        this.overlayContainer_.style.width = "100%",
        this.overlayContainer_.style.height = "100%",
        this.overlayContainer_.style.pointerEvents = "none",
        this.overlayContainer_.className = "ol-overlaycontainer",
        this.viewport_.appendChild(this.overlayContainer_),
        this.overlayContainerStopEvent_ = document.createElement("div"),
        this.overlayContainerStopEvent_.style.position = "absolute",
        this.overlayContainerStopEvent_.style.zIndex = "0",
        this.overlayContainerStopEvent_.style.width = "100%",
        this.overlayContainerStopEvent_.style.height = "100%",
        this.overlayContainerStopEvent_.style.pointerEvents = "none",
        this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent",
        this.viewport_.appendChild(this.overlayContainerStopEvent_),
        this.mapBrowserEventHandler_ = null,
        this.moveTolerance_ = i.moveTolerance,
        this.keyboardEventTarget_ = s.keyboardEventTarget,
        this.targetChangeHandlerKeys_ = null,
        this.targetElement_ = null,
        this.resizeObserver_ = new ResizeObserver( () => this.updateSize()),
        this.controls = s.controls || defaults$1(),
        this.interactions = s.interactions || defaults({
            onFocusOnly: !0
        }),
        this.overlays_ = s.overlays,
        this.overlayIdIndex_ = {},
        this.renderer_ = null,
        this.postRenderFunctions_ = [],
        this.tileQueue_ = new TileQueue$1(this.getTilePriority.bind(this),this.handleTileChange_.bind(this)),
        this.addChangeListener(MapProperty.LAYERGROUP, this.handleLayerGroupChanged_),
        this.addChangeListener(MapProperty.VIEW, this.handleViewChanged_),
        this.addChangeListener(MapProperty.SIZE, this.handleSizeChanged_),
        this.addChangeListener(MapProperty.TARGET, this.handleTargetChanged_),
        this.setProperties(s.values);
        const a = this;
        i.view && !(i.view instanceof View$1) && i.view.then(function(_) {
            a.setView(new View$1(_))
        }),
        this.controls.addEventListener(CollectionEventType.ADD, _ => {
            _.element.setMap(this)
        }
        ),
        this.controls.addEventListener(CollectionEventType.REMOVE, _ => {
            _.element.setMap(null)
        }
        ),
        this.interactions.addEventListener(CollectionEventType.ADD, _ => {
            _.element.setMap(this)
        }
        ),
        this.interactions.addEventListener(CollectionEventType.REMOVE, _ => {
            _.element.setMap(null)
        }
        ),
        this.overlays_.addEventListener(CollectionEventType.ADD, _ => {
            this.addOverlayInternal_(_.element)
        }
        ),
        this.overlays_.addEventListener(CollectionEventType.REMOVE, _ => {
            const $ = _.element.getId();
            $ !== void 0 && delete this.overlayIdIndex_[$.toString()],
            _.element.setMap(null)
        }
        ),
        this.controls.forEach(_ => {
            _.setMap(this)
        }
        ),
        this.interactions.forEach(_ => {
            _.setMap(this)
        }
        ),
        this.overlays_.forEach(this.addOverlayInternal_.bind(this))
    }
    addControl(i) {
        this.getControls().push(i)
    }
    addInteraction(i) {
        this.getInteractions().push(i)
    }
    addLayer(i) {
        this.getLayerGroup().getLayers().push(i)
    }
    handleLayerAdd_(i) {
        setLayerMapProperty(i.layer, this)
    }
    addOverlay(i) {
        this.getOverlays().push(i)
    }
    addOverlayInternal_(i) {
        const s = i.getId();
        s !== void 0 && (this.overlayIdIndex_[s.toString()] = i),
        i.setMap(this)
    }
    disposeInternal() {
        this.controls.clear(),
        this.interactions.clear(),
        this.overlays_.clear(),
        this.resizeObserver_.disconnect(),
        this.setTarget(null),
        super.disposeInternal()
    }
    forEachFeatureAtPixel(i, s, a) {
        if (!this.frameState_ || !this.renderer_)
            return;
        const _ = this.getCoordinateFromPixelInternal(i);
        a = a !== void 0 ? a : {};
        const $ = a.hitTolerance !== void 0 ? a.hitTolerance : 0
          , _e = a.layerFilter !== void 0 ? a.layerFilter : TRUE
          , tt = a.checkWrapped !== !1;
        return this.renderer_.forEachFeatureAtCoordinate(_, this.frameState_, $, tt, s, null, _e, null)
    }
    getFeaturesAtPixel(i, s) {
        const a = [];
        return this.forEachFeatureAtPixel(i, function(_) {
            a.push(_)
        }, s),
        a
    }
    getAllLayers() {
        const i = [];
        function s(a) {
            a.forEach(function(_) {
                _ instanceof LayerGroup$1 ? s(_.getLayers()) : i.push(_)
            })
        }
        return s(this.getLayers()),
        i
    }
    hasFeatureAtPixel(i, s) {
        if (!this.frameState_ || !this.renderer_)
            return !1;
        const a = this.getCoordinateFromPixelInternal(i);
        s = s !== void 0 ? s : {};
        const _ = s.layerFilter !== void 0 ? s.layerFilter : TRUE
          , $ = s.hitTolerance !== void 0 ? s.hitTolerance : 0
          , _e = s.checkWrapped !== !1;
        return this.renderer_.hasFeatureAtCoordinate(a, this.frameState_, $, _e, _, null)
    }
    getEventCoordinate(i) {
        return this.getCoordinateFromPixel(this.getEventPixel(i))
    }
    getEventCoordinateInternal(i) {
        return this.getCoordinateFromPixelInternal(this.getEventPixel(i))
    }
    getEventPixel(i) {
        const a = this.viewport_.getBoundingClientRect()
          , _ = this.getSize()
          , $ = a.width / _[0]
          , _e = a.height / _[1]
          , tt = "changedTouches"in i ? i.changedTouches[0] : i;
        return [(tt.clientX - a.left) / $, (tt.clientY - a.top) / _e]
    }
    getTarget() {
        return this.get(MapProperty.TARGET)
    }
    getTargetElement() {
        return this.targetElement_
    }
    getCoordinateFromPixel(i) {
        return toUserCoordinate(this.getCoordinateFromPixelInternal(i), this.getView().getProjection())
    }
    getCoordinateFromPixelInternal(i) {
        const s = this.frameState_;
        return s ? apply(s.pixelToCoordinateTransform, i.slice()) : null
    }
    getControls() {
        return this.controls
    }
    getOverlays() {
        return this.overlays_
    }
    getOverlayById(i) {
        const s = this.overlayIdIndex_[i.toString()];
        return s !== void 0 ? s : null
    }
    getInteractions() {
        return this.interactions
    }
    getLayerGroup() {
        return this.get(MapProperty.LAYERGROUP)
    }
    setLayers(i) {
        const s = this.getLayerGroup();
        if (i instanceof Collection$1) {
            s.setLayers(i);
            return
        }
        const a = s.getLayers();
        a.clear(),
        a.extend(i)
    }
    getLayers() {
        return this.getLayerGroup().getLayers()
    }
    getLoadingOrNotReady() {
        const i = this.getLayerGroup().getLayerStatesArray();
        for (let s = 0, a = i.length; s < a; ++s) {
            const _ = i[s];
            if (!_.visible)
                continue;
            const $ = _.layer.getRenderer();
            if ($ && !$.ready)
                return !0;
            const _e = _.layer.getSource();
            if (_e && _e.loading)
                return !0
        }
        return !1
    }
    getPixelFromCoordinate(i) {
        const s = fromUserCoordinate(i, this.getView().getProjection());
        return this.getPixelFromCoordinateInternal(s)
    }
    getPixelFromCoordinateInternal(i) {
        const s = this.frameState_;
        return s ? apply(s.coordinateToPixelTransform, i.slice(0, 2)) : null
    }
    getRenderer() {
        return this.renderer_
    }
    getSize() {
        return this.get(MapProperty.SIZE)
    }
    getView() {
        return this.get(MapProperty.VIEW)
    }
    getViewport() {
        return this.viewport_
    }
    getOverlayContainer() {
        return this.overlayContainer_
    }
    getOverlayContainerStopEvent() {
        return this.overlayContainerStopEvent_
    }
    getOwnerDocument() {
        const i = this.getTargetElement();
        return i ? i.ownerDocument : document
    }
    getTilePriority(i, s, a, _) {
        return getTilePriority(this.frameState_, i, s, a, _)
    }
    handleBrowserEvent(i, s) {
        s = s || i.type;
        const a = new MapBrowserEvent$1(s,this,i);
        this.handleMapBrowserEvent(a)
    }
    handleMapBrowserEvent(i) {
        if (!this.frameState_)
            return;
        const s = i.originalEvent
          , a = s.type;
        if (a === PointerEventType.POINTERDOWN || a === EventType.WHEEL || a === EventType.KEYDOWN) {
            const _ = this.getOwnerDocument()
              , $ = this.viewport_.getRootNode ? this.viewport_.getRootNode() : _
              , _e = s.target;
            if (this.overlayContainerStopEvent_.contains(_e) || !($ === _ ? _.documentElement : $).contains(_e))
                return
        }
        if (i.frameState = this.frameState_,
        this.dispatchEvent(i) !== !1) {
            const _ = this.getInteractions().getArray().slice();
            for (let $ = _.length - 1; $ >= 0; $--) {
                const _e = _[$];
                if (_e.getMap() !== this || !_e.getActive() || !this.getTargetElement())
                    continue;
                if (!_e.handleEvent(i) || i.propagationStopped)
                    break
            }
        }
    }
    handlePostRender() {
        const i = this.frameState_
          , s = this.tileQueue_;
        if (!s.isEmpty()) {
            let _ = this.maxTilesLoading_
              , $ = _;
            if (i) {
                const _e = i.viewHints;
                if (_e[ViewHint.ANIMATING] || _e[ViewHint.INTERACTING]) {
                    const tt = Date.now() - i.time > 8;
                    _ = tt ? 0 : 8,
                    $ = tt ? 0 : 2
                }
            }
            s.getTilesLoading() < _ && (s.reprioritize(),
            s.loadMoreTiles(_, $))
        }
        i && this.renderer_ && !i.animate && (this.renderComplete_ === !0 ? (this.hasListener(RenderEventType.RENDERCOMPLETE) && this.renderer_.dispatchRenderEvent(RenderEventType.RENDERCOMPLETE, i),
        this.loaded_ === !1 && (this.loaded_ = !0,
        this.dispatchEvent(new MapEvent$1(MapEventType.LOADEND,this,i)))) : this.loaded_ === !0 && (this.loaded_ = !1,
        this.dispatchEvent(new MapEvent$1(MapEventType.LOADSTART,this,i))));
        const a = this.postRenderFunctions_;
        for (let _ = 0, $ = a.length; _ < $; ++_)
            a[_](this, i);
        a.length = 0
    }
    handleSizeChanged_() {
        this.getView() && !this.getView().getAnimating() && this.getView().resolveConstraints(0),
        this.render()
    }
    handleTargetChanged_() {
        if (this.mapBrowserEventHandler_) {
            for (let a = 0, _ = this.targetChangeHandlerKeys_.length; a < _; ++a)
                unlistenByKey(this.targetChangeHandlerKeys_[a]);
            this.targetChangeHandlerKeys_ = null,
            this.viewport_.removeEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_),
            this.viewport_.removeEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_),
            this.mapBrowserEventHandler_.dispose(),
            this.mapBrowserEventHandler_ = null,
            removeNode(this.viewport_)
        }
        if (this.targetElement_) {
            this.resizeObserver_.unobserve(this.targetElement_);
            const a = this.targetElement_.getRootNode();
            a instanceof ShadowRoot && this.resizeObserver_.unobserve(a.host),
            this.setSize(void 0)
        }
        const i = this.getTarget()
          , s = typeof i == "string" ? document.getElementById(i) : i;
        if (this.targetElement_ = s,
        !s)
            this.renderer_ && (clearTimeout(this.postRenderTimeoutHandle_),
            this.postRenderTimeoutHandle_ = void 0,
            this.postRenderFunctions_.length = 0,
            this.renderer_.dispose(),
            this.renderer_ = null),
            this.animationDelayKey_ && (cancelAnimationFrame(this.animationDelayKey_),
            this.animationDelayKey_ = void 0);
        else {
            s.appendChild(this.viewport_),
            this.renderer_ || (this.renderer_ = new CompositeMapRenderer$1(this)),
            this.mapBrowserEventHandler_ = new MapBrowserEventHandler$1(this,this.moveTolerance_);
            for (const $ in MapBrowserEventType)
                this.mapBrowserEventHandler_.addEventListener(MapBrowserEventType[$], this.handleMapBrowserEvent.bind(this));
            this.viewport_.addEventListener(EventType.CONTEXTMENU, this.boundHandleBrowserEvent_, !1),
            this.viewport_.addEventListener(EventType.WHEEL, this.boundHandleBrowserEvent_, PASSIVE_EVENT_LISTENERS ? {
                passive: !1
            } : !1);
            const a = this.keyboardEventTarget_ ? this.keyboardEventTarget_ : s;
            this.targetChangeHandlerKeys_ = [listen(a, EventType.KEYDOWN, this.handleBrowserEvent, this), listen(a, EventType.KEYPRESS, this.handleBrowserEvent, this)];
            const _ = s.getRootNode();
            _ instanceof ShadowRoot && this.resizeObserver_.observe(_.host),
            this.resizeObserver_.observe(s)
        }
        this.updateSize()
    }
    handleTileChange_() {
        this.render()
    }
    handleViewPropertyChanged_() {
        this.render()
    }
    handleViewChanged_() {
        this.viewPropertyListenerKey_ && (unlistenByKey(this.viewPropertyListenerKey_),
        this.viewPropertyListenerKey_ = null),
        this.viewChangeListenerKey_ && (unlistenByKey(this.viewChangeListenerKey_),
        this.viewChangeListenerKey_ = null);
        const i = this.getView();
        i && (this.updateViewportSize_(),
        this.viewPropertyListenerKey_ = listen(i, ObjectEventType.PROPERTYCHANGE, this.handleViewPropertyChanged_, this),
        this.viewChangeListenerKey_ = listen(i, EventType.CHANGE, this.handleViewPropertyChanged_, this),
        i.resolveConstraints(0)),
        this.render()
    }
    handleLayerGroupChanged_() {
        this.layerGroupPropertyListenerKeys_ && (this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey),
        this.layerGroupPropertyListenerKeys_ = null);
        const i = this.getLayerGroup();
        i && (this.handleLayerAdd_(new GroupEvent("addlayer",i)),
        this.layerGroupPropertyListenerKeys_ = [listen(i, ObjectEventType.PROPERTYCHANGE, this.render, this), listen(i, EventType.CHANGE, this.render, this), listen(i, "addlayer", this.handleLayerAdd_, this), listen(i, "removelayer", this.handleLayerRemove_, this)]),
        this.render()
    }
    isRendered() {
        return !!this.frameState_
    }
    animationDelay_() {
        this.animationDelayKey_ = void 0,
        this.renderFrame_(Date.now())
    }
    renderSync() {
        this.animationDelayKey_ && cancelAnimationFrame(this.animationDelayKey_),
        this.animationDelay_()
    }
    redrawText() {
        const i = this.getLayerGroup().getLayerStatesArray();
        for (let s = 0, a = i.length; s < a; ++s) {
            const _ = i[s].layer;
            _.hasRenderer() && _.getRenderer().handleFontsChanged()
        }
    }
    render() {
        this.renderer_ && this.animationDelayKey_ === void 0 && (this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_))
    }
    flushDeclutterItems() {
        const i = this.frameState_;
        i && this.renderer_.flushDeclutterItems(i)
    }
    removeControl(i) {
        return this.getControls().remove(i)
    }
    removeInteraction(i) {
        return this.getInteractions().remove(i)
    }
    removeLayer(i) {
        return this.getLayerGroup().getLayers().remove(i)
    }
    handleLayerRemove_(i) {
        removeLayerMapProperty(i.layer)
    }
    removeOverlay(i) {
        return this.getOverlays().remove(i)
    }
    renderFrame_(i) {
        const s = this.getSize()
          , a = this.getView()
          , _ = this.frameState_;
        let $ = null;
        if (s !== void 0 && hasArea(s) && a && a.isDef()) {
            const _e = a.getHints(this.frameState_ ? this.frameState_.viewHints : void 0)
              , tt = a.getState();
            if ($ = {
                animate: !1,
                coordinateToPixelTransform: this.coordinateToPixelTransform_,
                declutterTree: null,
                extent: getForViewAndSize(tt.center, tt.resolution, tt.rotation, s),
                index: this.frameIndex_++,
                layerIndex: 0,
                layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
                pixelRatio: this.pixelRatio_,
                pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
                postRenderFunctions: [],
                size: s,
                tileQueue: this.tileQueue_,
                time: i,
                usedTiles: {},
                viewState: tt,
                viewHints: _e,
                wantedTiles: {},
                mapId: getUid(this),
                renderTargets: {}
            },
            tt.nextCenter && tt.nextResolution) {
                const nt = isNaN(tt.nextRotation) ? tt.rotation : tt.nextRotation;
                $.nextExtent = getForViewAndSize(tt.nextCenter, tt.nextResolution, nt, s)
            }
        }
        this.frameState_ = $,
        this.renderer_.renderFrame($),
        $ && ($.animate && this.render(),
        Array.prototype.push.apply(this.postRenderFunctions_, $.postRenderFunctions),
        _ && (!this.previousExtent_ || !isEmpty(this.previousExtent_) && !equals$1($.extent, this.previousExtent_)) && (this.dispatchEvent(new MapEvent$1(MapEventType.MOVESTART,this,_)),
        this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_)),
        this.previousExtent_ && !$.viewHints[ViewHint.ANIMATING] && !$.viewHints[ViewHint.INTERACTING] && !equals$1($.extent, this.previousExtent_) && (this.dispatchEvent(new MapEvent$1(MapEventType.MOVEEND,this,$)),
        clone($.extent, this.previousExtent_))),
        this.dispatchEvent(new MapEvent$1(MapEventType.POSTRENDER,this,$)),
        this.renderComplete_ = this.hasListener(MapEventType.LOADSTART) || this.hasListener(MapEventType.LOADEND) || this.hasListener(RenderEventType.RENDERCOMPLETE) ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady() : void 0,
        this.postRenderTimeoutHandle_ || (this.postRenderTimeoutHandle_ = setTimeout( () => {
            this.postRenderTimeoutHandle_ = void 0,
            this.handlePostRender()
        }
        , 0))
    }
    setLayerGroup(i) {
        const s = this.getLayerGroup();
        s && this.handleLayerRemove_(new GroupEvent("removelayer",s)),
        this.set(MapProperty.LAYERGROUP, i)
    }
    setSize(i) {
        this.set(MapProperty.SIZE, i)
    }
    setTarget(i) {
        this.set(MapProperty.TARGET, i)
    }
    setView(i) {
        if (!i || i instanceof View$1) {
            this.set(MapProperty.VIEW, i);
            return
        }
        this.set(MapProperty.VIEW, new View$1);
        const s = this;
        i.then(function(a) {
            s.setView(new View$1(a))
        })
    }
    updateSize() {
        const i = this.getTargetElement();
        let s;
        if (i) {
            const _ = getComputedStyle(i)
              , $ = i.offsetWidth - parseFloat(_.borderLeftWidth) - parseFloat(_.paddingLeft) - parseFloat(_.paddingRight) - parseFloat(_.borderRightWidth)
              , _e = i.offsetHeight - parseFloat(_.borderTopWidth) - parseFloat(_.paddingTop) - parseFloat(_.paddingBottom) - parseFloat(_.borderBottomWidth);
            !isNaN($) && !isNaN(_e) && (s = [$, _e],
            !hasArea(s) && (i.offsetWidth || i.offsetHeight || i.getClientRects().length) && warn("No map visible because the map container's width or height are 0."))
        }
        const a = this.getSize();
        s && (!a || !equals$2(s, a)) && (this.setSize(s),
        this.updateViewportSize_())
    }
    updateViewportSize_() {
        const i = this.getView();
        if (i) {
            let s;
            const a = getComputedStyle(this.viewport_);
            a.width && a.height && (s = [parseInt(a.width, 10), parseInt(a.height, 10)]),
            i.setViewportSize(s)
        }
    }
}
;
function createOptionsInternal(o) {
    let i = null;
    o.keyboardEventTarget !== void 0 && (i = typeof o.keyboardEventTarget == "string" ? document.getElementById(o.keyboardEventTarget) : o.keyboardEventTarget);
    const s = {}
      , a = o.layers && typeof o.layers.getLayers == "function" ? o.layers : new LayerGroup$1({
        layers: o.layers
    });
    s[MapProperty.LAYERGROUP] = a,
    s[MapProperty.TARGET] = o.target,
    s[MapProperty.VIEW] = o.view instanceof View$1 ? o.view : new View$1;
    let _;
    o.controls !== void 0 && (Array.isArray(o.controls) ? _ = new Collection$1(o.controls.slice()) : (assert(typeof o.controls.getArray == "function", "Expected `controls` to be an array or an `ol/Collection.js`"),
    _ = o.controls));
    let $;
    o.interactions !== void 0 && (Array.isArray(o.interactions) ? $ = new Collection$1(o.interactions.slice()) : (assert(typeof o.interactions.getArray == "function", "Expected `interactions` to be an array or an `ol/Collection.js`"),
    $ = o.interactions));
    let _e;
    return o.overlays !== void 0 ? Array.isArray(o.overlays) ? _e = new Collection$1(o.overlays.slice()) : (assert(typeof o.overlays.getArray == "function", "Expected `overlays` to be an array or an `ol/Collection.js`"),
    _e = o.overlays) : _e = new Collection$1,
    {
        controls: _,
        interactions: $,
        keyboardEventTarget: i,
        overlays: _e,
        values: s
    }
}
const Map$2 = Map$1;
class Circle extends SimpleGeometry {
    constructor(i, s, a) {
        super(),
        a !== void 0 && s === void 0 ? this.setFlatCoordinates(a, i) : (s = s || 0,
        this.setCenterAndRadius(i, s, a))
    }
    clone() {
        const i = new Circle(this.flatCoordinates.slice(),void 0,this.layout);
        return i.applyProperties(this),
        i
    }
    closestPointXY(i, s, a, _) {
        const $ = this.flatCoordinates
          , _e = i - $[0]
          , tt = s - $[1]
          , nt = _e * _e + tt * tt;
        if (nt < _) {
            if (nt === 0)
                for (let rt = 0; rt < this.stride; ++rt)
                    a[rt] = $[rt];
            else {
                const rt = this.getRadius() / Math.sqrt(nt);
                a[0] = $[0] + rt * _e,
                a[1] = $[1] + rt * tt;
                for (let ot = 2; ot < this.stride; ++ot)
                    a[ot] = $[ot]
            }
            return a.length = this.stride,
            nt
        }
        return _
    }
    containsXY(i, s) {
        const a = this.flatCoordinates
          , _ = i - a[0]
          , $ = s - a[1];
        return _ * _ + $ * $ <= this.getRadiusSquared_()
    }
    getCenter() {
        return this.flatCoordinates.slice(0, this.stride)
    }
    computeExtent(i) {
        const s = this.flatCoordinates
          , a = s[this.stride] - s[0];
        return createOrUpdate$2(s[0] - a, s[1] - a, s[0] + a, s[1] + a, i)
    }
    getRadius() {
        return Math.sqrt(this.getRadiusSquared_())
    }
    getRadiusSquared_() {
        const i = this.flatCoordinates[this.stride] - this.flatCoordinates[0]
          , s = this.flatCoordinates[this.stride + 1] - this.flatCoordinates[1];
        return i * i + s * s
    }
    getType() {
        return "Circle"
    }
    intersectsExtent(i) {
        const s = this.getExtent();
        if (intersects$1(i, s)) {
            const a = this.getCenter();
            return i[0] <= a[0] && i[2] >= a[0] || i[1] <= a[1] && i[3] >= a[1] ? !0 : forEachCorner(i, this.intersectsCoordinate.bind(this))
        }
        return !1
    }
    setCenter(i) {
        const s = this.stride
          , a = this.flatCoordinates[s] - this.flatCoordinates[0]
          , _ = i.slice();
        _[s] = _[0] + a;
        for (let $ = 1; $ < s; ++$)
            _[s + $] = i[$];
        this.setFlatCoordinates(this.layout, _),
        this.changed()
    }
    setCenterAndRadius(i, s, a) {
        this.setLayout(a, i, 0),
        this.flatCoordinates || (this.flatCoordinates = []);
        const _ = this.flatCoordinates;
        let $ = deflateCoordinate(_, 0, i, this.stride);
        _[$++] = _[0] + s;
        for (let _e = 1, tt = this.stride; _e < tt; ++_e)
            _[$++] = _[_e];
        _.length = $,
        this.changed()
    }
    getCoordinates() {
        return null
    }
    setCoordinates(i, s) {}
    setRadius(i) {
        this.flatCoordinates[this.stride] = this.flatCoordinates[0] + i,
        this.changed()
    }
    rotate(i, s) {
        const a = this.getCenter()
          , _ = this.getStride();
        this.setCenter(rotate(a, 0, a.length, _, i, s, a)),
        this.changed()
    }
}
Circle.prototype.transform;
const Circle$1 = Circle;
class Feature extends BaseObject$1 {
    constructor(i) {
        if (super(),
        this.on,
        this.once,
        this.un,
        this.id_ = void 0,
        this.geometryName_ = "geometry",
        this.style_ = null,
        this.styleFunction_ = void 0,
        this.geometryChangeKey_ = null,
        this.addChangeListener(this.geometryName_, this.handleGeometryChanged_),
        i)
            if (typeof i.getSimplifiedGeometry == "function") {
                const s = i;
                this.setGeometry(s)
            } else {
                const s = i;
                this.setProperties(s)
            }
    }
    clone() {
        const i = new Feature(this.hasProperties() ? this.getProperties() : null);
        i.setGeometryName(this.getGeometryName());
        const s = this.getGeometry();
        s && i.setGeometry(s.clone());
        const a = this.getStyle();
        return a && i.setStyle(a),
        i
    }
    getGeometry() {
        return this.get(this.geometryName_)
    }
    getId() {
        return this.id_
    }
    getGeometryName() {
        return this.geometryName_
    }
    getStyle() {
        return this.style_
    }
    getStyleFunction() {
        return this.styleFunction_
    }
    handleGeometryChange_() {
        this.changed()
    }
    handleGeometryChanged_() {
        this.geometryChangeKey_ && (unlistenByKey(this.geometryChangeKey_),
        this.geometryChangeKey_ = null);
        const i = this.getGeometry();
        i && (this.geometryChangeKey_ = listen(i, EventType.CHANGE, this.handleGeometryChange_, this)),
        this.changed()
    }
    setGeometry(i) {
        this.set(this.geometryName_, i)
    }
    setStyle(i) {
        this.style_ = i,
        this.styleFunction_ = i ? createStyleFunction(i) : void 0,
        this.changed()
    }
    setId(i) {
        this.id_ = i,
        this.changed()
    }
    setGeometryName(i) {
        this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_),
        this.geometryName_ = i,
        this.addChangeListener(this.geometryName_, this.handleGeometryChanged_),
        this.handleGeometryChanged_()
    }
}
function createStyleFunction(o) {
    if (typeof o == "function")
        return o;
    let i;
    return Array.isArray(o) ? i = o : (assert(typeof o.getZIndex == "function", "Expected an `ol/style/Style` or an array of `ol/style/Style.js`"),
    i = [o]),
    function() {
        return i
    }
}
const Feature$1 = Feature;
class GeometryCollection extends Geometry$1 {
    constructor(i) {
        super(),
        this.geometries_ = i || null,
        this.changeEventsKeys_ = [],
        this.listenGeometriesChange_()
    }
    unlistenGeometriesChange_() {
        this.changeEventsKeys_.forEach(unlistenByKey),
        this.changeEventsKeys_.length = 0
    }
    listenGeometriesChange_() {
        if (this.geometries_)
            for (let i = 0, s = this.geometries_.length; i < s; ++i)
                this.changeEventsKeys_.push(listen(this.geometries_[i], EventType.CHANGE, this.changed, this))
    }
    clone() {
        const i = new GeometryCollection(null);
        return i.setGeometries(this.geometries_),
        i.applyProperties(this),
        i
    }
    closestPointXY(i, s, a, _) {
        if (_ < closestSquaredDistanceXY(this.getExtent(), i, s))
            return _;
        const $ = this.geometries_;
        for (let _e = 0, tt = $.length; _e < tt; ++_e)
            _ = $[_e].closestPointXY(i, s, a, _);
        return _
    }
    containsXY(i, s) {
        const a = this.geometries_;
        for (let _ = 0, $ = a.length; _ < $; ++_)
            if (a[_].containsXY(i, s))
                return !0;
        return !1
    }
    computeExtent(i) {
        createOrUpdateEmpty(i);
        const s = this.geometries_;
        for (let a = 0, _ = s.length; a < _; ++a)
            extend$1(i, s[a].getExtent());
        return i
    }
    getGeometries() {
        return cloneGeometries(this.geometries_)
    }
    getGeometriesArray() {
        return this.geometries_
    }
    getGeometriesArrayRecursive() {
        let i = [];
        const s = this.geometries_;
        for (let a = 0, _ = s.length; a < _; ++a)
            s[a].getType() === this.getType() ? i = i.concat(s[a].getGeometriesArrayRecursive()) : i.push(s[a]);
        return i
    }
    getSimplifiedGeometry(i) {
        if (this.simplifiedGeometryRevision !== this.getRevision() && (this.simplifiedGeometryMaxMinSquaredTolerance = 0,
        this.simplifiedGeometryRevision = this.getRevision()),
        i < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && i < this.simplifiedGeometryMaxMinSquaredTolerance)
            return this;
        const s = []
          , a = this.geometries_;
        let _ = !1;
        for (let $ = 0, _e = a.length; $ < _e; ++$) {
            const tt = a[$]
              , nt = tt.getSimplifiedGeometry(i);
            s.push(nt),
            nt !== tt && (_ = !0)
        }
        if (_) {
            const $ = new GeometryCollection(null);
            return $.setGeometriesArray(s),
            $
        }
        return this.simplifiedGeometryMaxMinSquaredTolerance = i,
        this
    }
    getType() {
        return "GeometryCollection"
    }
    intersectsExtent(i) {
        const s = this.geometries_;
        for (let a = 0, _ = s.length; a < _; ++a)
            if (s[a].intersectsExtent(i))
                return !0;
        return !1
    }
    isEmpty() {
        return this.geometries_.length === 0
    }
    rotate(i, s) {
        const a = this.geometries_;
        for (let _ = 0, $ = a.length; _ < $; ++_)
            a[_].rotate(i, s);
        this.changed()
    }
    scale(i, s, a) {
        a || (a = getCenter(this.getExtent()));
        const _ = this.geometries_;
        for (let $ = 0, _e = _.length; $ < _e; ++$)
            _[$].scale(i, s, a);
        this.changed()
    }
    setGeometries(i) {
        this.setGeometriesArray(cloneGeometries(i))
    }
    setGeometriesArray(i) {
        this.unlistenGeometriesChange_(),
        this.geometries_ = i,
        this.listenGeometriesChange_(),
        this.changed()
    }
    applyTransform(i) {
        const s = this.geometries_;
        for (let a = 0, _ = s.length; a < _; ++a)
            s[a].applyTransform(i);
        this.changed()
    }
    translate(i, s) {
        const a = this.geometries_;
        for (let _ = 0, $ = a.length; _ < $; ++_)
            a[_].translate(i, s);
        this.changed()
    }
    disposeInternal() {
        this.unlistenGeometriesChange_(),
        super.disposeInternal()
    }
}
function cloneGeometries(o) {
    const i = [];
    for (let s = 0, a = o.length; s < a; ++s)
        i.push(o[s].clone());
    return i
}
const GeometryCollection$1 = GeometryCollection;
function interpolatePoint(o, i, s, a, _, $, _e) {
    let tt, nt;
    const rt = (s - i) / a;
    if (rt === 1)
        tt = i;
    else if (rt === 2)
        tt = i,
        nt = _;
    else if (rt !== 0) {
        let ot = o[i]
          , et = o[i + 1]
          , j = 0;
        const it = [0];
        for (let lt = i + a; lt < s; lt += a) {
            const ct = o[lt]
              , ut = o[lt + 1];
            j += Math.sqrt((ct - ot) * (ct - ot) + (ut - et) * (ut - et)),
            it.push(j),
            ot = ct,
            et = ut
        }
        const st = _ * j
          , at = binarySearch(it, st);
        at < 0 ? (nt = (st - it[-at - 2]) / (it[-at - 1] - it[-at - 2]),
        tt = i + (-at - 2) * a) : tt = i + at * a
    }
    _e = _e > 1 ? _e : 2,
    $ = $ || new Array(_e);
    for (let ot = 0; ot < _e; ++ot)
        $[ot] = tt === void 0 ? NaN : nt === void 0 ? o[tt + ot] : lerp$1(o[tt + ot], o[tt + a + ot], nt);
    return $
}
function lineStringCoordinateAtM(o, i, s, a, _, $) {
    if (s == i)
        return null;
    let _e;
    if (_ < o[i + a - 1])
        return $ ? (_e = o.slice(i, i + a),
        _e[a - 1] = _,
        _e) : null;
    if (o[s - 1] < _)
        return $ ? (_e = o.slice(s - a, s),
        _e[a - 1] = _,
        _e) : null;
    if (_ == o[i + a - 1])
        return o.slice(i, i + a);
    let tt = i / a
      , nt = s / a;
    for (; tt < nt; ) {
        const j = tt + nt >> 1;
        _ < o[(j + 1) * a - 1] ? nt = j : tt = j + 1
    }
    const rt = o[tt * a - 1];
    if (_ == rt)
        return o.slice((tt - 1) * a, (tt - 1) * a + a);
    const ot = o[(tt + 1) * a - 1]
      , et = (_ - rt) / (ot - rt);
    _e = [];
    for (let j = 0; j < a - 1; ++j)
        _e.push(lerp$1(o[(tt - 1) * a + j], o[tt * a + j], et));
    return _e.push(_),
    _e
}
function lineStringsCoordinateAtM(o, i, s, a, _, $, _e) {
    if (_e)
        return lineStringCoordinateAtM(o, i, s[s.length - 1], a, _, $);
    let tt;
    if (_ < o[a - 1])
        return $ ? (tt = o.slice(0, a),
        tt[a - 1] = _,
        tt) : null;
    if (o[o.length - 1] < _)
        return $ ? (tt = o.slice(o.length - a),
        tt[a - 1] = _,
        tt) : null;
    for (let nt = 0, rt = s.length; nt < rt; ++nt) {
        const ot = s[nt];
        if (i != ot) {
            if (_ < o[i + a - 1])
                return null;
            if (_ <= o[ot - 1])
                return lineStringCoordinateAtM(o, i, ot, a, _, !1);
            i = ot
        }
    }
    return null
}
function lineStringLength(o, i, s, a) {
    let _ = o[i]
      , $ = o[i + 1]
      , _e = 0;
    for (let tt = i + a; tt < s; tt += a) {
        const nt = o[tt]
          , rt = o[tt + 1];
        _e += Math.sqrt((nt - _) * (nt - _) + (rt - $) * (rt - $)),
        _ = nt,
        $ = rt
    }
    return _e
}
class LineString extends SimpleGeometry {
    constructor(i, s) {
        super(),
        this.flatMidpoint_ = null,
        this.flatMidpointRevision_ = -1,
        this.maxDelta_ = -1,
        this.maxDeltaRevision_ = -1,
        s !== void 0 && !Array.isArray(i[0]) ? this.setFlatCoordinates(s, i) : this.setCoordinates(i, s)
    }
    appendCoordinate(i) {
        this.flatCoordinates ? extend$2(this.flatCoordinates, i) : this.flatCoordinates = i.slice(),
        this.changed()
    }
    clone() {
        const i = new LineString(this.flatCoordinates.slice(),this.layout);
        return i.applyProperties(this),
        i
    }
    closestPointXY(i, s, a, _) {
        return _ < closestSquaredDistanceXY(this.getExtent(), i, s) ? _ : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(maxSquaredDelta(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, 0)),
        this.maxDeltaRevision_ = this.getRevision()),
        assignClosestPoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, this.maxDelta_, !1, i, s, a, _))
    }
    forEachSegment(i) {
        return forEach(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, i)
    }
    getCoordinateAtM(i, s) {
        return this.layout != "XYM" && this.layout != "XYZM" ? null : (s = s !== void 0 ? s : !1,
        lineStringCoordinateAtM(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, i, s))
    }
    getCoordinates() {
        return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride)
    }
    getCoordinateAt(i, s) {
        return interpolatePoint(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, i, s, this.stride)
    }
    getLength() {
        return lineStringLength(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride)
    }
    getFlatMidpoint() {
        return this.flatMidpointRevision_ != this.getRevision() && (this.flatMidpoint_ = this.getCoordinateAt(.5, this.flatMidpoint_),
        this.flatMidpointRevision_ = this.getRevision()),
        this.flatMidpoint_
    }
    getSimplifiedGeometryInternal(i) {
        const s = [];
        return s.length = douglasPeucker(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, i, s, 0),
        new LineString(s,"XY")
    }
    getType() {
        return "LineString"
    }
    intersectsExtent(i) {
        return intersectsLineString(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride, i)
    }
    setCoordinates(i, s) {
        this.setLayout(s, i, 1),
        this.flatCoordinates || (this.flatCoordinates = []),
        this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, i, this.stride),
        this.changed()
    }
}
const LineString$1 = LineString;
class MultiLineString extends SimpleGeometry {
    constructor(i, s, a) {
        if (super(),
        this.ends_ = [],
        this.maxDelta_ = -1,
        this.maxDeltaRevision_ = -1,
        Array.isArray(i[0]))
            this.setCoordinates(i, s);
        else if (s !== void 0 && a)
            this.setFlatCoordinates(s, i),
            this.ends_ = a;
        else {
            let _ = this.getLayout();
            const $ = i
              , _e = []
              , tt = [];
            for (let nt = 0, rt = $.length; nt < rt; ++nt) {
                const ot = $[nt];
                nt === 0 && (_ = ot.getLayout()),
                extend$2(_e, ot.getFlatCoordinates()),
                tt.push(_e.length)
            }
            this.setFlatCoordinates(_, _e),
            this.ends_ = tt
        }
    }
    appendLineString(i) {
        this.flatCoordinates ? extend$2(this.flatCoordinates, i.getFlatCoordinates().slice()) : this.flatCoordinates = i.getFlatCoordinates().slice(),
        this.ends_.push(this.flatCoordinates.length),
        this.changed()
    }
    clone() {
        const i = new MultiLineString(this.flatCoordinates.slice(),this.layout,this.ends_.slice());
        return i.applyProperties(this),
        i
    }
    closestPointXY(i, s, a, _) {
        return _ < closestSquaredDistanceXY(this.getExtent(), i, s) ? _ : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(arrayMaxSquaredDelta(this.flatCoordinates, 0, this.ends_, this.stride, 0)),
        this.maxDeltaRevision_ = this.getRevision()),
        assignClosestArrayPoint(this.flatCoordinates, 0, this.ends_, this.stride, this.maxDelta_, !1, i, s, a, _))
    }
    getCoordinateAtM(i, s, a) {
        return this.layout != "XYM" && this.layout != "XYZM" || this.flatCoordinates.length === 0 ? null : (s = s !== void 0 ? s : !1,
        a = a !== void 0 ? a : !1,
        lineStringsCoordinateAtM(this.flatCoordinates, 0, this.ends_, this.stride, i, s, a))
    }
    getCoordinates() {
        return inflateCoordinatesArray(this.flatCoordinates, 0, this.ends_, this.stride)
    }
    getEnds() {
        return this.ends_
    }
    getLineString(i) {
        return i < 0 || this.ends_.length <= i ? null : new LineString$1(this.flatCoordinates.slice(i === 0 ? 0 : this.ends_[i - 1], this.ends_[i]),this.layout)
    }
    getLineStrings() {
        const i = this.flatCoordinates
          , s = this.ends_
          , a = this.layout
          , _ = [];
        let $ = 0;
        for (let _e = 0, tt = s.length; _e < tt; ++_e) {
            const nt = s[_e]
              , rt = new LineString$1(i.slice($, nt),a);
            _.push(rt),
            $ = nt
        }
        return _
    }
    getFlatMidpoints() {
        const i = []
          , s = this.flatCoordinates;
        let a = 0;
        const _ = this.ends_
          , $ = this.stride;
        for (let _e = 0, tt = _.length; _e < tt; ++_e) {
            const nt = _[_e]
              , rt = interpolatePoint(s, a, nt, $, .5);
            extend$2(i, rt),
            a = nt
        }
        return i
    }
    getSimplifiedGeometryInternal(i) {
        const s = []
          , a = [];
        return s.length = douglasPeuckerArray(this.flatCoordinates, 0, this.ends_, this.stride, i, s, 0, a),
        new MultiLineString(s,"XY",a)
    }
    getType() {
        return "MultiLineString"
    }
    intersectsExtent(i) {
        return intersectsLineStringArray(this.flatCoordinates, 0, this.ends_, this.stride, i)
    }
    setCoordinates(i, s) {
        this.setLayout(s, i, 2),
        this.flatCoordinates || (this.flatCoordinates = []);
        const a = deflateCoordinatesArray(this.flatCoordinates, 0, i, this.stride, this.ends_);
        this.flatCoordinates.length = a.length === 0 ? 0 : a[a.length - 1],
        this.changed()
    }
}
const MultiLineString$1 = MultiLineString;
class MultiPoint extends SimpleGeometry {
    constructor(i, s) {
        super(),
        s && !Array.isArray(i[0]) ? this.setFlatCoordinates(s, i) : this.setCoordinates(i, s)
    }
    appendPoint(i) {
        this.flatCoordinates ? extend$2(this.flatCoordinates, i.getFlatCoordinates()) : this.flatCoordinates = i.getFlatCoordinates().slice(),
        this.changed()
    }
    clone() {
        const i = new MultiPoint(this.flatCoordinates.slice(),this.layout);
        return i.applyProperties(this),
        i
    }
    closestPointXY(i, s, a, _) {
        if (_ < closestSquaredDistanceXY(this.getExtent(), i, s))
            return _;
        const $ = this.flatCoordinates
          , _e = this.stride;
        for (let tt = 0, nt = $.length; tt < nt; tt += _e) {
            const rt = squaredDistance$1(i, s, $[tt], $[tt + 1]);
            if (rt < _) {
                _ = rt;
                for (let ot = 0; ot < _e; ++ot)
                    a[ot] = $[tt + ot];
                a.length = _e
            }
        }
        return _
    }
    getCoordinates() {
        return inflateCoordinates(this.flatCoordinates, 0, this.flatCoordinates.length, this.stride)
    }
    getPoint(i) {
        const s = this.flatCoordinates ? this.flatCoordinates.length / this.stride : 0;
        return i < 0 || s <= i ? null : new Point$1(this.flatCoordinates.slice(i * this.stride, (i + 1) * this.stride),this.layout)
    }
    getPoints() {
        const i = this.flatCoordinates
          , s = this.layout
          , a = this.stride
          , _ = [];
        for (let $ = 0, _e = i.length; $ < _e; $ += a) {
            const tt = new Point$1(i.slice($, $ + a),s);
            _.push(tt)
        }
        return _
    }
    getType() {
        return "MultiPoint"
    }
    intersectsExtent(i) {
        const s = this.flatCoordinates
          , a = this.stride;
        for (let _ = 0, $ = s.length; _ < $; _ += a) {
            const _e = s[_]
              , tt = s[_ + 1];
            if (containsXY(i, _e, tt))
                return !0
        }
        return !1
    }
    setCoordinates(i, s) {
        this.setLayout(s, i, 1),
        this.flatCoordinates || (this.flatCoordinates = []),
        this.flatCoordinates.length = deflateCoordinates(this.flatCoordinates, 0, i, this.stride),
        this.changed()
    }
}
const MultiPoint$1 = MultiPoint;
function linearRingss(o, i, s, a) {
    const _ = [];
    let $ = createEmpty();
    for (let _e = 0, tt = s.length; _e < tt; ++_e) {
        const nt = s[_e];
        $ = createOrUpdateFromFlatCoordinates(o, i, nt[0], a),
        _.push(($[0] + $[2]) / 2, ($[1] + $[3]) / 2),
        i = nt[nt.length - 1]
    }
    return _
}
class MultiPolygon extends SimpleGeometry {
    constructor(i, s, a) {
        if (super(),
        this.endss_ = [],
        this.flatInteriorPointsRevision_ = -1,
        this.flatInteriorPoints_ = null,
        this.maxDelta_ = -1,
        this.maxDeltaRevision_ = -1,
        this.orientedRevision_ = -1,
        this.orientedFlatCoordinates_ = null,
        !a && !Array.isArray(i[0])) {
            let _ = this.getLayout();
            const $ = i
              , _e = []
              , tt = [];
            for (let nt = 0, rt = $.length; nt < rt; ++nt) {
                const ot = $[nt];
                nt === 0 && (_ = ot.getLayout());
                const et = _e.length
                  , j = ot.getEnds();
                for (let it = 0, st = j.length; it < st; ++it)
                    j[it] += et;
                extend$2(_e, ot.getFlatCoordinates()),
                tt.push(j)
            }
            s = _,
            i = _e,
            a = tt
        }
        s !== void 0 && a ? (this.setFlatCoordinates(s, i),
        this.endss_ = a) : this.setCoordinates(i, s)
    }
    appendPolygon(i) {
        let s;
        if (!this.flatCoordinates)
            this.flatCoordinates = i.getFlatCoordinates().slice(),
            s = i.getEnds().slice(),
            this.endss_.push();
        else {
            const a = this.flatCoordinates.length;
            extend$2(this.flatCoordinates, i.getFlatCoordinates()),
            s = i.getEnds().slice();
            for (let _ = 0, $ = s.length; _ < $; ++_)
                s[_] += a
        }
        this.endss_.push(s),
        this.changed()
    }
    clone() {
        const i = this.endss_.length
          , s = new Array(i);
        for (let _ = 0; _ < i; ++_)
            s[_] = this.endss_[_].slice();
        const a = new MultiPolygon(this.flatCoordinates.slice(),this.layout,s);
        return a.applyProperties(this),
        a
    }
    closestPointXY(i, s, a, _) {
        return _ < closestSquaredDistanceXY(this.getExtent(), i, s) ? _ : (this.maxDeltaRevision_ != this.getRevision() && (this.maxDelta_ = Math.sqrt(multiArrayMaxSquaredDelta(this.flatCoordinates, 0, this.endss_, this.stride, 0)),
        this.maxDeltaRevision_ = this.getRevision()),
        assignClosestMultiArrayPoint(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, this.maxDelta_, !0, i, s, a, _))
    }
    containsXY(i, s) {
        return linearRingssContainsXY(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, i, s)
    }
    getArea() {
        return linearRingss$1(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride)
    }
    getCoordinates(i) {
        let s;
        return i !== void 0 ? (s = this.getOrientedFlatCoordinates().slice(),
        orientLinearRingsArray(s, 0, this.endss_, this.stride, i)) : s = this.flatCoordinates,
        inflateMultiCoordinatesArray(s, 0, this.endss_, this.stride)
    }
    getEndss() {
        return this.endss_
    }
    getFlatInteriorPoints() {
        if (this.flatInteriorPointsRevision_ != this.getRevision()) {
            const i = linearRingss(this.flatCoordinates, 0, this.endss_, this.stride);
            this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, i),
            this.flatInteriorPointsRevision_ = this.getRevision()
        }
        return this.flatInteriorPoints_
    }
    getInteriorPoints() {
        return new MultiPoint$1(this.getFlatInteriorPoints().slice(),"XYM")
    }
    getOrientedFlatCoordinates() {
        if (this.orientedRevision_ != this.getRevision()) {
            const i = this.flatCoordinates;
            linearRingssAreOriented(i, 0, this.endss_, this.stride) ? this.orientedFlatCoordinates_ = i : (this.orientedFlatCoordinates_ = i.slice(),
            this.orientedFlatCoordinates_.length = orientLinearRingsArray(this.orientedFlatCoordinates_, 0, this.endss_, this.stride)),
            this.orientedRevision_ = this.getRevision()
        }
        return this.orientedFlatCoordinates_
    }
    getSimplifiedGeometryInternal(i) {
        const s = []
          , a = [];
        return s.length = quantizeMultiArray(this.flatCoordinates, 0, this.endss_, this.stride, Math.sqrt(i), s, 0, a),
        new MultiPolygon(s,"XY",a)
    }
    getPolygon(i) {
        if (i < 0 || this.endss_.length <= i)
            return null;
        let s;
        if (i === 0)
            s = 0;
        else {
            const $ = this.endss_[i - 1];
            s = $[$.length - 1]
        }
        const a = this.endss_[i].slice()
          , _ = a[a.length - 1];
        if (s !== 0)
            for (let $ = 0, _e = a.length; $ < _e; ++$)
                a[$] -= s;
        return new Polygon$1(this.flatCoordinates.slice(s, _),this.layout,a)
    }
    getPolygons() {
        const i = this.layout
          , s = this.flatCoordinates
          , a = this.endss_
          , _ = [];
        let $ = 0;
        for (let _e = 0, tt = a.length; _e < tt; ++_e) {
            const nt = a[_e].slice()
              , rt = nt[nt.length - 1];
            if ($ !== 0)
                for (let et = 0, j = nt.length; et < j; ++et)
                    nt[et] -= $;
            const ot = new Polygon$1(s.slice($, rt),i,nt);
            _.push(ot),
            $ = rt
        }
        return _
    }
    getType() {
        return "MultiPolygon"
    }
    intersectsExtent(i) {
        return intersectsLinearRingMultiArray(this.getOrientedFlatCoordinates(), 0, this.endss_, this.stride, i)
    }
    setCoordinates(i, s) {
        this.setLayout(s, i, 3),
        this.flatCoordinates || (this.flatCoordinates = []);
        const a = deflateMultiCoordinatesArray(this.flatCoordinates, 0, i, this.stride, this.endss_);
        if (a.length === 0)
            this.flatCoordinates.length = 0;
        else {
            const _ = a[a.length - 1];
            this.flatCoordinates.length = _.length === 0 ? 0 : _[_.length - 1]
        }
        this.changed()
    }
}
const MultiPolygon$1 = MultiPolygon;
function quickselect(o, i, s, a, _) {
    quickselectStep(o, i, s || 0, a || o.length - 1, _ || defaultCompare)
}
function quickselectStep(o, i, s, a, _) {
    for (; a > s; ) {
        if (a - s > 600) {
            var $ = a - s + 1
              , _e = i - s + 1
              , tt = Math.log($)
              , nt = .5 * Math.exp(2 * tt / 3)
              , rt = .5 * Math.sqrt(tt * nt * ($ - nt) / $) * (_e - $ / 2 < 0 ? -1 : 1)
              , ot = Math.max(s, Math.floor(i - _e * nt / $ + rt))
              , et = Math.min(a, Math.floor(i + ($ - _e) * nt / $ + rt));
            quickselectStep(o, i, ot, et, _)
        }
        var j = o[i]
          , it = s
          , st = a;
        for (swap(o, s, i),
        _(o[a], j) > 0 && swap(o, s, a); it < st; ) {
            for (swap(o, it, st),
            it++,
            st--; _(o[it], j) < 0; )
                it++;
            for (; _(o[st], j) > 0; )
                st--
        }
        _(o[s], j) === 0 ? swap(o, s, st) : (st++,
        swap(o, st, a)),
        st <= i && (s = st + 1),
        i <= st && (a = st - 1)
    }
}
function swap(o, i, s) {
    var a = o[i];
    o[i] = o[s],
    o[s] = a
}
function defaultCompare(o, i) {
    return o < i ? -1 : o > i ? 1 : 0
}
let RBush$2 = class {
    constructor(i=9) {
        this._maxEntries = Math.max(4, i),
        this._minEntries = Math.max(2, Math.ceil(this._maxEntries * .4)),
        this.clear()
    }
    all() {
        return this._all(this.data, [])
    }
    search(i) {
        let s = this.data;
        const a = [];
        if (!intersects(i, s))
            return a;
        const _ = this.toBBox
          , $ = [];
        for (; s; ) {
            for (let _e = 0; _e < s.children.length; _e++) {
                const tt = s.children[_e]
                  , nt = s.leaf ? _(tt) : tt;
                intersects(i, nt) && (s.leaf ? a.push(tt) : contains(i, nt) ? this._all(tt, a) : $.push(tt))
            }
            s = $.pop()
        }
        return a
    }
    collides(i) {
        let s = this.data;
        if (!intersects(i, s))
            return !1;
        const a = [];
        for (; s; ) {
            for (let _ = 0; _ < s.children.length; _++) {
                const $ = s.children[_]
                  , _e = s.leaf ? this.toBBox($) : $;
                if (intersects(i, _e)) {
                    if (s.leaf || contains(i, _e))
                        return !0;
                    a.push($)
                }
            }
            s = a.pop()
        }
        return !1
    }
    load(i) {
        if (!(i && i.length))
            return this;
        if (i.length < this._minEntries) {
            for (let a = 0; a < i.length; a++)
                this.insert(i[a]);
            return this
        }
        let s = this._build(i.slice(), 0, i.length - 1, 0);
        if (!this.data.children.length)
            this.data = s;
        else if (this.data.height === s.height)
            this._splitRoot(this.data, s);
        else {
            if (this.data.height < s.height) {
                const a = this.data;
                this.data = s,
                s = a
            }
            this._insert(s, this.data.height - s.height - 1, !0)
        }
        return this
    }
    insert(i) {
        return i && this._insert(i, this.data.height - 1),
        this
    }
    clear() {
        return this.data = createNode([]),
        this
    }
    remove(i, s) {
        if (!i)
            return this;
        let a = this.data;
        const _ = this.toBBox(i)
          , $ = []
          , _e = [];
        let tt, nt, rt;
        for (; a || $.length; ) {
            if (a || (a = $.pop(),
            nt = $[$.length - 1],
            tt = _e.pop(),
            rt = !0),
            a.leaf) {
                const ot = findItem(i, a.children, s);
                if (ot !== -1)
                    return a.children.splice(ot, 1),
                    $.push(a),
                    this._condense($),
                    this
            }
            !rt && !a.leaf && contains(a, _) ? ($.push(a),
            _e.push(tt),
            tt = 0,
            nt = a,
            a = a.children[0]) : nt ? (tt++,
            a = nt.children[tt],
            rt = !1) : a = null
        }
        return this
    }
    toBBox(i) {
        return i
    }
    compareMinX(i, s) {
        return i.minX - s.minX
    }
    compareMinY(i, s) {
        return i.minY - s.minY
    }
    toJSON() {
        return this.data
    }
    fromJSON(i) {
        return this.data = i,
        this
    }
    _all(i, s) {
        const a = [];
        for (; i; )
            i.leaf ? s.push(...i.children) : a.push(...i.children),
            i = a.pop();
        return s
    }
    _build(i, s, a, _) {
        const $ = a - s + 1;
        let _e = this._maxEntries, tt;
        if ($ <= _e)
            return tt = createNode(i.slice(s, a + 1)),
            calcBBox(tt, this.toBBox),
            tt;
        _ || (_ = Math.ceil(Math.log($) / Math.log(_e)),
        _e = Math.ceil($ / Math.pow(_e, _ - 1))),
        tt = createNode([]),
        tt.leaf = !1,
        tt.height = _;
        const nt = Math.ceil($ / _e)
          , rt = nt * Math.ceil(Math.sqrt(_e));
        multiSelect(i, s, a, rt, this.compareMinX);
        for (let ot = s; ot <= a; ot += rt) {
            const et = Math.min(ot + rt - 1, a);
            multiSelect(i, ot, et, nt, this.compareMinY);
            for (let j = ot; j <= et; j += nt) {
                const it = Math.min(j + nt - 1, et);
                tt.children.push(this._build(i, j, it, _ - 1))
            }
        }
        return calcBBox(tt, this.toBBox),
        tt
    }
    _chooseSubtree(i, s, a, _) {
        for (; _.push(s),
        !(s.leaf || _.length - 1 === a); ) {
            let $ = 1 / 0, _e = 1 / 0, tt;
            for (let nt = 0; nt < s.children.length; nt++) {
                const rt = s.children[nt]
                  , ot = bboxArea(rt)
                  , et = enlargedArea(i, rt) - ot;
                et < _e ? (_e = et,
                $ = ot < $ ? ot : $,
                tt = rt) : et === _e && ot < $ && ($ = ot,
                tt = rt)
            }
            s = tt || s.children[0]
        }
        return s
    }
    _insert(i, s, a) {
        const _ = a ? i : this.toBBox(i)
          , $ = []
          , _e = this._chooseSubtree(_, this.data, s, $);
        for (_e.children.push(i),
        extend(_e, _); s >= 0 && $[s].children.length > this._maxEntries; )
            this._split($, s),
            s--;
        this._adjustParentBBoxes(_, $, s)
    }
    _split(i, s) {
        const a = i[s]
          , _ = a.children.length
          , $ = this._minEntries;
        this._chooseSplitAxis(a, $, _);
        const _e = this._chooseSplitIndex(a, $, _)
          , tt = createNode(a.children.splice(_e, a.children.length - _e));
        tt.height = a.height,
        tt.leaf = a.leaf,
        calcBBox(a, this.toBBox),
        calcBBox(tt, this.toBBox),
        s ? i[s - 1].children.push(tt) : this._splitRoot(a, tt)
    }
    _splitRoot(i, s) {
        this.data = createNode([i, s]),
        this.data.height = i.height + 1,
        this.data.leaf = !1,
        calcBBox(this.data, this.toBBox)
    }
    _chooseSplitIndex(i, s, a) {
        let _, $ = 1 / 0, _e = 1 / 0;
        for (let tt = s; tt <= a - s; tt++) {
            const nt = distBBox(i, 0, tt, this.toBBox)
              , rt = distBBox(i, tt, a, this.toBBox)
              , ot = intersectionArea(nt, rt)
              , et = bboxArea(nt) + bboxArea(rt);
            ot < $ ? ($ = ot,
            _ = tt,
            _e = et < _e ? et : _e) : ot === $ && et < _e && (_e = et,
            _ = tt)
        }
        return _ || a - s
    }
    _chooseSplitAxis(i, s, a) {
        const _ = i.leaf ? this.compareMinX : compareNodeMinX
          , $ = i.leaf ? this.compareMinY : compareNodeMinY
          , _e = this._allDistMargin(i, s, a, _)
          , tt = this._allDistMargin(i, s, a, $);
        _e < tt && i.children.sort(_)
    }
    _allDistMargin(i, s, a, _) {
        i.children.sort(_);
        const $ = this.toBBox
          , _e = distBBox(i, 0, s, $)
          , tt = distBBox(i, a - s, a, $);
        let nt = bboxMargin(_e) + bboxMargin(tt);
        for (let rt = s; rt < a - s; rt++) {
            const ot = i.children[rt];
            extend(_e, i.leaf ? $(ot) : ot),
            nt += bboxMargin(_e)
        }
        for (let rt = a - s - 1; rt >= s; rt--) {
            const ot = i.children[rt];
            extend(tt, i.leaf ? $(ot) : ot),
            nt += bboxMargin(tt)
        }
        return nt
    }
    _adjustParentBBoxes(i, s, a) {
        for (let _ = a; _ >= 0; _--)
            extend(s[_], i)
    }
    _condense(i) {
        for (let s = i.length - 1, a; s >= 0; s--)
            i[s].children.length === 0 ? s > 0 ? (a = i[s - 1].children,
            a.splice(a.indexOf(i[s]), 1)) : this.clear() : calcBBox(i[s], this.toBBox)
    }
}
;
function findItem(o, i, s) {
    if (!s)
        return i.indexOf(o);
    for (let a = 0; a < i.length; a++)
        if (s(o, i[a]))
            return a;
    return -1
}
function calcBBox(o, i) {
    distBBox(o, 0, o.children.length, i, o)
}
function distBBox(o, i, s, a, _) {
    _ || (_ = createNode(null)),
    _.minX = 1 / 0,
    _.minY = 1 / 0,
    _.maxX = -1 / 0,
    _.maxY = -1 / 0;
    for (let $ = i; $ < s; $++) {
        const _e = o.children[$];
        extend(_, o.leaf ? a(_e) : _e)
    }
    return _
}
function extend(o, i) {
    return o.minX = Math.min(o.minX, i.minX),
    o.minY = Math.min(o.minY, i.minY),
    o.maxX = Math.max(o.maxX, i.maxX),
    o.maxY = Math.max(o.maxY, i.maxY),
    o
}
function compareNodeMinX(o, i) {
    return o.minX - i.minX
}
function compareNodeMinY(o, i) {
    return o.minY - i.minY
}
function bboxArea(o) {
    return (o.maxX - o.minX) * (o.maxY - o.minY)
}
function bboxMargin(o) {
    return o.maxX - o.minX + (o.maxY - o.minY)
}
function enlargedArea(o, i) {
    return (Math.max(i.maxX, o.maxX) - Math.min(i.minX, o.minX)) * (Math.max(i.maxY, o.maxY) - Math.min(i.minY, o.minY))
}
function intersectionArea(o, i) {
    const s = Math.max(o.minX, i.minX)
      , a = Math.max(o.minY, i.minY)
      , _ = Math.min(o.maxX, i.maxX)
      , $ = Math.min(o.maxY, i.maxY);
    return Math.max(0, _ - s) * Math.max(0, $ - a)
}
function contains(o, i) {
    return o.minX <= i.minX && o.minY <= i.minY && i.maxX <= o.maxX && i.maxY <= o.maxY
}
function intersects(o, i) {
    return i.minX <= o.maxX && i.minY <= o.maxY && i.maxX >= o.minX && i.maxY >= o.minY
}
function createNode(o) {
    return {
        children: o,
        height: 1,
        leaf: !0,
        minX: 1 / 0,
        minY: 1 / 0,
        maxX: -1 / 0,
        maxY: -1 / 0
    }
}
function multiSelect(o, i, s, a, _) {
    const $ = [i, s];
    for (; $.length; ) {
        if (s = $.pop(),
        i = $.pop(),
        s - i <= a)
            continue;
        const _e = i + Math.ceil((s - i) / a / 2) * a;
        quickselect(o, _e, i, s, _),
        $.push(i, _e, _e, s)
    }
}
const ImageState = {
    IDLE: 0,
    LOADING: 1,
    LOADED: 2,
    ERROR: 3,
    EMPTY: 4
};
class ImageStyle {
    constructor(i) {
        this.opacity_ = i.opacity,
        this.rotateWithView_ = i.rotateWithView,
        this.rotation_ = i.rotation,
        this.scale_ = i.scale,
        this.scaleArray_ = toSize(i.scale),
        this.displacement_ = i.displacement,
        this.declutterMode_ = i.declutterMode
    }
    clone() {
        const i = this.getScale();
        return new ImageStyle({
            opacity: this.getOpacity(),
            scale: Array.isArray(i) ? i.slice() : i,
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView(),
            displacement: this.getDisplacement().slice(),
            declutterMode: this.getDeclutterMode()
        })
    }
    getOpacity() {
        return this.opacity_
    }
    getRotateWithView() {
        return this.rotateWithView_
    }
    getRotation() {
        return this.rotation_
    }
    getScale() {
        return this.scale_
    }
    getScaleArray() {
        return this.scaleArray_
    }
    getDisplacement() {
        return this.displacement_
    }
    getDeclutterMode() {
        return this.declutterMode_
    }
    getAnchor() {
        return abstract()
    }
    getImage(i) {
        return abstract()
    }
    getHitDetectionImage() {
        return abstract()
    }
    getPixelRatio(i) {
        return 1
    }
    getImageState() {
        return abstract()
    }
    getImageSize() {
        return abstract()
    }
    getOrigin() {
        return abstract()
    }
    getSize() {
        return abstract()
    }
    setDisplacement(i) {
        this.displacement_ = i
    }
    setOpacity(i) {
        this.opacity_ = i
    }
    setRotateWithView(i) {
        this.rotateWithView_ = i
    }
    setRotation(i) {
        this.rotation_ = i
    }
    setScale(i) {
        this.scale_ = i,
        this.scaleArray_ = toSize(i)
    }
    listenImageChange(i) {
        abstract()
    }
    load() {
        abstract()
    }
    unlistenImageChange(i) {
        abstract()
    }
}
const ImageStyle$1 = ImageStyle;
function asColorLike(o) {
    return Array.isArray(o) ? toString(o) : o
}
class RegularShape extends ImageStyle$1 {
    constructor(i) {
        const s = i.rotateWithView !== void 0 ? i.rotateWithView : !1;
        super({
            opacity: 1,
            rotateWithView: s,
            rotation: i.rotation !== void 0 ? i.rotation : 0,
            scale: i.scale !== void 0 ? i.scale : 1,
            displacement: i.displacement !== void 0 ? i.displacement : [0, 0],
            declutterMode: i.declutterMode
        }),
        this.canvas_ = void 0,
        this.hitDetectionCanvas_ = null,
        this.fill_ = i.fill !== void 0 ? i.fill : null,
        this.origin_ = [0, 0],
        this.points_ = i.points,
        this.radius_ = i.radius !== void 0 ? i.radius : i.radius1,
        this.radius2_ = i.radius2,
        this.angle_ = i.angle !== void 0 ? i.angle : 0,
        this.stroke_ = i.stroke !== void 0 ? i.stroke : null,
        this.size_ = null,
        this.renderOptions_ = null,
        this.render()
    }
    clone() {
        const i = this.getScale()
          , s = new RegularShape({
            fill: this.getFill() ? this.getFill().clone() : void 0,
            points: this.getPoints(),
            radius: this.getRadius(),
            radius2: this.getRadius2(),
            angle: this.getAngle(),
            stroke: this.getStroke() ? this.getStroke().clone() : void 0,
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView(),
            scale: Array.isArray(i) ? i.slice() : i,
            displacement: this.getDisplacement().slice(),
            declutterMode: this.getDeclutterMode()
        });
        return s.setOpacity(this.getOpacity()),
        s
    }
    getAnchor() {
        const i = this.size_;
        if (!i)
            return null;
        const s = this.getDisplacement()
          , a = this.getScaleArray();
        return [i[0] / 2 - s[0] / a[0], i[1] / 2 + s[1] / a[1]]
    }
    getAngle() {
        return this.angle_
    }
    getFill() {
        return this.fill_
    }
    setFill(i) {
        this.fill_ = i,
        this.render()
    }
    getHitDetectionImage() {
        return this.hitDetectionCanvas_ || this.createHitDetectionCanvas_(this.renderOptions_),
        this.hitDetectionCanvas_
    }
    getImage(i) {
        let s = this.canvas_[i];
        if (!s) {
            const a = this.renderOptions_
              , _ = createCanvasContext2D(a.size * i, a.size * i);
            this.draw_(a, _, i),
            s = _.canvas,
            this.canvas_[i] = s
        }
        return s
    }
    getPixelRatio(i) {
        return i
    }
    getImageSize() {
        return this.size_
    }
    getImageState() {
        return ImageState.LOADED
    }
    getOrigin() {
        return this.origin_
    }
    getPoints() {
        return this.points_
    }
    getRadius() {
        return this.radius_
    }
    getRadius2() {
        return this.radius2_
    }
    getSize() {
        return this.size_
    }
    getStroke() {
        return this.stroke_
    }
    setStroke(i) {
        this.stroke_ = i,
        this.render()
    }
    listenImageChange(i) {}
    load() {}
    unlistenImageChange(i) {}
    calculateLineJoinSize_(i, s, a) {
        if (s === 0 || this.points_ === 1 / 0 || i !== "bevel" && i !== "miter")
            return s;
        let _ = this.radius_
          , $ = this.radius2_ === void 0 ? _ : this.radius2_;
        if (_ < $) {
            const pt = _;
            _ = $,
            $ = pt
        }
        const _e = this.radius2_ === void 0 ? this.points_ : this.points_ * 2
          , tt = 2 * Math.PI / _e
          , nt = $ * Math.sin(tt)
          , rt = Math.sqrt($ * $ - nt * nt)
          , ot = _ - rt
          , et = Math.sqrt(nt * nt + ot * ot)
          , j = et / nt;
        if (i === "miter" && j <= a)
            return j * s;
        const it = s / 2 / j
          , st = s / 2 * (ot / et)
          , lt = Math.sqrt((_ + it) * (_ + it) + st * st) - _;
        if (this.radius2_ === void 0 || i === "bevel")
            return lt * 2;
        const ct = _ * Math.sin(tt)
          , ut = Math.sqrt(_ * _ - ct * ct)
          , dt = $ - ut
          , ht = Math.sqrt(ct * ct + dt * dt) / ct;
        if (ht <= a) {
            const pt = ht * s / 2 - $ - _;
            return 2 * Math.max(lt, pt)
        }
        return lt * 2
    }
    createRenderOptions() {
        let i = defaultLineCap, s = defaultLineJoin, a = 0, _ = null, $ = 0, _e, tt = 0;
        this.stroke_ && (_e = this.stroke_.getColor(),
        _e === null && (_e = defaultStrokeStyle),
        _e = asColorLike(_e),
        tt = this.stroke_.getWidth(),
        tt === void 0 && (tt = defaultLineWidth),
        _ = this.stroke_.getLineDash(),
        $ = this.stroke_.getLineDashOffset(),
        s = this.stroke_.getLineJoin(),
        s === void 0 && (s = defaultLineJoin),
        i = this.stroke_.getLineCap(),
        i === void 0 && (i = defaultLineCap),
        a = this.stroke_.getMiterLimit(),
        a === void 0 && (a = defaultMiterLimit));
        const nt = this.calculateLineJoinSize_(s, tt, a)
          , rt = Math.max(this.radius_, this.radius2_ || 0)
          , ot = Math.ceil(2 * rt + nt);
        return {
            strokeStyle: _e,
            strokeWidth: tt,
            size: ot,
            lineCap: i,
            lineDash: _,
            lineDashOffset: $,
            lineJoin: s,
            miterLimit: a
        }
    }
    render() {
        this.renderOptions_ = this.createRenderOptions();
        const i = this.renderOptions_.size;
        this.canvas_ = {},
        this.size_ = [i, i]
    }
    draw_(i, s, a) {
        if (s.scale(a, a),
        s.translate(i.size / 2, i.size / 2),
        this.createPath_(s),
        this.fill_) {
            let _ = this.fill_.getColor();
            _ === null && (_ = defaultFillStyle),
            s.fillStyle = asColorLike(_),
            s.fill()
        }
        this.stroke_ && (s.strokeStyle = i.strokeStyle,
        s.lineWidth = i.strokeWidth,
        i.lineDash && (s.setLineDash(i.lineDash),
        s.lineDashOffset = i.lineDashOffset),
        s.lineCap = i.lineCap,
        s.lineJoin = i.lineJoin,
        s.miterLimit = i.miterLimit,
        s.stroke())
    }
    createHitDetectionCanvas_(i) {
        if (this.fill_) {
            let s = this.fill_.getColor()
              , a = 0;
            if (typeof s == "string" && (s = asArray(s)),
            s === null ? a = 1 : Array.isArray(s) && (a = s.length === 4 ? s[3] : 1),
            a === 0) {
                const _ = createCanvasContext2D(i.size, i.size);
                this.hitDetectionCanvas_ = _.canvas,
                this.drawHitDetectionCanvas_(i, _)
            }
        }
        this.hitDetectionCanvas_ || (this.hitDetectionCanvas_ = this.getImage(1))
    }
    createPath_(i) {
        let s = this.points_;
        const a = this.radius_;
        if (s === 1 / 0)
            i.arc(0, 0, a, 0, 2 * Math.PI);
        else {
            const _ = this.radius2_ === void 0 ? a : this.radius2_;
            this.radius2_ !== void 0 && (s *= 2);
            const $ = this.angle_ - Math.PI / 2
              , _e = 2 * Math.PI / s;
            for (let tt = 0; tt < s; tt++) {
                const nt = $ + tt * _e
                  , rt = tt % 2 === 0 ? a : _;
                i.lineTo(rt * Math.cos(nt), rt * Math.sin(nt))
            }
            i.closePath()
        }
    }
    drawHitDetectionCanvas_(i, s) {
        s.translate(i.size / 2, i.size / 2),
        this.createPath_(s),
        s.fillStyle = defaultFillStyle,
        s.fill(),
        this.stroke_ && (s.strokeStyle = i.strokeStyle,
        s.lineWidth = i.strokeWidth,
        i.lineDash && (s.setLineDash(i.lineDash),
        s.lineDashOffset = i.lineDashOffset),
        s.lineJoin = i.lineJoin,
        s.miterLimit = i.miterLimit,
        s.stroke())
    }
}
const RegularShape$1 = RegularShape;
class CircleStyle extends RegularShape$1 {
    constructor(i) {
        i = i || {
            radius: 5
        },
        super({
            points: 1 / 0,
            fill: i.fill,
            radius: i.radius,
            stroke: i.stroke,
            scale: i.scale !== void 0 ? i.scale : 1,
            rotation: i.rotation !== void 0 ? i.rotation : 0,
            rotateWithView: i.rotateWithView !== void 0 ? i.rotateWithView : !1,
            displacement: i.displacement !== void 0 ? i.displacement : [0, 0],
            declutterMode: i.declutterMode
        })
    }
    clone() {
        const i = this.getScale()
          , s = new CircleStyle({
            fill: this.getFill() ? this.getFill().clone() : void 0,
            stroke: this.getStroke() ? this.getStroke().clone() : void 0,
            radius: this.getRadius(),
            scale: Array.isArray(i) ? i.slice() : i,
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView(),
            displacement: this.getDisplacement().slice(),
            declutterMode: this.getDeclutterMode()
        });
        return s.setOpacity(this.getOpacity()),
        s
    }
    setRadius(i) {
        this.radius_ = i,
        this.render()
    }
}
const CircleStyle$1 = CircleStyle;
class Fill {
    constructor(i) {
        i = i || {},
        this.color_ = i.color !== void 0 ? i.color : null
    }
    clone() {
        const i = this.getColor();
        return new Fill({
            color: Array.isArray(i) ? i.slice() : i || void 0
        })
    }
    getColor() {
        return this.color_
    }
    setColor(i) {
        this.color_ = i
    }
}
const Fill$1 = Fill;
class Stroke {
    constructor(i) {
        i = i || {},
        this.color_ = i.color !== void 0 ? i.color : null,
        this.lineCap_ = i.lineCap,
        this.lineDash_ = i.lineDash !== void 0 ? i.lineDash : null,
        this.lineDashOffset_ = i.lineDashOffset,
        this.lineJoin_ = i.lineJoin,
        this.miterLimit_ = i.miterLimit,
        this.width_ = i.width
    }
    clone() {
        const i = this.getColor();
        return new Stroke({
            color: Array.isArray(i) ? i.slice() : i || void 0,
            lineCap: this.getLineCap(),
            lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
            lineDashOffset: this.getLineDashOffset(),
            lineJoin: this.getLineJoin(),
            miterLimit: this.getMiterLimit(),
            width: this.getWidth()
        })
    }
    getColor() {
        return this.color_
    }
    getLineCap() {
        return this.lineCap_
    }
    getLineDash() {
        return this.lineDash_
    }
    getLineDashOffset() {
        return this.lineDashOffset_
    }
    getLineJoin() {
        return this.lineJoin_
    }
    getMiterLimit() {
        return this.miterLimit_
    }
    getWidth() {
        return this.width_
    }
    setColor(i) {
        this.color_ = i
    }
    setLineCap(i) {
        this.lineCap_ = i
    }
    setLineDash(i) {
        this.lineDash_ = i
    }
    setLineDashOffset(i) {
        this.lineDashOffset_ = i
    }
    setLineJoin(i) {
        this.lineJoin_ = i
    }
    setMiterLimit(i) {
        this.miterLimit_ = i
    }
    setWidth(i) {
        this.width_ = i
    }
}
const Stroke$1 = Stroke;
class Style {
    constructor(i) {
        i = i || {},
        this.geometry_ = null,
        this.geometryFunction_ = defaultGeometryFunction,
        i.geometry !== void 0 && this.setGeometry(i.geometry),
        this.fill_ = i.fill !== void 0 ? i.fill : null,
        this.image_ = i.image !== void 0 ? i.image : null,
        this.renderer_ = i.renderer !== void 0 ? i.renderer : null,
        this.hitDetectionRenderer_ = i.hitDetectionRenderer !== void 0 ? i.hitDetectionRenderer : null,
        this.stroke_ = i.stroke !== void 0 ? i.stroke : null,
        this.text_ = i.text !== void 0 ? i.text : null,
        this.zIndex_ = i.zIndex
    }
    clone() {
        let i = this.getGeometry();
        return i && typeof i == "object" && (i = i.clone()),
        new Style({
            geometry: i,
            fill: this.getFill() ? this.getFill().clone() : void 0,
            image: this.getImage() ? this.getImage().clone() : void 0,
            renderer: this.getRenderer(),
            stroke: this.getStroke() ? this.getStroke().clone() : void 0,
            text: this.getText() ? this.getText().clone() : void 0,
            zIndex: this.getZIndex()
        })
    }
    getRenderer() {
        return this.renderer_
    }
    setRenderer(i) {
        this.renderer_ = i
    }
    setHitDetectionRenderer(i) {
        this.hitDetectionRenderer_ = i
    }
    getHitDetectionRenderer() {
        return this.hitDetectionRenderer_
    }
    getGeometry() {
        return this.geometry_
    }
    getGeometryFunction() {
        return this.geometryFunction_
    }
    getFill() {
        return this.fill_
    }
    setFill(i) {
        this.fill_ = i
    }
    getImage() {
        return this.image_
    }
    setImage(i) {
        this.image_ = i
    }
    getStroke() {
        return this.stroke_
    }
    setStroke(i) {
        this.stroke_ = i
    }
    getText() {
        return this.text_
    }
    setText(i) {
        this.text_ = i
    }
    getZIndex() {
        return this.zIndex_
    }
    setGeometry(i) {
        typeof i == "function" ? this.geometryFunction_ = i : typeof i == "string" ? this.geometryFunction_ = function(s) {
            return s.get(i)
        }
        : i ? i !== void 0 && (this.geometryFunction_ = function() {
            return i
        }
        ) : this.geometryFunction_ = defaultGeometryFunction,
        this.geometry_ = i
    }
    setZIndex(i) {
        this.zIndex_ = i
    }
}
function toFunction(o) {
    let i;
    if (typeof o == "function")
        i = o;
    else {
        let s;
        Array.isArray(o) ? s = o : (assert(typeof o.getZIndex == "function", "Expected an `Style` or an array of `Style`"),
        s = [o]),
        i = function() {
            return s
        }
    }
    return i
}
let defaultStyles = null;
function createDefaultStyle(o, i) {
    if (!defaultStyles) {
        const s = new Fill$1({
            color: "rgba(255,255,255,0.4)"
        })
          , a = new Stroke$1({
            color: "#3399CC",
            width: 1.25
        });
        defaultStyles = [new Style({
            image: new CircleStyle$1({
                fill: s,
                stroke: a,
                radius: 5
            }),
            fill: s,
            stroke: a
        })]
    }
    return defaultStyles
}
function createEditingStyle() {
    const o = {}
      , i = [255, 255, 255, 1]
      , s = [0, 153, 255, 1]
      , a = 3;
    return o.Polygon = [new Style({
        fill: new Fill$1({
            color: [255, 255, 255, .5]
        })
    })],
    o.MultiPolygon = o.Polygon,
    o.LineString = [new Style({
        stroke: new Stroke$1({
            color: i,
            width: a + 2
        })
    }), new Style({
        stroke: new Stroke$1({
            color: s,
            width: a
        })
    })],
    o.MultiLineString = o.LineString,
    o.Circle = o.Polygon.concat(o.LineString),
    o.Point = [new Style({
        image: new CircleStyle$1({
            radius: a * 2,
            fill: new Fill$1({
                color: s
            }),
            stroke: new Stroke$1({
                color: i,
                width: a / 2
            })
        }),
        zIndex: 1 / 0
    })],
    o.MultiPoint = o.Point,
    o.GeometryCollection = o.Polygon.concat(o.LineString, o.Point),
    o
}
function defaultGeometryFunction(o) {
    return o.getGeometry()
}
const Style$1 = Style;
function listenImage(o, i, s) {
    const a = o;
    let _ = !0
      , $ = !1
      , _e = !1;
    const tt = [listenOnce(a, EventType.LOAD, function() {
        _e = !0,
        $ || i()
    })];
    return a.src && IMAGE_DECODE ? ($ = !0,
    a.decode().then(function() {
        _ && i()
    }).catch(function(nt) {
        _ && (_e ? i() : s())
    })) : tt.push(listenOnce(a, EventType.ERROR, s)),
    function() {
        _ = !1,
        tt.forEach(unlistenByKey)
    }
}
function load(o, i) {
    return new Promise( (s, a) => {
        function _() {
            _e(),
            s(o)
        }
        function $() {
            _e(),
            a(new Error("Image load error"))
        }
        function _e() {
            o.removeEventListener("load", _),
            o.removeEventListener("error", $)
        }
        o.addEventListener("load", _),
        o.addEventListener("error", $),
        i && (o.src = i)
    }
    )
}
function decodeFallback(o, i) {
    return i && (o.src = i),
    IMAGE_DECODE ? new Promise( (s, a) => o.decode().then( () => s(o), a)) : load(o)
}
let taintedTestContext = null;
class IconImage extends EventTarget {
    constructor(i, s, a, _, $) {
        super(),
        this.hitDetectionImage_ = null,
        this.image_ = i,
        this.crossOrigin_ = a,
        this.canvas_ = {},
        this.color_ = $,
        this.imageState_ = _ === void 0 ? ImageState.IDLE : _,
        this.size_ = i && i.width && i.height ? [i.width, i.height] : null,
        this.src_ = s,
        this.tainted_
    }
    initializeImage_() {
        this.image_ = new Image,
        this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_)
    }
    isTainted_() {
        if (this.tainted_ === void 0 && this.imageState_ === ImageState.LOADED) {
            taintedTestContext || (taintedTestContext = createCanvasContext2D(1, 1, void 0, {
                willReadFrequently: !0
            })),
            taintedTestContext.drawImage(this.image_, 0, 0);
            try {
                taintedTestContext.getImageData(0, 0, 1, 1),
                this.tainted_ = !1
            } catch {
                taintedTestContext = null,
                this.tainted_ = !0
            }
        }
        return this.tainted_ === !0
    }
    dispatchChangeEvent_() {
        this.dispatchEvent(EventType.CHANGE)
    }
    handleImageError_() {
        this.imageState_ = ImageState.ERROR,
        this.dispatchChangeEvent_()
    }
    handleImageLoad_() {
        this.imageState_ = ImageState.LOADED,
        this.size_ = [this.image_.width, this.image_.height],
        this.dispatchChangeEvent_()
    }
    getImage(i) {
        return this.image_ || this.initializeImage_(),
        this.replaceColor_(i),
        this.canvas_[i] ? this.canvas_[i] : this.image_
    }
    getPixelRatio(i) {
        return this.replaceColor_(i),
        this.canvas_[i] ? i : 1
    }
    getImageState() {
        return this.imageState_
    }
    getHitDetectionImage() {
        if (this.image_ || this.initializeImage_(),
        !this.hitDetectionImage_)
            if (this.isTainted_()) {
                const i = this.size_[0]
                  , s = this.size_[1]
                  , a = createCanvasContext2D(i, s);
                a.fillRect(0, 0, i, s),
                this.hitDetectionImage_ = a.canvas
            } else
                this.hitDetectionImage_ = this.image_;
        return this.hitDetectionImage_
    }
    getSize() {
        return this.size_
    }
    getSrc() {
        return this.src_
    }
    load() {
        if (this.imageState_ === ImageState.IDLE) {
            this.image_ || this.initializeImage_(),
            this.imageState_ = ImageState.LOADING;
            try {
                this.src_ !== void 0 && (this.image_.src = this.src_)
            } catch {
                this.handleImageError_()
            }
            this.image_ instanceof HTMLImageElement && decodeFallback(this.image_, this.src_).then(i => {
                this.image_ = i,
                this.handleImageLoad_()
            }
            ).catch(this.handleImageError_.bind(this))
        }
    }
    replaceColor_(i) {
        if (!this.color_ || this.canvas_[i] || this.imageState_ !== ImageState.LOADED)
            return;
        const s = this.image_
          , a = document.createElement("canvas");
        a.width = Math.ceil(s.width * i),
        a.height = Math.ceil(s.height * i);
        const _ = a.getContext("2d");
        _.scale(i, i),
        _.drawImage(s, 0, 0),
        _.globalCompositeOperation = "multiply",
        _.fillStyle = asString(this.color_),
        _.fillRect(0, 0, a.width / i, a.height / i),
        _.globalCompositeOperation = "destination-in",
        _.drawImage(s, 0, 0),
        this.canvas_[i] = a
    }
}
function get(o, i, s, a, _) {
    let $ = i === void 0 ? void 0 : shared.get(i, s, _);
    return $ || ($ = new IconImage(o,o instanceof HTMLImageElement ? o.src || void 0 : i,s,a,_),
    shared.set(i, s, _, $)),
    $
}
function calculateScale(o, i, s, a) {
    return s !== void 0 && a !== void 0 ? [s / o, a / i] : s !== void 0 ? s / o : a !== void 0 ? a / i : 1
}
class Icon extends ImageStyle$1 {
    constructor(i) {
        i = i || {};
        const s = i.opacity !== void 0 ? i.opacity : 1
          , a = i.rotation !== void 0 ? i.rotation : 0
          , _ = i.scale !== void 0 ? i.scale : 1
          , $ = i.rotateWithView !== void 0 ? i.rotateWithView : !1;
        super({
            opacity: s,
            rotation: a,
            scale: _,
            displacement: i.displacement !== void 0 ? i.displacement : [0, 0],
            rotateWithView: $,
            declutterMode: i.declutterMode
        }),
        this.anchor_ = i.anchor !== void 0 ? i.anchor : [.5, .5],
        this.normalizedAnchor_ = null,
        this.anchorOrigin_ = i.anchorOrigin !== void 0 ? i.anchorOrigin : "top-left",
        this.anchorXUnits_ = i.anchorXUnits !== void 0 ? i.anchorXUnits : "fraction",
        this.anchorYUnits_ = i.anchorYUnits !== void 0 ? i.anchorYUnits : "fraction",
        this.crossOrigin_ = i.crossOrigin !== void 0 ? i.crossOrigin : null;
        const _e = i.img !== void 0 ? i.img : null;
        let tt = i.src;
        assert(!(tt !== void 0 && _e), "`image` and `src` cannot be provided at the same time"),
        (tt === void 0 || tt.length === 0) && _e && (tt = _e.src || getUid(_e)),
        assert(tt !== void 0 && tt.length > 0, "A defined and non-empty `src` or `image` must be provided"),
        assert(!((i.width !== void 0 || i.height !== void 0) && i.scale !== void 0), "`width` or `height` cannot be provided together with `scale`");
        let nt;
        if (i.src !== void 0 ? nt = ImageState.IDLE : _e !== void 0 && (_e instanceof HTMLImageElement ? _e.complete ? nt = _e.src ? ImageState.LOADED : ImageState.IDLE : nt = ImageState.LOADING : nt = ImageState.LOADED),
        this.color_ = i.color !== void 0 ? asArray(i.color) : null,
        this.iconImage_ = get(_e, tt, this.crossOrigin_, nt, this.color_),
        this.offset_ = i.offset !== void 0 ? i.offset : [0, 0],
        this.offsetOrigin_ = i.offsetOrigin !== void 0 ? i.offsetOrigin : "top-left",
        this.origin_ = null,
        this.size_ = i.size !== void 0 ? i.size : null,
        i.width !== void 0 || i.height !== void 0) {
            let rt, ot;
            if (i.size)
                [rt,ot] = i.size;
            else {
                const et = this.getImage(1);
                if (et.width && et.height)
                    rt = et.width,
                    ot = et.height;
                else if (et instanceof HTMLImageElement) {
                    this.initialOptions_ = i;
                    const j = () => {
                        if (this.unlistenImageChange(j),
                        !this.initialOptions_)
                            return;
                        const it = this.iconImage_.getSize();
                        this.setScale(calculateScale(it[0], it[1], i.width, i.height))
                    }
                    ;
                    this.listenImageChange(j);
                    return
                }
            }
            rt !== void 0 && this.setScale(calculateScale(rt, ot, i.width, i.height))
        }
    }
    clone() {
        let i, s, a;
        return this.initialOptions_ ? (s = this.initialOptions_.width,
        a = this.initialOptions_.height) : (i = this.getScale(),
        i = Array.isArray(i) ? i.slice() : i),
        new Icon({
            anchor: this.anchor_.slice(),
            anchorOrigin: this.anchorOrigin_,
            anchorXUnits: this.anchorXUnits_,
            anchorYUnits: this.anchorYUnits_,
            color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
            crossOrigin: this.crossOrigin_,
            offset: this.offset_.slice(),
            offsetOrigin: this.offsetOrigin_,
            opacity: this.getOpacity(),
            rotateWithView: this.getRotateWithView(),
            rotation: this.getRotation(),
            scale: i,
            width: s,
            height: a,
            size: this.size_ !== null ? this.size_.slice() : void 0,
            src: this.getSrc(),
            displacement: this.getDisplacement().slice(),
            declutterMode: this.getDeclutterMode()
        })
    }
    getAnchor() {
        let i = this.normalizedAnchor_;
        if (!i) {
            i = this.anchor_;
            const _ = this.getSize();
            if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
                if (!_)
                    return null;
                i = this.anchor_.slice(),
                this.anchorXUnits_ == "fraction" && (i[0] *= _[0]),
                this.anchorYUnits_ == "fraction" && (i[1] *= _[1])
            }
            if (this.anchorOrigin_ != "top-left") {
                if (!_)
                    return null;
                i === this.anchor_ && (i = this.anchor_.slice()),
                (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") && (i[0] = -i[0] + _[0]),
                (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") && (i[1] = -i[1] + _[1])
            }
            this.normalizedAnchor_ = i
        }
        const s = this.getDisplacement()
          , a = this.getScaleArray();
        return [i[0] - s[0] / a[0], i[1] + s[1] / a[1]]
    }
    setAnchor(i) {
        this.anchor_ = i,
        this.normalizedAnchor_ = null
    }
    getColor() {
        return this.color_
    }
    getImage(i) {
        return this.iconImage_.getImage(i)
    }
    getPixelRatio(i) {
        return this.iconImage_.getPixelRatio(i)
    }
    getImageSize() {
        return this.iconImage_.getSize()
    }
    getImageState() {
        return this.iconImage_.getImageState()
    }
    getHitDetectionImage() {
        return this.iconImage_.getHitDetectionImage()
    }
    getOrigin() {
        if (this.origin_)
            return this.origin_;
        let i = this.offset_;
        if (this.offsetOrigin_ != "top-left") {
            const s = this.getSize()
              , a = this.iconImage_.getSize();
            if (!s || !a)
                return null;
            i = i.slice(),
            (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") && (i[0] = a[0] - s[0] - i[0]),
            (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") && (i[1] = a[1] - s[1] - i[1])
        }
        return this.origin_ = i,
        this.origin_
    }
    getSrc() {
        return this.iconImage_.getSrc()
    }
    getSize() {
        return this.size_ ? this.size_ : this.iconImage_.getSize()
    }
    getWidth() {
        const i = this.getScaleArray();
        if (this.size_)
            return this.size_[0] * i[0];
        if (this.iconImage_.getImageState() == ImageState.LOADED)
            return this.iconImage_.getSize()[0] * i[0]
    }
    getHeight() {
        const i = this.getScaleArray();
        if (this.size_)
            return this.size_[1] * i[1];
        if (this.iconImage_.getImageState() == ImageState.LOADED)
            return this.iconImage_.getSize()[1] * i[1]
    }
    setScale(i) {
        delete this.initialOptions_,
        super.setScale(i)
    }
    listenImageChange(i) {
        this.iconImage_.addEventListener(EventType.CHANGE, i)
    }
    load() {
        this.iconImage_.load()
    }
    unlistenImageChange(i) {
        this.iconImage_.removeEventListener(EventType.CHANGE, i)
    }
}
const Icon$1 = Icon
  , DEFAULT_FILL_COLOR = "#333";
class Text {
    constructor(i) {
        i = i || {},
        this.font_ = i.font,
        this.rotation_ = i.rotation,
        this.rotateWithView_ = i.rotateWithView,
        this.scale_ = i.scale,
        this.scaleArray_ = toSize(i.scale !== void 0 ? i.scale : 1),
        this.text_ = i.text,
        this.textAlign_ = i.textAlign,
        this.justify_ = i.justify,
        this.repeat_ = i.repeat,
        this.textBaseline_ = i.textBaseline,
        this.fill_ = i.fill !== void 0 ? i.fill : new Fill$1({
            color: DEFAULT_FILL_COLOR
        }),
        this.maxAngle_ = i.maxAngle !== void 0 ? i.maxAngle : Math.PI / 4,
        this.placement_ = i.placement !== void 0 ? i.placement : "point",
        this.overflow_ = !!i.overflow,
        this.stroke_ = i.stroke !== void 0 ? i.stroke : null,
        this.offsetX_ = i.offsetX !== void 0 ? i.offsetX : 0,
        this.offsetY_ = i.offsetY !== void 0 ? i.offsetY : 0,
        this.backgroundFill_ = i.backgroundFill ? i.backgroundFill : null,
        this.backgroundStroke_ = i.backgroundStroke ? i.backgroundStroke : null,
        this.padding_ = i.padding === void 0 ? null : i.padding
    }
    clone() {
        const i = this.getScale();
        return new Text({
            font: this.getFont(),
            placement: this.getPlacement(),
            repeat: this.getRepeat(),
            maxAngle: this.getMaxAngle(),
            overflow: this.getOverflow(),
            rotation: this.getRotation(),
            rotateWithView: this.getRotateWithView(),
            scale: Array.isArray(i) ? i.slice() : i,
            text: this.getText(),
            textAlign: this.getTextAlign(),
            justify: this.getJustify(),
            textBaseline: this.getTextBaseline(),
            fill: this.getFill() ? this.getFill().clone() : void 0,
            stroke: this.getStroke() ? this.getStroke().clone() : void 0,
            offsetX: this.getOffsetX(),
            offsetY: this.getOffsetY(),
            backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
            backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
            padding: this.getPadding() || void 0
        })
    }
    getOverflow() {
        return this.overflow_
    }
    getFont() {
        return this.font_
    }
    getMaxAngle() {
        return this.maxAngle_
    }
    getPlacement() {
        return this.placement_
    }
    getRepeat() {
        return this.repeat_
    }
    getOffsetX() {
        return this.offsetX_
    }
    getOffsetY() {
        return this.offsetY_
    }
    getFill() {
        return this.fill_
    }
    getRotateWithView() {
        return this.rotateWithView_
    }
    getRotation() {
        return this.rotation_
    }
    getScale() {
        return this.scale_
    }
    getScaleArray() {
        return this.scaleArray_
    }
    getStroke() {
        return this.stroke_
    }
    getText() {
        return this.text_
    }
    getTextAlign() {
        return this.textAlign_
    }
    getJustify() {
        return this.justify_
    }
    getTextBaseline() {
        return this.textBaseline_
    }
    getBackgroundFill() {
        return this.backgroundFill_
    }
    getBackgroundStroke() {
        return this.backgroundStroke_
    }
    getPadding() {
        return this.padding_
    }
    setOverflow(i) {
        this.overflow_ = i
    }
    setFont(i) {
        this.font_ = i
    }
    setMaxAngle(i) {
        this.maxAngle_ = i
    }
    setOffsetX(i) {
        this.offsetX_ = i
    }
    setOffsetY(i) {
        this.offsetY_ = i
    }
    setPlacement(i) {
        this.placement_ = i
    }
    setRepeat(i) {
        this.repeat_ = i
    }
    setRotateWithView(i) {
        this.rotateWithView_ = i
    }
    setFill(i) {
        this.fill_ = i
    }
    setRotation(i) {
        this.rotation_ = i
    }
    setScale(i) {
        this.scale_ = i,
        this.scaleArray_ = toSize(i !== void 0 ? i : 1)
    }
    setStroke(i) {
        this.stroke_ = i
    }
    setText(i) {
        this.text_ = i
    }
    setTextAlign(i) {
        this.textAlign_ = i
    }
    setJustify(i) {
        this.justify_ = i
    }
    setTextBaseline(i) {
        this.textBaseline_ = i
    }
    setBackgroundFill(i) {
        this.backgroundFill_ = i
    }
    setBackgroundStroke(i) {
        this.backgroundStroke_ = i
    }
    setPadding(i) {
        this.padding_ = i
    }
}
const Text$1 = Text;
let numTypes = 0;
const BooleanType = 1 << numTypes++
  , NumberType = 1 << numTypes++
  , StringType = 1 << numTypes++
  , ColorType = 1 << numTypes++
  , NumberArrayType = 1 << numTypes++
  , AnyType = Math.pow(2, numTypes) - 1
  , typeNames = {
    [BooleanType]: "boolean",
    [NumberType]: "number",
    [StringType]: "string",
    [ColorType]: "color",
    [NumberArrayType]: "number[]"
}
  , namedTypes = Object.keys(typeNames).map(Number).sort(ascending);
function typeName(o) {
    const i = [];
    for (const s of namedTypes)
        includesType(o, s) && i.push(typeNames[s]);
    return i.length === 0 ? "untyped" : i.length < 3 ? i.join(" or ") : i.slice(0, -1).join(", ") + ", or " + i[i.length - 1]
}
function includesType(o, i) {
    return (o & i) === i
}
function overlapsType(o, i) {
    return !!(o & i)
}
class LiteralExpression {
    constructor(i, s) {
        this.type = i,
        this.value = s
    }
}
class CallExpression {
    constructor(i, s, ...a) {
        this.type = i,
        this.operator = s,
        this.args = a
    }
}
function newParsingContext() {
    return {
        variables: new Set,
        properties: new Set
    }
}
function parse(o, i) {
    switch (typeof o) {
    case "boolean":
        return new LiteralExpression(BooleanType,o);
    case "number":
        return new LiteralExpression(NumberType,o);
    case "string":
        return new LiteralExpression(StringType,o)
    }
    if (!Array.isArray(o))
        throw new Error("Expression must be an array or a primitive value");
    if (o.length === 0)
        throw new Error("Empty expression");
    if (typeof o[0] == "string")
        return parseCallExpression(o, i);
    for (const a of o)
        if (typeof a != "number")
            throw new Error("Expected an array of numbers");
    let s = NumberArrayType;
    return (o.length === 3 || o.length === 4) && (s |= ColorType),
    new LiteralExpression(s,o)
}
const Ops = {
    Number: "number",
    String: "string",
    Get: "get",
    Var: "var",
    Any: "any",
    All: "all",
    Not: "!",
    Resolution: "resolution",
    Equal: "==",
    NotEqual: "!=",
    GreaterThan: ">",
    GreaterThanOrEqualTo: ">=",
    LessThan: "<",
    LessThanOrEqualTo: "<=",
    Multiply: "*",
    Divide: "/",
    Add: "+",
    Subtract: "-",
    Clamp: "clamp",
    Mod: "%",
    Pow: "^",
    Abs: "abs",
    Floor: "floor",
    Ceil: "ceil",
    Round: "round",
    Sin: "sin",
    Cos: "cos",
    Atan: "atan",
    Sqrt: "sqrt",
    Match: "match"
}
  , parsers = {
    [Ops.Number]: createParser(withArgs(1, 1 / 0, AnyType), NumberType),
    [Ops.String]: createParser(withArgs(1, 1 / 0, AnyType), StringType),
    [Ops.Get]: createParser(withGetArgs, AnyType),
    [Ops.Var]: createParser(withVarArgs, AnyType),
    [Ops.Resolution]: createParser(withNoArgs, NumberType),
    [Ops.Any]: createParser(withArgs(2, 1 / 0, BooleanType), BooleanType),
    [Ops.All]: createParser(withArgs(2, 1 / 0, BooleanType), BooleanType),
    [Ops.Not]: createParser(withArgs(1, 1, BooleanType), BooleanType),
    [Ops.Equal]: createParser(withArgs(2, 2, AnyType), BooleanType),
    [Ops.NotEqual]: createParser(withArgs(2, 2, AnyType), BooleanType),
    [Ops.GreaterThan]: createParser(withArgs(2, 2, AnyType), BooleanType),
    [Ops.GreaterThanOrEqualTo]: createParser(withArgs(2, 2, AnyType), BooleanType),
    [Ops.LessThan]: createParser(withArgs(2, 2, AnyType), BooleanType),
    [Ops.LessThanOrEqualTo]: createParser(withArgs(2, 2, AnyType), BooleanType),
    [Ops.Multiply]: createParser(withArgs(2, 1 / 0, NumberType), NumberType),
    [Ops.Divide]: createParser(withArgs(2, 2, NumberType), NumberType),
    [Ops.Add]: createParser(withArgs(2, 1 / 0, NumberType), NumberType),
    [Ops.Subtract]: createParser(withArgs(2, 2, NumberType), NumberType),
    [Ops.Clamp]: createParser(withArgs(3, 3, NumberType), NumberType),
    [Ops.Mod]: createParser(withArgs(2, 2, NumberType), NumberType),
    [Ops.Pow]: createParser(withArgs(2, 2, NumberType), NumberType),
    [Ops.Abs]: createParser(withArgs(1, 1, NumberType), NumberType),
    [Ops.Floor]: createParser(withArgs(1, 1, NumberType), NumberType),
    [Ops.Ceil]: createParser(withArgs(1, 1, NumberType), NumberType),
    [Ops.Round]: createParser(withArgs(1, 1, NumberType), NumberType),
    [Ops.Sin]: createParser(withArgs(1, 1, NumberType), NumberType),
    [Ops.Cos]: createParser(withArgs(1, 1, NumberType), NumberType),
    [Ops.Atan]: createParser(withArgs(1, 2, NumberType), NumberType),
    [Ops.Sqrt]: createParser(withArgs(1, 1, NumberType), NumberType),
    [Ops.Match]: createParser(withArgs(4, 1 / 0, StringType | NumberType), AnyType)
};
function withGetArgs(o, i) {
    if (o.length !== 2)
        throw new Error("Expected 1 argument for get operation");
    const s = parse(o[1], i);
    if (!(s instanceof LiteralExpression))
        throw new Error("Expected a literal argument for get operation");
    if (typeof s.value != "string")
        throw new Error("Expected a string argument for get operation");
    return i.properties.add(s.value),
    [s]
}
function withVarArgs(o, i) {
    if (o.length !== 2)
        throw new Error("Expected 1 argument for var operation");
    const s = parse(o[1], i);
    if (!(s instanceof LiteralExpression))
        throw new Error("Expected a literal argument for var operation");
    if (typeof s.value != "string")
        throw new Error("Expected a string argument for get operation");
    return i.variables.add(s.value),
    [s]
}
function withNoArgs(o, i) {
    const s = o[0];
    if (o.length !== 1)
        throw new Error(`Expected no arguments for ${s} operation`);
    return []
}
function withArgs(o, i, s) {
    return function(a, _) {
        const $ = a[0]
          , _e = a.length - 1;
        if (o === i) {
            if (_e !== o) {
                const nt = o === 1 ? "" : "s";
                throw new Error(`Expected ${o} argument${nt} for operation ${$}, got ${_e}`)
            }
        } else if (_e < o || _e > i)
            throw new Error(`Expected ${o} to ${i} arguments for operation ${$}, got ${_e}`);
        const tt = new Array(_e);
        for (let nt = 0; nt < _e; ++nt) {
            const rt = parse(a[nt + 1], _);
            if (!overlapsType(s, rt.type)) {
                const ot = typeName(s)
                  , et = typeName(rt.type);
                throw new Error(`Unexpected type for argument ${nt} of ${$} operation : got ${ot} but expected ${et}`)
            }
            tt[nt] = rt
        }
        return tt
    }
}
function createParser(o, i) {
    return function(s, a) {
        const _ = s[0]
          , $ = o(s, a);
        return new CallExpression(i,_,...$)
    }
}
function parseCallExpression(o, i) {
    const s = o[0]
      , a = parsers[s];
    if (!a)
        throw new Error(`Unknown operator: ${s}`);
    return a(o, i)
}
function newEvaluationContext() {
    return {
        variables: {},
        properties: {},
        resolution: NaN
    }
}
function buildExpression(o, i, s) {
    const a = parse(o, s);
    if (!overlapsType(i, a.type)) {
        const _ = typeName(i)
          , $ = typeName(a.type);
        throw new Error(`Expected expression to be of type ${_}, got ${$}`)
    }
    return compileExpression(a)
}
function compileExpression(o, i) {
    if (o instanceof LiteralExpression)
        return function() {
            return o.value
        }
        ;
    const s = o.operator;
    switch (s) {
    case Ops.Number:
    case Ops.String:
        return compileAssertionExpression(o);
    case Ops.Get:
    case Ops.Var:
        return compileAccessorExpression(o);
    case Ops.Resolution:
        return a => a.resolution;
    case Ops.Any:
    case Ops.All:
    case Ops.Not:
        return compileLogicalExpression(o);
    case Ops.Equal:
    case Ops.NotEqual:
    case Ops.LessThan:
    case Ops.LessThanOrEqualTo:
    case Ops.GreaterThan:
    case Ops.GreaterThanOrEqualTo:
        return compileComparisonExpression(o);
    case Ops.Multiply:
    case Ops.Divide:
    case Ops.Add:
    case Ops.Subtract:
    case Ops.Clamp:
    case Ops.Mod:
    case Ops.Pow:
    case Ops.Abs:
    case Ops.Floor:
    case Ops.Ceil:
    case Ops.Round:
    case Ops.Sin:
    case Ops.Cos:
    case Ops.Atan:
    case Ops.Sqrt:
        return compileNumericExpression(o);
    case Ops.Match:
        return compileMatchExpression(o);
    default:
        throw new Error(`Unsupported operator ${s}`)
    }
}
function compileAssertionExpression(o, i) {
    const s = o.operator
      , a = o.args.length
      , _ = new Array(a);
    for (let $ = 0; $ < a; ++$)
        _[$] = compileExpression(o.args[$]);
    switch (s) {
    case Ops.Number:
    case Ops.String:
        return $ => {
            for (let _e = 0; _e < a; ++_e) {
                const tt = _[_e]($);
                if (typeof tt === s)
                    return tt
            }
            throw new Error(`Expected one of the values to be a ${s}`)
        }
        ;
    default:
        throw new Error(`Unsupported assertion operator ${s}`)
    }
}
function compileAccessorExpression(o, i) {
    const s = o.args[0];
    if (!(s instanceof LiteralExpression))
        throw new Error("Expected literal name");
    const a = s.value;
    if (typeof a != "string")
        throw new Error("Expected string name");
    switch (o.operator) {
    case Ops.Get:
        return _ => _.properties[a];
    case Ops.Var:
        return _ => _.variables[a];
    default:
        throw new Error(`Unsupported accessor operator ${o.operator}`)
    }
}
function compileComparisonExpression(o, i) {
    const s = o.operator
      , a = compileExpression(o.args[0])
      , _ = compileExpression(o.args[1]);
    switch (s) {
    case Ops.Equal:
        return $ => a($) === _($);
    case Ops.NotEqual:
        return $ => a($) !== _($);
    case Ops.LessThan:
        return $ => a($) < _($);
    case Ops.LessThanOrEqualTo:
        return $ => a($) <= _($);
    case Ops.GreaterThan:
        return $ => a($) > _($);
    case Ops.GreaterThanOrEqualTo:
        return $ => a($) >= _($);
    default:
        throw new Error(`Unsupported comparison operator ${s}`)
    }
}
function compileLogicalExpression(o, i) {
    const s = o.operator
      , a = o.args.length
      , _ = new Array(a);
    for (let $ = 0; $ < a; ++$)
        _[$] = compileExpression(o.args[$]);
    switch (s) {
    case Ops.Any:
        return $ => {
            for (let _e = 0; _e < a; ++_e)
                if (_[_e]($))
                    return !0;
            return !1
        }
        ;
    case Ops.All:
        return $ => {
            for (let _e = 0; _e < a; ++_e)
                if (!_[_e]($))
                    return !1;
            return !0
        }
        ;
    case Ops.Not:
        return $ => !_[0]($);
    default:
        throw new Error(`Unsupported logical operator ${s}`)
    }
}
function compileNumericExpression(o, i) {
    const s = o.operator
      , a = o.args.length
      , _ = new Array(a);
    for (let $ = 0; $ < a; ++$)
        _[$] = compileExpression(o.args[$]);
    switch (s) {
    case Ops.Multiply:
        return $ => {
            let _e = 1;
            for (let tt = 0; tt < a; ++tt)
                _e *= _[tt]($);
            return _e
        }
        ;
    case Ops.Divide:
        return $ => _[0]($) / _[1]($);
    case Ops.Add:
        return $ => {
            let _e = 0;
            for (let tt = 0; tt < a; ++tt)
                _e += _[tt]($);
            return _e
        }
        ;
    case Ops.Subtract:
        return $ => _[0]($) - _[1]($);
    case Ops.Clamp:
        return $ => {
            const _e = _[0]($)
              , tt = _[1]($);
            if (_e < tt)
                return tt;
            const nt = _[2]($);
            return _e > nt ? nt : _e
        }
        ;
    case Ops.Mod:
        return $ => _[0]($) % _[1]($);
    case Ops.Pow:
        return $ => Math.pow(_[0]($), _[1]($));
    case Ops.Abs:
        return $ => Math.abs(_[0]($));
    case Ops.Floor:
        return $ => Math.floor(_[0]($));
    case Ops.Ceil:
        return $ => Math.ceil(_[0]($));
    case Ops.Round:
        return $ => Math.round(_[0]($));
    case Ops.Sin:
        return $ => Math.sin(_[0]($));
    case Ops.Cos:
        return $ => Math.cos(_[0]($));
    case Ops.Atan:
        return a === 2 ? $ => Math.atan2(_[0]($), _[1]($)) : $ => Math.atan(_[0]($));
    case Ops.Sqrt:
        return $ => Math.sqrt(_[0]($));
    default:
        throw new Error(`Unsupported numeric operator ${s}`)
    }
}
function compileMatchExpression(o, i) {
    const s = o.args.length
      , a = new Array(s);
    for (let _ = 0; _ < s; ++_)
        a[_] = compileExpression(o.args[_]);
    return _ => {
        const $ = a[0](_);
        for (let _e = 1; _e < s; _e += 2)
            if ($ === a[_e](_))
                return a[_e + 1](_);
        return a[s - 1](_)
    }
}
function always(o) {
    return !0
}
function rulesToStyleFunction(o) {
    const i = newParsingContext()
      , s = buildRuleSet(o, i)
      , a = newEvaluationContext();
    return function(_, $) {
        return a.properties = _.getPropertiesInternal(),
        a.resolution = $,
        s(a)
    }
}
function flatStylesToStyleFunction(o) {
    const i = newParsingContext()
      , s = o.length
      , a = new Array(s);
    for (let _e = 0; _e < s; ++_e)
        a[_e] = buildStyle(o[_e], i);
    const _ = newEvaluationContext()
      , $ = new Array(s);
    return function(_e, tt) {
        _.properties = _e.getPropertiesInternal(),
        _.resolution = tt;
        for (let nt = 0; nt < s; ++nt)
            $[nt] = a[nt](_);
        return $
    }
}
function buildRuleSet(o, i) {
    const s = o.length
      , a = new Array(s);
    for (let _ = 0; _ < s; ++_) {
        const $ = o[_]
          , _e = "filter"in $ ? buildExpression($.filter, BooleanType, i) : always;
        let tt;
        if (Array.isArray($.style)) {
            const nt = $.style.length;
            tt = new Array(nt);
            for (let rt = 0; rt < nt; ++rt)
                tt[rt] = buildStyle($.style[rt], i)
        } else
            tt = [buildStyle($.style, i)];
        a[_] = {
            filter: _e,
            styles: tt
        }
    }
    return function(_) {
        const $ = [];
        let _e = !1;
        for (let tt = 0; tt < s; ++tt) {
            const nt = a[tt].filter;
            if (nt(_) && !(o[tt].else && _e)) {
                _e = !0;
                for (const rt of a[tt].styles) {
                    const ot = rt(_);
                    ot && $.push(ot)
                }
            }
        }
        return $
    }
}
function buildStyle(o, i) {
    const s = buildFill(o, "", i)
      , a = buildStroke(o, "", i)
      , _ = buildText(o, i)
      , $ = buildImage(o, i)
      , _e = numberEvaluator(o, "z-index", i)
      , tt = new Style$1;
    return function(nt) {
        let rt = !0;
        if (s) {
            const ot = s(nt);
            ot && (rt = !1),
            tt.setFill(ot)
        }
        if (a) {
            const ot = a(nt);
            ot && (rt = !1),
            tt.setStroke(ot)
        }
        if (_) {
            const ot = _(nt);
            ot && (rt = !1),
            tt.setText(ot)
        }
        if ($) {
            const ot = $(nt);
            ot && (rt = !1),
            tt.setImage(ot)
        }
        return _e && tt.setZIndex(_e(nt)),
        rt ? null : tt
    }
}
function buildFill(o, i, s) {
    const a = colorLikeEvaluator(o, i + "fill-color", s);
    if (!a)
        return null;
    const _ = new Fill$1;
    return function($) {
        const _e = a($);
        return _e === "none" ? null : (_.setColor(_e),
        _)
    }
}
function buildStroke(o, i, s) {
    const a = numberEvaluator(o, i + "stroke-width", s)
      , _ = colorLikeEvaluator(o, i + "stroke-color", s);
    if (!a && !_)
        return null;
    const $ = stringEvaluator(o, i + "stroke-line-cap", s)
      , _e = stringEvaluator(o, i + "stroke-line-join", s)
      , tt = numberArrayEvaluator(o, i + "stroke-line-dash", s)
      , nt = numberEvaluator(o, i + "stroke-line-dash-offset", s)
      , rt = numberEvaluator(o, i + "stroke-miter-limit", s)
      , ot = new Stroke$1;
    return function(et) {
        if (_) {
            const j = _(et);
            if (j === "none")
                return null;
            ot.setColor(j)
        }
        if (a && ot.setWidth(a(et)),
        $) {
            const j = $(et);
            if (j !== "butt" && j !== "round" && j !== "square")
                throw new Error("Expected butt, round, or square line cap");
            ot.setLineCap(j)
        }
        if (_e) {
            const j = _e(et);
            if (j !== "bevel" && j !== "round" && j !== "miter")
                throw new Error("Expected bevel, round, or miter line join");
            ot.setLineJoin(j)
        }
        return tt && ot.setLineDash(tt(et)),
        nt && ot.setLineDashOffset(nt(et)),
        rt && ot.setMiterLimit(rt(et)),
        ot
    }
}
function buildText(o, i) {
    const s = "text-"
      , a = stringEvaluator(o, s + "value", i);
    if (!a)
        return null;
    const _ = buildFill(o, s, i)
      , $ = buildFill(o, s + "background-", i)
      , _e = buildStroke(o, s, i)
      , tt = buildStroke(o, s + "background-", i)
      , nt = stringEvaluator(o, s + "font", i)
      , rt = numberEvaluator(o, s + "max-angle", i)
      , ot = numberEvaluator(o, s + "offset-x", i)
      , et = numberEvaluator(o, s + "offset-y", i)
      , j = booleanEvaluator(o, s + "overflow", i)
      , it = stringEvaluator(o, s + "placement", i)
      , st = numberEvaluator(o, s + "repeat", i)
      , at = sizeLikeEvaluator(o, s + "scale", i)
      , lt = booleanEvaluator(o, s + "rotate-with-view", i)
      , ct = numberEvaluator(o, s + "rotation", i)
      , ut = stringEvaluator(o, s + "align", i)
      , dt = stringEvaluator(o, s + "justify", i)
      , ft = stringEvaluator(o, s + "baseline", i)
      , ht = numberArrayEvaluator(o, s + "padding", i)
      , pt = new Text$1({});
    return function(gt) {
        if (pt.setText(a(gt)),
        _ && pt.setFill(_(gt)),
        $ && pt.setBackgroundFill($(gt)),
        _e && pt.setStroke(_e(gt)),
        tt && pt.setBackgroundStroke(tt(gt)),
        nt && pt.setFont(nt(gt)),
        rt && pt.setMaxAngle(rt(gt)),
        ot && pt.setOffsetX(ot(gt)),
        et && pt.setOffsetY(et(gt)),
        j && pt.setOverflow(j(gt)),
        it) {
            const _t = it(gt);
            if (_t !== "point" && _t !== "line")
                throw new Error("Expected point or line for text-placement");
            pt.setPlacement(_t)
        }
        if (st && pt.setRepeat(st(gt)),
        at && pt.setScale(at(gt)),
        lt && pt.setRotateWithView(lt(gt)),
        ct && pt.setRotation(ct(gt)),
        ut) {
            const _t = ut(gt);
            if (_t !== "left" && _t !== "center" && _t !== "right" && _t !== "end" && _t !== "start")
                throw new Error("Expected left, right, center, start, or end for text-align");
            pt.setTextAlign(_t)
        }
        if (dt) {
            const _t = dt(gt);
            if (_t !== "left" && _t !== "right" && _t !== "center")
                throw new Error("Expected left, right, or center for text-justify");
            pt.setJustify(_t)
        }
        if (ft) {
            const _t = ft(gt);
            if (_t !== "bottom" && _t !== "top" && _t !== "middle" && _t !== "alphabetic" && _t !== "hanging")
                throw new Error("Expected bottom, top, middle, alphabetic, or hanging for text-baseline");
            pt.setTextBaseline(_t)
        }
        return ht && pt.setPadding(ht(gt)),
        pt
    }
}
function buildImage(o, i) {
    return "icon-src"in o ? buildIcon(o, i) : "shape-points"in o ? buildShape(o, i) : "circle-radius"in o ? buildCircle(o, i) : null
}
function buildIcon(o, i) {
    const s = "icon-"
      , a = s + "src"
      , _ = requireString(o[a], a)
      , $ = coordinateEvaluator(o, s + "anchor", i)
      , _e = sizeLikeEvaluator(o, s + "scale", i)
      , tt = numberEvaluator(o, s + "opacity", i)
      , nt = coordinateEvaluator(o, s + "displacement", i)
      , rt = numberEvaluator(o, s + "rotation", i)
      , ot = booleanEvaluator(o, s + "rotate-with-view", i)
      , et = optionalIconOrigin(o, s + "anchor-origin")
      , j = optionalIconAnchorUnits(o, s + "anchor-x-units")
      , it = optionalIconAnchorUnits(o, s + "anchor-y-units")
      , st = optionalColorLike(o, s + "color")
      , at = optionalString(o, s + "cross-origin")
      , lt = optionalNumberArray(o, s + "offset")
      , ct = optionalIconOrigin(o, s + "offset-origin")
      , ut = optionalNumber(o, s + "width")
      , dt = optionalNumber(o, s + "height")
      , ft = optionalSize(o, s + "size")
      , ht = optionalDeclutterMode(o, s + "declutter")
      , pt = new Icon$1({
        src: _,
        anchorOrigin: et,
        anchorXUnits: j,
        anchorYUnits: it,
        color: st,
        crossOrigin: at,
        offset: lt,
        offsetOrigin: ct,
        height: dt,
        width: ut,
        size: ft,
        declutterMode: ht
    });
    return function(gt) {
        return tt && pt.setOpacity(tt(gt)),
        nt && pt.setDisplacement(nt(gt)),
        rt && pt.setRotation(rt(gt)),
        ot && pt.setRotateWithView(ot(gt)),
        _e && pt.setScale(_e(gt)),
        $ && pt.setAnchor($(gt)),
        pt
    }
}
function buildShape(o, i) {
    const s = "shape-"
      , a = s + "points"
      , _ = requireNumber(o[a], a)
      , $ = buildFill(o, s, i)
      , _e = buildStroke(o, s, i)
      , tt = sizeLikeEvaluator(o, s + "scale", i)
      , nt = coordinateEvaluator(o, s + "displacement", i)
      , rt = numberEvaluator(o, s + "rotation", i)
      , ot = booleanEvaluator(o, s + "rotate-with-view", i)
      , et = optionalNumber(o, s + "radius")
      , j = optionalNumber(o, s + "radius1")
      , it = optionalNumber(o, s + "radius2")
      , st = optionalNumber(o, s + "angle")
      , at = optionalDeclutterMode(o, s + "declutter-mode")
      , lt = new RegularShape$1({
        points: _,
        radius: et,
        radius1: j,
        radius2: it,
        angle: st,
        declutterMode: at
    });
    return function(ct) {
        return $ && lt.setFill($(ct)),
        _e && lt.setStroke(_e(ct)),
        nt && lt.setDisplacement(nt(ct)),
        rt && lt.setRotation(rt(ct)),
        ot && lt.setRotateWithView(ot(ct)),
        tt && lt.setScale(tt(ct)),
        lt
    }
}
function buildCircle(o, i) {
    const s = "circle-"
      , a = buildFill(o, s, i)
      , _ = buildStroke(o, s, i)
      , $ = numberEvaluator(o, s + "radius", i)
      , _e = sizeLikeEvaluator(o, s + "scale", i)
      , tt = coordinateEvaluator(o, s + "displacement", i)
      , nt = numberEvaluator(o, s + "rotation", i)
      , rt = booleanEvaluator(o, s + "rotate-with-view", i)
      , ot = optionalDeclutterMode(o, s + "declutter-mode")
      , et = new CircleStyle$1({
        radius: 5,
        declutterMode: ot
    });
    return function(j) {
        return $ && et.setRadius($(j)),
        a && et.setFill(a(j)),
        _ && et.setStroke(_(j)),
        tt && et.setDisplacement(tt(j)),
        nt && et.setRotation(nt(j)),
        rt && et.setRotateWithView(rt(j)),
        _e && et.setScale(_e(j)),
        et
    }
}
function numberEvaluator(o, i, s) {
    if (!(i in o))
        return;
    const a = buildExpression(o[i], NumberType, s);
    return function(_) {
        return requireNumber(a(_), i)
    }
}
function stringEvaluator(o, i, s) {
    if (!(i in o))
        return null;
    const a = buildExpression(o[i], StringType, s);
    return function(_) {
        return requireString(a(_), i)
    }
}
function booleanEvaluator(o, i, s) {
    if (!(i in o))
        return null;
    const a = buildExpression(o[i], BooleanType, s);
    return function(_) {
        const $ = a(_);
        if (typeof $ != "boolean")
            throw new Error(`Expected a boolean for ${i}`);
        return $
    }
}
function colorLikeEvaluator(o, i, s) {
    if (!(i in o))
        return null;
    const a = buildExpression(o[i], ColorType | StringType, s);
    return function(_) {
        return requireColorLike(a(_), i)
    }
}
function numberArrayEvaluator(o, i, s) {
    if (!(i in o))
        return null;
    const a = buildExpression(o[i], NumberArrayType, s);
    return function(_) {
        return requireNumberArray(a(_), i)
    }
}
function coordinateEvaluator(o, i, s) {
    if (!(i in o))
        return null;
    const a = buildExpression(o[i], NumberArrayType, s);
    return function(_) {
        const $ = requireNumberArray(a(_), i);
        if ($.length !== 2)
            throw new Error(`Expected two numbers for ${i}`);
        return $
    }
}
function sizeLikeEvaluator(o, i, s) {
    if (!(i in o))
        return null;
    const a = buildExpression(o[i], NumberArrayType, s);
    return function(_) {
        return requireSizeLike(a(_), i)
    }
}
function optionalNumber(o, i) {
    const s = o[i];
    if (s !== void 0) {
        if (typeof s != "number")
            throw new Error(`Expected a number for ${i}`);
        return s
    }
}
function optionalSize(o, i) {
    const s = o[i];
    if (s !== void 0) {
        if (typeof s == "number")
            return toSize(s);
        if (!Array.isArray(s))
            throw new Error(`Expected a number or size array for ${i}`);
        if (s.length !== 2 || typeof s[0] != "number" || typeof s[1] != "number")
            throw new Error(`Expected a number or size array for ${i}`);
        return s
    }
}
function optionalString(o, i) {
    const s = o[i];
    if (s !== void 0) {
        if (typeof s != "string")
            throw new Error(`Expected a string for ${i}`);
        return s
    }
}
function optionalIconOrigin(o, i) {
    const s = o[i];
    if (s !== void 0) {
        if (s !== "bottom-left" && s !== "bottom-right" && s !== "top-left" && s !== "top-right")
            throw new Error(`Expected bottom-left, bottom-right, top-left, or top-right for ${i}`);
        return s
    }
}
function optionalIconAnchorUnits(o, i) {
    const s = o[i];
    if (s !== void 0) {
        if (s !== "pixels" && s !== "fraction")
            throw new Error(`Expected pixels or fraction for ${i}`);
        return s
    }
}
function optionalNumberArray(o, i) {
    const s = o[i];
    if (s !== void 0)
        return requireNumberArray(s, i)
}
function optionalDeclutterMode(o, i) {
    const s = o[i];
    if (s !== void 0) {
        if (typeof s != "string")
            throw new Error(`Expected a string for ${i}`);
        if (s !== "declutter" && s !== "obstacle" && s !== "none")
            throw new Error(`Expected declutter, obstacle, or none for ${i}`);
        return s
    }
}
function optionalColorLike(o, i) {
    const s = o[i];
    if (s !== void 0)
        return requireColorLike(s, i)
}
function requireNumberArray(o, i) {
    if (!Array.isArray(o))
        throw new Error(`Expected an array for ${i}`);
    const s = o.length;
    for (let a = 0; a < s; ++a)
        if (typeof o[a] != "number")
            throw new Error(`Expected an array of numbers for ${i}`);
    return o
}
function requireString(o, i) {
    if (typeof o != "string")
        throw new Error(`Expected a string for ${i}`);
    return o
}
function requireNumber(o, i) {
    if (typeof o != "number")
        throw new Error(`Expected a number for ${i}`);
    return o
}
function requireColorLike(o, i) {
    if (typeof o == "string")
        return o;
    const s = requireNumberArray(o, i)
      , a = s.length;
    if (a < 3 || a > 4)
        throw new Error(`Expected a color with 3 or 4 values for ${i}`);
    return s
}
function requireSizeLike(o, i) {
    if (typeof o == "number")
        return o;
    const s = requireNumberArray(o, i);
    if (s.length !== 2)
        throw new Error(`Expected an array of two numbers for ${i}`);
    return s
}
const Property = {
    RENDER_ORDER: "renderOrder"
};
class BaseVectorLayer extends Layer$1 {
    constructor(i) {
        i = i || {};
        const s = Object.assign({}, i);
        delete s.style,
        delete s.renderBuffer,
        delete s.updateWhileAnimating,
        delete s.updateWhileInteracting,
        super(s),
        this.declutter_ = i.declutter !== void 0 ? i.declutter : !1,
        this.renderBuffer_ = i.renderBuffer !== void 0 ? i.renderBuffer : 100,
        this.style_ = null,
        this.styleFunction_ = void 0,
        this.setStyle(i.style),
        this.updateWhileAnimating_ = i.updateWhileAnimating !== void 0 ? i.updateWhileAnimating : !1,
        this.updateWhileInteracting_ = i.updateWhileInteracting !== void 0 ? i.updateWhileInteracting : !1
    }
    getDeclutter() {
        return this.declutter_
    }
    getFeatures(i) {
        return super.getFeatures(i)
    }
    getRenderBuffer() {
        return this.renderBuffer_
    }
    getRenderOrder() {
        return this.get(Property.RENDER_ORDER)
    }
    getStyle() {
        return this.style_
    }
    getStyleFunction() {
        return this.styleFunction_
    }
    getUpdateWhileAnimating() {
        return this.updateWhileAnimating_
    }
    getUpdateWhileInteracting() {
        return this.updateWhileInteracting_
    }
    renderDeclutter(i) {
        i.declutterTree || (i.declutterTree = new RBush$2(9)),
        this.getRenderer().renderDeclutter(i)
    }
    setRenderOrder(i) {
        this.set(Property.RENDER_ORDER, i)
    }
    setStyle(i) {
        this.style_ = toStyleLike(i),
        this.styleFunction_ = i === null ? void 0 : toFunction(this.style_),
        this.changed()
    }
}
function toStyleLike(o) {
    if (o === void 0)
        return createDefaultStyle;
    if (!o)
        return null;
    if (typeof o == "function" || o instanceof Style$1)
        return o;
    if (!Array.isArray(o))
        return flatStylesToStyleFunction([o]);
    if (o.length === 0)
        return [];
    const i = o.length
      , s = o[0];
    if (s instanceof Style$1) {
        const _ = new Array(i);
        for (let $ = 0; $ < i; ++$) {
            const _e = o[$];
            if (!(_e instanceof Style$1))
                throw new Error("Expected a list of style instances");
            _[$] = _e
        }
        return _
    }
    if ("style"in s) {
        const _ = new Array(i);
        for (let $ = 0; $ < i; ++$) {
            const _e = o[$];
            if (!("style"in _e))
                throw new Error("Expected a list of rules with a style property");
            _[$] = _e
        }
        return rulesToStyleFunction(_)
    }
    return flatStylesToStyleFunction(o)
}
const BaseVectorLayer$1 = BaseVectorLayer
  , Instruction = {
    BEGIN_GEOMETRY: 0,
    BEGIN_PATH: 1,
    CIRCLE: 2,
    CLOSE_PATH: 3,
    CUSTOM: 4,
    DRAW_CHARS: 5,
    DRAW_IMAGE: 6,
    END_GEOMETRY: 7,
    FILL: 8,
    MOVE_TO_LINE_TO: 9,
    SET_FILL_STYLE: 10,
    SET_STROKE_STYLE: 11,
    STROKE: 12
}
  , fillInstruction = [Instruction.FILL]
  , strokeInstruction = [Instruction.STROKE]
  , beginPathInstruction = [Instruction.BEGIN_PATH]
  , closePathInstruction = [Instruction.CLOSE_PATH]
  , CanvasInstruction = Instruction;
class VectorContext {
    drawCustom(i, s, a, _) {}
    drawGeometry(i) {}
    setStyle(i) {}
    drawCircle(i, s) {}
    drawFeature(i, s) {}
    drawGeometryCollection(i, s) {}
    drawLineString(i, s) {}
    drawMultiLineString(i, s) {}
    drawMultiPoint(i, s) {}
    drawMultiPolygon(i, s) {}
    drawPoint(i, s) {}
    drawPolygon(i, s) {}
    drawText(i, s) {}
    setFillStrokeStyle(i, s) {}
    setImageStyle(i, s) {}
    setTextStyle(i, s) {}
}
const VectorContext$1 = VectorContext;
class CanvasBuilder extends VectorContext$1 {
    constructor(i, s, a, _) {
        super(),
        this.tolerance = i,
        this.maxExtent = s,
        this.pixelRatio = _,
        this.maxLineWidth = 0,
        this.resolution = a,
        this.beginGeometryInstruction1_ = null,
        this.beginGeometryInstruction2_ = null,
        this.bufferedMaxExtent_ = null,
        this.instructions = [],
        this.coordinates = [],
        this.tmpCoordinate_ = [],
        this.hitDetectionInstructions = [],
        this.state = {}
    }
    applyPixelRatio(i) {
        const s = this.pixelRatio;
        return s == 1 ? i : i.map(function(a) {
            return a * s
        })
    }
    appendFlatPointCoordinates(i, s) {
        const a = this.getBufferedMaxExtent()
          , _ = this.tmpCoordinate_
          , $ = this.coordinates;
        let _e = $.length;
        for (let tt = 0, nt = i.length; tt < nt; tt += s)
            _[0] = i[tt],
            _[1] = i[tt + 1],
            containsCoordinate(a, _) && ($[_e++] = _[0],
            $[_e++] = _[1]);
        return _e
    }
    appendFlatLineCoordinates(i, s, a, _, $, _e) {
        const tt = this.coordinates;
        let nt = tt.length;
        const rt = this.getBufferedMaxExtent();
        _e && (s += _);
        let ot = i[s]
          , et = i[s + 1];
        const j = this.tmpCoordinate_;
        let it = !0, st, at, lt;
        for (st = s + _; st < a; st += _)
            j[0] = i[st],
            j[1] = i[st + 1],
            lt = coordinateRelationship(rt, j),
            lt !== at ? (it && (tt[nt++] = ot,
            tt[nt++] = et,
            it = !1),
            tt[nt++] = j[0],
            tt[nt++] = j[1]) : lt === Relationship.INTERSECTING ? (tt[nt++] = j[0],
            tt[nt++] = j[1],
            it = !1) : it = !0,
            ot = j[0],
            et = j[1],
            at = lt;
        return ($ && it || st === s + _) && (tt[nt++] = ot,
        tt[nt++] = et),
        nt
    }
    drawCustomCoordinates_(i, s, a, _, $) {
        for (let _e = 0, tt = a.length; _e < tt; ++_e) {
            const nt = a[_e]
              , rt = this.appendFlatLineCoordinates(i, s, nt, _, !1, !1);
            $.push(rt),
            s = nt
        }
        return s
    }
    drawCustom(i, s, a, _) {
        this.beginGeometry(i, s);
        const $ = i.getType()
          , _e = i.getStride()
          , tt = this.coordinates.length;
        let nt, rt, ot, et, j;
        switch ($) {
        case "MultiPolygon":
            nt = i.getOrientedFlatCoordinates(),
            et = [];
            const it = i.getEndss();
            j = 0;
            for (let st = 0, at = it.length; st < at; ++st) {
                const lt = [];
                j = this.drawCustomCoordinates_(nt, j, it[st], _e, lt),
                et.push(lt)
            }
            this.instructions.push([CanvasInstruction.CUSTOM, tt, et, i, a, inflateMultiCoordinatesArray]),
            this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, tt, et, i, _ || a, inflateMultiCoordinatesArray]);
            break;
        case "Polygon":
        case "MultiLineString":
            ot = [],
            nt = $ == "Polygon" ? i.getOrientedFlatCoordinates() : i.getFlatCoordinates(),
            j = this.drawCustomCoordinates_(nt, 0, i.getEnds(), _e, ot),
            this.instructions.push([CanvasInstruction.CUSTOM, tt, ot, i, a, inflateCoordinatesArray]),
            this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, tt, ot, i, _ || a, inflateCoordinatesArray]);
            break;
        case "LineString":
        case "Circle":
            nt = i.getFlatCoordinates(),
            rt = this.appendFlatLineCoordinates(nt, 0, nt.length, _e, !1, !1),
            this.instructions.push([CanvasInstruction.CUSTOM, tt, rt, i, a, inflateCoordinates]),
            this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, tt, rt, i, _ || a, inflateCoordinates]);
            break;
        case "MultiPoint":
            nt = i.getFlatCoordinates(),
            rt = this.appendFlatPointCoordinates(nt, _e),
            rt > tt && (this.instructions.push([CanvasInstruction.CUSTOM, tt, rt, i, a, inflateCoordinates]),
            this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, tt, rt, i, _ || a, inflateCoordinates]));
            break;
        case "Point":
            nt = i.getFlatCoordinates(),
            this.coordinates.push(nt[0], nt[1]),
            rt = this.coordinates.length,
            this.instructions.push([CanvasInstruction.CUSTOM, tt, rt, i, a]),
            this.hitDetectionInstructions.push([CanvasInstruction.CUSTOM, tt, rt, i, _ || a]);
            break
        }
        this.endGeometry(s)
    }
    beginGeometry(i, s) {
        this.beginGeometryInstruction1_ = [CanvasInstruction.BEGIN_GEOMETRY, s, 0, i],
        this.instructions.push(this.beginGeometryInstruction1_),
        this.beginGeometryInstruction2_ = [CanvasInstruction.BEGIN_GEOMETRY, s, 0, i],
        this.hitDetectionInstructions.push(this.beginGeometryInstruction2_)
    }
    finish() {
        return {
            instructions: this.instructions,
            hitDetectionInstructions: this.hitDetectionInstructions,
            coordinates: this.coordinates
        }
    }
    reverseHitDetectionInstructions() {
        const i = this.hitDetectionInstructions;
        i.reverse();
        let s;
        const a = i.length;
        let _, $, _e = -1;
        for (s = 0; s < a; ++s)
            _ = i[s],
            $ = _[0],
            $ == CanvasInstruction.END_GEOMETRY ? _e = s : $ == CanvasInstruction.BEGIN_GEOMETRY && (_[2] = s,
            reverseSubArray(this.hitDetectionInstructions, _e, s),
            _e = -1)
    }
    setFillStrokeStyle(i, s) {
        const a = this.state;
        if (i) {
            const _ = i.getColor();
            a.fillStyle = asColorLike(_ || defaultFillStyle)
        } else
            a.fillStyle = void 0;
        if (s) {
            const _ = s.getColor();
            a.strokeStyle = asColorLike(_ || defaultStrokeStyle);
            const $ = s.getLineCap();
            a.lineCap = $ !== void 0 ? $ : defaultLineCap;
            const _e = s.getLineDash();
            a.lineDash = _e ? _e.slice() : defaultLineDash;
            const tt = s.getLineDashOffset();
            a.lineDashOffset = tt || defaultLineDashOffset;
            const nt = s.getLineJoin();
            a.lineJoin = nt !== void 0 ? nt : defaultLineJoin;
            const rt = s.getWidth();
            a.lineWidth = rt !== void 0 ? rt : defaultLineWidth;
            const ot = s.getMiterLimit();
            a.miterLimit = ot !== void 0 ? ot : defaultMiterLimit,
            a.lineWidth > this.maxLineWidth && (this.maxLineWidth = a.lineWidth,
            this.bufferedMaxExtent_ = null)
        } else
            a.strokeStyle = void 0,
            a.lineCap = void 0,
            a.lineDash = null,
            a.lineDashOffset = void 0,
            a.lineJoin = void 0,
            a.lineWidth = void 0,
            a.miterLimit = void 0
    }
    createFill(i) {
        const s = i.fillStyle
          , a = [CanvasInstruction.SET_FILL_STYLE, s];
        return typeof s != "string" && a.push(!0),
        a
    }
    applyStroke(i) {
        this.instructions.push(this.createStroke(i))
    }
    createStroke(i) {
        return [CanvasInstruction.SET_STROKE_STYLE, i.strokeStyle, i.lineWidth * this.pixelRatio, i.lineCap, i.lineJoin, i.miterLimit, this.applyPixelRatio(i.lineDash), i.lineDashOffset * this.pixelRatio]
    }
    updateFillStyle(i, s) {
        const a = i.fillStyle;
        (typeof a != "string" || i.currentFillStyle != a) && (a !== void 0 && this.instructions.push(s.call(this, i)),
        i.currentFillStyle = a)
    }
    updateStrokeStyle(i, s) {
        const a = i.strokeStyle
          , _ = i.lineCap
          , $ = i.lineDash
          , _e = i.lineDashOffset
          , tt = i.lineJoin
          , nt = i.lineWidth
          , rt = i.miterLimit;
        (i.currentStrokeStyle != a || i.currentLineCap != _ || $ != i.currentLineDash && !equals$2(i.currentLineDash, $) || i.currentLineDashOffset != _e || i.currentLineJoin != tt || i.currentLineWidth != nt || i.currentMiterLimit != rt) && (a !== void 0 && s.call(this, i),
        i.currentStrokeStyle = a,
        i.currentLineCap = _,
        i.currentLineDash = $,
        i.currentLineDashOffset = _e,
        i.currentLineJoin = tt,
        i.currentLineWidth = nt,
        i.currentMiterLimit = rt)
    }
    endGeometry(i) {
        this.beginGeometryInstruction1_[2] = this.instructions.length,
        this.beginGeometryInstruction1_ = null,
        this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length,
        this.beginGeometryInstruction2_ = null;
        const s = [CanvasInstruction.END_GEOMETRY, i];
        this.instructions.push(s),
        this.hitDetectionInstructions.push(s)
    }
    getBufferedMaxExtent() {
        if (!this.bufferedMaxExtent_ && (this.bufferedMaxExtent_ = clone(this.maxExtent),
        this.maxLineWidth > 0)) {
            const i = this.resolution * (this.maxLineWidth + 1) / 2;
            buffer$1(this.bufferedMaxExtent_, i, this.bufferedMaxExtent_)
        }
        return this.bufferedMaxExtent_
    }
}
const Builder = CanvasBuilder;
class CanvasImageBuilder extends Builder {
    constructor(i, s, a, _) {
        super(i, s, a, _),
        this.hitDetectionImage_ = null,
        this.image_ = null,
        this.imagePixelRatio_ = void 0,
        this.anchorX_ = void 0,
        this.anchorY_ = void 0,
        this.height_ = void 0,
        this.opacity_ = void 0,
        this.originX_ = void 0,
        this.originY_ = void 0,
        this.rotateWithView_ = void 0,
        this.rotation_ = void 0,
        this.scale_ = void 0,
        this.width_ = void 0,
        this.declutterMode_ = void 0,
        this.declutterImageWithText_ = void 0
    }
    drawPoint(i, s) {
        if (!this.image_)
            return;
        this.beginGeometry(i, s);
        const a = i.getFlatCoordinates()
          , _ = i.getStride()
          , $ = this.coordinates.length
          , _e = this.appendFlatPointCoordinates(a, _);
        this.instructions.push([CanvasInstruction.DRAW_IMAGE, $, _e, this.image_, this.anchorX_ * this.imagePixelRatio_, this.anchorY_ * this.imagePixelRatio_, Math.ceil(this.height_ * this.imagePixelRatio_), this.opacity_, this.originX_ * this.imagePixelRatio_, this.originY_ * this.imagePixelRatio_, this.rotateWithView_, this.rotation_, [this.scale_[0] * this.pixelRatio / this.imagePixelRatio_, this.scale_[1] * this.pixelRatio / this.imagePixelRatio_], Math.ceil(this.width_ * this.imagePixelRatio_), this.declutterMode_, this.declutterImageWithText_]),
        this.hitDetectionInstructions.push([CanvasInstruction.DRAW_IMAGE, $, _e, this.hitDetectionImage_, this.anchorX_, this.anchorY_, this.height_, 1, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_, this.declutterMode_, this.declutterImageWithText_]),
        this.endGeometry(s)
    }
    drawMultiPoint(i, s) {
        if (!this.image_)
            return;
        this.beginGeometry(i, s);
        const a = i.getFlatCoordinates()
          , _ = i.getStride()
          , $ = this.coordinates.length
          , _e = this.appendFlatPointCoordinates(a, _);
        this.instructions.push([CanvasInstruction.DRAW_IMAGE, $, _e, this.image_, this.anchorX_ * this.imagePixelRatio_, this.anchorY_ * this.imagePixelRatio_, Math.ceil(this.height_ * this.imagePixelRatio_), this.opacity_, this.originX_ * this.imagePixelRatio_, this.originY_ * this.imagePixelRatio_, this.rotateWithView_, this.rotation_, [this.scale_[0] * this.pixelRatio / this.imagePixelRatio_, this.scale_[1] * this.pixelRatio / this.imagePixelRatio_], Math.ceil(this.width_ * this.imagePixelRatio_), this.declutterMode_, this.declutterImageWithText_]),
        this.hitDetectionInstructions.push([CanvasInstruction.DRAW_IMAGE, $, _e, this.hitDetectionImage_, this.anchorX_, this.anchorY_, this.height_, 1, this.originX_, this.originY_, this.rotateWithView_, this.rotation_, this.scale_, this.width_, this.declutterMode_, this.declutterImageWithText_]),
        this.endGeometry(s)
    }
    finish() {
        return this.reverseHitDetectionInstructions(),
        this.anchorX_ = void 0,
        this.anchorY_ = void 0,
        this.hitDetectionImage_ = null,
        this.image_ = null,
        this.imagePixelRatio_ = void 0,
        this.height_ = void 0,
        this.scale_ = void 0,
        this.opacity_ = void 0,
        this.originX_ = void 0,
        this.originY_ = void 0,
        this.rotateWithView_ = void 0,
        this.rotation_ = void 0,
        this.width_ = void 0,
        super.finish()
    }
    setImageStyle(i, s) {
        const a = i.getAnchor()
          , _ = i.getSize()
          , $ = i.getOrigin();
        this.imagePixelRatio_ = i.getPixelRatio(this.pixelRatio),
        this.anchorX_ = a[0],
        this.anchorY_ = a[1],
        this.hitDetectionImage_ = i.getHitDetectionImage(),
        this.image_ = i.getImage(this.pixelRatio),
        this.height_ = _[1],
        this.opacity_ = i.getOpacity(),
        this.originX_ = $[0],
        this.originY_ = $[1],
        this.rotateWithView_ = i.getRotateWithView(),
        this.rotation_ = i.getRotation(),
        this.scale_ = i.getScaleArray(),
        this.width_ = _[0],
        this.declutterMode_ = i.getDeclutterMode(),
        this.declutterImageWithText_ = s
    }
}
const ImageBuilder = CanvasImageBuilder;
class CanvasLineStringBuilder extends Builder {
    constructor(i, s, a, _) {
        super(i, s, a, _)
    }
    drawFlatCoordinates_(i, s, a, _) {
        const $ = this.coordinates.length
          , _e = this.appendFlatLineCoordinates(i, s, a, _, !1, !1)
          , tt = [CanvasInstruction.MOVE_TO_LINE_TO, $, _e];
        return this.instructions.push(tt),
        this.hitDetectionInstructions.push(tt),
        a
    }
    drawLineString(i, s) {
        const a = this.state
          , _ = a.strokeStyle
          , $ = a.lineWidth;
        if (_ === void 0 || $ === void 0)
            return;
        this.updateStrokeStyle(a, this.applyStroke),
        this.beginGeometry(i, s),
        this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, a.strokeStyle, a.lineWidth, a.lineCap, a.lineJoin, a.miterLimit, defaultLineDash, defaultLineDashOffset], beginPathInstruction);
        const _e = i.getFlatCoordinates()
          , tt = i.getStride();
        this.drawFlatCoordinates_(_e, 0, _e.length, tt),
        this.hitDetectionInstructions.push(strokeInstruction),
        this.endGeometry(s)
    }
    drawMultiLineString(i, s) {
        const a = this.state
          , _ = a.strokeStyle
          , $ = a.lineWidth;
        if (_ === void 0 || $ === void 0)
            return;
        this.updateStrokeStyle(a, this.applyStroke),
        this.beginGeometry(i, s),
        this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, a.strokeStyle, a.lineWidth, a.lineCap, a.lineJoin, a.miterLimit, defaultLineDash, defaultLineDashOffset], beginPathInstruction);
        const _e = i.getEnds()
          , tt = i.getFlatCoordinates()
          , nt = i.getStride();
        let rt = 0;
        for (let ot = 0, et = _e.length; ot < et; ++ot)
            rt = this.drawFlatCoordinates_(tt, rt, _e[ot], nt);
        this.hitDetectionInstructions.push(strokeInstruction),
        this.endGeometry(s)
    }
    finish() {
        const i = this.state;
        return i.lastStroke != null && i.lastStroke != this.coordinates.length && this.instructions.push(strokeInstruction),
        this.reverseHitDetectionInstructions(),
        this.state = null,
        super.finish()
    }
    applyStroke(i) {
        i.lastStroke != null && i.lastStroke != this.coordinates.length && (this.instructions.push(strokeInstruction),
        i.lastStroke = this.coordinates.length),
        i.lastStroke = 0,
        super.applyStroke(i),
        this.instructions.push(beginPathInstruction)
    }
}
const LineStringBuilder = CanvasLineStringBuilder;
class CanvasPolygonBuilder extends Builder {
    constructor(i, s, a, _) {
        super(i, s, a, _)
    }
    drawFlatCoordinatess_(i, s, a, _) {
        const $ = this.state
          , _e = $.fillStyle !== void 0
          , tt = $.strokeStyle !== void 0
          , nt = a.length;
        this.instructions.push(beginPathInstruction),
        this.hitDetectionInstructions.push(beginPathInstruction);
        for (let rt = 0; rt < nt; ++rt) {
            const ot = a[rt]
              , et = this.coordinates.length
              , j = this.appendFlatLineCoordinates(i, s, ot, _, !0, !tt)
              , it = [CanvasInstruction.MOVE_TO_LINE_TO, et, j];
            this.instructions.push(it),
            this.hitDetectionInstructions.push(it),
            tt && (this.instructions.push(closePathInstruction),
            this.hitDetectionInstructions.push(closePathInstruction)),
            s = ot
        }
        return _e && (this.instructions.push(fillInstruction),
        this.hitDetectionInstructions.push(fillInstruction)),
        tt && (this.instructions.push(strokeInstruction),
        this.hitDetectionInstructions.push(strokeInstruction)),
        s
    }
    drawCircle(i, s) {
        const a = this.state
          , _ = a.fillStyle
          , $ = a.strokeStyle;
        if (_ === void 0 && $ === void 0)
            return;
        this.setFillStrokeStyles_(),
        this.beginGeometry(i, s),
        a.fillStyle !== void 0 && this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, defaultFillStyle]),
        a.strokeStyle !== void 0 && this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, a.strokeStyle, a.lineWidth, a.lineCap, a.lineJoin, a.miterLimit, defaultLineDash, defaultLineDashOffset]);
        const _e = i.getFlatCoordinates()
          , tt = i.getStride()
          , nt = this.coordinates.length;
        this.appendFlatLineCoordinates(_e, 0, _e.length, tt, !1, !1);
        const rt = [CanvasInstruction.CIRCLE, nt];
        this.instructions.push(beginPathInstruction, rt),
        this.hitDetectionInstructions.push(beginPathInstruction, rt),
        a.fillStyle !== void 0 && (this.instructions.push(fillInstruction),
        this.hitDetectionInstructions.push(fillInstruction)),
        a.strokeStyle !== void 0 && (this.instructions.push(strokeInstruction),
        this.hitDetectionInstructions.push(strokeInstruction)),
        this.endGeometry(s)
    }
    drawPolygon(i, s) {
        const a = this.state
          , _ = a.fillStyle
          , $ = a.strokeStyle;
        if (_ === void 0 && $ === void 0)
            return;
        this.setFillStrokeStyles_(),
        this.beginGeometry(i, s),
        a.fillStyle !== void 0 && this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, defaultFillStyle]),
        a.strokeStyle !== void 0 && this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, a.strokeStyle, a.lineWidth, a.lineCap, a.lineJoin, a.miterLimit, defaultLineDash, defaultLineDashOffset]);
        const _e = i.getEnds()
          , tt = i.getOrientedFlatCoordinates()
          , nt = i.getStride();
        this.drawFlatCoordinatess_(tt, 0, _e, nt),
        this.endGeometry(s)
    }
    drawMultiPolygon(i, s) {
        const a = this.state
          , _ = a.fillStyle
          , $ = a.strokeStyle;
        if (_ === void 0 && $ === void 0)
            return;
        this.setFillStrokeStyles_(),
        this.beginGeometry(i, s),
        a.fillStyle !== void 0 && this.hitDetectionInstructions.push([CanvasInstruction.SET_FILL_STYLE, defaultFillStyle]),
        a.strokeStyle !== void 0 && this.hitDetectionInstructions.push([CanvasInstruction.SET_STROKE_STYLE, a.strokeStyle, a.lineWidth, a.lineCap, a.lineJoin, a.miterLimit, defaultLineDash, defaultLineDashOffset]);
        const _e = i.getEndss()
          , tt = i.getOrientedFlatCoordinates()
          , nt = i.getStride();
        let rt = 0;
        for (let ot = 0, et = _e.length; ot < et; ++ot)
            rt = this.drawFlatCoordinatess_(tt, rt, _e[ot], nt);
        this.endGeometry(s)
    }
    finish() {
        this.reverseHitDetectionInstructions(),
        this.state = null;
        const i = this.tolerance;
        if (i !== 0) {
            const s = this.coordinates;
            for (let a = 0, _ = s.length; a < _; ++a)
                s[a] = snap(s[a], i)
        }
        return super.finish()
    }
    setFillStrokeStyles_() {
        const i = this.state;
        i.fillStyle !== void 0 && this.updateFillStyle(i, this.createFill),
        i.strokeStyle !== void 0 && this.updateStrokeStyle(i, this.applyStroke)
    }
}
const PolygonBuilder = CanvasPolygonBuilder;
function lineChunk(o, i, s, a, _) {
    const $ = [];
    let _e = s
      , tt = 0
      , nt = i.slice(s, 2);
    for (; tt < o && _e + _ < a; ) {
        const [rt,ot] = nt.slice(-2)
          , et = i[_e + _]
          , j = i[_e + _ + 1]
          , it = Math.sqrt((et - rt) * (et - rt) + (j - ot) * (j - ot));
        if (tt += it,
        tt >= o) {
            const st = (o - tt + it) / it
              , at = lerp$1(rt, et, st)
              , lt = lerp$1(ot, j, st);
            nt.push(at, lt),
            $.push(nt),
            nt = [at, lt],
            tt == o && (_e += _),
            tt = 0
        } else if (tt < o)
            nt.push(i[_e + _], i[_e + _ + 1]),
            _e += _;
        else {
            const st = it - tt
              , at = lerp$1(rt, et, st / it)
              , lt = lerp$1(ot, j, st / it);
            nt.push(at, lt),
            $.push(nt),
            nt = [at, lt],
            tt = 0,
            _e += _
        }
    }
    return tt > 0 && $.push(nt),
    $
}
function matchingChunk(o, i, s, a, _) {
    let $ = s, _e = s, tt = 0, nt = 0, rt = s, ot, et, j, it, st, at, lt, ct, ut, dt;
    for (et = s; et < a; et += _) {
        const ft = i[et]
          , ht = i[et + 1];
        st !== void 0 && (ut = ft - st,
        dt = ht - at,
        it = Math.sqrt(ut * ut + dt * dt),
        lt !== void 0 && (nt += j,
        ot = Math.acos((lt * ut + ct * dt) / (j * it)),
        ot > o && (nt > tt && (tt = nt,
        $ = rt,
        _e = et),
        nt = 0,
        rt = et - _)),
        j = it,
        lt = ut,
        ct = dt),
        st = ft,
        at = ht
    }
    return nt += it,
    nt > tt ? [rt, et] : [$, _e]
}
const TEXT_ALIGN = {
    left: 0,
    center: .5,
    right: 1,
    top: 0,
    middle: .5,
    hanging: .2,
    alphabetic: .8,
    ideographic: .8,
    bottom: 1
};
class CanvasTextBuilder extends Builder {
    constructor(i, s, a, _) {
        super(i, s, a, _),
        this.labels_ = null,
        this.text_ = "",
        this.textOffsetX_ = 0,
        this.textOffsetY_ = 0,
        this.textRotateWithView_ = void 0,
        this.textRotation_ = 0,
        this.textFillState_ = null,
        this.fillStates = {},
        this.fillStates[defaultFillStyle] = {
            fillStyle: defaultFillStyle
        },
        this.textStrokeState_ = null,
        this.strokeStates = {},
        this.textState_ = {},
        this.textStates = {},
        this.textKey_ = "",
        this.fillKey_ = "",
        this.strokeKey_ = "",
        this.declutterImageWithText_ = void 0
    }
    finish() {
        const i = super.finish();
        return i.textStates = this.textStates,
        i.fillStates = this.fillStates,
        i.strokeStates = this.strokeStates,
        i
    }
    drawText(i, s) {
        const a = this.textFillState_
          , _ = this.textStrokeState_
          , $ = this.textState_;
        if (this.text_ === "" || !$ || !a && !_)
            return;
        const _e = this.coordinates;
        let tt = _e.length;
        const nt = i.getType();
        let rt = null
          , ot = i.getStride();
        if ($.placement === "line" && (nt == "LineString" || nt == "MultiLineString" || nt == "Polygon" || nt == "MultiPolygon")) {
            if (!intersects$1(this.getBufferedMaxExtent(), i.getExtent()))
                return;
            let et;
            if (rt = i.getFlatCoordinates(),
            nt == "LineString")
                et = [rt.length];
            else if (nt == "MultiLineString")
                et = i.getEnds();
            else if (nt == "Polygon")
                et = i.getEnds().slice(0, 1);
            else if (nt == "MultiPolygon") {
                const at = i.getEndss();
                et = [];
                for (let lt = 0, ct = at.length; lt < ct; ++lt)
                    et.push(at[lt][0])
            }
            this.beginGeometry(i, s);
            const j = $.repeat
              , it = j ? void 0 : $.textAlign;
            let st = 0;
            for (let at = 0, lt = et.length; at < lt; ++at) {
                let ct;
                j ? ct = lineChunk(j * this.resolution, rt, st, et[at], ot) : ct = [rt.slice(st, et[at])];
                for (let ut = 0, dt = ct.length; ut < dt; ++ut) {
                    const ft = ct[ut];
                    let ht = 0
                      , pt = ft.length;
                    if (it == null) {
                        const _t = matchingChunk($.maxAngle, ft, 0, ft.length, 2);
                        ht = _t[0],
                        pt = _t[1]
                    }
                    for (let _t = ht; _t < pt; _t += ot)
                        _e.push(ft[_t], ft[_t + 1]);
                    const gt = _e.length;
                    st = et[at],
                    this.drawChars_(tt, gt),
                    tt = gt
                }
            }
            this.endGeometry(s)
        } else {
            let et = $.overflow ? null : [];
            switch (nt) {
            case "Point":
            case "MultiPoint":
                rt = i.getFlatCoordinates();
                break;
            case "LineString":
                rt = i.getFlatMidpoint();
                break;
            case "Circle":
                rt = i.getCenter();
                break;
            case "MultiLineString":
                rt = i.getFlatMidpoints(),
                ot = 2;
                break;
            case "Polygon":
                rt = i.getFlatInteriorPoint(),
                $.overflow || et.push(rt[2] / this.resolution),
                ot = 3;
                break;
            case "MultiPolygon":
                const ct = i.getFlatInteriorPoints();
                rt = [];
                for (let ut = 0, dt = ct.length; ut < dt; ut += 3)
                    $.overflow || et.push(ct[ut + 2] / this.resolution),
                    rt.push(ct[ut], ct[ut + 1]);
                if (rt.length === 0)
                    return;
                ot = 2;
                break
            }
            const j = this.appendFlatPointCoordinates(rt, ot);
            if (j === tt)
                return;
            if (et && (j - tt) / 2 !== rt.length / ot) {
                let ct = tt / 2;
                et = et.filter( (ut, dt) => {
                    const ft = _e[(ct + dt) * 2] === rt[dt * ot] && _e[(ct + dt) * 2 + 1] === rt[dt * ot + 1];
                    return ft || --ct,
                    ft
                }
                )
            }
            this.saveTextStates_(),
            ($.backgroundFill || $.backgroundStroke) && (this.setFillStrokeStyle($.backgroundFill, $.backgroundStroke),
            $.backgroundFill && this.updateFillStyle(this.state, this.createFill),
            $.backgroundStroke && (this.updateStrokeStyle(this.state, this.applyStroke),
            this.hitDetectionInstructions.push(this.createStroke(this.state)))),
            this.beginGeometry(i, s);
            let it = $.padding;
            if (it != defaultPadding && ($.scale[0] < 0 || $.scale[1] < 0)) {
                let ct = $.padding[0]
                  , ut = $.padding[1]
                  , dt = $.padding[2]
                  , ft = $.padding[3];
                $.scale[0] < 0 && (ut = -ut,
                ft = -ft),
                $.scale[1] < 0 && (ct = -ct,
                dt = -dt),
                it = [ct, ut, dt, ft]
            }
            const st = this.pixelRatio;
            this.instructions.push([CanvasInstruction.DRAW_IMAGE, tt, j, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [1, 1], NaN, void 0, this.declutterImageWithText_, it == defaultPadding ? defaultPadding : it.map(function(ct) {
                return ct * st
            }), !!$.backgroundFill, !!$.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_, this.textOffsetX_, this.textOffsetY_, et]);
            const at = 1 / st
              , lt = this.state.fillStyle;
            $.backgroundFill && (this.state.fillStyle = defaultFillStyle,
            this.hitDetectionInstructions.push(this.createFill(this.state))),
            this.hitDetectionInstructions.push([CanvasInstruction.DRAW_IMAGE, tt, j, null, NaN, NaN, NaN, 1, 0, 0, this.textRotateWithView_, this.textRotation_, [at, at], NaN, void 0, this.declutterImageWithText_, it, !!$.backgroundFill, !!$.backgroundStroke, this.text_, this.textKey_, this.strokeKey_, this.fillKey_ ? defaultFillStyle : this.fillKey_, this.textOffsetX_, this.textOffsetY_, et]),
            $.backgroundFill && (this.state.fillStyle = lt,
            this.hitDetectionInstructions.push(this.createFill(this.state))),
            this.endGeometry(s)
        }
    }
    saveTextStates_() {
        const i = this.textStrokeState_
          , s = this.textState_
          , a = this.textFillState_
          , _ = this.strokeKey_;
        i && (_ in this.strokeStates || (this.strokeStates[_] = {
            strokeStyle: i.strokeStyle,
            lineCap: i.lineCap,
            lineDashOffset: i.lineDashOffset,
            lineWidth: i.lineWidth,
            lineJoin: i.lineJoin,
            miterLimit: i.miterLimit,
            lineDash: i.lineDash
        }));
        const $ = this.textKey_;
        $ in this.textStates || (this.textStates[$] = {
            font: s.font,
            textAlign: s.textAlign || defaultTextAlign,
            justify: s.justify,
            textBaseline: s.textBaseline || defaultTextBaseline,
            scale: s.scale
        });
        const _e = this.fillKey_;
        a && (_e in this.fillStates || (this.fillStates[_e] = {
            fillStyle: a.fillStyle
        }))
    }
    drawChars_(i, s) {
        const a = this.textStrokeState_
          , _ = this.textState_
          , $ = this.strokeKey_
          , _e = this.textKey_
          , tt = this.fillKey_;
        this.saveTextStates_();
        const nt = this.pixelRatio
          , rt = TEXT_ALIGN[_.textBaseline]
          , ot = this.textOffsetY_ * nt
          , et = this.text_
          , j = a ? a.lineWidth * Math.abs(_.scale[0]) / 2 : 0;
        this.instructions.push([CanvasInstruction.DRAW_CHARS, i, s, rt, _.overflow, tt, _.maxAngle, nt, ot, $, j * nt, et, _e, 1]),
        this.hitDetectionInstructions.push([CanvasInstruction.DRAW_CHARS, i, s, rt, _.overflow, tt && defaultFillStyle, _.maxAngle, nt, ot, $, j * nt, et, _e, 1 / nt])
    }
    setTextStyle(i, s) {
        let a, _, $;
        if (!i)
            this.text_ = "";
        else {
            const _e = i.getFill();
            _e ? (_ = this.textFillState_,
            _ || (_ = {},
            this.textFillState_ = _),
            _.fillStyle = asColorLike(_e.getColor() || defaultFillStyle)) : (_ = null,
            this.textFillState_ = _);
            const tt = i.getStroke();
            if (!tt)
                $ = null,
                this.textStrokeState_ = $;
            else {
                $ = this.textStrokeState_,
                $ || ($ = {},
                this.textStrokeState_ = $);
                const st = tt.getLineDash()
                  , at = tt.getLineDashOffset()
                  , lt = tt.getWidth()
                  , ct = tt.getMiterLimit();
                $.lineCap = tt.getLineCap() || defaultLineCap,
                $.lineDash = st ? st.slice() : defaultLineDash,
                $.lineDashOffset = at === void 0 ? defaultLineDashOffset : at,
                $.lineJoin = tt.getLineJoin() || defaultLineJoin,
                $.lineWidth = lt === void 0 ? defaultLineWidth : lt,
                $.miterLimit = ct === void 0 ? defaultMiterLimit : ct,
                $.strokeStyle = asColorLike(tt.getColor() || defaultStrokeStyle)
            }
            a = this.textState_;
            const nt = i.getFont() || defaultFont;
            registerFont(nt);
            const rt = i.getScaleArray();
            a.overflow = i.getOverflow(),
            a.font = nt,
            a.maxAngle = i.getMaxAngle(),
            a.placement = i.getPlacement(),
            a.textAlign = i.getTextAlign(),
            a.repeat = i.getRepeat(),
            a.justify = i.getJustify(),
            a.textBaseline = i.getTextBaseline() || defaultTextBaseline,
            a.backgroundFill = i.getBackgroundFill(),
            a.backgroundStroke = i.getBackgroundStroke(),
            a.padding = i.getPadding() || defaultPadding,
            a.scale = rt === void 0 ? [1, 1] : rt;
            const ot = i.getOffsetX()
              , et = i.getOffsetY()
              , j = i.getRotateWithView()
              , it = i.getRotation();
            this.text_ = i.getText() || "",
            this.textOffsetX_ = ot === void 0 ? 0 : ot,
            this.textOffsetY_ = et === void 0 ? 0 : et,
            this.textRotateWithView_ = j === void 0 ? !1 : j,
            this.textRotation_ = it === void 0 ? 0 : it,
            this.strokeKey_ = $ ? (typeof $.strokeStyle == "string" ? $.strokeStyle : getUid($.strokeStyle)) + $.lineCap + $.lineDashOffset + "|" + $.lineWidth + $.lineJoin + $.miterLimit + "[" + $.lineDash.join() + "]" : "",
            this.textKey_ = a.font + a.scale + (a.textAlign || "?") + (a.repeat || "?") + (a.justify || "?") + (a.textBaseline || "?"),
            this.fillKey_ = _ ? typeof _.fillStyle == "string" ? _.fillStyle : "|" + getUid(_.fillStyle) : ""
        }
        this.declutterImageWithText_ = s
    }
}
const BATCH_CONSTRUCTORS = {
    Circle: PolygonBuilder,
    Default: Builder,
    Image: ImageBuilder,
    LineString: LineStringBuilder,
    Polygon: PolygonBuilder,
    Text: CanvasTextBuilder
};
class BuilderGroup {
    constructor(i, s, a, _) {
        this.tolerance_ = i,
        this.maxExtent_ = s,
        this.pixelRatio_ = _,
        this.resolution_ = a,
        this.buildersByZIndex_ = {}
    }
    finish() {
        const i = {};
        for (const s in this.buildersByZIndex_) {
            i[s] = i[s] || {};
            const a = this.buildersByZIndex_[s];
            for (const _ in a) {
                const $ = a[_].finish();
                i[s][_] = $
            }
        }
        return i
    }
    getBuilder(i, s) {
        const a = i !== void 0 ? i.toString() : "0";
        let _ = this.buildersByZIndex_[a];
        _ === void 0 && (_ = {},
        this.buildersByZIndex_[a] = _);
        let $ = _[s];
        if ($ === void 0) {
            const _e = BATCH_CONSTRUCTORS[s];
            $ = new _e(this.tolerance_,this.maxExtent_,this.resolution_,this.pixelRatio_),
            _[s] = $
        }
        return $
    }
}
const CanvasBuilderGroup = BuilderGroup;
class LayerRenderer extends Observable$1 {
    constructor(i) {
        super(),
        this.ready = !0,
        this.boundHandleImageChange_ = this.handleImageChange_.bind(this),
        this.layer_ = i,
        this.declutterExecutorGroup = null
    }
    getFeatures(i) {
        return abstract()
    }
    getData(i) {
        return null
    }
    prepareFrame(i) {
        return abstract()
    }
    renderFrame(i, s) {
        return abstract()
    }
    loadedTileCallback(i, s, a) {
        i[s] || (i[s] = {}),
        i[s][a.tileCoord.toString()] = a
    }
    createLoadedTileFinder(i, s, a) {
        return (_, $) => {
            const _e = this.loadedTileCallback.bind(this, a, _);
            return i.forEachLoadedTile(s, _, $, _e)
        }
    }
    forEachFeatureAtCoordinate(i, s, a, _, $) {}
    getLayer() {
        return this.layer_
    }
    handleFontsChanged() {}
    handleImageChange_(i) {
        const s = i.target;
        (s.getState() === ImageState.LOADED || s.getState() === ImageState.ERROR) && this.renderIfReadyAndVisible()
    }
    loadImage(i) {
        let s = i.getState();
        return s != ImageState.LOADED && s != ImageState.ERROR && i.addEventListener(EventType.CHANGE, this.boundHandleImageChange_),
        s == ImageState.IDLE && (i.load(),
        s = i.getState()),
        s == ImageState.LOADED
    }
    renderIfReadyAndVisible() {
        const i = this.getLayer();
        i && i.getVisible() && i.getSourceState() === "ready" && i.changed()
    }
    disposeInternal() {
        delete this.layer_,
        super.disposeInternal()
    }
}
const LayerRenderer$1 = LayerRenderer
  , canvasPool$1 = [];
let pixelContext$1 = null;
function createPixelContext$1() {
    pixelContext$1 = createCanvasContext2D(1, 1, void 0, {
        willReadFrequently: !0
    })
}
class CanvasLayerRenderer extends LayerRenderer$1 {
    constructor(i) {
        super(i),
        this.container = null,
        this.renderedResolution,
        this.tempTransform = create$1(),
        this.pixelTransform = create$1(),
        this.inversePixelTransform = create$1(),
        this.context = null,
        this.containerReused = !1,
        this.pixelContext_ = null,
        this.frameState = null
    }
    getImageData(i, s, a) {
        pixelContext$1 || createPixelContext$1(),
        pixelContext$1.clearRect(0, 0, 1, 1);
        let _;
        try {
            pixelContext$1.drawImage(i, s, a, 1, 1, 0, 0, 1, 1),
            _ = pixelContext$1.getImageData(0, 0, 1, 1).data
        } catch {
            return pixelContext$1 = null,
            null
        }
        return _
    }
    getBackground(i) {
        let a = this.getLayer().getBackground();
        return typeof a == "function" && (a = a(i.viewState.resolution)),
        a || void 0
    }
    useContainer(i, s, a) {
        const _ = this.getLayer().getClassName();
        let $, _e;
        if (i && i.className === _ && (!a || i && i.style.backgroundColor && equals$2(asArray(i.style.backgroundColor), asArray(a)))) {
            const tt = i.firstElementChild;
            tt instanceof HTMLCanvasElement && (_e = tt.getContext("2d"))
        }
        if (_e && _e.canvas.style.transform === s ? (this.container = i,
        this.context = _e,
        this.containerReused = !0) : this.containerReused ? (this.container = null,
        this.context = null,
        this.containerReused = !1) : this.container && (this.container.style.backgroundColor = null),
        !this.container) {
            $ = document.createElement("div"),
            $.className = _;
            let tt = $.style;
            tt.position = "absolute",
            tt.width = "100%",
            tt.height = "100%",
            _e = createCanvasContext2D();
            const nt = _e.canvas;
            $.appendChild(nt),
            tt = nt.style,
            tt.position = "absolute",
            tt.left = "0",
            tt.transformOrigin = "top left",
            this.container = $,
            this.context = _e
        }
        !this.containerReused && a && !this.container.style.backgroundColor && (this.container.style.backgroundColor = a)
    }
    clipUnrotated(i, s, a) {
        const _ = getTopLeft(a)
          , $ = getTopRight(a)
          , _e = getBottomRight(a)
          , tt = getBottomLeft(a);
        apply(s.coordinateToPixelTransform, _),
        apply(s.coordinateToPixelTransform, $),
        apply(s.coordinateToPixelTransform, _e),
        apply(s.coordinateToPixelTransform, tt);
        const nt = this.inversePixelTransform;
        apply(nt, _),
        apply(nt, $),
        apply(nt, _e),
        apply(nt, tt),
        i.save(),
        i.beginPath(),
        i.moveTo(Math.round(_[0]), Math.round(_[1])),
        i.lineTo(Math.round($[0]), Math.round($[1])),
        i.lineTo(Math.round(_e[0]), Math.round(_e[1])),
        i.lineTo(Math.round(tt[0]), Math.round(tt[1])),
        i.clip()
    }
    dispatchRenderEvent_(i, s, a) {
        const _ = this.getLayer();
        if (_.hasListener(i)) {
            const $ = new RenderEvent$1(i,this.inversePixelTransform,a,s);
            _.dispatchEvent($)
        }
    }
    preRender(i, s) {
        this.frameState = s,
        this.dispatchRenderEvent_(RenderEventType.PRERENDER, i, s)
    }
    postRender(i, s) {
        this.dispatchRenderEvent_(RenderEventType.POSTRENDER, i, s)
    }
    getRenderTransform(i, s, a, _, $, _e, tt) {
        const nt = $ / 2
          , rt = _e / 2
          , ot = _ / s
          , et = -ot
          , j = -i[0] + tt
          , it = -i[1];
        return compose(this.tempTransform, nt, rt, ot, et, -a, j, it)
    }
    disposeInternal() {
        delete this.frameState,
        super.disposeInternal()
    }
}
const CanvasLayerRenderer$1 = CanvasLayerRenderer;
function drawTextOnPath(o, i, s, a, _, $, _e, tt, nt, rt, ot, et) {
    let j = o[i]
      , it = o[i + 1]
      , st = 0
      , at = 0
      , lt = 0
      , ct = 0;
    function ut() {
        st = j,
        at = it,
        i += a,
        j = o[i],
        it = o[i + 1],
        ct += lt,
        lt = Math.sqrt((j - st) * (j - st) + (it - at) * (it - at))
    }
    do
        ut();
    while (i < s - a && ct + lt < $);
    let dt = lt === 0 ? 0 : ($ - ct) / lt;
    const ft = lerp$1(st, j, dt)
      , ht = lerp$1(at, it, dt)
      , pt = i - a
      , gt = ct
      , _t = $ + tt * nt(rt, _, ot);
    for (; i < s - a && ct + lt < _t; )
        ut();
    dt = lt === 0 ? 0 : (_t - ct) / lt;
    const mt = lerp$1(st, j, dt)
      , yt = lerp$1(at, it, dt);
    let bt;
    if (et) {
        const Et = [ft, ht, mt, yt];
        rotate(Et, 0, 4, 2, et, Et, Et),
        bt = Et[0] > Et[2]
    } else
        bt = ft > mt;
    const vt = Math.PI
      , wt = []
      , Tt = pt + a === i;
    i = pt,
    lt = 0,
    ct = gt,
    j = o[i],
    it = o[i + 1];
    let $t;
    if (Tt) {
        ut(),
        $t = Math.atan2(it - at, j - st),
        bt && ($t += $t > 0 ? -vt : vt);
        const Et = (mt + ft) / 2
          , Pt = (yt + ht) / 2;
        return wt[0] = [Et, Pt, (_t - $) / 2, $t, _],
        wt
    }
    _ = _.replace(/\n/g, " ");
    for (let Et = 0, Pt = _.length; Et < Pt; ) {
        ut();
        let Rt = Math.atan2(it - at, j - st);
        if (bt && (Rt += Rt > 0 ? -vt : vt),
        $t !== void 0) {
            let Vt = Rt - $t;
            if (Vt += Vt > vt ? -2 * vt : Vt < -vt ? 2 * vt : 0,
            Math.abs(Vt) > _e)
                return null
        }
        $t = Rt;
        const At = Et;
        let Mt = 0;
        for (; Et < Pt; ++Et) {
            const Vt = bt ? Pt - Et - 1 : Et
              , Nt = tt * nt(rt, _[Vt], ot);
            if (i + a < s && ct + lt < $ + Mt + Nt / 2)
                break;
            Mt += Nt
        }
        if (Et === At)
            continue;
        const Ut = bt ? _.substring(Pt - At, Pt - Et) : _.substring(At, Et);
        dt = lt === 0 ? 0 : ($ + Mt / 2 - ct) / lt;
        const Lt = lerp$1(st, j, dt)
          , tn = lerp$1(at, it, dt);
        wt.push([Lt, tn, Mt / 2, Rt, Ut]),
        $ += Mt
    }
    return wt
}
const tmpExtent = createEmpty()
  , p1 = []
  , p2 = []
  , p3 = []
  , p4 = [];
function getDeclutterBox(o) {
    return o[3].declutterBox
}
const rtlRegEx = new RegExp("[" + String.fromCharCode(1425) + "-" + String.fromCharCode(2303) + String.fromCharCode(64285) + "-" + String.fromCharCode(65023) + String.fromCharCode(65136) + "-" + String.fromCharCode(65276) + String.fromCharCode(67584) + "-" + String.fromCharCode(69631) + String.fromCharCode(124928) + "-" + String.fromCharCode(126975) + "]");
function horizontalTextAlign(o, i) {
    return i === "start" ? i = rtlRegEx.test(o) ? "right" : "left" : i === "end" && (i = rtlRegEx.test(o) ? "left" : "right"),
    TEXT_ALIGN[i]
}
function createTextChunks(o, i, s) {
    return s > 0 && o.push(`
`, ""),
    o.push(i, ""),
    o
}
class Executor {
    constructor(i, s, a, _) {
        this.overlaps = a,
        this.pixelRatio = s,
        this.resolution = i,
        this.alignFill_,
        this.instructions = _.instructions,
        this.coordinates = _.coordinates,
        this.coordinateCache_ = {},
        this.renderedTransform_ = create$1(),
        this.hitDetectionInstructions = _.hitDetectionInstructions,
        this.pixelCoordinates_ = null,
        this.viewRotation_ = 0,
        this.fillStates = _.fillStates || {},
        this.strokeStates = _.strokeStates || {},
        this.textStates = _.textStates || {},
        this.widths_ = {},
        this.labels_ = {}
    }
    createLabel(i, s, a, _) {
        const $ = i + s + a + _;
        if (this.labels_[$])
            return this.labels_[$];
        const _e = _ ? this.strokeStates[_] : null
          , tt = a ? this.fillStates[a] : null
          , nt = this.textStates[s]
          , rt = this.pixelRatio
          , ot = [nt.scale[0] * rt, nt.scale[1] * rt]
          , et = Array.isArray(i)
          , j = nt.justify ? TEXT_ALIGN[nt.justify] : horizontalTextAlign(Array.isArray(i) ? i[0] : i, nt.textAlign || defaultTextAlign)
          , it = _ && _e.lineWidth ? _e.lineWidth : 0
          , st = et ? i : i.split(`
`).reduce(createTextChunks, [])
          , {width: at, height: lt, widths: ct, heights: ut, lineWidths: dt} = getTextDimensions(nt, st)
          , ft = at + it
          , ht = []
          , pt = (ft + 2) * ot[0]
          , gt = (lt + it) * ot[1]
          , _t = {
            width: pt < 0 ? Math.floor(pt) : Math.ceil(pt),
            height: gt < 0 ? Math.floor(gt) : Math.ceil(gt),
            contextInstructions: ht
        };
        (ot[0] != 1 || ot[1] != 1) && ht.push("scale", ot),
        _ && (ht.push("strokeStyle", _e.strokeStyle),
        ht.push("lineWidth", it),
        ht.push("lineCap", _e.lineCap),
        ht.push("lineJoin", _e.lineJoin),
        ht.push("miterLimit", _e.miterLimit),
        ht.push("setLineDash", [_e.lineDash]),
        ht.push("lineDashOffset", _e.lineDashOffset)),
        a && ht.push("fillStyle", tt.fillStyle),
        ht.push("textBaseline", "middle"),
        ht.push("textAlign", "center");
        const mt = .5 - j;
        let yt = j * ft + mt * it;
        const bt = []
          , vt = [];
        let wt = 0, Tt = 0, $t = 0, Et = 0, Pt;
        for (let Rt = 0, At = st.length; Rt < At; Rt += 2) {
            const Mt = st[Rt];
            if (Mt === `
`) {
                Tt += wt,
                wt = 0,
                yt = j * ft + mt * it,
                ++Et;
                continue
            }
            const Ut = st[Rt + 1] || nt.font;
            Ut !== Pt && (_ && bt.push("font", Ut),
            a && vt.push("font", Ut),
            Pt = Ut),
            wt = Math.max(wt, ut[$t]);
            const Lt = [Mt, yt + mt * ct[$t] + j * (ct[$t] - dt[Et]), .5 * (it + wt) + Tt];
            yt += ct[$t],
            _ && bt.push("strokeText", Lt),
            a && vt.push("fillText", Lt),
            ++$t
        }
        return Array.prototype.push.apply(ht, bt),
        Array.prototype.push.apply(ht, vt),
        this.labels_[$] = _t,
        _t
    }
    replayTextBackground_(i, s, a, _, $, _e, tt) {
        i.beginPath(),
        i.moveTo.apply(i, s),
        i.lineTo.apply(i, a),
        i.lineTo.apply(i, _),
        i.lineTo.apply(i, $),
        i.lineTo.apply(i, s),
        _e && (this.alignFill_ = _e[2],
        this.fill_(i)),
        tt && (this.setStrokeStyle_(i, tt),
        i.stroke())
    }
    calculateImageOrLabelDimensions_(i, s, a, _, $, _e, tt, nt, rt, ot, et, j, it, st, at, lt) {
        tt *= j[0],
        nt *= j[1];
        let ct = a - tt
          , ut = _ - nt;
        const dt = $ + rt > i ? i - rt : $
          , ft = _e + ot > s ? s - ot : _e
          , ht = st[3] + dt * j[0] + st[1]
          , pt = st[0] + ft * j[1] + st[2]
          , gt = ct - st[3]
          , _t = ut - st[0];
        (at || et !== 0) && (p1[0] = gt,
        p4[0] = gt,
        p1[1] = _t,
        p2[1] = _t,
        p2[0] = gt + ht,
        p3[0] = p2[0],
        p3[1] = _t + pt,
        p4[1] = p3[1]);
        let mt;
        return et !== 0 ? (mt = compose(create$1(), a, _, 1, 1, et, -a, -_),
        apply(mt, p1),
        apply(mt, p2),
        apply(mt, p3),
        apply(mt, p4),
        createOrUpdate$2(Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1]), tmpExtent)) : createOrUpdate$2(Math.min(gt, gt + ht), Math.min(_t, _t + pt), Math.max(gt, gt + ht), Math.max(_t, _t + pt), tmpExtent),
        it && (ct = Math.round(ct),
        ut = Math.round(ut)),
        {
            drawImageX: ct,
            drawImageY: ut,
            drawImageW: dt,
            drawImageH: ft,
            originX: rt,
            originY: ot,
            declutterBox: {
                minX: tmpExtent[0],
                minY: tmpExtent[1],
                maxX: tmpExtent[2],
                maxY: tmpExtent[3],
                value: lt
            },
            canvasTransform: mt,
            scale: j
        }
    }
    replayImageOrLabel_(i, s, a, _, $, _e, tt) {
        const nt = !!(_e || tt)
          , rt = _.declutterBox
          , ot = i.canvas
          , et = tt ? tt[2] * _.scale[0] / 2 : 0;
        return rt.minX - et <= ot.width / s && rt.maxX + et >= 0 && rt.minY - et <= ot.height / s && rt.maxY + et >= 0 && (nt && this.replayTextBackground_(i, p1, p2, p3, p4, _e, tt),
        drawImageOrLabel(i, _.canvasTransform, $, a, _.originX, _.originY, _.drawImageW, _.drawImageH, _.drawImageX, _.drawImageY, _.scale)),
        !0
    }
    fill_(i) {
        if (this.alignFill_) {
            const s = apply(this.renderedTransform_, [0, 0])
              , a = 512 * this.pixelRatio;
            i.save(),
            i.translate(s[0] % a, s[1] % a),
            i.rotate(this.viewRotation_)
        }
        i.fill(),
        this.alignFill_ && i.restore()
    }
    setStrokeStyle_(i, s) {
        i.strokeStyle = s[1],
        i.lineWidth = s[2],
        i.lineCap = s[3],
        i.lineJoin = s[4],
        i.miterLimit = s[5],
        i.lineDashOffset = s[7],
        i.setLineDash(s[6])
    }
    drawLabelWithPointPlacement_(i, s, a, _) {
        const $ = this.textStates[s]
          , _e = this.createLabel(i, s, _, a)
          , tt = this.strokeStates[a]
          , nt = this.pixelRatio
          , rt = horizontalTextAlign(Array.isArray(i) ? i[0] : i, $.textAlign || defaultTextAlign)
          , ot = TEXT_ALIGN[$.textBaseline || defaultTextBaseline]
          , et = tt && tt.lineWidth ? tt.lineWidth : 0
          , j = _e.width / nt - 2 * $.scale[0]
          , it = rt * j + 2 * (.5 - rt) * et
          , st = ot * _e.height / nt + 2 * (.5 - ot) * et;
        return {
            label: _e,
            anchorX: it,
            anchorY: st
        }
    }
    execute_(i, s, a, _, $, _e, tt, nt) {
        let rt;
        this.pixelCoordinates_ && equals$2(a, this.renderedTransform_) ? rt = this.pixelCoordinates_ : (this.pixelCoordinates_ || (this.pixelCoordinates_ = []),
        rt = transform2D(this.coordinates, 0, this.coordinates.length, 2, a, this.pixelCoordinates_),
        setFromArray(this.renderedTransform_, a));
        let ot = 0;
        const et = _.length;
        let j = 0, it, st, at, lt, ct, ut, dt, ft, ht, pt, gt, _t, mt = 0, yt = 0, bt = null, vt = null;
        const wt = this.coordinateCache_
          , Tt = this.viewRotation_
          , $t = Math.round(Math.atan2(-a[1], a[0]) * 1e12) / 1e12
          , Et = {
            context: i,
            pixelRatio: this.pixelRatio,
            resolution: this.resolution,
            rotation: Tt
        }
          , Pt = this.instructions != _ || this.overlaps ? 0 : 200;
        let Rt, At, Mt, Ut;
        for (; ot < et; ) {
            const Lt = _[ot];
            switch (Lt[0]) {
            case CanvasInstruction.BEGIN_GEOMETRY:
                Rt = Lt[1],
                Ut = Lt[3],
                Rt.getGeometry() ? tt !== void 0 && !intersects$1(tt, Ut.getExtent()) ? ot = Lt[2] + 1 : ++ot : ot = Lt[2];
                break;
            case CanvasInstruction.BEGIN_PATH:
                mt > Pt && (this.fill_(i),
                mt = 0),
                yt > Pt && (i.stroke(),
                yt = 0),
                !mt && !yt && (i.beginPath(),
                lt = NaN,
                ct = NaN),
                ++ot;
                break;
            case CanvasInstruction.CIRCLE:
                j = Lt[1];
                const Vt = rt[j]
                  , Nt = rt[j + 1]
                  , Yt = rt[j + 2]
                  , Xt = rt[j + 3]
                  , jt = Yt - Vt
                  , Gt = Xt - Nt
                  , Kt = Math.sqrt(jt * jt + Gt * Gt);
                i.moveTo(Vt + Kt, Nt),
                i.arc(Vt, Nt, Kt, 0, 2 * Math.PI, !0),
                ++ot;
                break;
            case CanvasInstruction.CLOSE_PATH:
                i.closePath(),
                ++ot;
                break;
            case CanvasInstruction.CUSTOM:
                j = Lt[1],
                it = Lt[2];
                const qt = Lt[3]
                  , rn = Lt[4]
                  , on = Lt.length == 6 ? Lt[5] : void 0;
                Et.geometry = qt,
                Et.feature = Rt,
                ot in wt || (wt[ot] = []);
                const _n = wt[ot];
                on ? on(rt, j, it, 2, _n) : (_n[0] = rt[j],
                _n[1] = rt[j + 1],
                _n.length = 2),
                rn(_n, Et),
                ++ot;
                break;
            case CanvasInstruction.DRAW_IMAGE:
                j = Lt[1],
                it = Lt[2],
                ft = Lt[3],
                st = Lt[4],
                at = Lt[5];
                let mn = Lt[6];
                const Sn = Lt[7]
                  , bn = Lt[8]
                  , In = Lt[9]
                  , Nn = Lt[10];
                let cn = Lt[11];
                const $n = Lt[12];
                let gn = Lt[13];
                const dn = Lt[14]
                  , Dn = Lt[15];
                if (!ft && Lt.length >= 20) {
                    ht = Lt[19],
                    pt = Lt[20],
                    gt = Lt[21],
                    _t = Lt[22];
                    const hn = this.drawLabelWithPointPlacement_(ht, pt, gt, _t);
                    ft = hn.label,
                    Lt[3] = ft;
                    const Ft = Lt[23];
                    st = (hn.anchorX - Ft) * this.pixelRatio,
                    Lt[4] = st;
                    const Qt = Lt[24];
                    at = (hn.anchorY - Qt) * this.pixelRatio,
                    Lt[5] = at,
                    mn = ft.height,
                    Lt[6] = mn,
                    gn = ft.width,
                    Lt[13] = gn
                }
                let kn;
                Lt.length > 25 && (kn = Lt[25]);
                let An, Fn, On;
                Lt.length > 17 ? (An = Lt[16],
                Fn = Lt[17],
                On = Lt[18]) : (An = defaultPadding,
                Fn = !1,
                On = !1),
                Nn && $t ? cn += Tt : !Nn && !$t && (cn -= Tt);
                let jn = 0;
                for (; j < it; j += 2) {
                    if (kn && kn[jn++] < gn / this.pixelRatio)
                        continue;
                    const hn = this.calculateImageOrLabelDimensions_(ft.width, ft.height, rt[j], rt[j + 1], gn, mn, st, at, bn, In, cn, $n, $, An, Fn || On, Rt)
                      , Ft = [i, s, ft, hn, Sn, Fn ? bt : null, On ? vt : null];
                    if (nt) {
                        if (dn === "none")
                            continue;
                        if (dn === "obstacle") {
                            nt.insert(hn.declutterBox);
                            continue
                        } else {
                            let Qt, yn;
                            if (Dn) {
                                const wn = it - j;
                                if (!Dn[wn]) {
                                    Dn[wn] = Ft;
                                    continue
                                }
                                if (Qt = Dn[wn],
                                delete Dn[wn],
                                yn = getDeclutterBox(Qt),
                                nt.collides(yn))
                                    continue
                            }
                            if (nt.collides(hn.declutterBox))
                                continue;
                            Qt && (nt.insert(yn),
                            this.replayImageOrLabel_.apply(this, Qt)),
                            nt.insert(hn.declutterBox)
                        }
                    }
                    this.replayImageOrLabel_.apply(this, Ft)
                }
                ++ot;
                break;
            case CanvasInstruction.DRAW_CHARS:
                const Vn = Lt[1]
                  , Mn = Lt[2]
                  , fn = Lt[3]
                  , It = Lt[4];
                _t = Lt[5];
                const xt = Lt[6]
                  , Ot = Lt[7]
                  , Dt = Lt[8];
                gt = Lt[9];
                const Bt = Lt[10];
                ht = Lt[11],
                pt = Lt[12];
                const Wt = [Lt[13], Lt[13]]
                  , Zt = this.textStates[pt]
                  , an = Zt.font
                  , en = [Zt.scale[0] * Ot, Zt.scale[1] * Ot];
                let Jt;
                an in this.widths_ ? Jt = this.widths_[an] : (Jt = {},
                this.widths_[an] = Jt);
                const pn = lineStringLength(rt, Vn, Mn, 2)
                  , vn = Math.abs(en[0]) * measureAndCacheTextWidth(an, ht, Jt);
                if (It || vn <= pn) {
                    const hn = this.textStates[pt].textAlign
                      , Ft = (pn - vn) * horizontalTextAlign(ht, hn)
                      , Qt = drawTextOnPath(rt, Vn, Mn, 2, ht, Ft, xt, Math.abs(en[0]), measureAndCacheTextWidth, an, Jt, $t ? 0 : this.viewRotation_);
                    e: if (Qt) {
                        const yn = [];
                        let wn, Ln, Hn, Rn, Cn;
                        if (gt)
                            for (wn = 0,
                            Ln = Qt.length; wn < Ln; ++wn) {
                                Cn = Qt[wn],
                                Hn = Cn[4],
                                Rn = this.createLabel(Hn, pt, "", gt),
                                st = Cn[2] + (en[0] < 0 ? -Bt : Bt),
                                at = fn * Rn.height + (.5 - fn) * 2 * Bt * en[1] / en[0] - Dt;
                                const zn = this.calculateImageOrLabelDimensions_(Rn.width, Rn.height, Cn[0], Cn[1], Rn.width, Rn.height, st, at, 0, 0, Cn[3], Wt, !1, defaultPadding, !1, Rt);
                                if (nt && nt.collides(zn.declutterBox))
                                    break e;
                                yn.push([i, s, Rn, zn, 1, null, null])
                            }
                        if (_t)
                            for (wn = 0,
                            Ln = Qt.length; wn < Ln; ++wn) {
                                Cn = Qt[wn],
                                Hn = Cn[4],
                                Rn = this.createLabel(Hn, pt, _t, ""),
                                st = Cn[2],
                                at = fn * Rn.height - Dt;
                                const zn = this.calculateImageOrLabelDimensions_(Rn.width, Rn.height, Cn[0], Cn[1], Rn.width, Rn.height, st, at, 0, 0, Cn[3], Wt, !1, defaultPadding, !1, Rt);
                                if (nt && nt.collides(zn.declutterBox))
                                    break e;
                                yn.push([i, s, Rn, zn, 1, null, null])
                            }
                        nt && nt.load(yn.map(getDeclutterBox));
                        for (let zn = 0, qn = yn.length; zn < qn; ++zn)
                            this.replayImageOrLabel_.apply(this, yn[zn])
                    }
                }
                ++ot;
                break;
            case CanvasInstruction.END_GEOMETRY:
                if (_e !== void 0) {
                    Rt = Lt[1];
                    const hn = _e(Rt, Ut);
                    if (hn)
                        return hn
                }
                ++ot;
                break;
            case CanvasInstruction.FILL:
                Pt ? mt++ : this.fill_(i),
                ++ot;
                break;
            case CanvasInstruction.MOVE_TO_LINE_TO:
                for (j = Lt[1],
                it = Lt[2],
                At = rt[j],
                Mt = rt[j + 1],
                ut = At + .5 | 0,
                dt = Mt + .5 | 0,
                (ut !== lt || dt !== ct) && (i.moveTo(At, Mt),
                lt = ut,
                ct = dt),
                j += 2; j < it; j += 2)
                    At = rt[j],
                    Mt = rt[j + 1],
                    ut = At + .5 | 0,
                    dt = Mt + .5 | 0,
                    (j == it - 2 || ut !== lt || dt !== ct) && (i.lineTo(At, Mt),
                    lt = ut,
                    ct = dt);
                ++ot;
                break;
            case CanvasInstruction.SET_FILL_STYLE:
                bt = Lt,
                this.alignFill_ = Lt[2],
                mt && (this.fill_(i),
                mt = 0,
                yt && (i.stroke(),
                yt = 0)),
                i.fillStyle = Lt[1],
                ++ot;
                break;
            case CanvasInstruction.SET_STROKE_STYLE:
                vt = Lt,
                yt && (i.stroke(),
                yt = 0),
                this.setStrokeStyle_(i, Lt),
                ++ot;
                break;
            case CanvasInstruction.STROKE:
                Pt ? yt++ : i.stroke(),
                ++ot;
                break;
            default:
                ++ot;
                break
            }
        }
        mt && this.fill_(i),
        yt && i.stroke()
    }
    execute(i, s, a, _, $, _e) {
        this.viewRotation_ = _,
        this.execute_(i, s, a, this.instructions, $, void 0, void 0, _e)
    }
    executeHitDetection(i, s, a, _, $) {
        return this.viewRotation_ = a,
        this.execute_(i, 1, s, this.hitDetectionInstructions, !0, _, $)
    }
}
const Executor$1 = Executor
  , ORDER = ["Polygon", "Circle", "LineString", "Image", "Text", "Default"];
class ExecutorGroup {
    constructor(i, s, a, _, $, _e) {
        this.maxExtent_ = i,
        this.overlaps_ = _,
        this.pixelRatio_ = a,
        this.resolution_ = s,
        this.renderBuffer_ = _e,
        this.executorsByZIndex_ = {},
        this.hitDetectionContext_ = null,
        this.hitDetectionTransform_ = create$1(),
        this.createExecutors_($)
    }
    clip(i, s) {
        const a = this.getClipCoords(s);
        i.beginPath(),
        i.moveTo(a[0], a[1]),
        i.lineTo(a[2], a[3]),
        i.lineTo(a[4], a[5]),
        i.lineTo(a[6], a[7]),
        i.clip()
    }
    createExecutors_(i) {
        for (const s in i) {
            let a = this.executorsByZIndex_[s];
            a === void 0 && (a = {},
            this.executorsByZIndex_[s] = a);
            const _ = i[s];
            for (const $ in _) {
                const _e = _[$];
                a[$] = new Executor$1(this.resolution_,this.pixelRatio_,this.overlaps_,_e)
            }
        }
    }
    hasExecutors(i) {
        for (const s in this.executorsByZIndex_) {
            const a = this.executorsByZIndex_[s];
            for (let _ = 0, $ = i.length; _ < $; ++_)
                if (i[_]in a)
                    return !0
        }
        return !1
    }
    forEachFeatureAtCoordinate(i, s, a, _, $, _e) {
        _ = Math.round(_);
        const tt = _ * 2 + 1
          , nt = compose(this.hitDetectionTransform_, _ + .5, _ + .5, 1 / s, -1 / s, -a, -i[0], -i[1])
          , rt = !this.hitDetectionContext_;
        rt && (this.hitDetectionContext_ = createCanvasContext2D(tt, tt, void 0, {
            willReadFrequently: !0
        }));
        const ot = this.hitDetectionContext_;
        ot.canvas.width !== tt || ot.canvas.height !== tt ? (ot.canvas.width = tt,
        ot.canvas.height = tt) : rt || ot.clearRect(0, 0, tt, tt);
        let et;
        this.renderBuffer_ !== void 0 && (et = createEmpty(),
        extendCoordinate(et, i),
        buffer$1(et, s * (this.renderBuffer_ + _), et));
        const j = getPixelIndexArray(_);
        let it;
        function st(ht, pt) {
            const gt = ot.getImageData(0, 0, tt, tt).data;
            for (let _t = 0, mt = j.length; _t < mt; _t++)
                if (gt[j[_t]] > 0) {
                    if (!_e || it !== "Image" && it !== "Text" || _e.includes(ht)) {
                        const yt = (j[_t] - 3) / 4
                          , bt = _ - yt % tt
                          , vt = _ - (yt / tt | 0)
                          , wt = $(ht, pt, bt * bt + vt * vt);
                        if (wt)
                            return wt
                    }
                    ot.clearRect(0, 0, tt, tt);
                    break
                }
        }
        const at = Object.keys(this.executorsByZIndex_).map(Number);
        at.sort(ascending);
        let lt, ct, ut, dt, ft;
        for (lt = at.length - 1; lt >= 0; --lt) {
            const ht = at[lt].toString();
            for (ut = this.executorsByZIndex_[ht],
            ct = ORDER.length - 1; ct >= 0; --ct)
                if (it = ORDER[ct],
                dt = ut[it],
                dt !== void 0 && (ft = dt.executeHitDetection(ot, nt, a, st, et),
                ft))
                    return ft
        }
    }
    getClipCoords(i) {
        const s = this.maxExtent_;
        if (!s)
            return null;
        const a = s[0]
          , _ = s[1]
          , $ = s[2]
          , _e = s[3]
          , tt = [a, _, a, _e, $, _e, $, _];
        return transform2D(tt, 0, 8, 2, i, tt),
        tt
    }
    isEmpty() {
        return isEmpty$1(this.executorsByZIndex_)
    }
    execute(i, s, a, _, $, _e, tt) {
        const nt = Object.keys(this.executorsByZIndex_).map(Number);
        nt.sort(ascending),
        this.maxExtent_ && (i.save(),
        this.clip(i, a)),
        _e = _e || ORDER;
        let rt, ot, et, j, it, st;
        for (tt && nt.reverse(),
        rt = 0,
        ot = nt.length; rt < ot; ++rt) {
            const at = nt[rt].toString();
            for (it = this.executorsByZIndex_[at],
            et = 0,
            j = _e.length; et < j; ++et) {
                const lt = _e[et];
                st = it[lt],
                st !== void 0 && st.execute(i, s, a, _, $, tt)
            }
        }
        this.maxExtent_ && i.restore()
    }
}
const circlePixelIndexArrayCache = {};
function getPixelIndexArray(o) {
    if (circlePixelIndexArrayCache[o] !== void 0)
        return circlePixelIndexArrayCache[o];
    const i = o * 2 + 1
      , s = o * o
      , a = new Array(s + 1);
    for (let $ = 0; $ <= o; ++$)
        for (let _e = 0; _e <= o; ++_e) {
            const tt = $ * $ + _e * _e;
            if (tt > s)
                break;
            let nt = a[tt];
            nt || (nt = [],
            a[tt] = nt),
            nt.push(((o + $) * i + (o + _e)) * 4 + 3),
            $ > 0 && nt.push(((o - $) * i + (o + _e)) * 4 + 3),
            _e > 0 && (nt.push(((o + $) * i + (o - _e)) * 4 + 3),
            $ > 0 && nt.push(((o - $) * i + (o - _e)) * 4 + 3))
        }
    const _ = [];
    for (let $ = 0, _e = a.length; $ < _e; ++$)
        a[$] && _.push(...a[$]);
    return circlePixelIndexArrayCache[o] = _,
    _
}
const ExecutorGroup$1 = ExecutorGroup;
class CanvasImmediateRenderer extends VectorContext$1 {
    constructor(i, s, a, _, $, _e, tt) {
        super(),
        this.context_ = i,
        this.pixelRatio_ = s,
        this.extent_ = a,
        this.transform_ = _,
        this.transformRotation_ = _ ? toFixed(Math.atan2(_[1], _[0]), 10) : 0,
        this.viewRotation_ = $,
        this.squaredTolerance_ = _e,
        this.userTransform_ = tt,
        this.contextFillState_ = null,
        this.contextStrokeState_ = null,
        this.contextTextState_ = null,
        this.fillState_ = null,
        this.strokeState_ = null,
        this.image_ = null,
        this.imageAnchorX_ = 0,
        this.imageAnchorY_ = 0,
        this.imageHeight_ = 0,
        this.imageOpacity_ = 0,
        this.imageOriginX_ = 0,
        this.imageOriginY_ = 0,
        this.imageRotateWithView_ = !1,
        this.imageRotation_ = 0,
        this.imageScale_ = [0, 0],
        this.imageWidth_ = 0,
        this.text_ = "",
        this.textOffsetX_ = 0,
        this.textOffsetY_ = 0,
        this.textRotateWithView_ = !1,
        this.textRotation_ = 0,
        this.textScale_ = [0, 0],
        this.textFillState_ = null,
        this.textStrokeState_ = null,
        this.textState_ = null,
        this.pixelCoordinates_ = [],
        this.tmpLocalTransform_ = create$1()
    }
    drawImages_(i, s, a, _) {
        if (!this.image_)
            return;
        const $ = transform2D(i, s, a, _, this.transform_, this.pixelCoordinates_)
          , _e = this.context_
          , tt = this.tmpLocalTransform_
          , nt = _e.globalAlpha;
        this.imageOpacity_ != 1 && (_e.globalAlpha = nt * this.imageOpacity_);
        let rt = this.imageRotation_;
        this.transformRotation_ === 0 && (rt -= this.viewRotation_),
        this.imageRotateWithView_ && (rt += this.viewRotation_);
        for (let ot = 0, et = $.length; ot < et; ot += 2) {
            const j = $[ot] - this.imageAnchorX_
              , it = $[ot + 1] - this.imageAnchorY_;
            if (rt !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
                const st = j + this.imageAnchorX_
                  , at = it + this.imageAnchorY_;
                compose(tt, st, at, 1, 1, rt, -st, -at),
                _e.save(),
                _e.transform.apply(_e, tt),
                _e.translate(st, at),
                _e.scale(this.imageScale_[0], this.imageScale_[1]),
                _e.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, -this.imageAnchorX_, -this.imageAnchorY_, this.imageWidth_, this.imageHeight_),
                _e.restore()
            } else
                _e.drawImage(this.image_, this.imageOriginX_, this.imageOriginY_, this.imageWidth_, this.imageHeight_, j, it, this.imageWidth_, this.imageHeight_)
        }
        this.imageOpacity_ != 1 && (_e.globalAlpha = nt)
    }
    drawText_(i, s, a, _) {
        if (!this.textState_ || this.text_ === "")
            return;
        this.textFillState_ && this.setContextFillState_(this.textFillState_),
        this.textStrokeState_ && this.setContextStrokeState_(this.textStrokeState_),
        this.setContextTextState_(this.textState_);
        const $ = transform2D(i, s, a, _, this.transform_, this.pixelCoordinates_)
          , _e = this.context_;
        let tt = this.textRotation_;
        for (this.transformRotation_ === 0 && (tt -= this.viewRotation_),
        this.textRotateWithView_ && (tt += this.viewRotation_); s < a; s += _) {
            const nt = $[s] + this.textOffsetX_
              , rt = $[s + 1] + this.textOffsetY_;
            tt !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1 ? (_e.save(),
            _e.translate(nt - this.textOffsetX_, rt - this.textOffsetY_),
            _e.rotate(tt),
            _e.translate(this.textOffsetX_, this.textOffsetY_),
            _e.scale(this.textScale_[0], this.textScale_[1]),
            this.textStrokeState_ && _e.strokeText(this.text_, 0, 0),
            this.textFillState_ && _e.fillText(this.text_, 0, 0),
            _e.restore()) : (this.textStrokeState_ && _e.strokeText(this.text_, nt, rt),
            this.textFillState_ && _e.fillText(this.text_, nt, rt))
        }
    }
    moveToLineTo_(i, s, a, _, $) {
        const _e = this.context_
          , tt = transform2D(i, s, a, _, this.transform_, this.pixelCoordinates_);
        _e.moveTo(tt[0], tt[1]);
        let nt = tt.length;
        $ && (nt -= 2);
        for (let rt = 2; rt < nt; rt += 2)
            _e.lineTo(tt[rt], tt[rt + 1]);
        return $ && _e.closePath(),
        a
    }
    drawRings_(i, s, a, _) {
        for (let $ = 0, _e = a.length; $ < _e; ++$)
            s = this.moveToLineTo_(i, s, a[$], _, !0);
        return s
    }
    drawCircle(i) {
        if (this.squaredTolerance_ && (i = i.simplifyTransformed(this.squaredTolerance_, this.userTransform_)),
        !!intersects$1(this.extent_, i.getExtent())) {
            if (this.fillState_ || this.strokeState_) {
                this.fillState_ && this.setContextFillState_(this.fillState_),
                this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
                const s = transformGeom2D(i, this.transform_, this.pixelCoordinates_)
                  , a = s[2] - s[0]
                  , _ = s[3] - s[1]
                  , $ = Math.sqrt(a * a + _ * _)
                  , _e = this.context_;
                _e.beginPath(),
                _e.arc(s[0], s[1], $, 0, 2 * Math.PI),
                this.fillState_ && _e.fill(),
                this.strokeState_ && _e.stroke()
            }
            this.text_ !== "" && this.drawText_(i.getCenter(), 0, 2, 2)
        }
    }
    setStyle(i) {
        this.setFillStrokeStyle(i.getFill(), i.getStroke()),
        this.setImageStyle(i.getImage()),
        this.setTextStyle(i.getText())
    }
    setTransform(i) {
        this.transform_ = i
    }
    drawGeometry(i) {
        switch (i.getType()) {
        case "Point":
            this.drawPoint(i);
            break;
        case "LineString":
            this.drawLineString(i);
            break;
        case "Polygon":
            this.drawPolygon(i);
            break;
        case "MultiPoint":
            this.drawMultiPoint(i);
            break;
        case "MultiLineString":
            this.drawMultiLineString(i);
            break;
        case "MultiPolygon":
            this.drawMultiPolygon(i);
            break;
        case "GeometryCollection":
            this.drawGeometryCollection(i);
            break;
        case "Circle":
            this.drawCircle(i);
            break
        }
    }
    drawFeature(i, s) {
        const a = s.getGeometryFunction()(i);
        a && (this.setStyle(s),
        this.drawGeometry(a))
    }
    drawGeometryCollection(i) {
        const s = i.getGeometriesArray();
        for (let a = 0, _ = s.length; a < _; ++a)
            this.drawGeometry(s[a])
    }
    drawPoint(i) {
        this.squaredTolerance_ && (i = i.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
        const s = i.getFlatCoordinates()
          , a = i.getStride();
        this.image_ && this.drawImages_(s, 0, s.length, a),
        this.text_ !== "" && this.drawText_(s, 0, s.length, a)
    }
    drawMultiPoint(i) {
        this.squaredTolerance_ && (i = i.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
        const s = i.getFlatCoordinates()
          , a = i.getStride();
        this.image_ && this.drawImages_(s, 0, s.length, a),
        this.text_ !== "" && this.drawText_(s, 0, s.length, a)
    }
    drawLineString(i) {
        if (this.squaredTolerance_ && (i = i.simplifyTransformed(this.squaredTolerance_, this.userTransform_)),
        !!intersects$1(this.extent_, i.getExtent())) {
            if (this.strokeState_) {
                this.setContextStrokeState_(this.strokeState_);
                const s = this.context_
                  , a = i.getFlatCoordinates();
                s.beginPath(),
                this.moveToLineTo_(a, 0, a.length, i.getStride(), !1),
                s.stroke()
            }
            if (this.text_ !== "") {
                const s = i.getFlatMidpoint();
                this.drawText_(s, 0, 2, 2)
            }
        }
    }
    drawMultiLineString(i) {
        this.squaredTolerance_ && (i = i.simplifyTransformed(this.squaredTolerance_, this.userTransform_));
        const s = i.getExtent();
        if (intersects$1(this.extent_, s)) {
            if (this.strokeState_) {
                this.setContextStrokeState_(this.strokeState_);
                const a = this.context_
                  , _ = i.getFlatCoordinates();
                let $ = 0;
                const _e = i.getEnds()
                  , tt = i.getStride();
                a.beginPath();
                for (let nt = 0, rt = _e.length; nt < rt; ++nt)
                    $ = this.moveToLineTo_(_, $, _e[nt], tt, !1);
                a.stroke()
            }
            if (this.text_ !== "") {
                const a = i.getFlatMidpoints();
                this.drawText_(a, 0, a.length, 2)
            }
        }
    }
    drawPolygon(i) {
        if (this.squaredTolerance_ && (i = i.simplifyTransformed(this.squaredTolerance_, this.userTransform_)),
        !!intersects$1(this.extent_, i.getExtent())) {
            if (this.strokeState_ || this.fillState_) {
                this.fillState_ && this.setContextFillState_(this.fillState_),
                this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
                const s = this.context_;
                s.beginPath(),
                this.drawRings_(i.getOrientedFlatCoordinates(), 0, i.getEnds(), i.getStride()),
                this.fillState_ && s.fill(),
                this.strokeState_ && s.stroke()
            }
            if (this.text_ !== "") {
                const s = i.getFlatInteriorPoint();
                this.drawText_(s, 0, 2, 2)
            }
        }
    }
    drawMultiPolygon(i) {
        if (this.squaredTolerance_ && (i = i.simplifyTransformed(this.squaredTolerance_, this.userTransform_)),
        !!intersects$1(this.extent_, i.getExtent())) {
            if (this.strokeState_ || this.fillState_) {
                this.fillState_ && this.setContextFillState_(this.fillState_),
                this.strokeState_ && this.setContextStrokeState_(this.strokeState_);
                const s = this.context_
                  , a = i.getOrientedFlatCoordinates();
                let _ = 0;
                const $ = i.getEndss()
                  , _e = i.getStride();
                s.beginPath();
                for (let tt = 0, nt = $.length; tt < nt; ++tt) {
                    const rt = $[tt];
                    _ = this.drawRings_(a, _, rt, _e)
                }
                this.fillState_ && s.fill(),
                this.strokeState_ && s.stroke()
            }
            if (this.text_ !== "") {
                const s = i.getFlatInteriorPoints();
                this.drawText_(s, 0, s.length, 2)
            }
        }
    }
    setContextFillState_(i) {
        const s = this.context_
          , a = this.contextFillState_;
        a ? a.fillStyle != i.fillStyle && (a.fillStyle = i.fillStyle,
        s.fillStyle = i.fillStyle) : (s.fillStyle = i.fillStyle,
        this.contextFillState_ = {
            fillStyle: i.fillStyle
        })
    }
    setContextStrokeState_(i) {
        const s = this.context_
          , a = this.contextStrokeState_;
        a ? (a.lineCap != i.lineCap && (a.lineCap = i.lineCap,
        s.lineCap = i.lineCap),
        equals$2(a.lineDash, i.lineDash) || s.setLineDash(a.lineDash = i.lineDash),
        a.lineDashOffset != i.lineDashOffset && (a.lineDashOffset = i.lineDashOffset,
        s.lineDashOffset = i.lineDashOffset),
        a.lineJoin != i.lineJoin && (a.lineJoin = i.lineJoin,
        s.lineJoin = i.lineJoin),
        a.lineWidth != i.lineWidth && (a.lineWidth = i.lineWidth,
        s.lineWidth = i.lineWidth),
        a.miterLimit != i.miterLimit && (a.miterLimit = i.miterLimit,
        s.miterLimit = i.miterLimit),
        a.strokeStyle != i.strokeStyle && (a.strokeStyle = i.strokeStyle,
        s.strokeStyle = i.strokeStyle)) : (s.lineCap = i.lineCap,
        s.setLineDash(i.lineDash),
        s.lineDashOffset = i.lineDashOffset,
        s.lineJoin = i.lineJoin,
        s.lineWidth = i.lineWidth,
        s.miterLimit = i.miterLimit,
        s.strokeStyle = i.strokeStyle,
        this.contextStrokeState_ = {
            lineCap: i.lineCap,
            lineDash: i.lineDash,
            lineDashOffset: i.lineDashOffset,
            lineJoin: i.lineJoin,
            lineWidth: i.lineWidth,
            miterLimit: i.miterLimit,
            strokeStyle: i.strokeStyle
        })
    }
    setContextTextState_(i) {
        const s = this.context_
          , a = this.contextTextState_
          , _ = i.textAlign ? i.textAlign : defaultTextAlign;
        a ? (a.font != i.font && (a.font = i.font,
        s.font = i.font),
        a.textAlign != _ && (a.textAlign = _,
        s.textAlign = _),
        a.textBaseline != i.textBaseline && (a.textBaseline = i.textBaseline,
        s.textBaseline = i.textBaseline)) : (s.font = i.font,
        s.textAlign = _,
        s.textBaseline = i.textBaseline,
        this.contextTextState_ = {
            font: i.font,
            textAlign: _,
            textBaseline: i.textBaseline
        })
    }
    setFillStrokeStyle(i, s) {
        if (!i)
            this.fillState_ = null;
        else {
            const a = i.getColor();
            this.fillState_ = {
                fillStyle: asColorLike(a || defaultFillStyle)
            }
        }
        if (!s)
            this.strokeState_ = null;
        else {
            const a = s.getColor()
              , _ = s.getLineCap()
              , $ = s.getLineDash()
              , _e = s.getLineDashOffset()
              , tt = s.getLineJoin()
              , nt = s.getWidth()
              , rt = s.getMiterLimit()
              , ot = $ || defaultLineDash;
            this.strokeState_ = {
                lineCap: _ !== void 0 ? _ : defaultLineCap,
                lineDash: this.pixelRatio_ === 1 ? ot : ot.map(et => et * this.pixelRatio_),
                lineDashOffset: (_e || defaultLineDashOffset) * this.pixelRatio_,
                lineJoin: tt !== void 0 ? tt : defaultLineJoin,
                lineWidth: (nt !== void 0 ? nt : defaultLineWidth) * this.pixelRatio_,
                miterLimit: rt !== void 0 ? rt : defaultMiterLimit,
                strokeStyle: asColorLike(a || defaultStrokeStyle)
            }
        }
    }
    setImageStyle(i) {
        let s;
        if (!i || !(s = i.getSize())) {
            this.image_ = null;
            return
        }
        const a = i.getPixelRatio(this.pixelRatio_)
          , _ = i.getAnchor()
          , $ = i.getOrigin();
        this.image_ = i.getImage(this.pixelRatio_),
        this.imageAnchorX_ = _[0] * a,
        this.imageAnchorY_ = _[1] * a,
        this.imageHeight_ = s[1] * a,
        this.imageOpacity_ = i.getOpacity(),
        this.imageOriginX_ = $[0],
        this.imageOriginY_ = $[1],
        this.imageRotateWithView_ = i.getRotateWithView(),
        this.imageRotation_ = i.getRotation();
        const _e = i.getScaleArray();
        this.imageScale_ = [_e[0] * this.pixelRatio_ / a, _e[1] * this.pixelRatio_ / a],
        this.imageWidth_ = s[0] * a
    }
    setTextStyle(i) {
        if (!i)
            this.text_ = "";
        else {
            const s = i.getFill();
            if (!s)
                this.textFillState_ = null;
            else {
                const it = s.getColor();
                this.textFillState_ = {
                    fillStyle: asColorLike(it || defaultFillStyle)
                }
            }
            const a = i.getStroke();
            if (!a)
                this.textStrokeState_ = null;
            else {
                const it = a.getColor()
                  , st = a.getLineCap()
                  , at = a.getLineDash()
                  , lt = a.getLineDashOffset()
                  , ct = a.getLineJoin()
                  , ut = a.getWidth()
                  , dt = a.getMiterLimit();
                this.textStrokeState_ = {
                    lineCap: st !== void 0 ? st : defaultLineCap,
                    lineDash: at || defaultLineDash,
                    lineDashOffset: lt || defaultLineDashOffset,
                    lineJoin: ct !== void 0 ? ct : defaultLineJoin,
                    lineWidth: ut !== void 0 ? ut : defaultLineWidth,
                    miterLimit: dt !== void 0 ? dt : defaultMiterLimit,
                    strokeStyle: asColorLike(it || defaultStrokeStyle)
                }
            }
            const _ = i.getFont()
              , $ = i.getOffsetX()
              , _e = i.getOffsetY()
              , tt = i.getRotateWithView()
              , nt = i.getRotation()
              , rt = i.getScaleArray()
              , ot = i.getText()
              , et = i.getTextAlign()
              , j = i.getTextBaseline();
            this.textState_ = {
                font: _ !== void 0 ? _ : defaultFont,
                textAlign: et !== void 0 ? et : defaultTextAlign,
                textBaseline: j !== void 0 ? j : defaultTextBaseline
            },
            this.text_ = ot !== void 0 ? Array.isArray(ot) ? ot.reduce( (it, st, at) => it += at % 2 ? " " : st, "") : ot : "",
            this.textOffsetX_ = $ !== void 0 ? this.pixelRatio_ * $ : 0,
            this.textOffsetY_ = _e !== void 0 ? this.pixelRatio_ * _e : 0,
            this.textRotateWithView_ = tt !== void 0 ? tt : !1,
            this.textRotation_ = nt !== void 0 ? nt : 0,
            this.textScale_ = [this.pixelRatio_ * rt[0], this.pixelRatio_ * rt[1]]
        }
    }
}
const CanvasImmediateRenderer$1 = CanvasImmediateRenderer
  , HIT_DETECT_RESOLUTION = .5;
function createHitDetectionImageData(o, i, s, a, _, $, _e) {
    const tt = o[0] * HIT_DETECT_RESOLUTION
      , nt = o[1] * HIT_DETECT_RESOLUTION
      , rt = createCanvasContext2D(tt, nt);
    rt.imageSmoothingEnabled = !1;
    const ot = rt.canvas
      , et = new CanvasImmediateRenderer$1(rt,HIT_DETECT_RESOLUTION,_,null,_e)
      , j = s.length
      , it = Math.floor((256 * 256 * 256 - 1) / j)
      , st = {};
    for (let lt = 1; lt <= j; ++lt) {
        const ct = s[lt - 1]
          , ut = ct.getStyleFunction() || a;
        if (!ut)
            continue;
        let dt = ut(ct, $);
        if (!dt)
            continue;
        Array.isArray(dt) || (dt = [dt]);
        const ht = (lt * it).toString(16).padStart(7, "#00000");
        for (let pt = 0, gt = dt.length; pt < gt; ++pt) {
            const _t = dt[pt]
              , mt = _t.getGeometryFunction()(ct);
            if (!mt || !intersects$1(_, mt.getExtent()))
                continue;
            const yt = _t.clone()
              , bt = yt.getFill();
            bt && bt.setColor(ht);
            const vt = yt.getStroke();
            vt && (vt.setColor(ht),
            vt.setLineDash(null)),
            yt.setText(void 0);
            const wt = _t.getImage();
            if (wt) {
                const Pt = wt.getImageSize();
                if (!Pt)
                    continue;
                const Rt = createCanvasContext2D(Pt[0], Pt[1], void 0, {
                    alpha: !1
                })
                  , At = Rt.canvas;
                Rt.fillStyle = ht,
                Rt.fillRect(0, 0, At.width, At.height),
                yt.setImage(new Icon$1({
                    img: At,
                    anchor: wt.getAnchor(),
                    anchorXUnits: "pixels",
                    anchorYUnits: "pixels",
                    offset: wt.getOrigin(),
                    opacity: 1,
                    size: wt.getSize(),
                    scale: wt.getScale(),
                    rotation: wt.getRotation(),
                    rotateWithView: wt.getRotateWithView()
                }))
            }
            const Tt = yt.getZIndex() || 0;
            let $t = st[Tt];
            $t || ($t = {},
            st[Tt] = $t,
            $t.Polygon = [],
            $t.Circle = [],
            $t.LineString = [],
            $t.Point = []);
            const Et = mt.getType();
            if (Et === "GeometryCollection") {
                const Pt = mt.getGeometriesArrayRecursive();
                for (let Rt = 0, At = Pt.length; Rt < At; ++Rt) {
                    const Mt = Pt[Rt];
                    $t[Mt.getType().replace("Multi", "")].push(Mt, yt)
                }
            } else
                $t[Et.replace("Multi", "")].push(mt, yt)
        }
    }
    const at = Object.keys(st).map(Number).sort(ascending);
    for (let lt = 0, ct = at.length; lt < ct; ++lt) {
        const ut = st[at[lt]];
        for (const dt in ut) {
            const ft = ut[dt];
            for (let ht = 0, pt = ft.length; ht < pt; ht += 2) {
                et.setStyle(ft[ht + 1]);
                for (let gt = 0, _t = i.length; gt < _t; ++gt)
                    et.setTransform(i[gt]),
                    et.drawGeometry(ft[ht])
            }
        }
    }
    return rt.getImageData(0, 0, ot.width, ot.height)
}
function hitDetect(o, i, s) {
    const a = [];
    if (s) {
        const _ = Math.floor(Math.round(o[0]) * HIT_DETECT_RESOLUTION)
          , $ = Math.floor(Math.round(o[1]) * HIT_DETECT_RESOLUTION)
          , _e = (clamp(_, 0, s.width - 1) + clamp($, 0, s.height - 1) * s.width) * 4
          , tt = s.data[_e]
          , nt = s.data[_e + 1]
          , ot = s.data[_e + 2] + 256 * (nt + 256 * tt)
          , et = Math.floor((256 * 256 * 256 - 1) / i.length);
        ot && ot % et === 0 && a.push(i[ot / et - 1])
    }
    return a
}
const SIMPLIFY_TOLERANCE = .5
  , GEOMETRY_RENDERERS = {
    Point: renderPointGeometry,
    LineString: renderLineStringGeometry,
    Polygon: renderPolygonGeometry,
    MultiPoint: renderMultiPointGeometry,
    MultiLineString: renderMultiLineStringGeometry,
    MultiPolygon: renderMultiPolygonGeometry,
    GeometryCollection: renderGeometryCollectionGeometry,
    Circle: renderCircleGeometry
};
function defaultOrder(o, i) {
    return parseInt(getUid(o), 10) - parseInt(getUid(i), 10)
}
function getSquaredTolerance(o, i) {
    const s = getTolerance(o, i);
    return s * s
}
function getTolerance(o, i) {
    return SIMPLIFY_TOLERANCE * o / i
}
function renderCircleGeometry(o, i, s, a, _) {
    const $ = s.getFill()
      , _e = s.getStroke();
    if ($ || _e) {
        const nt = o.getBuilder(s.getZIndex(), "Circle");
        nt.setFillStrokeStyle($, _e),
        nt.drawCircle(i, a)
    }
    const tt = s.getText();
    if (tt && tt.getText()) {
        const nt = (_ || o).getBuilder(s.getZIndex(), "Text");
        nt.setTextStyle(tt),
        nt.drawText(i, a)
    }
}
function renderFeature(o, i, s, a, _, $, _e) {
    let tt = !1;
    const nt = s.getImage();
    if (nt) {
        const rt = nt.getImageState();
        rt == ImageState.LOADED || rt == ImageState.ERROR ? nt.unlistenImageChange(_) : (rt == ImageState.IDLE && nt.load(),
        nt.listenImageChange(_),
        tt = !0)
    }
    return renderFeatureInternal(o, i, s, a, $, _e),
    tt
}
function renderFeatureInternal(o, i, s, a, _, $) {
    const _e = s.getGeometryFunction()(i);
    if (!_e)
        return;
    const tt = _e.simplifyTransformed(a, _);
    if (s.getRenderer())
        renderGeometry(o, tt, s, i);
    else {
        const rt = GEOMETRY_RENDERERS[tt.getType()];
        rt(o, tt, s, i, $)
    }
}
function renderGeometry(o, i, s, a) {
    if (i.getType() == "GeometryCollection") {
        const $ = i.getGeometries();
        for (let _e = 0, tt = $.length; _e < tt; ++_e)
            renderGeometry(o, $[_e], s, a);
        return
    }
    o.getBuilder(s.getZIndex(), "Default").drawCustom(i, a, s.getRenderer(), s.getHitDetectionRenderer())
}
function renderGeometryCollectionGeometry(o, i, s, a, _) {
    const $ = i.getGeometriesArray();
    let _e, tt;
    for (_e = 0,
    tt = $.length; _e < tt; ++_e) {
        const nt = GEOMETRY_RENDERERS[$[_e].getType()];
        nt(o, $[_e], s, a, _)
    }
}
function renderLineStringGeometry(o, i, s, a, _) {
    const $ = s.getStroke();
    if ($) {
        const tt = o.getBuilder(s.getZIndex(), "LineString");
        tt.setFillStrokeStyle(null, $),
        tt.drawLineString(i, a)
    }
    const _e = s.getText();
    if (_e && _e.getText()) {
        const tt = (_ || o).getBuilder(s.getZIndex(), "Text");
        tt.setTextStyle(_e),
        tt.drawText(i, a)
    }
}
function renderMultiLineStringGeometry(o, i, s, a, _) {
    const $ = s.getStroke();
    if ($) {
        const tt = o.getBuilder(s.getZIndex(), "LineString");
        tt.setFillStrokeStyle(null, $),
        tt.drawMultiLineString(i, a)
    }
    const _e = s.getText();
    if (_e && _e.getText()) {
        const tt = (_ || o).getBuilder(s.getZIndex(), "Text");
        tt.setTextStyle(_e),
        tt.drawText(i, a)
    }
}
function renderMultiPolygonGeometry(o, i, s, a, _) {
    const $ = s.getFill()
      , _e = s.getStroke();
    if (_e || $) {
        const nt = o.getBuilder(s.getZIndex(), "Polygon");
        nt.setFillStrokeStyle($, _e),
        nt.drawMultiPolygon(i, a)
    }
    const tt = s.getText();
    if (tt && tt.getText()) {
        const nt = (_ || o).getBuilder(s.getZIndex(), "Text");
        nt.setTextStyle(tt),
        nt.drawText(i, a)
    }
}
function renderPointGeometry(o, i, s, a, _) {
    const $ = s.getImage()
      , _e = s.getText();
    let tt;
    if ($) {
        if ($.getImageState() != ImageState.LOADED)
            return;
        let nt = o;
        if (_) {
            const ot = $.getDeclutterMode();
            if (ot !== "none")
                if (nt = _,
                ot === "obstacle") {
                    const et = o.getBuilder(s.getZIndex(), "Image");
                    et.setImageStyle($, tt),
                    et.drawPoint(i, a)
                } else
                    _e && _e.getText() && (tt = {})
        }
        const rt = nt.getBuilder(s.getZIndex(), "Image");
        rt.setImageStyle($, tt),
        rt.drawPoint(i, a)
    }
    if (_e && _e.getText()) {
        let nt = o;
        _ && (nt = _);
        const rt = nt.getBuilder(s.getZIndex(), "Text");
        rt.setTextStyle(_e, tt),
        rt.drawText(i, a)
    }
}
function renderMultiPointGeometry(o, i, s, a, _) {
    const $ = s.getImage()
      , _e = s.getText();
    let tt;
    if ($) {
        if ($.getImageState() != ImageState.LOADED)
            return;
        let nt = o;
        if (_) {
            const ot = $.getDeclutterMode();
            if (ot !== "none")
                if (nt = _,
                ot === "obstacle") {
                    const et = o.getBuilder(s.getZIndex(), "Image");
                    et.setImageStyle($, tt),
                    et.drawMultiPoint(i, a)
                } else
                    _e && _e.getText() && (tt = {})
        }
        const rt = nt.getBuilder(s.getZIndex(), "Image");
        rt.setImageStyle($, tt),
        rt.drawMultiPoint(i, a)
    }
    if (_e && _e.getText()) {
        let nt = o;
        _ && (nt = _);
        const rt = nt.getBuilder(s.getZIndex(), "Text");
        rt.setTextStyle(_e, tt),
        rt.drawText(i, a)
    }
}
function renderPolygonGeometry(o, i, s, a, _) {
    const $ = s.getFill()
      , _e = s.getStroke();
    if ($ || _e) {
        const nt = o.getBuilder(s.getZIndex(), "Polygon");
        nt.setFillStrokeStyle($, _e),
        nt.drawPolygon(i, a)
    }
    const tt = s.getText();
    if (tt && tt.getText()) {
        const nt = (_ || o).getBuilder(s.getZIndex(), "Text");
        nt.setTextStyle(tt),
        nt.drawText(i, a)
    }
}
class CanvasVectorLayerRenderer extends CanvasLayerRenderer$1 {
    constructor(i) {
        super(i),
        this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this),
        this.animatingOrInteracting_,
        this.hitDetectionImageData_ = null,
        this.renderedFeatures_ = null,
        this.renderedRevision_ = -1,
        this.renderedResolution_ = NaN,
        this.renderedExtent_ = createEmpty(),
        this.wrappedRenderedExtent_ = createEmpty(),
        this.renderedRotation_,
        this.renderedCenter_ = null,
        this.renderedProjection_ = null,
        this.renderedRenderOrder_ = null,
        this.replayGroup_ = null,
        this.replayGroupChanged = !0,
        this.declutterExecutorGroup = null,
        this.clipping = !0,
        this.compositionContext_ = null,
        this.opacity_ = 1
    }
    renderWorlds(i, s, a) {
        const _ = s.extent
          , $ = s.viewState
          , _e = $.center
          , tt = $.resolution
          , nt = $.projection
          , rt = $.rotation
          , ot = nt.getExtent()
          , et = this.getLayer().getSource()
          , j = s.pixelRatio
          , it = s.viewHints
          , st = !(it[ViewHint.ANIMATING] || it[ViewHint.INTERACTING])
          , at = this.compositionContext_
          , lt = Math.round(s.size[0] * j)
          , ct = Math.round(s.size[1] * j)
          , ut = et.getWrapX() && nt.canWrapX()
          , dt = ut ? getWidth(ot) : null
          , ft = ut ? Math.ceil((_[2] - ot[2]) / dt) + 1 : 1;
        let ht = ut ? Math.floor((_[0] - ot[0]) / dt) : 0;
        do {
            const pt = this.getRenderTransform(_e, tt, rt, j, lt, ct, ht * dt);
            i.execute(at, 1, pt, rt, st, void 0, a)
        } while (++ht < ft)
    }
    setupCompositionContext_() {
        if (this.opacity_ !== 1) {
            const i = createCanvasContext2D(this.context.canvas.width, this.context.canvas.height, canvasPool$1);
            this.compositionContext_ = i
        } else
            this.compositionContext_ = this.context
    }
    releaseCompositionContext_() {
        if (this.opacity_ !== 1) {
            const i = this.context.globalAlpha;
            this.context.globalAlpha = this.opacity_,
            this.context.drawImage(this.compositionContext_.canvas, 0, 0),
            this.context.globalAlpha = i,
            releaseCanvas$1(this.compositionContext_),
            canvasPool$1.push(this.compositionContext_.canvas),
            this.compositionContext_ = null
        }
    }
    renderDeclutter(i) {
        this.declutterExecutorGroup && (this.setupCompositionContext_(),
        this.renderWorlds(this.declutterExecutorGroup, i, i.declutterTree),
        this.releaseCompositionContext_())
    }
    renderFrame(i, s) {
        const a = i.pixelRatio
          , _ = i.layerStatesArray[i.layerIndex];
        makeScale(this.pixelTransform, 1 / a, 1 / a),
        makeInverse(this.inversePixelTransform, this.pixelTransform);
        const $ = toString$1(this.pixelTransform);
        this.useContainer(s, $, this.getBackground(i));
        const _e = this.context
          , tt = _e.canvas
          , nt = this.replayGroup_
          , rt = this.declutterExecutorGroup;
        let ot = nt && !nt.isEmpty() || rt && !rt.isEmpty();
        if (!ot && !(this.getLayer().hasListener(RenderEventType.PRERENDER) || this.getLayer().hasListener(RenderEventType.POSTRENDER)))
            return null;
        const et = Math.round(i.size[0] * a)
          , j = Math.round(i.size[1] * a);
        tt.width != et || tt.height != j ? (tt.width = et,
        tt.height = j,
        tt.style.transform !== $ && (tt.style.transform = $)) : this.containerReused || _e.clearRect(0, 0, et, j),
        this.preRender(_e, i);
        const it = i.viewState;
        it.projection,
        this.opacity_ = _.opacity,
        this.setupCompositionContext_();
        let st = !1;
        if (ot && _.extent && this.clipping) {
            const at = fromUserExtent(_.extent);
            ot = intersects$1(at, i.extent),
            st = ot && !containsExtent(at, i.extent),
            st && this.clipUnrotated(this.compositionContext_, i, at)
        }
        return ot && this.renderWorlds(nt, i),
        st && this.compositionContext_.restore(),
        this.releaseCompositionContext_(),
        this.postRender(_e, i),
        this.renderedRotation_ !== it.rotation && (this.renderedRotation_ = it.rotation,
        this.hitDetectionImageData_ = null),
        this.container
    }
    getFeatures(i) {
        return new Promise(s => {
            if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
                const a = [this.context.canvas.width, this.context.canvas.height];
                apply(this.pixelTransform, a);
                const _ = this.renderedCenter_
                  , $ = this.renderedResolution_
                  , _e = this.renderedRotation_
                  , tt = this.renderedProjection_
                  , nt = this.wrappedRenderedExtent_
                  , rt = this.getLayer()
                  , ot = []
                  , et = a[0] * HIT_DETECT_RESOLUTION
                  , j = a[1] * HIT_DETECT_RESOLUTION;
                ot.push(this.getRenderTransform(_, $, _e, HIT_DETECT_RESOLUTION, et, j, 0).slice());
                const it = rt.getSource()
                  , st = tt.getExtent();
                if (it.getWrapX() && tt.canWrapX() && !containsExtent(st, nt)) {
                    let at = nt[0];
                    const lt = getWidth(st);
                    let ct = 0, ut;
                    for (; at < st[0]; )
                        --ct,
                        ut = lt * ct,
                        ot.push(this.getRenderTransform(_, $, _e, HIT_DETECT_RESOLUTION, et, j, ut).slice()),
                        at += lt;
                    for (ct = 0,
                    at = nt[2]; at > st[2]; )
                        ++ct,
                        ut = lt * ct,
                        ot.push(this.getRenderTransform(_, $, _e, HIT_DETECT_RESOLUTION, et, j, ut).slice()),
                        at -= lt
                }
                this.hitDetectionImageData_ = createHitDetectionImageData(a, ot, this.renderedFeatures_, rt.getStyleFunction(), nt, $, _e)
            }
            s(hitDetect(i, this.renderedFeatures_, this.hitDetectionImageData_))
        }
        )
    }
    forEachFeatureAtCoordinate(i, s, a, _, $) {
        if (!this.replayGroup_)
            return;
        const _e = s.viewState.resolution
          , tt = s.viewState.rotation
          , nt = this.getLayer()
          , rt = {}
          , ot = function(it, st, at) {
            const lt = getUid(it)
              , ct = rt[lt];
            if (ct) {
                if (ct !== !0 && at < ct.distanceSq) {
                    if (at === 0)
                        return rt[lt] = !0,
                        $.splice($.lastIndexOf(ct), 1),
                        _(it, nt, st);
                    ct.geometry = st,
                    ct.distanceSq = at
                }
            } else {
                if (at === 0)
                    return rt[lt] = !0,
                    _(it, nt, st);
                $.push(rt[lt] = {
                    feature: it,
                    layer: nt,
                    geometry: st,
                    distanceSq: at,
                    callback: _
                })
            }
        };
        let et;
        const j = [this.replayGroup_];
        return this.declutterExecutorGroup && j.push(this.declutterExecutorGroup),
        j.some(it => et = it.forEachFeatureAtCoordinate(i, _e, tt, a, ot, it === this.declutterExecutorGroup && s.declutterTree ? s.declutterTree.all().map(st => st.value) : null)),
        et
    }
    handleFontsChanged() {
        const i = this.getLayer();
        i.getVisible() && this.replayGroup_ && i.changed()
    }
    handleStyleImageChange_(i) {
        this.renderIfReadyAndVisible()
    }
    prepareFrame(i) {
        const s = this.getLayer()
          , a = s.getSource();
        if (!a)
            return !1;
        const _ = i.viewHints[ViewHint.ANIMATING]
          , $ = i.viewHints[ViewHint.INTERACTING]
          , _e = s.getUpdateWhileAnimating()
          , tt = s.getUpdateWhileInteracting();
        if (this.ready && !_e && _ || !tt && $)
            return this.animatingOrInteracting_ = !0,
            !0;
        this.animatingOrInteracting_ = !1;
        const nt = i.extent
          , rt = i.viewState
          , ot = rt.projection
          , et = rt.resolution
          , j = i.pixelRatio
          , it = s.getRevision()
          , st = s.getRenderBuffer();
        let at = s.getRenderOrder();
        at === void 0 && (at = defaultOrder);
        const lt = rt.center.slice()
          , ct = buffer$1(nt, st * et)
          , ut = ct.slice()
          , dt = [ct.slice()]
          , ft = ot.getExtent();
        if (a.getWrapX() && ot.canWrapX() && !containsExtent(ft, i.extent)) {
            const $t = getWidth(ft)
              , Et = Math.max(getWidth(ct) / 2, $t);
            ct[0] = ft[0] - Et,
            ct[2] = ft[2] + Et,
            wrapX$1(lt, ot);
            const Pt = wrapX$2(dt[0], ot);
            Pt[0] < ft[0] && Pt[2] < ft[2] ? dt.push([Pt[0] + $t, Pt[1], Pt[2] + $t, Pt[3]]) : Pt[0] > ft[0] && Pt[2] > ft[2] && dt.push([Pt[0] - $t, Pt[1], Pt[2] - $t, Pt[3]])
        }
        if (this.ready && this.renderedResolution_ == et && this.renderedRevision_ == it && this.renderedRenderOrder_ == at && containsExtent(this.wrappedRenderedExtent_, ct))
            return equals$2(this.renderedExtent_, ut) || (this.hitDetectionImageData_ = null,
            this.renderedExtent_ = ut),
            this.renderedCenter_ = lt,
            this.replayGroupChanged = !1,
            !0;
        this.replayGroup_ = null;
        const ht = new CanvasBuilderGroup(getTolerance(et, j),ct,et,j);
        let pt;
        this.getLayer().getDeclutter() && (pt = new CanvasBuilderGroup(getTolerance(et, j),ct,et,j));
        let gt;
        for (let $t = 0, Et = dt.length; $t < Et; ++$t)
            a.loadFeatures(dt[$t], et, ot);
        const _t = getSquaredTolerance(et, j);
        let mt = !0;
        const yt = $t => {
            let Et;
            const Pt = $t.getStyleFunction() || s.getStyleFunction();
            if (Pt && (Et = Pt($t, et)),
            Et) {
                const Rt = this.renderFeature($t, _t, Et, ht, gt, pt);
                mt = mt && !Rt
            }
        }
          , bt = toUserExtent(ct)
          , vt = a.getFeaturesInExtent(bt);
        at && vt.sort(at);
        for (let $t = 0, Et = vt.length; $t < Et; ++$t)
            yt(vt[$t]);
        this.renderedFeatures_ = vt,
        this.ready = mt;
        const wt = ht.finish()
          , Tt = new ExecutorGroup$1(ct,et,j,a.getOverlaps(),wt,s.getRenderBuffer());
        return pt && (this.declutterExecutorGroup = new ExecutorGroup$1(ct,et,j,a.getOverlaps(),pt.finish(),s.getRenderBuffer())),
        this.renderedResolution_ = et,
        this.renderedRevision_ = it,
        this.renderedRenderOrder_ = at,
        this.renderedExtent_ = ut,
        this.wrappedRenderedExtent_ = ct,
        this.renderedCenter_ = lt,
        this.renderedProjection_ = ot,
        this.replayGroup_ = Tt,
        this.hitDetectionImageData_ = null,
        this.replayGroupChanged = !0,
        !0
    }
    renderFeature(i, s, a, _, $, _e) {
        if (!a)
            return !1;
        let tt = !1;
        if (Array.isArray(a))
            for (let nt = 0, rt = a.length; nt < rt; ++nt)
                tt = renderFeature(_, i, a[nt], s, this.boundHandleStyleImageChange_, $, _e) || tt;
        else
            tt = renderFeature(_, i, a, s, this.boundHandleStyleImageChange_, $, _e);
        return tt
    }
}
const CanvasVectorLayerRenderer$1 = CanvasVectorLayerRenderer;
class VectorLayer extends BaseVectorLayer$1 {
    constructor(i) {
        super(i)
    }
    createRenderer() {
        return new CanvasVectorLayerRenderer$1(this)
    }
}
const VectorLayer$1 = VectorLayer;
class RBush {
    constructor(i) {
        this.rbush_ = new RBush$2(i),
        this.items_ = {}
    }
    insert(i, s) {
        const a = {
            minX: i[0],
            minY: i[1],
            maxX: i[2],
            maxY: i[3],
            value: s
        };
        this.rbush_.insert(a),
        this.items_[getUid(s)] = a
    }
    load(i, s) {
        const a = new Array(s.length);
        for (let _ = 0, $ = s.length; _ < $; _++) {
            const _e = i[_]
              , tt = s[_]
              , nt = {
                minX: _e[0],
                minY: _e[1],
                maxX: _e[2],
                maxY: _e[3],
                value: tt
            };
            a[_] = nt,
            this.items_[getUid(tt)] = nt
        }
        this.rbush_.load(a)
    }
    remove(i) {
        const s = getUid(i)
          , a = this.items_[s];
        return delete this.items_[s],
        this.rbush_.remove(a) !== null
    }
    update(i, s) {
        const a = this.items_[getUid(s)]
          , _ = [a.minX, a.minY, a.maxX, a.maxY];
        equals$1(_, i) || (this.remove(s),
        this.insert(i, s))
    }
    getAll() {
        return this.rbush_.all().map(function(s) {
            return s.value
        })
    }
    getInExtent(i) {
        const s = {
            minX: i[0],
            minY: i[1],
            maxX: i[2],
            maxY: i[3]
        };
        return this.rbush_.search(s).map(function(_) {
            return _.value
        })
    }
    forEach(i) {
        return this.forEach_(this.getAll(), i)
    }
    forEachInExtent(i, s) {
        return this.forEach_(this.getInExtent(i), s)
    }
    forEach_(i, s) {
        let a;
        for (let _ = 0, $ = i.length; _ < $; _++)
            if (a = s(i[_]),
            a)
                return a;
        return a
    }
    isEmpty() {
        return isEmpty$1(this.items_)
    }
    clear() {
        this.rbush_.clear(),
        this.items_ = {}
    }
    getExtent(i) {
        const s = this.rbush_.toJSON();
        return createOrUpdate$2(s.minX, s.minY, s.maxX, s.maxY, i)
    }
    concat(i) {
        this.rbush_.load(i.rbush_.all());
        for (const s in i.items_)
            this.items_[s] = i.items_[s]
    }
}
const RBush$1 = RBush;
class Source extends BaseObject$1 {
    constructor(i) {
        super(),
        this.projection = get$1(i.projection),
        this.attributions_ = adaptAttributions(i.attributions),
        this.attributionsCollapsible_ = i.attributionsCollapsible !== void 0 ? i.attributionsCollapsible : !0,
        this.loading = !1,
        this.state_ = i.state !== void 0 ? i.state : "ready",
        this.wrapX_ = i.wrapX !== void 0 ? i.wrapX : !1,
        this.interpolate_ = !!i.interpolate,
        this.viewResolver = null,
        this.viewRejector = null;
        const s = this;
        this.viewPromise_ = new Promise(function(a, _) {
            s.viewResolver = a,
            s.viewRejector = _
        }
        )
    }
    getAttributions() {
        return this.attributions_
    }
    getAttributionsCollapsible() {
        return this.attributionsCollapsible_
    }
    getProjection() {
        return this.projection
    }
    getResolutions(i) {
        return null
    }
    getView() {
        return this.viewPromise_
    }
    getState() {
        return this.state_
    }
    getWrapX() {
        return this.wrapX_
    }
    getInterpolate() {
        return this.interpolate_
    }
    refresh() {
        this.changed()
    }
    setAttributions(i) {
        this.attributions_ = adaptAttributions(i),
        this.changed()
    }
    setState(i) {
        this.state_ = i,
        this.changed()
    }
}
function adaptAttributions(o) {
    return o ? Array.isArray(o) ? function(i) {
        return o
    }
    : typeof o == "function" ? o : function(i) {
        return [o]
    }
    : null
}
const Source$1 = Source
  , VectorEventType = {
    ADDFEATURE: "addfeature",
    CHANGEFEATURE: "changefeature",
    CLEAR: "clear",
    REMOVEFEATURE: "removefeature",
    FEATURESLOADSTART: "featuresloadstart",
    FEATURESLOADEND: "featuresloadend",
    FEATURESLOADERROR: "featuresloaderror"
};
function all(o, i) {
    return [[-1 / 0, -1 / 0, 1 / 0, 1 / 0]]
}
let withCredentials = !1;
function loadFeaturesXhr(o, i, s, a, _, $, _e) {
    const tt = new XMLHttpRequest;
    tt.open("GET", typeof o == "function" ? o(s, a, _) : o, !0),
    i.getType() == "arraybuffer" && (tt.responseType = "arraybuffer"),
    tt.withCredentials = withCredentials,
    tt.onload = function(nt) {
        if (!tt.status || tt.status >= 200 && tt.status < 300) {
            const rt = i.getType();
            let ot;
            rt == "json" || rt == "text" ? ot = tt.responseText : rt == "xml" ? (ot = tt.responseXML,
            ot || (ot = new DOMParser().parseFromString(tt.responseText, "application/xml"))) : rt == "arraybuffer" && (ot = tt.response),
            ot ? $(i.readFeatures(ot, {
                extent: s,
                featureProjection: _
            }), i.readProjection(ot)) : _e()
        } else
            _e()
    }
    ,
    tt.onerror = _e,
    tt.send()
}
function xhr(o, i) {
    return function(s, a, _, $, _e) {
        const tt = this;
        loadFeaturesXhr(o, i, s, a, _, function(nt, rt) {
            tt.addFeatures(nt),
            $ !== void 0 && $(nt)
        }, _e || VOID)
    }
}
class VectorSourceEvent extends Event$1 {
    constructor(i, s, a) {
        super(i),
        this.feature = s,
        this.features = a
    }
}
class VectorSource extends Source$1 {
    constructor(i) {
        i = i || {},
        super({
            attributions: i.attributions,
            interpolate: !0,
            projection: void 0,
            state: "ready",
            wrapX: i.wrapX !== void 0 ? i.wrapX : !0
        }),
        this.on,
        this.once,
        this.un,
        this.loader_ = VOID,
        this.format_ = i.format,
        this.overlaps_ = i.overlaps === void 0 ? !0 : i.overlaps,
        this.url_ = i.url,
        i.loader !== void 0 ? this.loader_ = i.loader : this.url_ !== void 0 && (assert(this.format_, "`format` must be set when `url` is set"),
        this.loader_ = xhr(this.url_, this.format_)),
        this.strategy_ = i.strategy !== void 0 ? i.strategy : all;
        const s = i.useSpatialIndex !== void 0 ? i.useSpatialIndex : !0;
        this.featuresRtree_ = s ? new RBush$1 : null,
        this.loadedExtentsRtree_ = new RBush$1,
        this.loadingExtentsCount_ = 0,
        this.nullGeometryFeatures_ = {},
        this.idIndex_ = {},
        this.uidIndex_ = {},
        this.featureChangeKeys_ = {},
        this.featuresCollection_ = null;
        let a, _;
        Array.isArray(i.features) ? _ = i.features : i.features && (a = i.features,
        _ = a.getArray()),
        !s && a === void 0 && (a = new Collection$1(_)),
        _ !== void 0 && this.addFeaturesInternal(_),
        a !== void 0 && this.bindFeaturesCollection_(a)
    }
    addFeature(i) {
        this.addFeatureInternal(i),
        this.changed()
    }
    addFeatureInternal(i) {
        const s = getUid(i);
        if (!this.addToIndex_(s, i)) {
            this.featuresCollection_ && this.featuresCollection_.remove(i);
            return
        }
        this.setupChangeEvents_(s, i);
        const a = i.getGeometry();
        if (a) {
            const _ = a.getExtent();
            this.featuresRtree_ && this.featuresRtree_.insert(_, i)
        } else
            this.nullGeometryFeatures_[s] = i;
        this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE,i))
    }
    setupChangeEvents_(i, s) {
        this.featureChangeKeys_[i] = [listen(s, EventType.CHANGE, this.handleFeatureChange_, this), listen(s, ObjectEventType.PROPERTYCHANGE, this.handleFeatureChange_, this)]
    }
    addToIndex_(i, s) {
        let a = !0;
        const _ = s.getId();
        return _ !== void 0 && (_.toString()in this.idIndex_ ? a = !1 : this.idIndex_[_.toString()] = s),
        a && (assert(!(i in this.uidIndex_), "The passed `feature` was already added to the source"),
        this.uidIndex_[i] = s),
        a
    }
    addFeatures(i) {
        this.addFeaturesInternal(i),
        this.changed()
    }
    addFeaturesInternal(i) {
        const s = []
          , a = []
          , _ = [];
        for (let $ = 0, _e = i.length; $ < _e; $++) {
            const tt = i[$]
              , nt = getUid(tt);
            this.addToIndex_(nt, tt) && a.push(tt)
        }
        for (let $ = 0, _e = a.length; $ < _e; $++) {
            const tt = a[$]
              , nt = getUid(tt);
            this.setupChangeEvents_(nt, tt);
            const rt = tt.getGeometry();
            if (rt) {
                const ot = rt.getExtent();
                s.push(ot),
                _.push(tt)
            } else
                this.nullGeometryFeatures_[nt] = tt
        }
        if (this.featuresRtree_ && this.featuresRtree_.load(s, _),
        this.hasListener(VectorEventType.ADDFEATURE))
            for (let $ = 0, _e = a.length; $ < _e; $++)
                this.dispatchEvent(new VectorSourceEvent(VectorEventType.ADDFEATURE,a[$]))
    }
    bindFeaturesCollection_(i) {
        let s = !1;
        this.addEventListener(VectorEventType.ADDFEATURE, function(a) {
            s || (s = !0,
            i.push(a.feature),
            s = !1)
        }),
        this.addEventListener(VectorEventType.REMOVEFEATURE, function(a) {
            s || (s = !0,
            i.remove(a.feature),
            s = !1)
        }),
        i.addEventListener(CollectionEventType.ADD, a => {
            s || (s = !0,
            this.addFeature(a.element),
            s = !1)
        }
        ),
        i.addEventListener(CollectionEventType.REMOVE, a => {
            s || (s = !0,
            this.removeFeature(a.element),
            s = !1)
        }
        ),
        this.featuresCollection_ = i
    }
    clear(i) {
        if (i) {
            for (const a in this.featureChangeKeys_)
                this.featureChangeKeys_[a].forEach(unlistenByKey);
            this.featuresCollection_ || (this.featureChangeKeys_ = {},
            this.idIndex_ = {},
            this.uidIndex_ = {})
        } else if (this.featuresRtree_) {
            const a = _ => {
                this.removeFeatureInternal(_)
            }
            ;
            this.featuresRtree_.forEach(a);
            for (const _ in this.nullGeometryFeatures_)
                this.removeFeatureInternal(this.nullGeometryFeatures_[_])
        }
        this.featuresCollection_ && this.featuresCollection_.clear(),
        this.featuresRtree_ && this.featuresRtree_.clear(),
        this.nullGeometryFeatures_ = {};
        const s = new VectorSourceEvent(VectorEventType.CLEAR);
        this.dispatchEvent(s),
        this.changed()
    }
    forEachFeature(i) {
        if (this.featuresRtree_)
            return this.featuresRtree_.forEach(i);
        this.featuresCollection_ && this.featuresCollection_.forEach(i)
    }
    forEachFeatureAtCoordinateDirect(i, s) {
        const a = [i[0], i[1], i[0], i[1]];
        return this.forEachFeatureInExtent(a, function(_) {
            if (_.getGeometry().intersectsCoordinate(i))
                return s(_)
        })
    }
    forEachFeatureInExtent(i, s) {
        if (this.featuresRtree_)
            return this.featuresRtree_.forEachInExtent(i, s);
        this.featuresCollection_ && this.featuresCollection_.forEach(s)
    }
    forEachFeatureIntersectingExtent(i, s) {
        return this.forEachFeatureInExtent(i, function(a) {
            if (a.getGeometry().intersectsExtent(i)) {
                const $ = s(a);
                if ($)
                    return $
            }
        })
    }
    getFeaturesCollection() {
        return this.featuresCollection_
    }
    getFeatures() {
        let i;
        return this.featuresCollection_ ? i = this.featuresCollection_.getArray().slice(0) : this.featuresRtree_ && (i = this.featuresRtree_.getAll(),
        isEmpty$1(this.nullGeometryFeatures_) || extend$2(i, Object.values(this.nullGeometryFeatures_))),
        i
    }
    getFeaturesAtCoordinate(i) {
        const s = [];
        return this.forEachFeatureAtCoordinateDirect(i, function(a) {
            s.push(a)
        }),
        s
    }
    getFeaturesInExtent(i, s) {
        if (this.featuresRtree_) {
            if (!(s && s.canWrapX() && this.getWrapX()))
                return this.featuresRtree_.getInExtent(i);
            const _ = wrapAndSliceX(i, s);
            return [].concat(..._.map($ => this.featuresRtree_.getInExtent($)))
        }
        return this.featuresCollection_ ? this.featuresCollection_.getArray().slice(0) : []
    }
    getClosestFeatureToCoordinate(i, s) {
        const a = i[0]
          , _ = i[1];
        let $ = null;
        const _e = [NaN, NaN];
        let tt = 1 / 0;
        const nt = [-1 / 0, -1 / 0, 1 / 0, 1 / 0];
        return s = s || TRUE,
        this.featuresRtree_.forEachInExtent(nt, function(rt) {
            if (s(rt)) {
                const ot = rt.getGeometry()
                  , et = tt;
                if (tt = ot.closestPointXY(a, _, _e, tt),
                tt < et) {
                    $ = rt;
                    const j = Math.sqrt(tt);
                    nt[0] = a - j,
                    nt[1] = _ - j,
                    nt[2] = a + j,
                    nt[3] = _ + j
                }
            }
        }),
        $
    }
    getExtent(i) {
        return this.featuresRtree_.getExtent(i)
    }
    getFeatureById(i) {
        const s = this.idIndex_[i.toString()];
        return s !== void 0 ? s : null
    }
    getFeatureByUid(i) {
        const s = this.uidIndex_[i];
        return s !== void 0 ? s : null
    }
    getFormat() {
        return this.format_
    }
    getOverlaps() {
        return this.overlaps_
    }
    getUrl() {
        return this.url_
    }
    handleFeatureChange_(i) {
        const s = i.target
          , a = getUid(s)
          , _ = s.getGeometry();
        if (!_)
            a in this.nullGeometryFeatures_ || (this.featuresRtree_ && this.featuresRtree_.remove(s),
            this.nullGeometryFeatures_[a] = s);
        else {
            const _e = _.getExtent();
            a in this.nullGeometryFeatures_ ? (delete this.nullGeometryFeatures_[a],
            this.featuresRtree_ && this.featuresRtree_.insert(_e, s)) : this.featuresRtree_ && this.featuresRtree_.update(_e, s)
        }
        const $ = s.getId();
        if ($ !== void 0) {
            const _e = $.toString();
            this.idIndex_[_e] !== s && (this.removeFromIdIndex_(s),
            this.idIndex_[_e] = s)
        } else
            this.removeFromIdIndex_(s),
            this.uidIndex_[a] = s;
        this.changed(),
        this.dispatchEvent(new VectorSourceEvent(VectorEventType.CHANGEFEATURE,s))
    }
    hasFeature(i) {
        const s = i.getId();
        return s !== void 0 ? s in this.idIndex_ : getUid(i)in this.uidIndex_
    }
    isEmpty() {
        return this.featuresRtree_ ? this.featuresRtree_.isEmpty() && isEmpty$1(this.nullGeometryFeatures_) : this.featuresCollection_ ? this.featuresCollection_.getLength() === 0 : !0
    }
    loadFeatures(i, s, a) {
        const _ = this.loadedExtentsRtree_
          , $ = this.strategy_(i, s, a);
        for (let _e = 0, tt = $.length; _e < tt; ++_e) {
            const nt = $[_e];
            _.forEachInExtent(nt, function(ot) {
                return containsExtent(ot.extent, nt)
            }) || (++this.loadingExtentsCount_,
            this.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADSTART)),
            this.loader_.call(this, nt, s, a, ot => {
                --this.loadingExtentsCount_,
                this.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADEND,void 0,ot))
            }
            , () => {
                --this.loadingExtentsCount_,
                this.dispatchEvent(new VectorSourceEvent(VectorEventType.FEATURESLOADERROR))
            }
            ),
            _.insert(nt, {
                extent: nt.slice()
            }))
        }
        this.loading = this.loader_.length < 4 ? !1 : this.loadingExtentsCount_ > 0
    }
    refresh() {
        this.clear(!0),
        this.loadedExtentsRtree_.clear(),
        super.refresh()
    }
    removeLoadedExtent(i) {
        const s = this.loadedExtentsRtree_;
        let a;
        s.forEachInExtent(i, function(_) {
            if (equals$1(_.extent, i))
                return a = _,
                !0
        }),
        a && s.remove(a)
    }
    removeFeature(i) {
        if (!i)
            return;
        const s = getUid(i);
        s in this.nullGeometryFeatures_ ? delete this.nullGeometryFeatures_[s] : this.featuresRtree_ && this.featuresRtree_.remove(i),
        this.removeFeatureInternal(i) && this.changed()
    }
    removeFeatureInternal(i) {
        const s = getUid(i)
          , a = this.featureChangeKeys_[s];
        if (!a)
            return;
        a.forEach(unlistenByKey),
        delete this.featureChangeKeys_[s];
        const _ = i.getId();
        return _ !== void 0 && delete this.idIndex_[_.toString()],
        delete this.uidIndex_[s],
        this.dispatchEvent(new VectorSourceEvent(VectorEventType.REMOVEFEATURE,i)),
        i
    }
    removeFromIdIndex_(i) {
        let s = !1;
        for (const a in this.idIndex_)
            if (this.idIndex_[a] === i) {
                delete this.idIndex_[a],
                s = !0;
                break
            }
        return s
    }
    setLoader(i) {
        this.loader_ = i
    }
    setUrl(i) {
        assert(this.format_, "`format` must be set when `url` is set"),
        this.url_ = i,
        this.setLoader(xhr(i, this.format_))
    }
}
const VectorSource$1 = VectorSource
  , DrawEventType = {
    DRAWSTART: "drawstart",
    DRAWEND: "drawend",
    DRAWABORT: "drawabort"
};
class DrawEvent extends Event$1 {
    constructor(i, s) {
        super(i),
        this.feature = s
    }
}
function getTraceTargets(o, i) {
    const s = [];
    for (let a = 0; a < i.length; ++a) {
        const $ = i[a].getGeometry();
        appendGeometryTraceTargets(o, $, s)
    }
    return s
}
function getSquaredDistance(o, i) {
    return squaredDistance$1(o[0], o[1], i[0], i[1])
}
function getCoordinate(o, i) {
    const s = o.length;
    return i < 0 ? o[i + s] : i >= s ? o[i - s] : o[i]
}
function getCumulativeSquaredDistance(o, i, s) {
    let a, _;
    i < s ? (a = i,
    _ = s) : (a = s,
    _ = i);
    const $ = Math.ceil(a)
      , _e = Math.floor(_);
    if ($ > _e) {
        const nt = interpolateCoordinate(o, a)
          , rt = interpolateCoordinate(o, _);
        return getSquaredDistance(nt, rt)
    }
    let tt = 0;
    if (a < $) {
        const nt = interpolateCoordinate(o, a)
          , rt = getCoordinate(o, $);
        tt += getSquaredDistance(nt, rt)
    }
    if (_e < _) {
        const nt = getCoordinate(o, _e)
          , rt = interpolateCoordinate(o, _);
        tt += getSquaredDistance(nt, rt)
    }
    for (let nt = $; nt < _e - 1; ++nt) {
        const rt = getCoordinate(o, nt)
          , ot = getCoordinate(o, nt + 1);
        tt += getSquaredDistance(rt, ot)
    }
    return tt
}
function appendGeometryTraceTargets(o, i, s) {
    if (i instanceof LineString$1) {
        appendTraceTarget(o, i.getCoordinates(), !1, s);
        return
    }
    if (i instanceof MultiLineString$1) {
        const a = i.getCoordinates();
        for (let _ = 0, $ = a.length; _ < $; ++_)
            appendTraceTarget(o, a[_], !1, s);
        return
    }
    if (i instanceof Polygon$1) {
        const a = i.getCoordinates();
        for (let _ = 0, $ = a.length; _ < $; ++_)
            appendTraceTarget(o, a[_], !0, s);
        return
    }
    if (i instanceof MultiPolygon$1) {
        const a = i.getCoordinates();
        for (let _ = 0, $ = a.length; _ < $; ++_) {
            const _e = a[_];
            for (let tt = 0, nt = _e.length; tt < nt; ++tt)
                appendTraceTarget(o, _e[tt], !0, s)
        }
        return
    }
    if (i instanceof GeometryCollection$1) {
        const a = i.getGeometries();
        for (let _ = 0; _ < a.length; ++_)
            appendGeometryTraceTargets(o, a[_], s);
        return
    }
}
const sharedUpdateInfo = {
    index: -1,
    endIndex: NaN
};
function getTraceTargetUpdate(o, i, s, a) {
    const _ = o[0]
      , $ = o[1];
    let _e = 1 / 0
      , tt = -1
      , nt = NaN;
    for (let et = 0; et < i.targets.length; ++et) {
        const j = i.targets[et]
          , it = j.coordinates;
        let st = 1 / 0, at;
        for (let lt = 0; lt < it.length - 1; ++lt) {
            const ct = it[lt]
              , ut = it[lt + 1]
              , dt = getPointSegmentRelationship(_, $, ct, ut);
            dt.squaredDistance < st && (st = dt.squaredDistance,
            at = lt + dt.along)
        }
        st < _e && (_e = st,
        j.ring && i.targetIndex === et && (j.endIndex > j.startIndex ? at < j.startIndex && (at += it.length) : j.endIndex < j.startIndex && at > j.startIndex && (at -= it.length)),
        nt = at,
        tt = et)
    }
    const rt = i.targets[tt];
    let ot = rt.ring;
    if (i.targetIndex === tt && ot) {
        const et = interpolateCoordinate(rt.coordinates, nt)
          , j = s.getPixelFromCoordinate(et);
        distance(j, i.startPx) > a && (ot = !1)
    }
    if (ot) {
        const et = rt.coordinates
          , j = et.length
          , it = rt.startIndex
          , st = nt;
        if (it < st) {
            const at = getCumulativeSquaredDistance(et, it, st);
            getCumulativeSquaredDistance(et, it, st - j) < at && (nt -= j)
        } else {
            const at = getCumulativeSquaredDistance(et, it, st);
            getCumulativeSquaredDistance(et, it, st + j) < at && (nt += j)
        }
    }
    return sharedUpdateInfo.index = tt,
    sharedUpdateInfo.endIndex = nt,
    sharedUpdateInfo
}
function appendTraceTarget(o, i, s, a) {
    const _ = o[0]
      , $ = o[1];
    for (let _e = 0, tt = i.length - 1; _e < tt; ++_e) {
        const nt = i[_e]
          , rt = i[_e + 1]
          , ot = getPointSegmentRelationship(_, $, nt, rt);
        if (ot.squaredDistance === 0) {
            const et = _e + ot.along;
            a.push({
                coordinates: i,
                ring: s,
                startIndex: et,
                endIndex: et
            });
            return
        }
    }
}
const sharedRel = {
    along: 0,
    squaredDistance: 0
};
function getPointSegmentRelationship(o, i, s, a) {
    const _ = s[0]
      , $ = s[1]
      , _e = a[0]
      , tt = a[1]
      , nt = _e - _
      , rt = tt - $;
    let ot = 0
      , et = _
      , j = $;
    return (nt !== 0 || rt !== 0) && (ot = clamp(((o - _) * nt + (i - $) * rt) / (nt * nt + rt * rt), 0, 1),
    et += nt * ot,
    j += rt * ot),
    sharedRel.along = ot,
    sharedRel.squaredDistance = toFixed(squaredDistance$1(o, i, et, j), 10),
    sharedRel
}
function interpolateCoordinate(o, i) {
    const s = o.length;
    let a = Math.floor(i);
    const _ = i - a;
    a >= s ? a -= s : a < 0 && (a += s);
    let $ = a + 1;
    $ >= s && ($ -= s);
    const _e = o[a]
      , tt = _e[0]
      , nt = _e[1]
      , rt = o[$]
      , ot = rt[0] - tt
      , et = rt[1] - nt;
    return [tt + ot * _, nt + et * _]
}
class Draw extends PointerInteraction$1 {
    constructor(i) {
        const s = i;
        s.stopDown || (s.stopDown = FALSE),
        super(s),
        this.on,
        this.once,
        this.un,
        this.shouldHandle_ = !1,
        this.downPx_ = null,
        this.downTimeout_,
        this.lastDragTime_,
        this.pointerType_,
        this.freehand_ = !1,
        this.source_ = i.source ? i.source : null,
        this.features_ = i.features ? i.features : null,
        this.snapTolerance_ = i.snapTolerance ? i.snapTolerance : 12,
        this.type_ = i.type,
        this.mode_ = getMode(this.type_),
        this.stopClick_ = !!i.stopClick,
        this.minPoints_ = i.minPoints ? i.minPoints : this.mode_ === "Polygon" ? 3 : 2,
        this.maxPoints_ = this.mode_ === "Circle" ? 2 : i.maxPoints ? i.maxPoints : 1 / 0,
        this.finishCondition_ = i.finishCondition ? i.finishCondition : TRUE,
        this.geometryLayout_ = i.geometryLayout ? i.geometryLayout : "XY";
        let a = i.geometryFunction;
        if (!a) {
            const _ = this.mode_;
            if (_ === "Circle")
                a = function($, _e, tt) {
                    const nt = _e || new Circle$1([NaN, NaN])
                      , rt = fromUserCoordinate($[0])
                      , ot = squaredDistance(rt, fromUserCoordinate($[$.length - 1]));
                    return nt.setCenterAndRadius(rt, Math.sqrt(ot), this.geometryLayout_),
                    nt
                }
                ;
            else {
                let $;
                _ === "Point" ? $ = Point$1 : _ === "LineString" ? $ = LineString$1 : _ === "Polygon" && ($ = Polygon$1),
                a = function(_e, tt, nt) {
                    return tt ? _ === "Polygon" ? _e[0].length ? tt.setCoordinates([_e[0].concat([_e[0][0]])], this.geometryLayout_) : tt.setCoordinates([], this.geometryLayout_) : tt.setCoordinates(_e, this.geometryLayout_) : tt = new $(_e,this.geometryLayout_),
                    tt
                }
            }
        }
        this.geometryFunction_ = a,
        this.dragVertexDelay_ = i.dragVertexDelay !== void 0 ? i.dragVertexDelay : 500,
        this.finishCoordinate_ = null,
        this.sketchFeature_ = null,
        this.sketchPoint_ = null,
        this.sketchCoords_ = null,
        this.sketchLine_ = null,
        this.sketchLineCoords_ = null,
        this.squaredClickTolerance_ = i.clickTolerance ? i.clickTolerance * i.clickTolerance : 36,
        this.overlay_ = new VectorLayer$1({
            source: new VectorSource$1({
                useSpatialIndex: !1,
                wrapX: i.wrapX ? i.wrapX : !1
            }),
            style: i.style ? i.style : getDefaultStyleFunction(),
            updateWhileInteracting: !0
        }),
        this.geometryName_ = i.geometryName,
        this.condition_ = i.condition ? i.condition : noModifierKeys,
        this.freehandCondition_,
        i.freehand ? this.freehandCondition_ = always$1 : this.freehandCondition_ = i.freehandCondition ? i.freehandCondition : shiftKeyOnly,
        this.traceCondition_,
        this.setTrace(i.trace || !1),
        this.traceState_ = {
            active: !1
        },
        this.traceSource_ = i.traceSource || i.source || null,
        this.addChangeListener(InteractionProperty.ACTIVE, this.updateState_)
    }
    setTrace(i) {
        let s;
        i ? i === !0 ? s = always$1 : s = i : s = never,
        this.traceCondition_ = s
    }
    setMap(i) {
        super.setMap(i),
        this.updateState_()
    }
    getOverlay() {
        return this.overlay_
    }
    handleEvent(i) {
        i.originalEvent.type === EventType.CONTEXTMENU && i.originalEvent.preventDefault(),
        this.freehand_ = this.mode_ !== "Point" && this.freehandCondition_(i);
        let s = i.type === MapBrowserEventType.POINTERMOVE
          , a = !0;
        return !this.freehand_ && this.lastDragTime_ && i.type === MapBrowserEventType.POINTERDRAG && (Date.now() - this.lastDragTime_ >= this.dragVertexDelay_ ? (this.downPx_ = i.pixel,
        this.shouldHandle_ = !this.freehand_,
        s = !0) : this.lastDragTime_ = void 0,
        this.shouldHandle_ && this.downTimeout_ !== void 0 && (clearTimeout(this.downTimeout_),
        this.downTimeout_ = void 0)),
        this.freehand_ && i.type === MapBrowserEventType.POINTERDRAG && this.sketchFeature_ !== null ? (this.addToDrawing_(i.coordinate),
        a = !1) : this.freehand_ && i.type === MapBrowserEventType.POINTERDOWN ? a = !1 : s && this.getPointerCount() < 2 ? (a = i.type === MapBrowserEventType.POINTERMOVE,
        a && this.freehand_ ? (this.handlePointerMove_(i),
        this.shouldHandle_ && i.originalEvent.preventDefault()) : (i.originalEvent.pointerType === "mouse" || i.type === MapBrowserEventType.POINTERDRAG && this.downTimeout_ === void 0) && this.handlePointerMove_(i)) : i.type === MapBrowserEventType.DBLCLICK && (a = !1),
        super.handleEvent(i) && a
    }
    handleDownEvent(i) {
        return this.shouldHandle_ = !this.freehand_,
        this.freehand_ ? (this.downPx_ = i.pixel,
        this.finishCoordinate_ || this.startDrawing_(i.coordinate),
        !0) : this.condition_(i) ? (this.lastDragTime_ = Date.now(),
        this.downTimeout_ = setTimeout( () => {
            this.handlePointerMove_(new MapBrowserEvent$1(MapBrowserEventType.POINTERMOVE,i.map,i.originalEvent,!1,i.frameState))
        }
        , this.dragVertexDelay_),
        this.downPx_ = i.pixel,
        !0) : (this.lastDragTime_ = void 0,
        !1)
    }
    deactivateTrace_() {
        this.traceState_ = {
            active: !1
        }
    }
    toggleTraceState_(i) {
        if (!this.traceSource_ || !this.traceCondition_(i))
            return;
        if (this.traceState_.active) {
            this.deactivateTrace_();
            return
        }
        const s = this.getMap()
          , a = s.getCoordinateFromPixel([i.pixel[0] - this.snapTolerance_, i.pixel[1] + this.snapTolerance_])
          , _ = s.getCoordinateFromPixel([i.pixel[0] + this.snapTolerance_, i.pixel[1] - this.snapTolerance_])
          , $ = boundingExtent([a, _])
          , _e = this.traceSource_.getFeaturesInExtent($);
        if (_e.length === 0)
            return;
        const tt = getTraceTargets(i.coordinate, _e);
        tt.length && (this.traceState_ = {
            active: !0,
            startPx: i.pixel.slice(),
            targets: tt,
            targetIndex: -1
        })
    }
    addOrRemoveTracedCoordinates_(i, s) {
        const a = i.startIndex <= i.endIndex
          , _ = i.startIndex <= s;
        a === _ ? a && s > i.endIndex || !a && s < i.endIndex ? this.addTracedCoordinates_(i, i.endIndex, s) : (a && s < i.endIndex || !a && s > i.endIndex) && this.removeTracedCoordinates_(s, i.endIndex) : (this.removeTracedCoordinates_(i.startIndex, i.endIndex),
        this.addTracedCoordinates_(i, i.startIndex, s))
    }
    removeTracedCoordinates_(i, s) {
        if (i === s)
            return;
        let a = 0;
        if (i < s) {
            const _ = Math.ceil(i);
            let $ = Math.floor(s);
            $ === s && ($ -= 1),
            a = $ - _ + 1
        } else {
            const _ = Math.floor(i);
            let $ = Math.ceil(s);
            $ === s && ($ += 1),
            a = _ - $ + 1
        }
        a > 0 && this.removeLastPoints_(a)
    }
    addTracedCoordinates_(i, s, a) {
        if (s === a)
            return;
        const _ = [];
        if (s < a) {
            const $ = Math.ceil(s);
            let _e = Math.floor(a);
            _e === a && (_e -= 1);
            for (let tt = $; tt <= _e; ++tt)
                _.push(getCoordinate(i.coordinates, tt))
        } else {
            const $ = Math.floor(s);
            let _e = Math.ceil(a);
            _e === a && (_e += 1);
            for (let tt = $; tt >= _e; --tt)
                _.push(getCoordinate(i.coordinates, tt))
        }
        _.length && this.appendCoordinates(_)
    }
    updateTrace_(i) {
        const s = this.traceState_;
        if (!s.active || s.targetIndex === -1 && distance(s.startPx, i.pixel) < this.snapTolerance_)
            return;
        const a = getTraceTargetUpdate(i.coordinate, s, this.getMap(), this.snapTolerance_);
        if (s.targetIndex !== a.index) {
            if (s.targetIndex !== -1) {
                const nt = s.targets[s.targetIndex];
                this.removeTracedCoordinates_(nt.startIndex, nt.endIndex)
            }
            const tt = s.targets[a.index];
            this.addTracedCoordinates_(tt, tt.startIndex, a.endIndex)
        } else {
            const tt = s.targets[s.targetIndex];
            this.addOrRemoveTracedCoordinates_(tt, a.endIndex)
        }
        s.targetIndex = a.index;
        const _ = s.targets[s.targetIndex];
        _.endIndex = a.endIndex;
        const $ = interpolateCoordinate(_.coordinates, _.endIndex)
          , _e = this.getMap().getPixelFromCoordinate($);
        i.coordinate = $,
        i.pixel = [Math.round(_e[0]), Math.round(_e[1])]
    }
    handleUpEvent(i) {
        let s = !0;
        if (this.getPointerCount() === 0) {
            this.downTimeout_ && (clearTimeout(this.downTimeout_),
            this.downTimeout_ = void 0),
            this.handlePointerMove_(i);
            const a = this.traceState_.active;
            if (this.toggleTraceState_(i),
            this.shouldHandle_) {
                const _ = !this.finishCoordinate_;
                _ && this.startDrawing_(i.coordinate),
                !_ && this.freehand_ ? this.finishDrawing() : !this.freehand_ && (!_ || this.mode_ === "Point") && (this.atFinish_(i.pixel, a) ? this.finishCondition_(i) && this.finishDrawing() : this.addToDrawing_(i.coordinate)),
                s = !1
            } else
                this.freehand_ && this.abortDrawing()
        }
        return !s && this.stopClick_ && i.preventDefault(),
        s
    }
    handlePointerMove_(i) {
        if (this.pointerType_ = i.originalEvent.pointerType,
        this.downPx_ && (!this.freehand_ && this.shouldHandle_ || this.freehand_ && !this.shouldHandle_)) {
            const s = this.downPx_
              , a = i.pixel
              , _ = s[0] - a[0]
              , $ = s[1] - a[1]
              , _e = _ * _ + $ * $;
            if (this.shouldHandle_ = this.freehand_ ? _e > this.squaredClickTolerance_ : _e <= this.squaredClickTolerance_,
            !this.shouldHandle_)
                return
        }
        if (!this.finishCoordinate_) {
            this.createOrUpdateSketchPoint_(i.coordinate.slice());
            return
        }
        this.updateTrace_(i),
        this.modifyDrawing_(i.coordinate)
    }
    atFinish_(i, s) {
        let a = !1;
        if (this.sketchFeature_) {
            let _ = !1
              , $ = [this.finishCoordinate_];
            const _e = this.mode_;
            if (_e === "Point")
                a = !0;
            else if (_e === "Circle")
                a = this.sketchCoords_.length === 2;
            else if (_e === "LineString")
                _ = !s && this.sketchCoords_.length > this.minPoints_;
            else if (_e === "Polygon") {
                const tt = this.sketchCoords_;
                _ = tt[0].length > this.minPoints_,
                $ = [tt[0][0], tt[0][tt[0].length - 2]],
                s ? $ = [tt[0][0]] : $ = [tt[0][0], tt[0][tt[0].length - 2]]
            }
            if (_) {
                const tt = this.getMap();
                for (let nt = 0, rt = $.length; nt < rt; nt++) {
                    const ot = $[nt]
                      , et = tt.getPixelFromCoordinate(ot)
                      , j = i[0] - et[0]
                      , it = i[1] - et[1]
                      , st = this.freehand_ ? 1 : this.snapTolerance_;
                    if (a = Math.sqrt(j * j + it * it) <= st,
                    a) {
                        this.finishCoordinate_ = ot;
                        break
                    }
                }
            }
        }
        return a
    }
    createOrUpdateSketchPoint_(i) {
        this.sketchPoint_ ? this.sketchPoint_.getGeometry().setCoordinates(i) : (this.sketchPoint_ = new Feature$1(new Point$1(i)),
        this.updateSketchFeatures_())
    }
    createOrUpdateCustomSketchLine_(i) {
        this.sketchLine_ || (this.sketchLine_ = new Feature$1);
        const s = i.getLinearRing(0);
        let a = this.sketchLine_.getGeometry();
        a ? (a.setFlatCoordinates(s.getLayout(), s.getFlatCoordinates()),
        a.changed()) : (a = new LineString$1(s.getFlatCoordinates(),s.getLayout()),
        this.sketchLine_.setGeometry(a))
    }
    startDrawing_(i) {
        const s = this.getMap().getView().getProjection()
          , a = getStrideForLayout(this.geometryLayout_);
        for (; i.length < a; )
            i.push(0);
        this.finishCoordinate_ = i,
        this.mode_ === "Point" ? this.sketchCoords_ = i.slice() : this.mode_ === "Polygon" ? (this.sketchCoords_ = [[i.slice(), i.slice()]],
        this.sketchLineCoords_ = this.sketchCoords_[0]) : this.sketchCoords_ = [i.slice(), i.slice()],
        this.sketchLineCoords_ && (this.sketchLine_ = new Feature$1(new LineString$1(this.sketchLineCoords_)));
        const _ = this.geometryFunction_(this.sketchCoords_, void 0, s);
        this.sketchFeature_ = new Feature$1,
        this.geometryName_ && this.sketchFeature_.setGeometryName(this.geometryName_),
        this.sketchFeature_.setGeometry(_),
        this.updateSketchFeatures_(),
        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART,this.sketchFeature_))
    }
    modifyDrawing_(i) {
        const s = this.getMap()
          , a = this.sketchFeature_.getGeometry()
          , _ = s.getView().getProjection()
          , $ = getStrideForLayout(this.geometryLayout_);
        let _e, tt;
        for (; i.length < $; )
            i.push(0);
        this.mode_ === "Point" ? tt = this.sketchCoords_ : this.mode_ === "Polygon" ? (_e = this.sketchCoords_[0],
        tt = _e[_e.length - 1],
        this.atFinish_(s.getPixelFromCoordinate(i)) && (i = this.finishCoordinate_.slice())) : (_e = this.sketchCoords_,
        tt = _e[_e.length - 1]),
        tt[0] = i[0],
        tt[1] = i[1],
        this.geometryFunction_(this.sketchCoords_, a, _),
        this.sketchPoint_ && this.sketchPoint_.getGeometry().setCoordinates(i),
        a.getType() === "Polygon" && this.mode_ !== "Polygon" ? this.createOrUpdateCustomSketchLine_(a) : this.sketchLineCoords_ && this.sketchLine_.getGeometry().setCoordinates(this.sketchLineCoords_),
        this.updateSketchFeatures_()
    }
    addToDrawing_(i) {
        const s = this.sketchFeature_.getGeometry()
          , a = this.getMap().getView().getProjection();
        let _, $;
        const _e = this.mode_;
        _e === "LineString" || _e === "Circle" ? (this.finishCoordinate_ = i.slice(),
        $ = this.sketchCoords_,
        $.length >= this.maxPoints_ && (this.freehand_ ? $.pop() : _ = !0),
        $.push(i.slice()),
        this.geometryFunction_($, s, a)) : _e === "Polygon" && ($ = this.sketchCoords_[0],
        $.length >= this.maxPoints_ && (this.freehand_ ? $.pop() : _ = !0),
        $.push(i.slice()),
        _ && (this.finishCoordinate_ = $[0]),
        this.geometryFunction_(this.sketchCoords_, s, a)),
        this.createOrUpdateSketchPoint_(i.slice()),
        this.updateSketchFeatures_(),
        _ && this.finishDrawing()
    }
    removeLastPoints_(i) {
        if (!this.sketchFeature_)
            return;
        const s = this.sketchFeature_.getGeometry()
          , a = this.getMap().getView().getProjection()
          , _ = this.mode_;
        for (let $ = 0; $ < i; ++$) {
            let _e;
            if (_ === "LineString" || _ === "Circle") {
                if (_e = this.sketchCoords_,
                _e.splice(-2, 1),
                _e.length >= 2) {
                    this.finishCoordinate_ = _e[_e.length - 2].slice();
                    const tt = this.finishCoordinate_.slice();
                    _e[_e.length - 1] = tt,
                    this.createOrUpdateSketchPoint_(tt)
                }
                this.geometryFunction_(_e, s, a),
                s.getType() === "Polygon" && this.sketchLine_ && this.createOrUpdateCustomSketchLine_(s)
            } else if (_ === "Polygon") {
                _e = this.sketchCoords_[0],
                _e.splice(-2, 1);
                const tt = this.sketchLine_.getGeometry();
                if (_e.length >= 2) {
                    const nt = _e[_e.length - 2].slice();
                    _e[_e.length - 1] = nt,
                    this.createOrUpdateSketchPoint_(nt)
                }
                tt.setCoordinates(_e),
                this.geometryFunction_(this.sketchCoords_, s, a)
            }
            if (_e.length === 1) {
                this.abortDrawing();
                break
            }
        }
        this.updateSketchFeatures_()
    }
    removeLastPoint() {
        this.removeLastPoints_(1)
    }
    finishDrawing() {
        const i = this.abortDrawing_();
        if (!i)
            return;
        let s = this.sketchCoords_;
        const a = i.getGeometry()
          , _ = this.getMap().getView().getProjection();
        this.mode_ === "LineString" ? (s.pop(),
        this.geometryFunction_(s, a, _)) : this.mode_ === "Polygon" && (s[0].pop(),
        this.geometryFunction_(s, a, _),
        s = a.getCoordinates()),
        this.type_ === "MultiPoint" ? i.setGeometry(new MultiPoint$1([s])) : this.type_ === "MultiLineString" ? i.setGeometry(new MultiLineString$1([s])) : this.type_ === "MultiPolygon" && i.setGeometry(new MultiPolygon$1([s])),
        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWEND,i)),
        this.features_ && this.features_.push(i),
        this.source_ && this.source_.addFeature(i)
    }
    abortDrawing_() {
        this.finishCoordinate_ = null;
        const i = this.sketchFeature_;
        return this.sketchFeature_ = null,
        this.sketchPoint_ = null,
        this.sketchLine_ = null,
        this.overlay_.getSource().clear(!0),
        this.deactivateTrace_(),
        i
    }
    abortDrawing() {
        const i = this.abortDrawing_();
        i && this.dispatchEvent(new DrawEvent(DrawEventType.DRAWABORT,i))
    }
    appendCoordinates(i) {
        const s = this.mode_
          , a = !this.sketchFeature_;
        a && this.startDrawing_(i[0]);
        let _;
        if (s === "LineString" || s === "Circle")
            _ = this.sketchCoords_;
        else if (s === "Polygon")
            _ = this.sketchCoords_ && this.sketchCoords_.length ? this.sketchCoords_[0] : [];
        else
            return;
        a && _.shift(),
        _.pop();
        for (let _e = 0; _e < i.length; _e++)
            this.addToDrawing_(i[_e]);
        const $ = i[i.length - 1];
        this.addToDrawing_($),
        this.modifyDrawing_($)
    }
    extend(i) {
        const a = i.getGeometry();
        this.sketchFeature_ = i,
        this.sketchCoords_ = a.getCoordinates();
        const _ = this.sketchCoords_[this.sketchCoords_.length - 1];
        this.finishCoordinate_ = _.slice(),
        this.sketchCoords_.push(_.slice()),
        this.sketchPoint_ = new Feature$1(new Point$1(_)),
        this.updateSketchFeatures_(),
        this.dispatchEvent(new DrawEvent(DrawEventType.DRAWSTART,this.sketchFeature_))
    }
    updateSketchFeatures_() {
        const i = [];
        this.sketchFeature_ && i.push(this.sketchFeature_),
        this.sketchLine_ && i.push(this.sketchLine_),
        this.sketchPoint_ && i.push(this.sketchPoint_);
        const s = this.overlay_.getSource();
        s.clear(!0),
        s.addFeatures(i)
    }
    updateState_() {
        const i = this.getMap()
          , s = this.getActive();
        (!i || !s) && this.abortDrawing(),
        this.overlay_.setMap(s ? i : null)
    }
}
function getDefaultStyleFunction() {
    const o = createEditingStyle();
    return function(i, s) {
        return o[i.getGeometry().getType()]
    }
}
function createBox() {
    return function(o, i, s) {
        const a = boundingExtent([o[0], o[o.length - 1]].map(function($) {
            return fromUserCoordinate($)
        }))
          , _ = [[getBottomLeft(a), getBottomRight(a), getTopRight(a), getTopLeft(a), getBottomLeft(a)]];
        return i ? i.setCoordinates(_) : i = new Polygon$1(_),
        i
    }
}
function getMode(o) {
    switch (o) {
    case "Point":
    case "MultiPoint":
        return "Point";
    case "LineString":
    case "MultiLineString":
        return "LineString";
    case "Polygon":
    case "MultiPolygon":
        return "Polygon";
    case "Circle":
        return "Circle";
    default:
        throw new Error("Invalid type: " + o)
    }
}
const Draw$1 = Draw;
class FeatureFormat {
    constructor() {
        this.dataProjection = void 0,
        this.defaultFeatureProjection = void 0,
        this.supportedMediaTypes = null
    }
    getReadOptions(i, s) {
        if (s) {
            let a = s.dataProjection ? get$1(s.dataProjection) : this.readProjection(i);
            s.extent && a && a.getUnits() === "tile-pixels" && (a = get$1(a),
            a.setWorldExtent(s.extent)),
            s = {
                dataProjection: a,
                featureProjection: s.featureProjection
            }
        }
        return this.adaptOptions(s)
    }
    adaptOptions(i) {
        return Object.assign({
            dataProjection: this.dataProjection,
            featureProjection: this.defaultFeatureProjection
        }, i)
    }
    getType() {
        return abstract()
    }
    readFeature(i, s) {
        return abstract()
    }
    readFeatures(i, s) {
        return abstract()
    }
    readGeometry(i, s) {
        return abstract()
    }
    readProjection(i) {
        return abstract()
    }
    writeFeature(i, s) {
        return abstract()
    }
    writeFeatures(i, s) {
        return abstract()
    }
    writeGeometry(i, s) {
        return abstract()
    }
}
function transformGeometryWithOptions(o, i, s) {
    const a = s ? get$1(s.featureProjection) : null
      , _ = s ? get$1(s.dataProjection) : null;
    let $;
    if (a && _ && !equivalent(a, _) ? $ = (i ? o.clone() : o).transform(i ? a : _, i ? _ : a) : $ = o,
    i && s && s.decimals !== void 0) {
        const _e = Math.pow(10, s.decimals)
          , tt = function(nt) {
            for (let rt = 0, ot = nt.length; rt < ot; ++rt)
                nt[rt] = Math.round(nt[rt] * _e) / _e;
            return nt
        };
        $ === o && ($ = o.clone()),
        $.applyTransform(tt)
    }
    return $
}
class JSONFeature extends FeatureFormat {
    constructor() {
        super()
    }
    getType() {
        return "json"
    }
    readFeature(i, s) {
        return this.readFeatureFromObject(getObject(i), this.getReadOptions(i, s))
    }
    readFeatures(i, s) {
        return this.readFeaturesFromObject(getObject(i), this.getReadOptions(i, s))
    }
    readFeatureFromObject(i, s) {
        return abstract()
    }
    readFeaturesFromObject(i, s) {
        return abstract()
    }
    readGeometry(i, s) {
        return this.readGeometryFromObject(getObject(i), this.getReadOptions(i, s))
    }
    readGeometryFromObject(i, s) {
        return abstract()
    }
    readProjection(i) {
        return this.readProjectionFromObject(getObject(i))
    }
    readProjectionFromObject(i) {
        return abstract()
    }
    writeFeature(i, s) {
        return JSON.stringify(this.writeFeatureObject(i, s))
    }
    writeFeatureObject(i, s) {
        return abstract()
    }
    writeFeatures(i, s) {
        return JSON.stringify(this.writeFeaturesObject(i, s))
    }
    writeFeaturesObject(i, s) {
        return abstract()
    }
    writeGeometry(i, s) {
        return JSON.stringify(this.writeGeometryObject(i, s))
    }
    writeGeometryObject(i, s) {
        return abstract()
    }
}
function getObject(o) {
    if (typeof o == "string") {
        const i = JSON.parse(o);
        return i || null
    }
    return o !== null ? o : null
}
const JSONFeature$1 = JSONFeature;
class GeoJSON extends JSONFeature$1 {
    constructor(i) {
        i = i || {},
        super(),
        this.dataProjection = get$1(i.dataProjection ? i.dataProjection : "EPSG:4326"),
        i.featureProjection && (this.defaultFeatureProjection = get$1(i.featureProjection)),
        this.geometryName_ = i.geometryName,
        this.extractGeometryName_ = i.extractGeometryName,
        this.supportedMediaTypes = ["application/geo+json", "application/vnd.geo+json"]
    }
    readFeatureFromObject(i, s) {
        let a = null;
        i.type === "Feature" ? a = i : a = {
            type: "Feature",
            geometry: i,
            properties: null
        };
        const _ = readGeometry(a.geometry, s)
          , $ = new Feature$1;
        return this.geometryName_ ? $.setGeometryName(this.geometryName_) : this.extractGeometryName_ && "geometry_name"in a !== void 0 && $.setGeometryName(a.geometry_name),
        $.setGeometry(_),
        "id"in a && $.setId(a.id),
        a.properties && $.setProperties(a.properties, !0),
        $
    }
    readFeaturesFromObject(i, s) {
        const a = i;
        let _ = null;
        if (a.type === "FeatureCollection") {
            const $ = i;
            _ = [];
            const _e = $.features;
            for (let tt = 0, nt = _e.length; tt < nt; ++tt)
                _.push(this.readFeatureFromObject(_e[tt], s))
        } else
            _ = [this.readFeatureFromObject(i, s)];
        return _
    }
    readGeometryFromObject(i, s) {
        return readGeometry(i, s)
    }
    readProjectionFromObject(i) {
        const s = i.crs;
        let a;
        if (s)
            if (s.type == "name")
                a = get$1(s.properties.name);
            else if (s.type === "EPSG")
                a = get$1("EPSG:" + s.properties.code);
            else
                throw new Error("Unknown SRS type");
        else
            a = this.dataProjection;
        return a
    }
    writeFeatureObject(i, s) {
        s = this.adaptOptions(s);
        const a = {
            type: "Feature",
            geometry: null,
            properties: null
        }
          , _ = i.getId();
        if (_ !== void 0 && (a.id = _),
        !i.hasProperties())
            return a;
        const $ = i.getProperties()
          , _e = i.getGeometry();
        return _e && (a.geometry = writeGeometry(_e, s),
        delete $[i.getGeometryName()]),
        isEmpty$1($) || (a.properties = $),
        a
    }
    writeFeaturesObject(i, s) {
        s = this.adaptOptions(s);
        const a = [];
        for (let _ = 0, $ = i.length; _ < $; ++_)
            a.push(this.writeFeatureObject(i[_], s));
        return {
            type: "FeatureCollection",
            features: a
        }
    }
    writeGeometryObject(i, s) {
        return writeGeometry(i, this.adaptOptions(s))
    }
}
function readGeometry(o, i) {
    if (!o)
        return null;
    let s;
    switch (o.type) {
    case "Point":
        {
            s = readPointGeometry(o);
            break
        }
    case "LineString":
        {
            s = readLineStringGeometry(o);
            break
        }
    case "Polygon":
        {
            s = readPolygonGeometry(o);
            break
        }
    case "MultiPoint":
        {
            s = readMultiPointGeometry(o);
            break
        }
    case "MultiLineString":
        {
            s = readMultiLineStringGeometry(o);
            break
        }
    case "MultiPolygon":
        {
            s = readMultiPolygonGeometry(o);
            break
        }
    case "GeometryCollection":
        {
            s = readGeometryCollectionGeometry(o);
            break
        }
    default:
        throw new Error("Unsupported GeoJSON type: " + o.type)
    }
    return transformGeometryWithOptions(s, !1, i)
}
function readGeometryCollectionGeometry(o, i) {
    const s = o.geometries.map(function(a) {
        return readGeometry(a, i)
    });
    return new GeometryCollection$1(s)
}
function readPointGeometry(o) {
    return new Point$1(o.coordinates)
}
function readLineStringGeometry(o) {
    return new LineString$1(o.coordinates)
}
function readMultiLineStringGeometry(o) {
    return new MultiLineString$1(o.coordinates)
}
function readMultiPointGeometry(o) {
    return new MultiPoint$1(o.coordinates)
}
function readMultiPolygonGeometry(o) {
    return new MultiPolygon$1(o.coordinates)
}
function readPolygonGeometry(o) {
    return new Polygon$1(o.coordinates)
}
function writeGeometry(o, i) {
    o = transformGeometryWithOptions(o, !0, i);
    const s = o.getType();
    let a;
    switch (s) {
    case "Point":
        {
            a = writePointGeometry(o);
            break
        }
    case "LineString":
        {
            a = writeLineStringGeometry(o);
            break
        }
    case "Polygon":
        {
            a = writePolygonGeometry(o, i);
            break
        }
    case "MultiPoint":
        {
            a = writeMultiPointGeometry(o);
            break
        }
    case "MultiLineString":
        {
            a = writeMultiLineStringGeometry(o);
            break
        }
    case "MultiPolygon":
        {
            a = writeMultiPolygonGeometry(o, i);
            break
        }
    case "GeometryCollection":
        {
            a = writeGeometryCollectionGeometry(o, i);
            break
        }
    case "Circle":
        {
            a = {
                type: "GeometryCollection",
                geometries: []
            };
            break
        }
    default:
        throw new Error("Unsupported geometry type: " + s)
    }
    return a
}
function writeGeometryCollectionGeometry(o, i) {
    return i = Object.assign({}, i),
    delete i.featureProjection,
    {
        type: "GeometryCollection",
        geometries: o.getGeometriesArray().map(function(a) {
            return writeGeometry(a, i)
        })
    }
}
function writeLineStringGeometry(o, i) {
    return {
        type: "LineString",
        coordinates: o.getCoordinates()
    }
}
function writeMultiLineStringGeometry(o, i) {
    return {
        type: "MultiLineString",
        coordinates: o.getCoordinates()
    }
}
function writeMultiPointGeometry(o, i) {
    return {
        type: "MultiPoint",
        coordinates: o.getCoordinates()
    }
}
function writeMultiPolygonGeometry(o, i) {
    let s;
    return i && (s = i.rightHanded),
    {
        type: "MultiPolygon",
        coordinates: o.getCoordinates(s)
    }
}
function writePointGeometry(o, i) {
    return {
        type: "Point",
        coordinates: o.getCoordinates()
    }
}
function writePolygonGeometry(o, i) {
    let s;
    return i && (s = i.rightHanded),
    {
        type: "Polygon",
        coordinates: o.getCoordinates(s)
    }
}
const GeoJSON$1 = GeoJSON;
class Tile extends EventTarget {
    constructor(i, s, a) {
        super(),
        a = a || {},
        this.tileCoord = i,
        this.state = s,
        this.interimTile = null,
        this.key = "",
        this.transition_ = a.transition === void 0 ? 250 : a.transition,
        this.transitionStarts_ = {},
        this.interpolate = !!a.interpolate
    }
    changed() {
        this.dispatchEvent(EventType.CHANGE)
    }
    release() {
        this.state === TileState.ERROR && this.setState(TileState.EMPTY)
    }
    getKey() {
        return this.key + "/" + this.tileCoord
    }
    getInterimTile() {
        if (!this.interimTile)
            return this;
        let i = this.interimTile;
        do {
            if (i.getState() == TileState.LOADED)
                return this.transition_ = 0,
                i;
            i = i.interimTile
        } while (i);
        return this
    }
    refreshInterimChain() {
        if (!this.interimTile)
            return;
        let i = this.interimTile
          , s = this;
        do {
            if (i.getState() == TileState.LOADED) {
                i.interimTile = null;
                break
            } else
                i.getState() == TileState.LOADING ? s = i : i.getState() == TileState.IDLE ? s.interimTile = i.interimTile : s = i;
            i = s.interimTile
        } while (i)
    }
    getTileCoord() {
        return this.tileCoord
    }
    getState() {
        return this.state
    }
    setState(i) {
        if (this.state !== TileState.ERROR && this.state > i)
            throw new Error("Tile load sequence violation");
        this.state = i,
        this.changed()
    }
    load() {
        abstract()
    }
    getAlpha(i, s) {
        if (!this.transition_)
            return 1;
        let a = this.transitionStarts_[i];
        if (!a)
            a = s,
            this.transitionStarts_[i] = a;
        else if (a === -1)
            return 1;
        const _ = s - a + 1e3 / 60;
        return _ >= this.transition_ ? 1 : easeIn(_ / this.transition_)
    }
    inTransition(i) {
        return this.transition_ ? this.transitionStarts_[i] !== -1 : !1
    }
    endTransition(i) {
        this.transition_ && (this.transitionStarts_[i] = -1)
    }
}
const Tile$1 = Tile;
class ImageTile extends Tile$1 {
    constructor(i, s, a, _, $, _e) {
        super(i, s, _e),
        this.crossOrigin_ = _,
        this.src_ = a,
        this.key = a,
        this.image_ = new Image,
        _ !== null && (this.image_.crossOrigin = _),
        this.unlisten_ = null,
        this.tileLoadFunction_ = $
    }
    getImage() {
        return this.image_
    }
    setImage(i) {
        this.image_ = i,
        this.state = TileState.LOADED,
        this.unlistenImage_(),
        this.changed()
    }
    handleImageError_() {
        this.state = TileState.ERROR,
        this.unlistenImage_(),
        this.image_ = getBlankImage(),
        this.changed()
    }
    handleImageLoad_() {
        const i = this.image_;
        i.naturalWidth && i.naturalHeight ? this.state = TileState.LOADED : this.state = TileState.EMPTY,
        this.unlistenImage_(),
        this.changed()
    }
    load() {
        this.state == TileState.ERROR && (this.state = TileState.IDLE,
        this.image_ = new Image,
        this.crossOrigin_ !== null && (this.image_.crossOrigin = this.crossOrigin_)),
        this.state == TileState.IDLE && (this.state = TileState.LOADING,
        this.changed(),
        this.tileLoadFunction_(this, this.src_),
        this.unlisten_ = listenImage(this.image_, this.handleImageLoad_.bind(this), this.handleImageError_.bind(this)))
    }
    unlistenImage_() {
        this.unlisten_ && (this.unlisten_(),
        this.unlisten_ = null)
    }
}
function getBlankImage() {
    const o = createCanvasContext2D(1, 1);
    return o.fillStyle = "rgba(0,0,0,0)",
    o.fillRect(0, 0, 1, 1),
    o.canvas
}
const ImageTile$1 = ImageTile;
class LRUCache {
    constructor(i) {
        this.highWaterMark = i !== void 0 ? i : 2048,
        this.count_ = 0,
        this.entries_ = {},
        this.oldest_ = null,
        this.newest_ = null
    }
    canExpireCache() {
        return this.highWaterMark > 0 && this.getCount() > this.highWaterMark
    }
    expireCache(i) {
        for (; this.canExpireCache(); )
            this.pop()
    }
    clear() {
        this.count_ = 0,
        this.entries_ = {},
        this.oldest_ = null,
        this.newest_ = null
    }
    containsKey(i) {
        return this.entries_.hasOwnProperty(i)
    }
    forEach(i) {
        let s = this.oldest_;
        for (; s; )
            i(s.value_, s.key_, this),
            s = s.newer
    }
    get(i, s) {
        const a = this.entries_[i];
        return assert(a !== void 0, "Tried to get a value for a key that does not exist in the cache"),
        a === this.newest_ || (a === this.oldest_ ? (this.oldest_ = this.oldest_.newer,
        this.oldest_.older = null) : (a.newer.older = a.older,
        a.older.newer = a.newer),
        a.newer = null,
        a.older = this.newest_,
        this.newest_.newer = a,
        this.newest_ = a),
        a.value_
    }
    remove(i) {
        const s = this.entries_[i];
        return assert(s !== void 0, "Tried to get a value for a key that does not exist in the cache"),
        s === this.newest_ ? (this.newest_ = s.older,
        this.newest_ && (this.newest_.newer = null)) : s === this.oldest_ ? (this.oldest_ = s.newer,
        this.oldest_ && (this.oldest_.older = null)) : (s.newer.older = s.older,
        s.older.newer = s.newer),
        delete this.entries_[i],
        --this.count_,
        s.value_
    }
    getCount() {
        return this.count_
    }
    getKeys() {
        const i = new Array(this.count_);
        let s = 0, a;
        for (a = this.newest_; a; a = a.older)
            i[s++] = a.key_;
        return i
    }
    getValues() {
        const i = new Array(this.count_);
        let s = 0, a;
        for (a = this.newest_; a; a = a.older)
            i[s++] = a.value_;
        return i
    }
    peekLast() {
        return this.oldest_.value_
    }
    peekLastKey() {
        return this.oldest_.key_
    }
    peekFirstKey() {
        return this.newest_.key_
    }
    peek(i) {
        if (this.containsKey(i))
            return this.entries_[i].value_
    }
    pop() {
        const i = this.oldest_;
        return delete this.entries_[i.key_],
        i.newer && (i.newer.older = null),
        this.oldest_ = i.newer,
        this.oldest_ || (this.newest_ = null),
        --this.count_,
        i.value_
    }
    replace(i, s) {
        this.get(i),
        this.entries_[i].value_ = s
    }
    set(i, s) {
        assert(!(i in this.entries_), "Tried to set a value for a key that is used already");
        const a = {
            key_: i,
            newer: null,
            older: this.newest_,
            value_: s
        };
        this.newest_ ? this.newest_.newer = a : this.oldest_ = a,
        this.newest_ = a,
        this.entries_[i] = a,
        ++this.count_
    }
    setSize(i) {
        this.highWaterMark = i
    }
}
const LRUCache$1 = LRUCache;
function createOrUpdate$1(o, i, s, a) {
    return a !== void 0 ? (a[0] = o,
    a[1] = i,
    a[2] = s,
    a) : [o, i, s]
}
function getKeyZXY(o, i, s) {
    return o + "/" + i + "/" + s
}
function getKey(o) {
    return getKeyZXY(o[0], o[1], o[2])
}
function fromKey(o) {
    return o.split("/").map(Number)
}
function hash(o) {
    return (o[1] << o[0]) + o[2]
}
function withinExtentAndZ(o, i) {
    const s = o[0]
      , a = o[1]
      , _ = o[2];
    if (i.getMinZoom() > s || s > i.getMaxZoom())
        return !1;
    const $ = i.getFullTileRange(s);
    return $ ? $.containsXY(a, _) : !0
}
class TileCache extends LRUCache$1 {
    clear() {
        for (; this.getCount() > 0; )
            this.pop().release();
        super.clear()
    }
    expireCache(i) {
        for (; this.canExpireCache() && !(this.peekLast().getKey()in i); )
            this.pop().release()
    }
    pruneExceptNewestZ() {
        if (this.getCount() === 0)
            return;
        const i = this.peekFirstKey()
          , a = fromKey(i)[0];
        this.forEach(_ => {
            _.tileCoord[0] !== a && (this.remove(getKey(_.tileCoord)),
            _.release())
        }
        )
    }
}
const TileCache$1 = TileCache;
class TileRange {
    constructor(i, s, a, _) {
        this.minX = i,
        this.maxX = s,
        this.minY = a,
        this.maxY = _
    }
    contains(i) {
        return this.containsXY(i[1], i[2])
    }
    containsTileRange(i) {
        return this.minX <= i.minX && i.maxX <= this.maxX && this.minY <= i.minY && i.maxY <= this.maxY
    }
    containsXY(i, s) {
        return this.minX <= i && i <= this.maxX && this.minY <= s && s <= this.maxY
    }
    equals(i) {
        return this.minX == i.minX && this.minY == i.minY && this.maxX == i.maxX && this.maxY == i.maxY
    }
    extend(i) {
        i.minX < this.minX && (this.minX = i.minX),
        i.maxX > this.maxX && (this.maxX = i.maxX),
        i.minY < this.minY && (this.minY = i.minY),
        i.maxY > this.maxY && (this.maxY = i.maxY)
    }
    getHeight() {
        return this.maxY - this.minY + 1
    }
    getSize() {
        return [this.getWidth(), this.getHeight()]
    }
    getWidth() {
        return this.maxX - this.minX + 1
    }
    intersects(i) {
        return this.minX <= i.maxX && this.maxX >= i.minX && this.minY <= i.maxY && this.maxY >= i.minY
    }
}
function createOrUpdate(o, i, s, a, _) {
    return _ !== void 0 ? (_.minX = o,
    _.maxX = i,
    _.minY = s,
    _.maxY = a,
    _) : new TileRange(o,i,s,a)
}
const TileRange$1 = TileRange
  , image = new CircleStyle$1({
    radius: 8,
    fill: new Fill$1({
        color: "red"
    }),
    stroke: new Stroke$1({
        color: "white",
        width: 2
    })
})
  , styles = {
    Point: new Style$1({
        image
    }),
    LineString: new Style$1({
        stroke: new Stroke$1({
            color: "red",
            width: 3
        })
    }),
    LinearRing: new Style$1({
        stroke: new Stroke$1({
            color: "red",
            width: 3
        })
    }),
    MultiLineString: new Style$1({
        stroke: new Stroke$1({
            color: "green",
            width: 1
        })
    }),
    MultiPoint: new Style$1({
        image
    }),
    MultiPolygon: new Style$1({
        stroke: new Stroke$1({
            color: "yellow",
            width: 1
        }),
        fill: new Fill$1({
            color: "rgba(255, 255, 0, 0.1)"
        })
    }),
    Polygon: new Style$1({
        stroke: new Stroke$1({
            color: "blue",
            lineDash: [4],
            width: 3
        }),
        fill: new Fill$1({
            color: "rgba(0, 0, 255, 0.3)"
        })
    }),
    GeometryCollection: new Style$1({
        stroke: new Stroke$1({
            color: "magenta",
            width: 2
        }),
        fill: new Fill$1({
            color: "magenta"
        }),
        image: new CircleStyle$1({
            radius: 10,
            fill: void 0,
            stroke: new Stroke$1({
                color: "magenta"
            })
        })
    }),
    Circle: new Style$1({
        stroke: new Stroke$1({
            color: "red",
            width: 2
        }),
        fill: new Fill$1({
            color: "rgba(255,0,0,0.2)"
        })
    })
}
  , highlightStyles = {
    Point: new Style$1({
        image
    }),
    LineString: new Style$1({
        stroke: new Stroke$1({
            color: "orange",
            width: 3
        })
    }),
    LinearRing: new Style$1({
        stroke: new Stroke$1({
            color: "orange",
            width: 1
        })
    }),
    MultiLineString: new Style$1({
        stroke: new Stroke$1({
            color: "orange",
            width: 1
        })
    }),
    MultiPoint: new Style$1({
        image
    }),
    MultiPolygon: new Style$1({
        stroke: new Stroke$1({
            color: "orange",
            width: 1
        }),
        fill: new Fill$1({
            color: "orange"
        })
    }),
    Polygon: new Style$1({
        stroke: new Stroke$1({
            color: "blue",
            lineDash: [4],
            width: 3
        }),
        fill: new Fill$1({
            color: "orange"
        })
    }),
    GeometryCollection: new Style$1({
        stroke: new Stroke$1({
            color: "orange",
            width: 2
        }),
        fill: new Fill$1({
            color: "orange"
        }),
        image: new CircleStyle$1({
            radius: 10,
            fill: void 0,
            stroke: new Stroke$1({
                color: "orange"
            })
        })
    }),
    Circle: new Style$1({
        stroke: new Stroke$1({
            color: "orange",
            width: 2
        }),
        fill: new Fill$1({
            color: "orange"
        })
    })
}
  , drawingStyle = {
    "fill-color": "rgba(255, 255, 255, 0.2)",
    "stroke-color": "rgb(30,144,255)",
    "stroke-width": 2,
    "circle-radius": 7,
    "circle-fill-color": "rgb(30,144,255)",
    "circle-stroke-color": "white"
};
function getFeatureStyle(o) {
    return styles[o.getGeometry().getType()]
}
function getHighlightStyle(o) {
    return highlightStyles[o.getGeometry().getType()]
}
const TileProperty = {
    PRELOAD: "preload",
    USE_INTERIM_TILES_ON_ERROR: "useInterimTilesOnError"
};
class BaseTileLayer extends Layer$1 {
    constructor(i) {
        i = i || {};
        const s = Object.assign({}, i);
        delete s.preload,
        delete s.useInterimTilesOnError,
        super(s),
        this.on,
        this.once,
        this.un,
        this.setPreload(i.preload !== void 0 ? i.preload : 0),
        this.setUseInterimTilesOnError(i.useInterimTilesOnError !== void 0 ? i.useInterimTilesOnError : !0)
    }
    getPreload() {
        return this.get(TileProperty.PRELOAD)
    }
    setPreload(i) {
        this.set(TileProperty.PRELOAD, i)
    }
    getUseInterimTilesOnError() {
        return this.get(TileProperty.USE_INTERIM_TILES_ON_ERROR)
    }
    setUseInterimTilesOnError(i) {
        this.set(TileProperty.USE_INTERIM_TILES_ON_ERROR, i)
    }
    getData(i) {
        return super.getData(i)
    }
}
const BaseTileLayer$1 = BaseTileLayer
  , ERROR_THRESHOLD = .5;
function asImageLike(o) {
    return o instanceof Image || o instanceof HTMLCanvasElement || o instanceof HTMLVideoElement || o instanceof ImageBitmap ? o : null
}
function asArrayLike(o) {
    return o instanceof Uint8Array || o instanceof Uint8ClampedArray || o instanceof Float32Array || o instanceof DataView ? o : null
}
let sharedContext = null;
function toArray(o) {
    sharedContext || (sharedContext = createCanvasContext2D(o.width, o.height, void 0, {
        willReadFrequently: !0
    }));
    const i = sharedContext.canvas
      , s = o.width;
    i.width !== s && (i.width = s);
    const a = o.height;
    return i.height !== a && (i.height = a),
    sharedContext.clearRect(0, 0, s, a),
    sharedContext.drawImage(o, 0, 0),
    sharedContext.getImageData(0, 0, s, a).data
}
const defaultSize = [256, 256];
let DataTile$1 = class extends Tile$1 {
    constructor(i) {
        const s = TileState.IDLE;
        super(i.tileCoord, s, {
            transition: i.transition,
            interpolate: i.interpolate
        }),
        this.loader_ = i.loader,
        this.data_ = null,
        this.error_ = null,
        this.size_ = i.size || null
    }
    getSize() {
        if (this.size_)
            return this.size_;
        const i = asImageLike(this.data_);
        return i ? [i.width, i.height] : defaultSize
    }
    getData() {
        return this.data_
    }
    getError() {
        return this.error_
    }
    load() {
        if (this.state !== TileState.IDLE && this.state !== TileState.ERROR)
            return;
        this.state = TileState.LOADING,
        this.changed();
        const i = this;
        this.loader_().then(function(s) {
            i.data_ = s,
            i.state = TileState.LOADED,
            i.changed()
        }).catch(function(s) {
            i.error_ = s,
            i.state = TileState.ERROR,
            i.changed()
        })
    }
}
;
const DataTile$2 = DataTile$1
  , MAX_SUBDIVISION = 10
  , MAX_TRIANGLE_WIDTH = .25;
class Triangulation {
    constructor(i, s, a, _, $, _e) {
        this.sourceProj_ = i,
        this.targetProj_ = s;
        let tt = {};
        const nt = getTransform(this.targetProj_, this.sourceProj_);
        this.transformInv_ = function(ut) {
            const dt = ut[0] + "/" + ut[1];
            return tt[dt] || (tt[dt] = nt(ut)),
            tt[dt]
        }
        ,
        this.maxSourceExtent_ = _,
        this.errorThresholdSquared_ = $ * $,
        this.triangles_ = [],
        this.wrapsXInSource_ = !1,
        this.canWrapXInSource_ = this.sourceProj_.canWrapX() && !!_ && !!this.sourceProj_.getExtent() && getWidth(_) >= getWidth(this.sourceProj_.getExtent()),
        this.sourceWorldWidth_ = this.sourceProj_.getExtent() ? getWidth(this.sourceProj_.getExtent()) : null,
        this.targetWorldWidth_ = this.targetProj_.getExtent() ? getWidth(this.targetProj_.getExtent()) : null;
        const rt = getTopLeft(a)
          , ot = getTopRight(a)
          , et = getBottomRight(a)
          , j = getBottomLeft(a)
          , it = this.transformInv_(rt)
          , st = this.transformInv_(ot)
          , at = this.transformInv_(et)
          , lt = this.transformInv_(j)
          , ct = MAX_SUBDIVISION + (_e ? Math.max(0, Math.ceil(Math.log2(getArea(a) / (_e * _e * 256 * 256)))) : 0);
        if (this.addQuad_(rt, ot, et, j, it, st, at, lt, ct),
        this.wrapsXInSource_) {
            let ut = 1 / 0;
            this.triangles_.forEach(function(dt, ft, ht) {
                ut = Math.min(ut, dt.source[0][0], dt.source[1][0], dt.source[2][0])
            }),
            this.triangles_.forEach(dt => {
                if (Math.max(dt.source[0][0], dt.source[1][0], dt.source[2][0]) - ut > this.sourceWorldWidth_ / 2) {
                    const ft = [[dt.source[0][0], dt.source[0][1]], [dt.source[1][0], dt.source[1][1]], [dt.source[2][0], dt.source[2][1]]];
                    ft[0][0] - ut > this.sourceWorldWidth_ / 2 && (ft[0][0] -= this.sourceWorldWidth_),
                    ft[1][0] - ut > this.sourceWorldWidth_ / 2 && (ft[1][0] -= this.sourceWorldWidth_),
                    ft[2][0] - ut > this.sourceWorldWidth_ / 2 && (ft[2][0] -= this.sourceWorldWidth_);
                    const ht = Math.min(ft[0][0], ft[1][0], ft[2][0]);
                    Math.max(ft[0][0], ft[1][0], ft[2][0]) - ht < this.sourceWorldWidth_ / 2 && (dt.source = ft)
                }
            }
            )
        }
        tt = {}
    }
    addTriangle_(i, s, a, _, $, _e) {
        this.triangles_.push({
            source: [_, $, _e],
            target: [i, s, a]
        })
    }
    addQuad_(i, s, a, _, $, _e, tt, nt, rt) {
        const ot = boundingExtent([$, _e, tt, nt])
          , et = this.sourceWorldWidth_ ? getWidth(ot) / this.sourceWorldWidth_ : null
          , j = this.sourceWorldWidth_
          , it = this.sourceProj_.canWrapX() && et > .5 && et < 1;
        let st = !1;
        if (rt > 0) {
            if (this.targetProj_.isGlobal() && this.targetWorldWidth_) {
                const lt = boundingExtent([i, s, a, _]);
                st = getWidth(lt) / this.targetWorldWidth_ > MAX_TRIANGLE_WIDTH || st
            }
            !it && this.sourceProj_.isGlobal() && et && (st = et > MAX_TRIANGLE_WIDTH || st)
        }
        if (!st && this.maxSourceExtent_ && isFinite(ot[0]) && isFinite(ot[1]) && isFinite(ot[2]) && isFinite(ot[3]) && !intersects$1(ot, this.maxSourceExtent_))
            return;
        let at = 0;
        if (!st && (!isFinite($[0]) || !isFinite($[1]) || !isFinite(_e[0]) || !isFinite(_e[1]) || !isFinite(tt[0]) || !isFinite(tt[1]) || !isFinite(nt[0]) || !isFinite(nt[1]))) {
            if (rt > 0)
                st = !0;
            else if (at = (!isFinite($[0]) || !isFinite($[1]) ? 8 : 0) + (!isFinite(_e[0]) || !isFinite(_e[1]) ? 4 : 0) + (!isFinite(tt[0]) || !isFinite(tt[1]) ? 2 : 0) + (!isFinite(nt[0]) || !isFinite(nt[1]) ? 1 : 0),
            at != 1 && at != 2 && at != 4 && at != 8)
                return
        }
        if (rt > 0) {
            if (!st) {
                const lt = [(i[0] + a[0]) / 2, (i[1] + a[1]) / 2]
                  , ct = this.transformInv_(lt);
                let ut;
                it ? ut = (modulo($[0], j) + modulo(tt[0], j)) / 2 - modulo(ct[0], j) : ut = ($[0] + tt[0]) / 2 - ct[0];
                const dt = ($[1] + tt[1]) / 2 - ct[1];
                st = ut * ut + dt * dt > this.errorThresholdSquared_
            }
            if (st) {
                if (Math.abs(i[0] - a[0]) <= Math.abs(i[1] - a[1])) {
                    const lt = [(s[0] + a[0]) / 2, (s[1] + a[1]) / 2]
                      , ct = this.transformInv_(lt)
                      , ut = [(_[0] + i[0]) / 2, (_[1] + i[1]) / 2]
                      , dt = this.transformInv_(ut);
                    this.addQuad_(i, s, lt, ut, $, _e, ct, dt, rt - 1),
                    this.addQuad_(ut, lt, a, _, dt, ct, tt, nt, rt - 1)
                } else {
                    const lt = [(i[0] + s[0]) / 2, (i[1] + s[1]) / 2]
                      , ct = this.transformInv_(lt)
                      , ut = [(a[0] + _[0]) / 2, (a[1] + _[1]) / 2]
                      , dt = this.transformInv_(ut);
                    this.addQuad_(i, lt, ut, _, $, ct, dt, nt, rt - 1),
                    this.addQuad_(lt, s, a, ut, ct, _e, tt, dt, rt - 1)
                }
                return
            }
        }
        if (it) {
            if (!this.canWrapXInSource_)
                return;
            this.wrapsXInSource_ = !0
        }
        at & 11 || this.addTriangle_(i, a, _, $, tt, nt),
        at & 14 || this.addTriangle_(i, a, s, $, tt, _e),
        at && (at & 13 || this.addTriangle_(s, _, i, _e, nt, $),
        at & 7 || this.addTriangle_(s, _, a, _e, nt, tt))
    }
    calculateSourceExtent() {
        const i = createEmpty();
        return this.triangles_.forEach(function(s, a, _) {
            const $ = s.source;
            extendCoordinate(i, $[0]),
            extendCoordinate(i, $[1]),
            extendCoordinate(i, $[2])
        }),
        i
    }
    getTriangles() {
        return this.triangles_
    }
}
const Triangulation$1 = Triangulation;
let brokenDiagonalRendering_;
const canvasPool = [];
function drawTestTriangle(o, i, s, a, _) {
    o.beginPath(),
    o.moveTo(0, 0),
    o.lineTo(i, s),
    o.lineTo(a, _),
    o.closePath(),
    o.save(),
    o.clip(),
    o.fillRect(0, 0, Math.max(i, a) + 1, Math.max(s, _)),
    o.restore()
}
function verifyBrokenDiagonalRendering(o, i) {
    return Math.abs(o[i * 4] - 210) > 2 || Math.abs(o[i * 4 + 3] - .75 * 255) > 2
}
function isBrokenDiagonalRendering() {
    if (brokenDiagonalRendering_ === void 0) {
        const o = createCanvasContext2D(6, 6, canvasPool);
        o.globalCompositeOperation = "lighter",
        o.fillStyle = "rgba(210, 0, 0, 0.75)",
        drawTestTriangle(o, 4, 5, 4, 0),
        drawTestTriangle(o, 4, 5, 0, 5);
        const i = o.getImageData(0, 0, 3, 3).data;
        brokenDiagonalRendering_ = verifyBrokenDiagonalRendering(i, 0) || verifyBrokenDiagonalRendering(i, 4) || verifyBrokenDiagonalRendering(i, 8),
        releaseCanvas$1(o),
        canvasPool.push(o.canvas)
    }
    return brokenDiagonalRendering_
}
function calculateSourceResolution(o, i, s, a) {
    const _ = transform(s, i, o);
    let $ = getPointResolution(i, a, s);
    const _e = i.getMetersPerUnit();
    _e !== void 0 && ($ *= _e);
    const tt = o.getMetersPerUnit();
    tt !== void 0 && ($ /= tt);
    const nt = o.getExtent();
    if (!nt || containsCoordinate(nt, _)) {
        const rt = getPointResolution(o, $, _) / $;
        isFinite(rt) && rt > 0 && ($ /= rt)
    }
    return $
}
function calculateSourceExtentResolution(o, i, s, a) {
    const _ = getCenter(s);
    let $ = calculateSourceResolution(o, i, _, a);
    return (!isFinite($) || $ <= 0) && forEachCorner(s, function(_e) {
        return $ = calculateSourceResolution(o, i, _e, a),
        isFinite($) && $ > 0
    }),
    $
}
function render(o, i, s, a, _, $, _e, tt, nt, rt, ot, et) {
    const j = createCanvasContext2D(Math.round(s * o), Math.round(s * i), canvasPool);
    if (et || (j.imageSmoothingEnabled = !1),
    nt.length === 0)
        return j.canvas;
    j.scale(s, s);
    function it(ft) {
        return Math.round(ft * s) / s
    }
    j.globalCompositeOperation = "lighter";
    const st = createEmpty();
    nt.forEach(function(ft, ht, pt) {
        extend$1(st, ft.extent)
    });
    const at = getWidth(st)
      , lt = getHeight(st)
      , ct = createCanvasContext2D(Math.round(s * at / a), Math.round(s * lt / a), canvasPool);
    et || (ct.imageSmoothingEnabled = !1);
    const ut = s / a;
    nt.forEach(function(ft, ht, pt) {
        const gt = ft.extent[0] - st[0]
          , _t = -(ft.extent[3] - st[3])
          , mt = getWidth(ft.extent)
          , yt = getHeight(ft.extent);
        ft.image.width > 0 && ft.image.height > 0 && ct.drawImage(ft.image, rt, rt, ft.image.width - 2 * rt, ft.image.height - 2 * rt, gt * ut, _t * ut, mt * ut, yt * ut)
    });
    const dt = getTopLeft(_e);
    return tt.getTriangles().forEach(function(ft, ht, pt) {
        const gt = ft.source
          , _t = ft.target;
        let mt = gt[0][0]
          , yt = gt[0][1]
          , bt = gt[1][0]
          , vt = gt[1][1]
          , wt = gt[2][0]
          , Tt = gt[2][1];
        const $t = it((_t[0][0] - dt[0]) / $)
          , Et = it(-(_t[0][1] - dt[1]) / $)
          , Pt = it((_t[1][0] - dt[0]) / $)
          , Rt = it(-(_t[1][1] - dt[1]) / $)
          , At = it((_t[2][0] - dt[0]) / $)
          , Mt = it(-(_t[2][1] - dt[1]) / $)
          , Ut = mt
          , Lt = yt;
        mt = 0,
        yt = 0,
        bt -= Ut,
        vt -= Lt,
        wt -= Ut,
        Tt -= Lt;
        const tn = [[bt, vt, 0, 0, Pt - $t], [wt, Tt, 0, 0, At - $t], [0, 0, bt, vt, Rt - Et], [0, 0, wt, Tt, Mt - Et]]
          , Vt = solveLinearSystem(tn);
        if (Vt) {
            if (j.save(),
            j.beginPath(),
            isBrokenDiagonalRendering() || !et) {
                j.moveTo(Pt, Rt);
                const Nt = 4
                  , Yt = $t - Pt
                  , Xt = Et - Rt;
                for (let jt = 0; jt < Nt; jt++)
                    j.lineTo(Pt + it((jt + 1) * Yt / Nt), Rt + it(jt * Xt / (Nt - 1))),
                    jt != Nt - 1 && j.lineTo(Pt + it((jt + 1) * Yt / Nt), Rt + it((jt + 1) * Xt / (Nt - 1)));
                j.lineTo(At, Mt)
            } else
                j.moveTo(Pt, Rt),
                j.lineTo($t, Et),
                j.lineTo(At, Mt);
            j.clip(),
            j.transform(Vt[0], Vt[2], Vt[1], Vt[3], $t, Et),
            j.translate(st[0] - Ut, st[3] - Lt),
            j.scale(a / s, -a / s),
            j.drawImage(ct.canvas, 0, 0),
            j.restore()
        }
    }),
    releaseCanvas$1(ct),
    canvasPool.push(ct.canvas),
    ot && (j.save(),
    j.globalCompositeOperation = "source-over",
    j.strokeStyle = "black",
    j.lineWidth = 1,
    tt.getTriangles().forEach(function(ft, ht, pt) {
        const gt = ft.target
          , _t = (gt[0][0] - dt[0]) / $
          , mt = -(gt[0][1] - dt[1]) / $
          , yt = (gt[1][0] - dt[0]) / $
          , bt = -(gt[1][1] - dt[1]) / $
          , vt = (gt[2][0] - dt[0]) / $
          , wt = -(gt[2][1] - dt[1]) / $;
        j.beginPath(),
        j.moveTo(yt, bt),
        j.lineTo(_t, mt),
        j.lineTo(vt, wt),
        j.closePath(),
        j.stroke()
    }),
    j.restore()),
    j.canvas
}
class ReprojDataTile extends DataTile$2 {
    constructor(i) {
        super({
            tileCoord: i.tileCoord,
            loader: () => Promise.resolve(new Uint8Array(4)),
            interpolate: i.interpolate,
            transition: i.transition
        }),
        this.pixelRatio_ = i.pixelRatio,
        this.gutter_ = i.gutter,
        this.reprojData_ = null,
        this.reprojError_ = null,
        this.reprojSize_ = void 0,
        this.sourceTileGrid_ = i.sourceTileGrid,
        this.targetTileGrid_ = i.targetTileGrid,
        this.wrappedTileCoord_ = i.wrappedTileCoord || i.tileCoord,
        this.sourceTiles_ = [],
        this.sourcesListenerKeys_ = null,
        this.sourceZ_ = 0;
        const s = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_)
          , a = this.targetTileGrid_.getExtent();
        let _ = this.sourceTileGrid_.getExtent();
        const $ = a ? getIntersection(s, a) : s;
        if (getArea($) === 0) {
            this.state = TileState.EMPTY;
            return
        }
        const _e = i.sourceProj
          , tt = _e.getExtent();
        tt && (_ ? _ = getIntersection(_, tt) : _ = tt);
        const nt = this.targetTileGrid_.getResolution(this.wrappedTileCoord_[0])
          , rt = i.targetProj
          , ot = calculateSourceExtentResolution(_e, rt, $, nt);
        if (!isFinite(ot) || ot <= 0) {
            this.state = TileState.EMPTY;
            return
        }
        const et = i.errorThreshold !== void 0 ? i.errorThreshold : ERROR_THRESHOLD;
        if (this.triangulation_ = new Triangulation$1(_e,rt,$,_,ot * et,nt),
        this.triangulation_.getTriangles().length === 0) {
            this.state = TileState.EMPTY;
            return
        }
        this.sourceZ_ = this.sourceTileGrid_.getZForResolution(ot);
        let j = this.triangulation_.calculateSourceExtent();
        if (_ && (_e.canWrapX() ? (j[1] = clamp(j[1], _[1], _[3]),
        j[3] = clamp(j[3], _[1], _[3])) : j = getIntersection(j, _)),
        !getArea(j))
            this.state = TileState.EMPTY;
        else {
            const it = this.sourceTileGrid_.getTileRangeForExtentAndZ(j, this.sourceZ_)
              , st = i.getTileFunction;
            for (let at = it.minX; at <= it.maxX; at++)
                for (let lt = it.minY; lt <= it.maxY; lt++) {
                    const ct = st(this.sourceZ_, at, lt, this.pixelRatio_);
                    ct && this.sourceTiles_.push(ct)
                }
            this.sourceTiles_.length === 0 && (this.state = TileState.EMPTY)
        }
    }
    getSize() {
        return this.reprojSize_
    }
    getData() {
        return this.reprojData_
    }
    getError() {
        return this.reprojError_
    }
    reproject_() {
        const i = [];
        if (this.sourceTiles_.forEach(s => {
            if (!s || s.getState() !== TileState.LOADED)
                return;
            const a = s.getSize()
              , _ = this.gutter_;
            let $;
            const _e = asArrayLike(s.getData());
            _e ? $ = _e : $ = toArray(asImageLike(s.getData()));
            const tt = [a[0] + 2 * _, a[1] + 2 * _]
              , nt = $ instanceof Float32Array
              , rt = tt[0] * tt[1]
              , ot = nt ? Float32Array : Uint8Array
              , et = new ot($.buffer)
              , j = ot.BYTES_PER_ELEMENT
              , it = j * et.length / rt
              , st = et.byteLength / tt[1]
              , at = Math.floor(st / j / tt[0])
              , lt = rt * at;
            let ct = et;
            if (et.length !== lt) {
                ct = new ot(lt);
                let ut = 0
                  , dt = 0;
                const ft = tt[0] * at;
                for (let ht = 0; ht < tt[1]; ++ht) {
                    for (let pt = 0; pt < ft; ++pt)
                        ct[ut++] = et[dt + pt];
                    dt += st / j
                }
            }
            i.push({
                extent: this.sourceTileGrid_.getTileCoordExtent(s.tileCoord),
                data: new Uint8Array(ct.buffer),
                dataType: ot,
                bytesPerPixel: it,
                pixelSize: tt
            })
        }
        ),
        this.sourceTiles_.length = 0,
        i.length === 0)
            this.state = TileState.ERROR;
        else {
            const s = this.wrappedTileCoord_[0]
              , a = this.targetTileGrid_.getTileSize(s)
              , _ = typeof a == "number" ? a : a[0]
              , $ = typeof a == "number" ? a : a[1]
              , _e = this.targetTileGrid_.getResolution(s)
              , tt = this.sourceTileGrid_.getResolution(this.sourceZ_)
              , nt = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
            let rt, ot;
            const et = i[0].bytesPerPixel
              , j = Math.ceil(et / 3);
            for (let it = j - 1; it >= 0; --it) {
                const st = [];
                for (let ft = 0, ht = i.length; ft < ht; ++ft) {
                    const pt = i[ft]
                      , gt = pt.data
                      , _t = pt.pixelSize
                      , mt = _t[0]
                      , yt = _t[1]
                      , bt = createCanvasContext2D(mt, yt, canvasPool)
                      , vt = bt.createImageData(mt, yt)
                      , wt = vt.data;
                    let Tt = it * 3;
                    for (let $t = 0, Et = wt.length; $t < Et; $t += 4)
                        wt[$t] = gt[Tt],
                        wt[$t + 1] = gt[Tt + 1],
                        wt[$t + 2] = gt[Tt + 2],
                        wt[$t + 3] = 255,
                        Tt += et;
                    bt.putImageData(vt, 0, 0),
                    st.push({
                        extent: pt.extent,
                        image: bt.canvas
                    })
                }
                const at = render(_, $, this.pixelRatio_, tt, this.sourceTileGrid_.getExtent(), _e, nt, this.triangulation_, st, this.gutter_, !1, !1);
                for (let ft = 0, ht = st.length; ft < ht; ++ft) {
                    const gt = st[ft].image.getContext("2d");
                    releaseCanvas$1(gt),
                    canvasPool.push(gt.canvas)
                }
                const lt = at.getContext("2d")
                  , ct = lt.getImageData(0, 0, at.width, at.height);
                releaseCanvas$1(lt),
                canvasPool.push(at),
                rt || (ot = new Uint8Array(et * ct.width * ct.height),
                rt = new i[0].dataType(ot.buffer));
                const ut = ct.data;
                let dt = it * 3;
                for (let ft = 0, ht = ut.length; ft < ht; ft += 4)
                    ut[ft + 3] === 255 ? (ot[dt] = ut[ft],
                    ot[dt + 1] = ut[ft + 1],
                    ot[dt + 2] = ut[ft + 2]) : (ot[dt] = 0,
                    ot[dt + 1] = 0,
                    ot[dt + 2] = 0),
                    dt += et
            }
            this.reprojData_ = rt,
            this.reprojSize_ = [Math.round(_ * this.pixelRatio_), Math.round($ * this.pixelRatio_)],
            this.state = TileState.LOADED
        }
        this.changed()
    }
    load() {
        if (this.state !== TileState.IDLE && this.state !== TileState.ERROR)
            return;
        this.state = TileState.LOADING,
        this.changed();
        let i = 0;
        this.sourcesListenerKeys_ = [],
        this.sourceTiles_.forEach(s => {
            const a = s.getState();
            if (a !== TileState.IDLE && a !== TileState.LOADING)
                return;
            i++;
            const _ = listen(s, EventType.CHANGE, function() {
                const $ = s.getState();
                ($ == TileState.LOADED || $ == TileState.ERROR || $ == TileState.EMPTY) && (unlistenByKey(_),
                i--,
                i === 0 && (this.unlistenSources_(),
                this.reproject_()))
            }, this);
            this.sourcesListenerKeys_.push(_)
        }
        ),
        i === 0 ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach(function(s) {
            s.getState() == TileState.IDLE && s.load()
        })
    }
    unlistenSources_() {
        this.sourcesListenerKeys_.forEach(unlistenByKey),
        this.sourcesListenerKeys_ = null
    }
}
const ReprojDataTile$1 = ReprojDataTile;
class ReprojTile extends Tile$1 {
    constructor(i, s, a, _, $, _e, tt, nt, rt, ot, et, j) {
        super($, TileState.IDLE, {
            interpolate: !!j
        }),
        this.renderEdges_ = et !== void 0 ? et : !1,
        this.pixelRatio_ = tt,
        this.gutter_ = nt,
        this.canvas_ = null,
        this.sourceTileGrid_ = s,
        this.targetTileGrid_ = _,
        this.wrappedTileCoord_ = _e || $,
        this.sourceTiles_ = [],
        this.sourcesListenerKeys_ = null,
        this.sourceZ_ = 0;
        const it = _.getTileCoordExtent(this.wrappedTileCoord_)
          , st = this.targetTileGrid_.getExtent();
        let at = this.sourceTileGrid_.getExtent();
        const lt = st ? getIntersection(it, st) : it;
        if (getArea(lt) === 0) {
            this.state = TileState.EMPTY;
            return
        }
        const ct = i.getExtent();
        ct && (at ? at = getIntersection(at, ct) : at = ct);
        const ut = _.getResolution(this.wrappedTileCoord_[0])
          , dt = calculateSourceExtentResolution(i, a, lt, ut);
        if (!isFinite(dt) || dt <= 0) {
            this.state = TileState.EMPTY;
            return
        }
        const ft = ot !== void 0 ? ot : ERROR_THRESHOLD;
        if (this.triangulation_ = new Triangulation$1(i,a,lt,at,dt * ft,ut),
        this.triangulation_.getTriangles().length === 0) {
            this.state = TileState.EMPTY;
            return
        }
        this.sourceZ_ = s.getZForResolution(dt);
        let ht = this.triangulation_.calculateSourceExtent();
        if (at && (i.canWrapX() ? (ht[1] = clamp(ht[1], at[1], at[3]),
        ht[3] = clamp(ht[3], at[1], at[3])) : ht = getIntersection(ht, at)),
        !getArea(ht))
            this.state = TileState.EMPTY;
        else {
            const pt = s.getTileRangeForExtentAndZ(ht, this.sourceZ_);
            for (let gt = pt.minX; gt <= pt.maxX; gt++)
                for (let _t = pt.minY; _t <= pt.maxY; _t++) {
                    const mt = rt(this.sourceZ_, gt, _t, tt);
                    mt && this.sourceTiles_.push(mt)
                }
            this.sourceTiles_.length === 0 && (this.state = TileState.EMPTY)
        }
    }
    getImage() {
        return this.canvas_
    }
    reproject_() {
        const i = [];
        if (this.sourceTiles_.forEach(s => {
            s && s.getState() == TileState.LOADED && i.push({
                extent: this.sourceTileGrid_.getTileCoordExtent(s.tileCoord),
                image: s.getImage()
            })
        }
        ),
        this.sourceTiles_.length = 0,
        i.length === 0)
            this.state = TileState.ERROR;
        else {
            const s = this.wrappedTileCoord_[0]
              , a = this.targetTileGrid_.getTileSize(s)
              , _ = typeof a == "number" ? a : a[0]
              , $ = typeof a == "number" ? a : a[1]
              , _e = this.targetTileGrid_.getResolution(s)
              , tt = this.sourceTileGrid_.getResolution(this.sourceZ_)
              , nt = this.targetTileGrid_.getTileCoordExtent(this.wrappedTileCoord_);
            this.canvas_ = render(_, $, this.pixelRatio_, tt, this.sourceTileGrid_.getExtent(), _e, nt, this.triangulation_, i, this.gutter_, this.renderEdges_, this.interpolate),
            this.state = TileState.LOADED
        }
        this.changed()
    }
    load() {
        if (this.state == TileState.IDLE) {
            this.state = TileState.LOADING,
            this.changed();
            let i = 0;
            this.sourcesListenerKeys_ = [],
            this.sourceTiles_.forEach(s => {
                const a = s.getState();
                if (a == TileState.IDLE || a == TileState.LOADING) {
                    i++;
                    const _ = listen(s, EventType.CHANGE, function($) {
                        const _e = s.getState();
                        (_e == TileState.LOADED || _e == TileState.ERROR || _e == TileState.EMPTY) && (unlistenByKey(_),
                        i--,
                        i === 0 && (this.unlistenSources_(),
                        this.reproject_()))
                    }, this);
                    this.sourcesListenerKeys_.push(_)
                }
            }
            ),
            i === 0 ? setTimeout(this.reproject_.bind(this), 0) : this.sourceTiles_.forEach(function(s, a, _) {
                s.getState() == TileState.IDLE && s.load()
            })
        }
    }
    unlistenSources_() {
        this.sourcesListenerKeys_.forEach(unlistenByKey),
        this.sourcesListenerKeys_ = null
    }
    release() {
        this.canvas_ && (releaseCanvas$1(this.canvas_.getContext("2d")),
        canvasPool.push(this.canvas_),
        this.canvas_ = null),
        super.release()
    }
}
const ReprojTile$1 = ReprojTile;
class BaseTileRepresentation extends EventTarget {
    constructor(i) {
        super(),
        this.tile,
        this.handleTileChange_ = this.handleTileChange_.bind(this),
        this.gutter_ = i.gutter || 0,
        this.helper_ = i.helper,
        this.loaded = !1,
        this.ready = !1
    }
    setTile(i) {
        if (i !== this.tile)
            if (this.tile && this.tile.removeEventListener(EventType.CHANGE, this.handleTileChange_),
            this.tile = i,
            this.loaded = i.getState() === TileState.LOADED,
            this.loaded)
                this.uploadTile();
            else {
                if (i instanceof ImageTile$1) {
                    const s = i.getImage();
                    s instanceof Image && !s.crossOrigin && (s.crossOrigin = "anonymous")
                }
                i.addEventListener(EventType.CHANGE, this.handleTileChange_)
            }
    }
    uploadTile() {
        abstract()
    }
    setReady() {
        this.ready = !0,
        this.dispatchEvent(EventType.CHANGE)
    }
    handleTileChange_() {
        this.tile.getState() === TileState.LOADED && (this.loaded = !0,
        this.uploadTile())
    }
    disposeInternal() {
        this.tile.removeEventListener(EventType.CHANGE, this.handleTileChange_)
    }
}
const BaseTileRepresentation$1 = BaseTileRepresentation
  , ARRAY_BUFFER = 34962
  , ELEMENT_ARRAY_BUFFER = 34963
  , STREAM_DRAW = 35040
  , STATIC_DRAW = 35044
  , DYNAMIC_DRAW = 35048
  , UNSIGNED_BYTE = 5121
  , UNSIGNED_SHORT = 5123
  , UNSIGNED_INT = 5125
  , FLOAT = 5126
  , CONTEXT_IDS = ["experimental-webgl", "webgl", "webkit-3d", "moz-webgl"];
function getContext(o, i) {
    i = Object.assign({
        preserveDrawingBuffer: !0,
        antialias: !SAFARI_BUG_237906
    }, i);
    const s = CONTEXT_IDS.length;
    for (let a = 0; a < s; ++a)
        try {
            const _ = o.getContext(CONTEXT_IDS[a], i);
            if (_)
                return _
        } catch {}
    return null
}
const BufferUsage = {
    STATIC_DRAW,
    STREAM_DRAW,
    DYNAMIC_DRAW
};
class WebGLArrayBuffer {
    constructor(i, s) {
        this.array = null,
        this.type = i,
        assert(i === ARRAY_BUFFER || i === ELEMENT_ARRAY_BUFFER, "A `WebGLArrayBuffer` must either be of type `ELEMENT_ARRAY_BUFFER` or `ARRAY_BUFFER`"),
        this.usage = s !== void 0 ? s : BufferUsage.STATIC_DRAW
    }
    ofSize(i) {
        return this.array = new (getArrayClassForType(this.type))(i),
        this
    }
    fromArray(i) {
        return this.array = getArrayClassForType(this.type).from(i),
        this
    }
    fromArrayBuffer(i) {
        return this.array = new (getArrayClassForType(this.type))(i),
        this
    }
    getType() {
        return this.type
    }
    getArray() {
        return this.array
    }
    getUsage() {
        return this.usage
    }
    getSize() {
        return this.array ? this.array.length : 0
    }
}
function getArrayClassForType(o) {
    switch (o) {
    case ARRAY_BUFFER:
        return Float32Array;
    case ELEMENT_ARRAY_BUFFER:
        return Uint32Array;
    default:
        return Float32Array
    }
}
const WebGLArrayBuffer$1 = WebGLArrayBuffer;
function bindAndConfigure(o, i, s) {
    const a = s ? o.LINEAR : o.NEAREST;
    o.bindTexture(o.TEXTURE_2D, i),
    o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, o.CLAMP_TO_EDGE),
    o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, o.CLAMP_TO_EDGE),
    o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, a),
    o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, a)
}
function uploadImageTexture(o, i, s, a) {
    bindAndConfigure(o, i, a),
    o.texImage2D(o.TEXTURE_2D, 0, o.RGBA, o.RGBA, o.UNSIGNED_BYTE, s)
}
function uploadDataTexture(o, i, s, a, _, $) {
    const _e = o.getGL();
    let tt, nt;
    s instanceof Float32Array ? (tt = _e.FLOAT,
    o.getExtension("OES_texture_float"),
    nt = o.getExtension("OES_texture_float_linear") !== null) : (tt = _e.UNSIGNED_BYTE,
    nt = !0),
    bindAndConfigure(_e, i, $ && nt);
    const rt = s.byteLength / a[1];
    let ot = 1;
    rt % 8 === 0 ? ot = 8 : rt % 4 === 0 ? ot = 4 : rt % 2 === 0 && (ot = 2);
    let et;
    switch (_) {
    case 1:
        {
            et = _e.LUMINANCE;
            break
        }
    case 2:
        {
            et = _e.LUMINANCE_ALPHA;
            break
        }
    case 3:
        {
            et = _e.RGB;
            break
        }
    case 4:
        {
            et = _e.RGBA;
            break
        }
    default:
        throw new Error(`Unsupported number of bands: ${_}`)
    }
    const j = _e.getParameter(_e.UNPACK_ALIGNMENT);
    _e.pixelStorei(_e.UNPACK_ALIGNMENT, ot),
    _e.texImage2D(_e.TEXTURE_2D, 0, et, a[0], a[1], 0, et, tt, s),
    _e.pixelStorei(_e.UNPACK_ALIGNMENT, j)
}
let pixelContext = null;
function createPixelContext() {
    pixelContext = createCanvasContext2D(1, 1, void 0, {
        willReadFrequently: !0
    })
}
class TileTexture extends BaseTileRepresentation$1 {
    constructor(i) {
        super(i),
        this.textures = [],
        this.renderSize_ = toSize(i.grid.getTileSize(i.tile.tileCoord[0])),
        this.bandCount = NaN;
        const s = new WebGLArrayBuffer$1(ARRAY_BUFFER,STATIC_DRAW);
        s.fromArray([0, 1, 1, 1, 1, 0, 0, 0]),
        this.helper_.flushBufferData(s),
        this.coords = s,
        this.setTile(i.tile)
    }
    uploadTile() {
        const i = this.helper_
          , s = i.getGL()
          , a = this.tile;
        this.textures.length = 0;
        let _;
        a instanceof ImageTile$1 || a instanceof ReprojTile$1 ? _ = a.getImage() : _ = a.getData();
        const $ = asImageLike(_);
        if ($) {
            const ut = s.createTexture();
            this.textures.push(ut),
            this.bandCount = 4,
            uploadImageTexture(s, ut, $, a.interpolate),
            this.setReady();
            return
        }
        _ = asArrayLike(_);
        const _e = a.getSize()
          , tt = [_e[0] + 2 * this.gutter_, _e[1] + 2 * this.gutter_]
          , nt = _ instanceof Float32Array
          , rt = tt[0] * tt[1]
          , ot = nt ? Float32Array : Uint8Array
          , et = ot.BYTES_PER_ELEMENT
          , j = _.byteLength / tt[1];
        this.bandCount = Math.floor(j / et / tt[0]);
        const it = Math.ceil(this.bandCount / 4);
        if (it === 1) {
            const ut = s.createTexture();
            this.textures.push(ut),
            uploadDataTexture(i, ut, _, tt, this.bandCount, a.interpolate),
            this.setReady();
            return
        }
        const st = new Array(it);
        for (let ut = 0; ut < it; ++ut) {
            const dt = s.createTexture();
            this.textures.push(dt);
            const ft = ut < it - 1 ? 4 : (this.bandCount - 1) % 4 + 1;
            st[ut] = new ot(rt * ft)
        }
        let at = 0
          , lt = 0;
        const ct = tt[0] * this.bandCount;
        for (let ut = 0; ut < tt[1]; ++ut) {
            for (let dt = 0; dt < ct; ++dt) {
                const ft = _[lt + dt]
                  , ht = Math.floor(at / this.bandCount)
                  , pt = dt % this.bandCount
                  , gt = Math.floor(pt / 4)
                  , _t = st[gt]
                  , mt = _t.length / rt
                  , yt = pt % 4;
                _t[ht * mt + yt] = ft,
                ++at
            }
            lt += j / et
        }
        for (let ut = 0; ut < it; ++ut) {
            const dt = this.textures[ut]
              , ft = st[ut]
              , ht = ft.length / rt;
            uploadDataTexture(i, dt, ft, tt, ht, a.interpolate)
        }
        this.setReady()
    }
    disposeInternal() {
        const i = this.helper_.getGL();
        this.helper_.deleteBuffer(this.coords);
        for (let s = 0; s < this.textures.length; ++s)
            i.deleteTexture(this.textures[s]);
        this.tile.removeEventListener(EventType.CHANGE, this.handleTileChange_)
    }
    getImagePixelData_(i, s, a) {
        const _ = this.gutter_
          , $ = this.renderSize_[0]
          , _e = this.renderSize_[1];
        pixelContext || createPixelContext(),
        pixelContext.clearRect(0, 0, 1, 1);
        const tt = i.width
          , nt = i.height
          , rt = tt - 2 * _
          , ot = nt - 2 * _
          , et = _ + Math.floor(rt * (s / $))
          , j = _ + Math.floor(ot * (a / _e));
        let it;
        try {
            pixelContext.drawImage(i, et, j, 1, 1, 0, 0, 1, 1),
            it = pixelContext.getImageData(0, 0, 1, 1).data
        } catch {
            return pixelContext = null,
            null
        }
        return it
    }
    getArrayPixelData_(i, s, a, _) {
        const $ = this.gutter_
          , _e = this.renderSize_[0]
          , tt = this.renderSize_[1]
          , nt = s[0]
          , rt = s[1]
          , ot = nt + 2 * $
          , et = rt + 2 * $
          , j = $ + Math.floor(nt * (a / _e))
          , it = $ + Math.floor(rt * (_ / tt));
        if (i instanceof DataView) {
            const at = i.byteLength / (ot * et)
              , lt = at * (it * ot + j)
              , ct = i.buffer.slice(lt, lt + at);
            return new DataView(ct)
        }
        const st = this.bandCount * (it * ot + j);
        return i.slice(st, st + this.bandCount)
    }
    getPixelData(i, s) {
        if (!this.loaded)
            return null;
        if (this.tile instanceof DataTile$2) {
            const a = this.tile.getData()
              , _ = asArrayLike(a);
            if (_) {
                const $ = this.tile.getSize();
                return this.getArrayPixelData_(_, $, i, s)
            }
            return this.getImagePixelData_(asImageLike(a), i, s)
        }
        return this.getImagePixelData_(this.tile.getImage(), i, s)
    }
}
const TileTexture$1 = TileTexture
  , ContextEventType = {
    LOST: "webglcontextlost",
    RESTORED: "webglcontextrestored"
}
  , DEFAULT_VERTEX_SHADER = `
  precision mediump float;
  
  attribute vec2 a_position;
  varying vec2 v_texCoord;
  varying vec2 v_screenCoord;
  
  uniform vec2 u_screenSize;
   
  void main() {
    v_texCoord = a_position * 0.5 + 0.5;
    v_screenCoord = v_texCoord * u_screenSize;
    gl_Position = vec4(a_position, 0.0, 1.0);
  }
`
  , DEFAULT_FRAGMENT_SHADER = `
  precision mediump float;
   
  uniform sampler2D u_image;
  uniform float u_opacity;
   
  varying vec2 v_texCoord;
   
  void main() {
    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;
  }
`;
class WebGLPostProcessingPass {
    constructor(i) {
        this.gl_ = i.webGlContext;
        const s = this.gl_;
        this.scaleRatio_ = i.scaleRatio || 1,
        this.renderTargetTexture_ = s.createTexture(),
        this.renderTargetTextureSize_ = null,
        this.frameBuffer_ = s.createFramebuffer(),
        this.depthBuffer_ = s.createRenderbuffer();
        const a = s.createShader(s.VERTEX_SHADER);
        s.shaderSource(a, i.vertexShader || DEFAULT_VERTEX_SHADER),
        s.compileShader(a);
        const _ = s.createShader(s.FRAGMENT_SHADER);
        s.shaderSource(_, i.fragmentShader || DEFAULT_FRAGMENT_SHADER),
        s.compileShader(_),
        this.renderTargetProgram_ = s.createProgram(),
        s.attachShader(this.renderTargetProgram_, a),
        s.attachShader(this.renderTargetProgram_, _),
        s.linkProgram(this.renderTargetProgram_),
        this.renderTargetVerticesBuffer_ = s.createBuffer();
        const $ = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];
        s.bindBuffer(s.ARRAY_BUFFER, this.renderTargetVerticesBuffer_),
        s.bufferData(s.ARRAY_BUFFER, new Float32Array($), s.STATIC_DRAW),
        this.renderTargetAttribLocation_ = s.getAttribLocation(this.renderTargetProgram_, "a_position"),
        this.renderTargetUniformLocation_ = s.getUniformLocation(this.renderTargetProgram_, "u_screenSize"),
        this.renderTargetOpacityLocation_ = s.getUniformLocation(this.renderTargetProgram_, "u_opacity"),
        this.renderTargetTextureLocation_ = s.getUniformLocation(this.renderTargetProgram_, "u_image"),
        this.uniforms_ = [],
        i.uniforms && Object.keys(i.uniforms).forEach(_e => {
            this.uniforms_.push({
                value: i.uniforms[_e],
                location: s.getUniformLocation(this.renderTargetProgram_, _e)
            })
        }
        )
    }
    getGL() {
        return this.gl_
    }
    init(i) {
        const s = this.getGL()
          , a = [s.drawingBufferWidth * this.scaleRatio_, s.drawingBufferHeight * this.scaleRatio_];
        if (s.bindFramebuffer(s.FRAMEBUFFER, this.getFrameBuffer()),
        s.bindRenderbuffer(s.RENDERBUFFER, this.getDepthBuffer()),
        s.viewport(0, 0, a[0], a[1]),
        !this.renderTargetTextureSize_ || this.renderTargetTextureSize_[0] !== a[0] || this.renderTargetTextureSize_[1] !== a[1]) {
            this.renderTargetTextureSize_ = a;
            const _ = 0
              , $ = s.RGBA
              , _e = 0
              , tt = s.RGBA
              , nt = s.UNSIGNED_BYTE
              , rt = null;
            s.bindTexture(s.TEXTURE_2D, this.renderTargetTexture_),
            s.texImage2D(s.TEXTURE_2D, _, $, a[0], a[1], _e, tt, nt, rt),
            s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.LINEAR),
            s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE),
            s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE),
            s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, this.renderTargetTexture_, 0),
            s.renderbufferStorage(s.RENDERBUFFER, s.DEPTH_COMPONENT16, a[0], a[1]),
            s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.RENDERBUFFER, this.depthBuffer_)
        }
    }
    apply(i, s, a, _) {
        const $ = this.getGL()
          , _e = i.size;
        if ($.bindFramebuffer($.FRAMEBUFFER, s ? s.getFrameBuffer() : null),
        $.activeTexture($.TEXTURE0),
        $.bindTexture($.TEXTURE_2D, this.renderTargetTexture_),
        !s) {
            const nt = getUid($.canvas);
            if (!i.renderTargets[nt]) {
                const rt = $.getContextAttributes();
                rt && rt.preserveDrawingBuffer && ($.clearColor(0, 0, 0, 0),
                $.clearDepth(1),
                $.clear($.COLOR_BUFFER_BIT | $.DEPTH_BUFFER_BIT)),
                i.renderTargets[nt] = !0
            }
        }
        $.disable($.DEPTH_TEST),
        $.enable($.BLEND),
        $.blendFunc($.ONE, $.ONE_MINUS_SRC_ALPHA),
        $.viewport(0, 0, $.drawingBufferWidth, $.drawingBufferHeight),
        $.bindBuffer($.ARRAY_BUFFER, this.renderTargetVerticesBuffer_),
        $.useProgram(this.renderTargetProgram_),
        $.enableVertexAttribArray(this.renderTargetAttribLocation_),
        $.vertexAttribPointer(this.renderTargetAttribLocation_, 2, $.FLOAT, !1, 0, 0),
        $.uniform2f(this.renderTargetUniformLocation_, _e[0], _e[1]),
        $.uniform1i(this.renderTargetTextureLocation_, 0);
        const tt = i.layerStatesArray[i.layerIndex].opacity;
        $.uniform1f(this.renderTargetOpacityLocation_, tt),
        this.applyUniforms(i),
        a && a($, i),
        $.drawArrays($.TRIANGLES, 0, 6),
        _ && _($, i)
    }
    getFrameBuffer() {
        return this.frameBuffer_
    }
    getDepthBuffer() {
        return this.depthBuffer_
    }
    applyUniforms(i) {
        const s = this.getGL();
        let a, _ = 1;
        this.uniforms_.forEach(function($) {
            if (a = typeof $.value == "function" ? $.value(i) : $.value,
            a instanceof HTMLCanvasElement || a instanceof ImageData)
                $.texture || ($.texture = s.createTexture()),
                s.activeTexture(s[`TEXTURE${_}`]),
                s.bindTexture(s.TEXTURE_2D, $.texture),
                s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.LINEAR),
                s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE),
                s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE),
                a instanceof ImageData ? s.texImage2D(s.TEXTURE_2D, 0, s.RGBA, s.RGBA, a.width, a.height, 0, s.UNSIGNED_BYTE, new Uint8Array(a.data)) : s.texImage2D(s.TEXTURE_2D, 0, s.RGBA, s.RGBA, s.UNSIGNED_BYTE, a),
                s.uniform1i($.location, _++);
            else if (Array.isArray(a))
                switch (a.length) {
                case 2:
                    s.uniform2f($.location, a[0], a[1]);
                    return;
                case 3:
                    s.uniform3f($.location, a[0], a[1], a[2]);
                    return;
                case 4:
                    s.uniform4f($.location, a[0], a[1], a[2], a[3]);
                    return;
                default:
                    return
                }
            else
                typeof a == "number" && s.uniform1f($.location, a)
        })
    }
}
const WebGLPostProcessingPass$1 = WebGLPostProcessingPass;
function create() {
    return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
}
function fromTransform(o, i) {
    return o[0] = i[0],
    o[1] = i[1],
    o[4] = i[2],
    o[5] = i[3],
    o[12] = i[4],
    o[13] = i[5],
    o
}
const DefaultUniform = {
    PROJECTION_MATRIX: "u_projectionMatrix",
    TIME: "u_time",
    ZOOM: "u_zoom",
    RESOLUTION: "u_resolution",
    ROTATION: "u_rotation",
    VIEWPORT_SIZE_PX: "u_viewportSizePx",
    PIXEL_RATIO: "u_pixelRatio",
    HIT_DETECTION: "u_hitDetection"
}
  , AttributeType = {
    UNSIGNED_BYTE,
    UNSIGNED_SHORT,
    UNSIGNED_INT,
    FLOAT
}
  , canvasCache = {};
function getSharedCanvasCacheKey(o) {
    return "shared/" + o
}
let uniqueCanvasCacheKeyCount = 0;
function getUniqueCanvasCacheKey() {
    const o = "unique/" + uniqueCanvasCacheKeyCount;
    return uniqueCanvasCacheKeyCount += 1,
    o
}
function getOrCreateContext(o) {
    let i = canvasCache[o];
    if (!i) {
        const s = document.createElement("canvas");
        s.width = 1,
        s.height = 1,
        s.style.position = "absolute",
        s.style.left = "0",
        i = {
            users: 0,
            context: getContext(s)
        },
        canvasCache[o] = i
    }
    return i.users += 1,
    i.context
}
function releaseCanvas(o) {
    const i = canvasCache[o];
    if (!i || (i.users -= 1,
    i.users > 0))
        return;
    const s = i.context
      , a = s.getExtension("WEBGL_lose_context");
    a && a.loseContext();
    const _ = s.canvas;
    _.width = 1,
    _.height = 1,
    delete canvasCache[o]
}
class WebGLHelper extends Disposable$1 {
    constructor(i) {
        super(),
        i = i || {},
        this.boundHandleWebGLContextLost_ = this.handleWebGLContextLost.bind(this),
        this.boundHandleWebGLContextRestored_ = this.handleWebGLContextRestored.bind(this),
        this.canvasCacheKey_ = i.canvasCacheKey ? getSharedCanvasCacheKey(i.canvasCacheKey) : getUniqueCanvasCacheKey(),
        this.gl_ = getOrCreateContext(this.canvasCacheKey_),
        this.bufferCache_ = {},
        this.extensionCache_ = {},
        this.currentProgram_ = null;
        const s = this.gl_.canvas;
        s.addEventListener(ContextEventType.LOST, this.boundHandleWebGLContextLost_),
        s.addEventListener(ContextEventType.RESTORED, this.boundHandleWebGLContextRestored_),
        this.offsetRotateMatrix_ = create$1(),
        this.offsetScaleMatrix_ = create$1(),
        this.tmpMat4_ = create(),
        this.uniformLocationsByProgram_ = {},
        this.attribLocationsByProgram_ = {},
        this.uniforms_ = [],
        i.uniforms && this.setUniforms(i.uniforms),
        this.postProcessPasses_ = i.postProcesses ? i.postProcesses.map(a => new WebGLPostProcessingPass$1({
            webGlContext: this.gl_,
            scaleRatio: a.scaleRatio,
            vertexShader: a.vertexShader,
            fragmentShader: a.fragmentShader,
            uniforms: a.uniforms
        })) : [new WebGLPostProcessingPass$1({
            webGlContext: this.gl_
        })],
        this.shaderCompileErrors_ = null,
        this.startTime_ = Date.now()
    }
    setUniforms(i) {
        this.uniforms_ = [],
        this.addUniforms(i)
    }
    addUniforms(i) {
        for (const s in i)
            this.uniforms_.push({
                name: s,
                value: i[s]
            })
    }
    canvasCacheKeyMatches(i) {
        return this.canvasCacheKey_ === getSharedCanvasCacheKey(i)
    }
    getExtension(i) {
        if (i in this.extensionCache_)
            return this.extensionCache_[i];
        const s = this.gl_.getExtension(i);
        return this.extensionCache_[i] = s,
        s
    }
    bindBuffer(i) {
        const s = this.gl_
          , a = getUid(i);
        let _ = this.bufferCache_[a];
        if (!_) {
            const $ = s.createBuffer();
            _ = {
                buffer: i,
                webGlBuffer: $
            },
            this.bufferCache_[a] = _
        }
        s.bindBuffer(i.getType(), _.webGlBuffer)
    }
    flushBufferData(i) {
        const s = this.gl_;
        this.bindBuffer(i),
        s.bufferData(i.getType(), i.getArray(), i.getUsage())
    }
    deleteBuffer(i) {
        const s = this.gl_
          , a = getUid(i)
          , _ = this.bufferCache_[a];
        _ && !s.isContextLost() && s.deleteBuffer(_.webGlBuffer),
        delete this.bufferCache_[a]
    }
    disposeInternal() {
        const i = this.gl_.canvas;
        i.removeEventListener(ContextEventType.LOST, this.boundHandleWebGLContextLost_),
        i.removeEventListener(ContextEventType.RESTORED, this.boundHandleWebGLContextRestored_),
        releaseCanvas(this.canvasCacheKey_),
        delete this.gl_
    }
    prepareDraw(i, s, a) {
        const _ = this.gl_
          , $ = this.getCanvas()
          , _e = i.size
          , tt = i.pixelRatio;
        ($.width !== _e[0] * tt || $.height !== _e[1] * tt) && ($.width = _e[0] * tt,
        $.height = _e[1] * tt,
        $.style.width = _e[0] + "px",
        $.style.height = _e[1] + "px");
        for (let nt = this.postProcessPasses_.length - 1; nt >= 0; nt--)
            this.postProcessPasses_[nt].init(i);
        _.bindTexture(_.TEXTURE_2D, null),
        _.clearColor(0, 0, 0, 0),
        _.depthRange(0, 1),
        _.clearDepth(1),
        _.clear(_.COLOR_BUFFER_BIT | _.DEPTH_BUFFER_BIT),
        _.enable(_.BLEND),
        _.blendFunc(_.ONE, s ? _.ZERO : _.ONE_MINUS_SRC_ALPHA),
        a ? (_.enable(_.DEPTH_TEST),
        _.depthFunc(_.LEQUAL)) : _.disable(_.DEPTH_TEST)
    }
    bindTexture(i, s, a) {
        const _ = this.gl_;
        _.activeTexture(_.TEXTURE0 + s),
        _.bindTexture(_.TEXTURE_2D, i),
        _.uniform1i(this.getUniformLocation(a), s)
    }
    prepareDrawToRenderTarget(i, s, a, _) {
        const $ = this.gl_
          , _e = s.getSize();
        $.bindFramebuffer($.FRAMEBUFFER, s.getFramebuffer()),
        $.bindRenderbuffer($.RENDERBUFFER, s.getDepthbuffer()),
        $.viewport(0, 0, _e[0], _e[1]),
        $.bindTexture($.TEXTURE_2D, s.getTexture()),
        $.clearColor(0, 0, 0, 0),
        $.depthRange(0, 1),
        $.clearDepth(1),
        $.clear($.COLOR_BUFFER_BIT | $.DEPTH_BUFFER_BIT),
        $.enable($.BLEND),
        $.blendFunc($.ONE, a ? $.ZERO : $.ONE_MINUS_SRC_ALPHA),
        _ ? ($.enable($.DEPTH_TEST),
        $.depthFunc($.LEQUAL)) : $.disable($.DEPTH_TEST)
    }
    drawElements(i, s) {
        const a = this.gl_;
        this.getExtension("OES_element_index_uint");
        const _ = a.UNSIGNED_INT
          , $ = 4
          , _e = s - i
          , tt = i * $;
        a.drawElements(a.TRIANGLES, _e, _, tt)
    }
    finalizeDraw(i, s, a) {
        for (let _ = 0, $ = this.postProcessPasses_.length; _ < $; _++)
            _ === $ - 1 ? this.postProcessPasses_[_].apply(i, null, s, a) : this.postProcessPasses_[_].apply(i, this.postProcessPasses_[_ + 1])
    }
    getCanvas() {
        return this.gl_.canvas
    }
    getGL() {
        return this.gl_
    }
    applyFrameState(i) {
        const s = i.size
          , a = i.viewState.rotation
          , _ = i.pixelRatio;
        this.setUniformFloatValue(DefaultUniform.TIME, (Date.now() - this.startTime_) * .001),
        this.setUniformFloatValue(DefaultUniform.ZOOM, i.viewState.zoom),
        this.setUniformFloatValue(DefaultUniform.RESOLUTION, i.viewState.resolution),
        this.setUniformFloatValue(DefaultUniform.PIXEL_RATIO, _),
        this.setUniformFloatVec2(DefaultUniform.VIEWPORT_SIZE_PX, [s[0], s[1]]),
        this.setUniformFloatValue(DefaultUniform.ROTATION, a)
    }
    applyHitDetectionUniform(i) {
        const s = this.getUniformLocation(DefaultUniform.HIT_DETECTION);
        this.getGL().uniform1i(s, i ? 1 : 0),
        i && this.setUniformFloatValue(DefaultUniform.PIXEL_RATIO, .5)
    }
    applyUniforms(i) {
        const s = this.gl_;
        let a, _ = 0;
        this.uniforms_.forEach($ => {
            if (a = typeof $.value == "function" ? $.value(i) : $.value,
            a instanceof HTMLCanvasElement || a instanceof HTMLImageElement || a instanceof ImageData)
                $.texture || ($.prevValue = void 0,
                $.texture = s.createTexture()),
                this.bindTexture($.texture, _, $.name),
                s.texParameteri(s.TEXTURE_2D, s.TEXTURE_MIN_FILTER, s.LINEAR),
                s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE),
                s.texParameteri(s.TEXTURE_2D, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE),
                (!(a instanceof HTMLImageElement) || a.complete) && $.prevValue !== a && ($.prevValue = a,
                s.texImage2D(s.TEXTURE_2D, 0, s.RGBA, s.RGBA, s.UNSIGNED_BYTE, a)),
                _++;
            else if (Array.isArray(a) && a.length === 6)
                this.setUniformMatrixValue($.name, fromTransform(this.tmpMat4_, a));
            else if (Array.isArray(a) && a.length <= 4)
                switch (a.length) {
                case 2:
                    s.uniform2f(this.getUniformLocation($.name), a[0], a[1]);
                    return;
                case 3:
                    s.uniform3f(this.getUniformLocation($.name), a[0], a[1], a[2]);
                    return;
                case 4:
                    s.uniform4f(this.getUniformLocation($.name), a[0], a[1], a[2], a[3]);
                    return;
                default:
                    return
                }
            else
                typeof a == "number" && s.uniform1f(this.getUniformLocation($.name), a)
        }
        )
    }
    useProgram(i, s) {
        this.gl_.useProgram(i),
        this.currentProgram_ = i,
        this.applyFrameState(s),
        this.applyUniforms(s)
    }
    compileShader(i, s) {
        const a = this.gl_
          , _ = a.createShader(s);
        return a.shaderSource(_, i),
        a.compileShader(_),
        _
    }
    getProgram(i, s) {
        const a = this.gl_
          , _ = this.compileShader(i, a.FRAGMENT_SHADER)
          , $ = this.compileShader(s, a.VERTEX_SHADER)
          , _e = a.createProgram();
        if (a.attachShader(_e, _),
        a.attachShader(_e, $),
        a.linkProgram(_e),
        !a.getShaderParameter(_, a.COMPILE_STATUS)) {
            const tt = `Fragment shader compilation failed: ${a.getShaderInfoLog(_)}`;
            throw new Error(tt)
        }
        if (a.deleteShader(_),
        !a.getShaderParameter($, a.COMPILE_STATUS)) {
            const tt = `Vertex shader compilation failed: ${a.getShaderInfoLog($)}`;
            throw new Error(tt)
        }
        if (a.deleteShader($),
        !a.getProgramParameter(_e, a.LINK_STATUS)) {
            const tt = `GL program linking failed: ${a.getProgramInfoLog(_e)}`;
            throw new Error(tt)
        }
        return _e
    }
    getUniformLocation(i) {
        const s = getUid(this.currentProgram_);
        return this.uniformLocationsByProgram_[s] === void 0 && (this.uniformLocationsByProgram_[s] = {}),
        this.uniformLocationsByProgram_[s][i] === void 0 && (this.uniformLocationsByProgram_[s][i] = this.gl_.getUniformLocation(this.currentProgram_, i)),
        this.uniformLocationsByProgram_[s][i]
    }
    getAttributeLocation(i) {
        const s = getUid(this.currentProgram_);
        return this.attribLocationsByProgram_[s] === void 0 && (this.attribLocationsByProgram_[s] = {}),
        this.attribLocationsByProgram_[s][i] === void 0 && (this.attribLocationsByProgram_[s][i] = this.gl_.getAttribLocation(this.currentProgram_, i)),
        this.attribLocationsByProgram_[s][i]
    }
    makeProjectionTransform(i, s) {
        const a = i.size
          , _ = i.viewState.rotation
          , $ = i.viewState.resolution
          , _e = i.viewState.center;
        return compose(s, 0, 0, 2 / ($ * a[0]), 2 / ($ * a[1]), -_, -_e[0], -_e[1]),
        s
    }
    setUniformFloatValue(i, s) {
        this.gl_.uniform1f(this.getUniformLocation(i), s)
    }
    setUniformFloatVec2(i, s) {
        this.gl_.uniform2fv(this.getUniformLocation(i), s)
    }
    setUniformFloatVec4(i, s) {
        this.gl_.uniform4fv(this.getUniformLocation(i), s)
    }
    setUniformMatrixValue(i, s) {
        this.gl_.uniformMatrix4fv(this.getUniformLocation(i), !1, s)
    }
    enableAttributeArray_(i, s, a, _, $) {
        const _e = this.getAttributeLocation(i);
        _e < 0 || (this.gl_.enableVertexAttribArray(_e),
        this.gl_.vertexAttribPointer(_e, s, a, !1, _, $))
    }
    enableAttributes(i) {
        const s = computeAttributesStride(i);
        let a = 0;
        for (let _ = 0; _ < i.length; _++) {
            const $ = i[_];
            this.enableAttributeArray_($.name, $.size, $.type || FLOAT, s, a),
            a += $.size * getByteSizeFromType($.type)
        }
    }
    handleWebGLContextLost() {
        clear(this.bufferCache_),
        this.currentProgram_ = null
    }
    handleWebGLContextRestored() {}
    createTexture(i, s, a) {
        const _ = this.gl_;
        a = a || _.createTexture();
        const $ = 0
          , _e = _.RGBA
          , tt = 0
          , nt = _.RGBA
          , rt = _.UNSIGNED_BYTE;
        return _.bindTexture(_.TEXTURE_2D, a),
        s ? _.texImage2D(_.TEXTURE_2D, $, _e, nt, rt, s) : _.texImage2D(_.TEXTURE_2D, $, _e, i[0], i[1], tt, nt, rt, null),
        _.texParameteri(_.TEXTURE_2D, _.TEXTURE_MIN_FILTER, _.LINEAR),
        _.texParameteri(_.TEXTURE_2D, _.TEXTURE_WRAP_S, _.CLAMP_TO_EDGE),
        _.texParameteri(_.TEXTURE_2D, _.TEXTURE_WRAP_T, _.CLAMP_TO_EDGE),
        a
    }
}
function computeAttributesStride(o) {
    let i = 0;
    for (let s = 0; s < o.length; s++) {
        const a = o[s];
        i += a.size * getByteSizeFromType(a.type)
    }
    return i
}
function getByteSizeFromType(o) {
    switch (o) {
    case AttributeType.UNSIGNED_BYTE:
        return Uint8Array.BYTES_PER_ELEMENT;
    case AttributeType.UNSIGNED_SHORT:
        return Uint16Array.BYTES_PER_ELEMENT;
    case AttributeType.UNSIGNED_INT:
        return Uint32Array.BYTES_PER_ELEMENT;
    case AttributeType.FLOAT:
    default:
        return Float32Array.BYTES_PER_ELEMENT
    }
}
class WebGLLayerRenderer extends LayerRenderer$1 {
    constructor(i, s) {
        super(i),
        s = s || {},
        this.inversePixelTransform_ = create$1(),
        this.pixelContext_ = null,
        this.postProcesses_ = s.postProcesses,
        this.uniforms_ = s.uniforms,
        this.helper,
        i.addChangeListener(LayerProperty.MAP, this.removeHelper.bind(this)),
        this.dispatchPreComposeEvent = this.dispatchPreComposeEvent.bind(this),
        this.dispatchPostComposeEvent = this.dispatchPostComposeEvent.bind(this)
    }
    dispatchPreComposeEvent(i, s) {
        const a = this.getLayer();
        if (a.hasListener(RenderEventType.PRECOMPOSE)) {
            const _ = new RenderEvent$1(RenderEventType.PRECOMPOSE,void 0,s,i);
            a.dispatchEvent(_)
        }
    }
    dispatchPostComposeEvent(i, s) {
        const a = this.getLayer();
        if (a.hasListener(RenderEventType.POSTCOMPOSE)) {
            const _ = new RenderEvent$1(RenderEventType.POSTCOMPOSE,void 0,s,i);
            a.dispatchEvent(_)
        }
    }
    reset(i) {
        this.uniforms_ = i.uniforms,
        this.helper && this.helper.setUniforms(this.uniforms_)
    }
    removeHelper() {
        this.helper && (this.helper.dispose(),
        delete this.helper)
    }
    prepareFrame(i) {
        if (this.getLayer().getRenderSource()) {
            let s = !0, a = -1, _;
            for (let _e = 0, tt = i.layerStatesArray.length; _e < tt; _e++) {
                const nt = i.layerStatesArray[_e].layer
                  , rt = nt.getRenderer();
                if (!(rt instanceof WebGLLayerRenderer)) {
                    s = !0;
                    continue
                }
                const ot = nt.getClassName();
                if ((s || ot !== _) && (a += 1,
                s = !1),
                _ = ot,
                rt === this)
                    break
            }
            const $ = "map/" + i.mapId + "/group/" + a;
            (!this.helper || !this.helper.canvasCacheKeyMatches($)) && (this.removeHelper(),
            this.helper = new WebGLHelper({
                postProcesses: this.postProcesses_,
                uniforms: this.uniforms_,
                canvasCacheKey: $
            }),
            _ && (this.helper.getCanvas().className = _),
            this.afterHelperCreated())
        }
        return this.prepareFrameInternal(i)
    }
    afterHelperCreated() {}
    prepareFrameInternal(i) {
        return !0
    }
    disposeInternal() {
        this.removeHelper(),
        super.disposeInternal()
    }
    dispatchRenderEvent_(i, s, a) {
        const _ = this.getLayer();
        if (_.hasListener(i)) {
            compose(this.inversePixelTransform_, 0, 0, a.pixelRatio, -a.pixelRatio, 0, 0, -a.size[1]);
            const $ = new RenderEvent$1(i,this.inversePixelTransform_,a,s);
            _.dispatchEvent($)
        }
    }
    preRender(i, s) {
        this.dispatchRenderEvent_(RenderEventType.PRERENDER, i, s)
    }
    postRender(i, s) {
        this.dispatchRenderEvent_(RenderEventType.POSTRENDER, i, s)
    }
}
const WebGLLayerRenderer$1 = WebGLLayerRenderer
  , Uniforms$1 = {
    TILE_TRANSFORM: "u_tileTransform",
    TRANSITION_ALPHA: "u_transitionAlpha",
    DEPTH: "u_depth",
    RENDER_EXTENT: "u_renderExtent",
    RESOLUTION: "u_resolution",
    ZOOM: "u_zoom",
    GLOBAL_ALPHA: "u_globalAlpha",
    PROJECTION_MATRIX: "u_projectionMatrix",
    SCREEN_TO_WORLD_MATRIX: "u_screenToWorldMatrix"
}
  , empty = {};
function depthForZ(o) {
    return 1 / (o + 2)
}
function newTileRepresentationLookup() {
    return {
        tileIds: new Set,
        representationsByZ: {}
    }
}
function lookupHasTile(o, i) {
    return o.tileIds.has(getUid(i))
}
function addTileRepresentationToLookup(o, i, s) {
    const a = o.representationsByZ;
    s in a || (a[s] = new Set),
    a[s].add(i),
    o.tileIds.add(getUid(i.tile))
}
function getRenderExtent(o, i) {
    const s = o.layerStatesArray[o.layerIndex];
    s.extent && (i = getIntersection(i, fromUserExtent(s.extent, o.viewState.projection)));
    const a = s.layer.getRenderSource();
    if (!a.getWrapX()) {
        const _ = a.getTileGridForProjection(o.viewState.projection).getExtent();
        _ && (i = getIntersection(i, _))
    }
    return i
}
function getCacheKey(o, i) {
    return `${o.getKey()},${getKey(i)}`
}
class WebGLBaseTileLayerRenderer extends WebGLLayerRenderer$1 {
    constructor(i, s) {
        super(i, {
            uniforms: s.uniforms,
            postProcesses: s.postProcesses
        }),
        this.renderComplete = !1,
        this.tileTransform_ = create$1(),
        this.tempMat4 = create(),
        this.tempTileRange_ = new TileRange$1(0,0,0,0),
        this.tempTileCoord_ = createOrUpdate$1(0, 0, 0),
        this.tempSize_ = [0, 0];
        const a = s.cacheSize !== void 0 ? s.cacheSize : 512;
        this.tileRepresentationCache = new LRUCache$1(a),
        this.frameState = null,
        this.projection_ = void 0
    }
    reset(i) {
        super.reset({
            uniforms: i.uniforms
        })
    }
    isDrawableTile_(i) {
        const s = this.getLayer()
          , a = i.getState()
          , _ = s.getUseInterimTilesOnError();
        return a == TileState.LOADED || a == TileState.EMPTY || a == TileState.ERROR && !_
    }
    prepareFrameInternal(i) {
        this.projection_ ? i.viewState.projection !== this.projection_ && (this.clearCache(),
        this.projection_ = i.viewState.projection) : this.projection_ = i.viewState.projection;
        const a = this.getLayer().getRenderSource();
        return !a || isEmpty(getRenderExtent(i, i.extent)) ? !1 : a.getState() === "ready"
    }
    createTileRepresentation(i) {
        return abstract()
    }
    enqueueTiles(i, s, a, _, $) {
        const _e = i.viewState
          , tt = this.getLayer()
          , nt = tt.getRenderSource()
          , rt = nt.getTileGridForProjection(_e.projection)
          , ot = nt.getGutterForProjection(_e.projection)
          , et = getUid(nt);
        et in i.wantedTiles || (i.wantedTiles[et] = {});
        const j = i.wantedTiles[et]
          , it = this.tileRepresentationCache
          , st = tt.getMapInternal()
          , at = Math.max(a - $, rt.getMinZoom(), rt.getZForResolution(Math.min(tt.getMaxResolution(), st ? st.getView().getResolutionForZoom(Math.max(tt.getMinZoom(), 0)) : rt.getResolution(0)), nt.zDirection));
        for (let lt = a; lt >= at; --lt) {
            const ct = rt.getTileRangeForExtentAndZ(s, lt, this.tempTileRange_)
              , ut = rt.getResolution(lt);
            for (let dt = ct.minX; dt <= ct.maxX; ++dt)
                for (let ft = ct.minY; ft <= ct.maxY; ++ft) {
                    const ht = createOrUpdate$1(lt, dt, ft, this.tempTileCoord_)
                      , pt = getCacheKey(nt, ht);
                    let gt, _t;
                    if (it.containsKey(pt) && (gt = it.get(pt),
                    _t = gt.tile),
                    (!gt || gt.tile.key !== nt.getKey()) && (_t = nt.getTile(lt, dt, ft, i.pixelRatio, _e.projection)),
                    lookupHasTile(_, _t))
                        continue;
                    if (!gt)
                        gt = this.createTileRepresentation({
                            tile: _t,
                            grid: rt,
                            helper: this.helper,
                            gutter: ot
                        }),
                        it.set(pt, gt);
                    else if (this.isDrawableTile_(_t))
                        gt.setTile(_t);
                    else {
                        const yt = _t.getInterimTile();
                        gt.setTile(yt)
                    }
                    addTileRepresentationToLookup(_, gt, lt);
                    const mt = _t.getKey();
                    j[mt] = !0,
                    _t.getState() === TileState.IDLE && (i.tileQueue.isKeyQueued(mt) || i.tileQueue.enqueue([_t, et, rt.getTileCoordCenter(ht), ut]))
                }
        }
    }
    beforeTilesRender(i, s) {
        this.helper.prepareDraw(this.frameState, !s, !0)
    }
    renderTile(i, s, a, _, $, _e, tt, nt, rt, ot, et) {}
    drawTile_(i, s, a, _, $, _e, tt) {
        if (!s.loaded)
            return;
        const rt = s.tile.tileCoord
          , ot = getKey(rt)
          , et = ot in _e ? _e[ot] : 1
          , j = tt.getResolution(a)
          , it = toSize(tt.getTileSize(a), this.tempSize_)
          , st = tt.getOrigin(a)
          , at = tt.getTileCoordExtent(rt)
          , lt = et < 1 ? -1 : depthForZ(a);
        et < 1 && (i.animate = !0);
        const ct = i.viewState
          , ut = ct.center[0]
          , dt = ct.center[1]
          , ft = it[0] + 2 * _
          , ht = it[1] + 2 * _
          , pt = ft / ht
          , gt = (ut - st[0]) / (it[0] * j)
          , _t = (st[1] - dt) / (it[1] * j)
          , mt = ct.resolution / j
          , yt = rt[1]
          , bt = rt[2];
        reset(this.tileTransform_),
        scale$3(this.tileTransform_, 2 / (i.size[0] * mt / ft), -2 / (i.size[1] * mt / ft)),
        rotate$2(this.tileTransform_, ct.rotation),
        scale$3(this.tileTransform_, 1, 1 / pt),
        translate$1(this.tileTransform_, (it[0] * (yt - gt) - _) / ft, (it[1] * (bt - _t) - _) / ht),
        this.renderTile(s, this.tileTransform_, i, $, j, it, st, at, lt, _, et)
    }
    renderFrame(i) {
        this.frameState = i,
        this.renderComplete = !0;
        const s = this.helper.getGL();
        this.preRender(s, i);
        const a = i.viewState
          , _ = this.getLayer()
          , $ = _.getRenderSource()
          , _e = $.getTileGridForProjection(a.projection)
          , tt = $.getGutterForProjection(a.projection)
          , nt = getRenderExtent(i, i.extent)
          , rt = _e.getZForResolution(a.resolution, $.zDirection)
          , ot = newTileRepresentationLookup()
          , et = _.getPreload();
        if (i.nextExtent) {
            const ht = _e.getZForResolution(a.nextResolution, $.zDirection)
              , pt = getRenderExtent(i, i.nextExtent);
            this.enqueueTiles(i, pt, ht, ot, et)
        }
        this.enqueueTiles(i, nt, rt, ot, 0),
        et > 0 && setTimeout( () => {
            this.enqueueTiles(i, nt, rt - 1, ot, et - 1)
        }
        , 0);
        const j = {}
          , it = getUid(this)
          , st = i.time;
        let at = !1;
        for (const ht of ot.representationsByZ[rt]) {
            const pt = ht.tile;
            if ((pt instanceof ReprojTile$1 || pt instanceof ReprojDataTile$1) && pt.getState() === TileState.EMPTY)
                continue;
            const gt = pt.tileCoord;
            if (ht.loaded) {
                const yt = pt.getAlpha(it, st);
                if (yt === 1) {
                    pt.endTransition(it);
                    continue
                }
                at = !0;
                const bt = getKey(gt);
                j[bt] = yt
            }
            if (this.renderComplete = !1,
            this.findAltTiles_(_e, gt, rt + 1, ot))
                continue;
            const mt = _e.getMinZoom();
            for (let yt = rt - 1; yt >= mt && !this.findAltTiles_(_e, gt, yt, ot); --yt)
                ;
        }
        this.beforeTilesRender(i, at);
        const lt = ot.representationsByZ
          , ct = Object.keys(lt).map(Number).sort(descending);
        for (let ht = 0, pt = ct.length; ht < pt; ++ht) {
            const gt = ct[ht];
            for (const _t of lt[gt]) {
                const mt = _t.tile.tileCoord;
                getKey(mt)in j || this.drawTile_(i, _t, gt, tt, nt, j, _e)
            }
        }
        for (const ht of lt[rt]) {
            const pt = ht.tile.tileCoord;
            getKey(pt)in j && this.drawTile_(i, ht, rt, tt, nt, j, _e)
        }
        this.helper.finalizeDraw(i, this.dispatchPreComposeEvent, this.dispatchPostComposeEvent);
        const ut = this.helper.getCanvas()
          , dt = this.tileRepresentationCache;
        for (; dt.canExpireCache(); )
            dt.pop().dispose();
        const ft = function(ht, pt) {
            $.updateCacheSize(.1, pt.viewState.projection),
            $.expireCache(pt.viewState.projection, empty)
        };
        return i.postRenderFunctions.push(ft),
        this.postRender(s, i),
        ut
    }
    findAltTiles_(i, s, a, _) {
        const $ = i.getTileRangeForTileCoordAndZ(s, a, this.tempTileRange_);
        if (!$)
            return !1;
        let _e = !0;
        const tt = this.tileRepresentationCache
          , nt = this.getLayer().getRenderSource();
        for (let rt = $.minX; rt <= $.maxX; ++rt)
            for (let ot = $.minY; ot <= $.maxY; ++ot) {
                const et = getCacheKey(nt, [a, rt, ot]);
                let j = !1;
                if (tt.containsKey(et)) {
                    const it = tt.get(et);
                    it.loaded && !lookupHasTile(_, it.tile) && (addTileRepresentationToLookup(_, it, a),
                    j = !0)
                }
                j || (_e = !1)
            }
        return _e
    }
    clearCache() {
        const i = this.tileRepresentationCache;
        i.forEach(s => s.dispose()),
        i.clear()
    }
    removeHelper() {
        this.helper && this.clearCache(),
        super.removeHelper()
    }
    disposeInternal() {
        super.disposeInternal(),
        delete this.frameState
    }
}
const WebGLBaseTileLayerRenderer$1 = WebGLBaseTileLayerRenderer
  , Uniforms = {
    ...Uniforms$1,
    TILE_TEXTURE_ARRAY: "u_tileTextures",
    TEXTURE_PIXEL_WIDTH: "u_texturePixelWidth",
    TEXTURE_PIXEL_HEIGHT: "u_texturePixelHeight",
    TEXTURE_RESOLUTION: "u_textureResolution",
    TEXTURE_ORIGIN_X: "u_textureOriginX",
    TEXTURE_ORIGIN_Y: "u_textureOriginY"
}
  , Attributes = {
    TEXTURE_COORD: "a_textureCoord"
}
  , attributeDescriptions = [{
    name: Attributes.TEXTURE_COORD,
    size: 2,
    type: AttributeType.FLOAT
}];
class WebGLTileLayerRenderer extends WebGLBaseTileLayerRenderer$1 {
    constructor(i, s) {
        super(i, s),
        this.program_,
        this.vertexShader_ = s.vertexShader,
        this.fragmentShader_ = s.fragmentShader,
        this.indices_ = new WebGLArrayBuffer$1(ELEMENT_ARRAY_BUFFER,STATIC_DRAW),
        this.indices_.fromArray([0, 1, 3, 1, 2, 3]),
        this.paletteTextures_ = s.paletteTextures || []
    }
    reset(i) {
        super.reset(i),
        this.vertexShader_ = i.vertexShader,
        this.fragmentShader_ = i.fragmentShader,
        this.helper && (this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_))
    }
    afterHelperCreated() {
        this.program_ = this.helper.getProgram(this.fragmentShader_, this.vertexShader_),
        this.helper.flushBufferData(this.indices_)
    }
    createTileRepresentation(i) {
        return new TileTexture$1(i)
    }
    beforeTilesRender(i, s) {
        super.beforeTilesRender(i, s),
        this.helper.useProgram(this.program_, i)
    }
    renderTile(i, s, a, _, $, _e, tt, nt, rt, ot, et) {
        const j = this.helper.getGL();
        this.helper.bindBuffer(i.coords),
        this.helper.bindBuffer(this.indices_),
        this.helper.enableAttributes(attributeDescriptions);
        let it = 0;
        for (; it < i.textures.length; ) {
            const pt = `${Uniforms.TILE_TEXTURE_ARRAY}[${it}]`;
            this.helper.bindTexture(i.textures[it], it, pt),
            ++it
        }
        for (let pt = 0; pt < this.paletteTextures_.length; ++pt) {
            const gt = this.paletteTextures_[pt]
              , _t = gt.getTexture(j);
            this.helper.bindTexture(_t, it, gt.name),
            ++it
        }
        const st = a.viewState
          , at = _e[0] + 2 * ot
          , lt = _e[1] + 2 * ot
          , ut = i.tile.tileCoord
          , dt = ut[1]
          , ft = ut[2];
        this.helper.setUniformMatrixValue(Uniforms.TILE_TRANSFORM, fromTransform(this.tempMat4, s)),
        this.helper.setUniformFloatValue(Uniforms.TRANSITION_ALPHA, et),
        this.helper.setUniformFloatValue(Uniforms.DEPTH, rt);
        let ht = _;
        ot > 0 && (ht = nt,
        getIntersection(ht, _, ht)),
        this.helper.setUniformFloatVec4(Uniforms.RENDER_EXTENT, ht),
        this.helper.setUniformFloatValue(Uniforms.RESOLUTION, st.resolution),
        this.helper.setUniformFloatValue(Uniforms.ZOOM, st.zoom),
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_WIDTH, at),
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_PIXEL_HEIGHT, lt),
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_RESOLUTION, $),
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_ORIGIN_X, tt[0] + dt * _e[0] * $ - ot * $),
        this.helper.setUniformFloatValue(Uniforms.TEXTURE_ORIGIN_Y, tt[1] - ft * _e[1] * $ + ot * $),
        this.helper.drawElements(0, this.indices_.getSize())
    }
    getData(i) {
        if (!this.helper.getGL())
            return null;
        const a = this.frameState;
        if (!a)
            return null;
        const _ = this.getLayer()
          , $ = apply(a.pixelToCoordinateTransform, i.slice())
          , _e = a.viewState
          , tt = _.getExtent();
        if (tt && !containsCoordinate(fromUserExtent(tt, _e.projection), $))
            return null;
        const nt = _.getSources(boundingExtent([$]), _e.resolution);
        let rt, ot, et;
        for (rt = nt.length - 1; rt >= 0; --rt)
            if (ot = nt[rt],
            ot.getState() === "ready") {
                if (et = ot.getTileGridForProjection(_e.projection),
                ot.getWrapX())
                    break;
                const it = et.getExtent();
                if (!it || containsCoordinate(it, $))
                    break
            }
        if (rt < 0)
            return null;
        const j = this.tileRepresentationCache;
        for (let it = et.getZForResolution(_e.resolution); it >= et.getMinZoom(); --it) {
            const st = et.getTileCoordForCoordAndZ($, it)
              , at = getCacheKey(ot, st);
            if (!j.containsKey(at))
                continue;
            const lt = j.get(at)
              , ct = lt.tile;
            if ((ct instanceof ReprojTile$1 || ct instanceof ReprojDataTile$1) && ct.getState() === TileState.EMPTY)
                return null;
            if (!lt.loaded)
                continue;
            const ut = et.getOrigin(it)
              , dt = toSize(et.getTileSize(it))
              , ft = et.getResolution(it)
              , ht = ($[0] - ut[0]) / ft - st[1] * dt[0]
              , pt = (ut[1] - $[1]) / ft - st[2] * dt[1];
            return lt.getPixelData(ht, pt)
        }
        return null
    }
    disposeInternal() {
        const i = this.helper;
        i && (i.getGL().deleteProgram(this.program_),
        delete this.program_,
        i.deleteBuffer(this.indices_)),
        super.disposeInternal(),
        delete this.indices_
    }
}
const WebGLTileLayerRenderer$1 = WebGLTileLayerRenderer;
class PaletteTexture {
    constructor(i, s) {
        this.name = i,
        this.data = s,
        this.texture_ = null
    }
    getTexture(i) {
        if (!this.texture_) {
            const s = i.createTexture();
            i.bindTexture(i.TEXTURE_2D, s),
            i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.CLAMP_TO_EDGE),
            i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.CLAMP_TO_EDGE),
            i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.NEAREST),
            i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.NEAREST),
            i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, this.data.length / 4, 1, 0, i.RGBA, i.UNSIGNED_BYTE, this.data),
            this.texture_ = s
        }
        return this.texture_
    }
}
const PaletteTexture$1 = PaletteTexture
  , ValueTypes = {
    NUMBER: 1,
    STRING: 2,
    COLOR: 4,
    BOOLEAN: 8,
    NUMBER_ARRAY: 16,
    ANY: 31,
    NONE: 0
};
function getTypeFromHint(o) {
    switch (o) {
    case "string":
        return ValueTypes.STRING;
    case "color":
        return ValueTypes.COLOR;
    case "number":
        return ValueTypes.NUMBER;
    case "boolean":
        return ValueTypes.BOOLEAN;
    case "number[]":
        return ValueTypes.NUMBER_ARRAY;
    default:
        throw new Error(`Unrecognized type hint: ${o}`)
    }
}
const Operators = {};
function getValueType(o) {
    if (typeof o == "number")
        return ValueTypes.NUMBER;
    if (typeof o == "boolean")
        return ValueTypes.BOOLEAN;
    if (typeof o == "string")
        return isStringColor(o) ? ValueTypes.COLOR | ValueTypes.STRING : ValueTypes.STRING;
    if (!Array.isArray(o))
        throw new Error(`Unhandled value type: ${JSON.stringify(o)}`);
    const i = o;
    if (i.every(function(_) {
        return typeof _ == "number"
    }))
        return i.length === 3 || i.length === 4 ? ValueTypes.COLOR | ValueTypes.NUMBER_ARRAY : ValueTypes.NUMBER_ARRAY;
    if (typeof i[0] != "string")
        throw new Error(`Expected an expression operator but received: ${JSON.stringify(i)}`);
    const a = Operators[i[0]];
    if (a === void 0)
        throw new Error(`Unrecognized expression operator: ${JSON.stringify(i)}`);
    return a.getReturnType(i.slice(1))
}
function isTypeUnique(o) {
    return Math.log2(o) % 1 === 0
}
function printTypes(o) {
    const i = [];
    return (o & ValueTypes.NUMBER) > 0 && i.push("number"),
    (o & ValueTypes.COLOR) > 0 && i.push("color"),
    (o & ValueTypes.BOOLEAN) > 0 && i.push("boolean"),
    (o & ValueTypes.NUMBER_ARRAY) > 0 && i.push("number[]"),
    (o & ValueTypes.STRING) > 0 && i.push("string"),
    i.length > 0 ? i.join(", ") : "(no type)"
}
function computeOperatorFunctionName(o, i) {
    return `operator_${o}_${Object.keys(i.functions).length}`
}
function numberToGlsl(o) {
    const i = o.toString();
    return i.includes(".") ? i : i + ".0"
}
function arrayToGlsl(o) {
    if (o.length < 2 || o.length > 4)
        throw new Error("`formatArray` can only output `vec2`, `vec3` or `vec4` arrays.");
    return `vec${o.length}(${o.map(numberToGlsl).join(", ")})`
}
function colorToGlsl(o) {
    const i = asArray(o)
      , s = i.length > 3 ? i[3] : 1;
    return arrayToGlsl([i[0] / 255 * s, i[1] / 255 * s, i[2] / 255 * s, s])
}
function getStringNumberEquivalent(o, i) {
    return o.stringLiteralsMap[i] === void 0 && (o.stringLiteralsMap[i] = Object.keys(o.stringLiteralsMap).length),
    o.stringLiteralsMap[i]
}
function stringToGlsl(o, i) {
    return numberToGlsl(getStringNumberEquivalent(o, i))
}
function expressionToGlsl(o, i, s) {
    const a = s !== void 0 ? s : ValueTypes.NUMBER;
    if (Array.isArray(i) && typeof i[0] == "string") {
        const $ = Operators[i[0]];
        if ($ === void 0)
            throw new Error(`Unrecognized expression operator: ${JSON.stringify(i)}`);
        return $.toGlsl(o, i.slice(1), a)
    }
    const _ = getValueType(i) & a;
    if (assertNotEmptyType(i, _, ""),
    (_ & ValueTypes.NUMBER) > 0)
        return numberToGlsl(i);
    if ((_ & ValueTypes.BOOLEAN) > 0)
        return i.toString();
    if ((_ & ValueTypes.STRING) > 0)
        return stringToGlsl(o, i.toString());
    if ((_ & ValueTypes.COLOR) > 0)
        return colorToGlsl(i);
    if ((_ & ValueTypes.NUMBER_ARRAY) > 0)
        return arrayToGlsl(i);
    throw new Error(`Unexpected expression ${i} (expected type ${printTypes(a)})`)
}
function assertNumber(o) {
    if (!(getValueType(o) & ValueTypes.NUMBER))
        throw new Error(`A numeric value was expected, got ${JSON.stringify(o)} instead`)
}
function assertNumbers(o) {
    for (let i = 0; i < o.length; i++)
        assertNumber(o[i])
}
function assertString(o) {
    if (!(getValueType(o) & ValueTypes.STRING))
        throw new Error(`A string value was expected, got ${JSON.stringify(o)} instead`)
}
function assertBoolean(o) {
    if (!(getValueType(o) & ValueTypes.BOOLEAN))
        throw new Error(`A boolean value was expected, got ${JSON.stringify(o)} instead`)
}
function assertArgsCount(o, i) {
    if (o.length !== i)
        throw new Error(`Exactly ${i} arguments were expected, got ${o.length} instead`)
}
function assertArgsMinCount(o, i) {
    if (o.length < i)
        throw new Error(`At least ${i} arguments were expected, got ${o.length} instead`)
}
function assertArgsMaxCount(o, i) {
    if (o.length > i)
        throw new Error(`At most ${i} arguments were expected, got ${o.length} instead`)
}
function assertArgsEven(o) {
    if (o.length % 2 !== 0)
        throw new Error(`An even amount of arguments was expected, got ${JSON.stringify(o)} instead`)
}
function assertArgsOdd(o) {
    if (o.length % 2 === 0)
        throw new Error(`An odd amount of arguments was expected, got ${JSON.stringify(o)} instead`)
}
function assertNotEmptyType(o, i, s) {
    if (i === ValueTypes.NONE)
        throw new Error(`No matching type was found for the following expression ${s}: ${JSON.stringify(o)}`)
}
function assertSingleType(o, i, s) {
    if (assertNotEmptyType(o, i, s),
    !isTypeUnique(i))
        throw new Error(`Expected to have a unique type for the following expression ${s}: ${JSON.stringify(o)}
Got the following types instead: ${printTypes(i)}`)
}
function assertOfType(o, i, s, a) {
    if ((i & s) === ValueTypes.NONE)
        throw new Error(`Expected the ${a} type of the following expression: ${JSON.stringify(o)} to be of the following types: ${printTypes(s)}
Got these types instead: ${printTypes(i)}`)
}
Operators.get = {
    getReturnType: function(o) {
        if (o.length === 2) {
            const i = o[1];
            return getTypeFromHint(i)
        }
        return ValueTypes.ANY
    },
    toGlsl: function(o, i, s) {
        assertArgsMinCount(i, 1),
        assertArgsMaxCount(i, 2),
        assertString(i[0]);
        const a = s & Operators.get.getReturnType(i);
        assertSingleType(["get", ...i], a, "");
        const _ = i[0].toString()
          , $ = o.attributes.find(tt => tt.name === _);
        if (!$)
            o.attributes.push({
                name: _,
                type: a
            });
        else if (a !== $.type)
            throw new Error(`The following attribute was used in different places with incompatible types: ${_}
Types were: ${printTypes($.type)} and ${printTypes(a)}`);
        return (o.inFragmentShader ? "v_" : "a_") + _
    }
};
function uniformNameForVariable(o) {
    return "u_var_" + o
}
Operators.var = {
    getReturnType: function() {
        return ValueTypes.ANY
    },
    toGlsl: function(o, i, s) {
        assertArgsCount(i, 1),
        assertString(i[0]);
        const a = i[0].toString();
        if (!o.style.variables || o.style.variables[a] === void 0)
            throw new Error(`The following variable is missing from the style: ${a}`);
        const _ = o.style.variables[a]
          , $ = s & getValueType(_);
        assertSingleType(["var", ...i], $, "");
        const _e = o.variables.find(tt => tt.name === a);
        if (!_e)
            o.variables.push({
                name: a,
                type: $
            });
        else if ($ !== _e.type)
            throw new Error(`The following variable was used in different places with incompatible types: ${a}
Types were: ${printTypes(_e.type)} and ${printTypes($)}`);
        return uniformNameForVariable(a)
    }
};
const PALETTE_TEXTURE_ARRAY = "u_paletteTextures";
Operators.palette = {
    getReturnType: function() {
        return ValueTypes.COLOR
    },
    toGlsl: function(o, i) {
        assertArgsCount(i, 2),
        assertNumber(i[0]);
        const s = expressionToGlsl(o, i[0])
          , a = i[1];
        if (!Array.isArray(a))
            throw new Error("The second argument of palette must be an array");
        const _ = a.length
          , $ = new Uint8Array(_ * 4);
        for (let nt = 0; nt < _; nt++) {
            const rt = a[nt];
            let ot;
            if (typeof rt == "string")
                ot = fromString(rt);
            else {
                if (!Array.isArray(rt))
                    throw new Error("The second argument of palette must be an array of strings or colors");
                const j = rt.length;
                if (j === 4)
                    ot = rt;
                else {
                    if (j !== 3)
                        throw new Error(`Expected palette color to have 3 or 4 values, got ${j}`);
                    ot = [rt[0], rt[1], rt[2], 1]
                }
            }
            const et = nt * 4;
            $[et] = ot[0],
            $[et + 1] = ot[1],
            $[et + 2] = ot[2],
            $[et + 3] = ot[3] * 255
        }
        o.paletteTextures || (o.paletteTextures = []);
        const _e = `${PALETTE_TEXTURE_ARRAY}[${o.paletteTextures.length}]`
          , tt = new PaletteTexture$1(_e,$);
        return o.paletteTextures.push(tt),
        `texture2D(${_e}, vec2((${s} + 0.5) / ${_}.0, 0.5))`
    }
};
const GET_BAND_VALUE_FUNC = "getBandValue";
Operators.band = {
    getReturnType: function() {
        return ValueTypes.NUMBER
    },
    toGlsl: function(o, i) {
        assertArgsMinCount(i, 1),
        assertArgsMaxCount(i, 3);
        const s = i[0];
        if (!(GET_BAND_VALUE_FUNC in o.functions)) {
            let _e = "";
            const tt = o.bandCount || 1;
            for (let nt = 0; nt < tt; nt++) {
                const rt = Math.floor(nt / 4);
                let ot = nt % 4;
                nt === tt - 1 && ot === 1 && (ot = 3);
                const et = `${Uniforms.TILE_TEXTURE_ARRAY}[${rt}]`;
                _e += `
          if (band == ${nt + 1}.0) {
            return texture2D(${et}, v_textureCoord + vec2(dx, dy))[${ot}];
          }
        `
            }
            o.functions[GET_BAND_VALUE_FUNC] = `
        float getBandValue(float band, float xOffset, float yOffset) {
          float dx = xOffset / ${Uniforms.TEXTURE_PIXEL_WIDTH};
          float dy = yOffset / ${Uniforms.TEXTURE_PIXEL_HEIGHT};
          ${_e}
        }
      `
        }
        const a = expressionToGlsl(o, s)
          , _ = expressionToGlsl(o, i[1] || 0)
          , $ = expressionToGlsl(o, i[2] || 0);
        return `${GET_BAND_VALUE_FUNC}(${a}, ${_}, ${$})`
    }
};
Operators.time = {
    getReturnType: function() {
        return ValueTypes.NUMBER
    },
    toGlsl: function(o, i) {
        return assertArgsCount(i, 0),
        "u_time"
    }
};
Operators.zoom = {
    getReturnType: function() {
        return ValueTypes.NUMBER
    },
    toGlsl: function(o, i) {
        return assertArgsCount(i, 0),
        "u_zoom"
    }
};
Operators.resolution = {
    getReturnType: function() {
        return ValueTypes.NUMBER
    },
    toGlsl: function(o, i) {
        return assertArgsCount(i, 0),
        "u_resolution"
    }
};
Operators["geometry-type"] = {
    getReturnType: function() {
        return ValueTypes.STRING
    },
    toGlsl: function(o, i) {
        assertArgsCount(i, 0);
        const s = "geometryType"
          , a = _e => {
            const tt = _e.getType();
            switch (tt) {
            case "Point":
            case "LineString":
            case "Polygon":
                return tt;
            case "MultiPoint":
            case "MultiLineString":
            case "MultiPolygon":
                return tt.substring(5);
            case "Circle":
                return "Polygon";
            case "GeometryCollection":
                return a(_e.getGeometries()[0])
            }
        }
        ;
        return o.attributes.find(_e => _e.name === s) || o.attributes.push({
            name: s,
            type: ValueTypes.STRING,
            callback: _e => a(_e.getGeometry())
        }),
        (o.inFragmentShader ? "v_" : "a_") + s
    }
};
Operators["*"] = {
    getReturnType: function(o) {
        let i = ValueTypes.NUMBER | ValueTypes.COLOR;
        for (let s = 0; s < o.length; s++)
            i = i & getValueType(o[s]);
        return i
    },
    toGlsl: function(o, i, s) {
        assertArgsMinCount(i, 2);
        let a = s;
        for (let _ = 0; _ < i.length; _++)
            a = a & getValueType(i[_]);
        return assertOfType(i, a, ValueTypes.NUMBER | ValueTypes.COLOR, "output"),
        `(${i.map(_ => expressionToGlsl(o, _, a)).join(" * ")})`
    }
};
Operators["/"] = {
    getReturnType: function() {
        return ValueTypes.NUMBER
    },
    toGlsl: function(o, i) {
        return assertArgsCount(i, 2),
        assertNumbers(i),
        `(${expressionToGlsl(o, i[0])} / ${expressionToGlsl(o, i[1])})`
    }
};
Operators["+"] = {
    getReturnType: function() {
        return ValueTypes.NUMBER
    },
    toGlsl: function(o, i) {
        return assertArgsMinCount(i, 2),
        assertNumbers(i),
        `(${i.map(s => expressionToGlsl(o, s)).join(" + ")})`
    }
};
Operators["-"] = {
    getReturnType: function() {
        return ValueTypes.NUMBER
    },
    toGlsl: function(o, i) {
        return assertArgsCount(i, 2),
        assertNumbers(i),
        `(${expressionToGlsl(o, i[0])} - ${expressionToGlsl(o, i[1])})`
    }
};
Operators.clamp = {
    getReturnType: function() {
        return ValueTypes.NUMBER
    },
    toGlsl: function(o, i) {
        assertArgsCount(i, 3),
        assertNumbers(i);
        const s = expressionToGlsl(o, i[1])
          , a = expressionToGlsl(o, i[2]);
        return `clamp(${expressionToGlsl(o, i[0])}, ${s}, ${a})`
    }
};
Operators["%"] = {
    getReturnType: function() {
        return ValueTypes.NUMBER
    },
    toGlsl: function(o, i) {
        return assertArgsCount(i, 2),
        assertNumbers(i),
        `mod(${expressionToGlsl(o, i[0])}, ${expressionToGlsl(o, i[1])})`
    }
};
Operators["^"] = {
    getReturnType: function() {
        return ValueTypes.NUMBER
    },
    toGlsl: function(o, i) {
        return assertArgsCount(i, 2),
        assertNumbers(i),
        `pow(${expressionToGlsl(o, i[0])}, ${expressionToGlsl(o, i[1])})`
    }
};
Operators.abs = {
    getReturnType: function() {
        return ValueTypes.NUMBER
    },
    toGlsl: function(o, i) {
        return assertArgsCount(i, 1),
        assertNumbers(i),
        `abs(${expressionToGlsl(o, i[0])})`
    }
};
Operators.floor = {
    getReturnType: function() {
        return ValueTypes.NUMBER
    },
    toGlsl: function(o, i) {
        return assertArgsCount(i, 1),
        assertNumbers(i),
        `floor(${expressionToGlsl(o, i[0])})`
    }
};
Operators.round = {
    getReturnType: function() {
        return ValueTypes.NUMBER
    },
    toGlsl: function(o, i) {
        return assertArgsCount(i, 1),
        assertNumbers(i),
        `floor(${expressionToGlsl(o, i[0])} + 0.5)`
    }
};
Operators.ceil = {
    getReturnType: function() {
        return ValueTypes.NUMBER
    },
    toGlsl: function(o, i) {
        return assertArgsCount(i, 1),
        assertNumbers(i),
        `ceil(${expressionToGlsl(o, i[0])})`
    }
};
Operators.sin = {
    getReturnType: function() {
        return ValueTypes.NUMBER
    },
    toGlsl: function(o, i) {
        return assertArgsCount(i, 1),
        assertNumbers(i),
        `sin(${expressionToGlsl(o, i[0])})`
    }
};
Operators.cos = {
    getReturnType: function() {
        return ValueTypes.NUMBER
    },
    toGlsl: function(o, i) {
        return assertArgsCount(i, 1),
        assertNumbers(i),
        `cos(${expressionToGlsl(o, i[0])})`
    }
};
Operators.atan = {
    getReturnType: function() {
        return ValueTypes.NUMBER
    },
    toGlsl: function(o, i) {
        return assertArgsMinCount(i, 1),
        assertArgsMaxCount(i, 2),
        assertNumbers(i),
        i.length === 2 ? `atan(${expressionToGlsl(o, i[0])}, ${expressionToGlsl(o, i[1])})` : `atan(${expressionToGlsl(o, i[0])})`
    }
};
Operators.sqrt = {
    getReturnType: function() {
        return ValueTypes.NUMBER
    },
    toGlsl: function(o, i) {
        return assertArgsCount(i, 1),
        assertNumbers(i),
        `sqrt(${expressionToGlsl(o, i[0])})`
    }
};
Operators[">"] = {
    getReturnType: function() {
        return ValueTypes.BOOLEAN
    },
    toGlsl: function(o, i) {
        return assertArgsCount(i, 2),
        assertNumbers(i),
        `(${expressionToGlsl(o, i[0])} > ${expressionToGlsl(o, i[1])})`
    }
};
Operators[">="] = {
    getReturnType: function() {
        return ValueTypes.BOOLEAN
    },
    toGlsl: function(o, i) {
        return assertArgsCount(i, 2),
        assertNumbers(i),
        `(${expressionToGlsl(o, i[0])} >= ${expressionToGlsl(o, i[1])})`
    }
};
Operators["<"] = {
    getReturnType: function() {
        return ValueTypes.BOOLEAN
    },
    toGlsl: function(o, i) {
        return assertArgsCount(i, 2),
        assertNumbers(i),
        `(${expressionToGlsl(o, i[0])} < ${expressionToGlsl(o, i[1])})`
    }
};
Operators["<="] = {
    getReturnType: function() {
        return ValueTypes.BOOLEAN
    },
    toGlsl: function(o, i) {
        return assertArgsCount(i, 2),
        assertNumbers(i),
        `(${expressionToGlsl(o, i[0])} <= ${expressionToGlsl(o, i[1])})`
    }
};
function getEqualOperator(o) {
    return {
        getReturnType: function() {
            return ValueTypes.BOOLEAN
        },
        toGlsl: function(i, s) {
            assertArgsCount(s, 2);
            let a = ValueTypes.ANY;
            for (let _ = 0; _ < s.length; _++)
                a &= getValueType(s[_]);
            if (a === ValueTypes.NONE)
                throw new Error(`All arguments should be of compatible type, got ${JSON.stringify(s)} instead`);
            return a &= ~ValueTypes.COLOR,
            `(${expressionToGlsl(i, s[0], a)} ${o} ${expressionToGlsl(i, s[1], a)})`
        }
    }
}
Operators["=="] = getEqualOperator("==");
Operators["!="] = getEqualOperator("!=");
Operators["!"] = {
    getReturnType: function() {
        return ValueTypes.BOOLEAN
    },
    toGlsl: function(o, i) {
        return assertArgsCount(i, 1),
        assertBoolean(i[0]),
        `(!${expressionToGlsl(o, i[0], ValueTypes.BOOLEAN)})`
    }
};
function getDecisionOperator(o) {
    return {
        getReturnType: function() {
            return ValueTypes.BOOLEAN
        },
        toGlsl: function(i, s) {
            assertArgsMinCount(s, 2);
            for (let _ = 0; _ < s.length; _++)
                assertBoolean(s[_]);
            let a = s.map(_ => expressionToGlsl(i, _, ValueTypes.BOOLEAN)).join(` ${o} `);
            return a = `(${a})`,
            a
        }
    }
}
Operators.all = getDecisionOperator("&&");
Operators.any = getDecisionOperator("||");
Operators.between = {
    getReturnType: function() {
        return ValueTypes.BOOLEAN
    },
    toGlsl: function(o, i) {
        assertArgsCount(i, 3),
        assertNumbers(i);
        const s = expressionToGlsl(o, i[1])
          , a = expressionToGlsl(o, i[2])
          , _ = expressionToGlsl(o, i[0]);
        return `(${_} >= ${s} && ${_} <= ${a})`
    }
};
Operators.array = {
    getReturnType: function() {
        return ValueTypes.NUMBER_ARRAY
    },
    toGlsl: function(o, i) {
        assertArgsMinCount(i, 2),
        assertArgsMaxCount(i, 4),
        assertNumbers(i);
        const s = i.map(function(a) {
            return expressionToGlsl(o, a)
        });
        return `vec${i.length}(${s.join(", ")})`
    }
};
Operators.color = {
    getReturnType: function() {
        return ValueTypes.COLOR
    },
    toGlsl: function(o, i) {
        assertArgsMinCount(i, 3),
        assertArgsMaxCount(i, 4),
        assertNumbers(i);
        const s = i.slice(0, 3).map(_ => `${expressionToGlsl(o, _)} / 255.0`);
        return i.length === 3 ? `vec4(${s.join(", ")}, 1.0)` : `(${expressionToGlsl(o, i[3])} * vec4(${s.join(", ")}, 1.0))`
    }
};
Operators.interpolate = {
    getReturnType: function(o) {
        let i = ValueTypes.COLOR | ValueTypes.NUMBER;
        for (let s = 3; s < o.length; s += 2)
            i = i & getValueType(o[s]);
        return i
    },
    toGlsl: function(o, i, s) {
        assertArgsEven(i),
        assertArgsMinCount(i, 6);
        const a = i[0];
        let _;
        switch (a[0]) {
        case "linear":
            _ = 1;
            break;
        case "exponential":
            _ = a[1];
            break;
        default:
            _ = null
        }
        if (!_)
            throw new Error(`Invalid interpolation type for "interpolate" operator, received: ${JSON.stringify(a)}`);
        const $ = ValueTypes.NUMBER
          , _e = Operators.interpolate.getReturnType(i) & s;
        assertSingleType(["interpolate", ...i], _e, "output");
        const tt = expressionToGlsl(o, i[1], $)
          , nt = numberToGlsl(_);
        let rt = "";
        for (let ot = 2; ot < i.length - 2; ot += 2) {
            const et = expressionToGlsl(o, i[ot], $)
              , j = rt || expressionToGlsl(o, i[ot + 1], _e)
              , it = expressionToGlsl(o, i[ot + 2], $)
              , st = expressionToGlsl(o, i[ot + 3], _e);
            let at;
            _ === 1 ? at = `(${tt} - ${et}) / (${it} - ${et})` : at = `(pow(${nt}, (${tt} - ${et})) - 1.0) / (pow(${nt}, (${it} - ${et})) - 1.0)`,
            rt = `mix(${j}, ${st}, clamp(${at}, 0.0, 1.0))`
        }
        return rt
    }
};
Operators.match = {
    getReturnType: function(o) {
        let i = ValueTypes.ANY;
        for (let s = 2; s < o.length; s += 2)
            i = i & getValueType(o[s]);
        return i = i & getValueType(o[o.length - 1]),
        i
    },
    toGlsl: function(o, i, s) {
        assertArgsEven(i),
        assertArgsMinCount(i, 4);
        let a = getValueType(i[0]);
        for (let nt = 1; nt < i.length - 1; nt += 2)
            a = a & getValueType(i[nt]);
        assertOfType(["match", ...i], a, ValueTypes.STRING | ValueTypes.NUMBER | ValueTypes.BOOLEAN, "input"),
        a = (ValueTypes.STRING | ValueTypes.NUMBER | ValueTypes.BOOLEAN) & a;
        const _ = Operators.match.getReturnType(i) & s;
        assertSingleType(["match", ...i], _, "output");
        const $ = expressionToGlsl(o, i[0], a)
          , _e = expressionToGlsl(o, i[i.length - 1], _);
        let tt = null;
        for (let nt = i.length - 3; nt >= 1; nt -= 2) {
            const rt = expressionToGlsl(o, i[nt], a)
              , ot = expressionToGlsl(o, i[nt + 1], _);
            tt = `(${$} == ${rt} ? ${ot} : ${tt || _e})`
        }
        return tt
    }
};
Operators.case = {
    getReturnType: function(o) {
        let i = ValueTypes.ANY;
        for (let s = 1; s < o.length; s += 2)
            i = i & getValueType(o[s]);
        return i = i & getValueType(o[o.length - 1]),
        i
    },
    toGlsl: function(o, i, s) {
        assertArgsOdd(i),
        assertArgsMinCount(i, 3);
        const a = Operators.case.getReturnType(i) & s;
        assertSingleType(["case", ...i], a, "output");
        for (let _e = 0; _e < i.length - 1; _e += 2)
            assertBoolean(i[_e]);
        const _ = expressionToGlsl(o, i[i.length - 1], a);
        let $ = null;
        for (let _e = i.length - 3; _e >= 0; _e -= 2) {
            const tt = expressionToGlsl(o, i[_e], ValueTypes.BOOLEAN)
              , nt = expressionToGlsl(o, i[_e + 1], a);
            $ = `(${tt} ? ${nt} : ${$ || _})`
        }
        return $
    }
};
Operators.in = {
    getReturnType: function(o) {
        return ValueTypes.BOOLEAN
    },
    toGlsl: function(o, i) {
        assertArgsCount(i, 2);
        const s = i[0];
        let a = i[1];
        if (!Array.isArray(a))
            throw new Error('The "in" operator expects an array literal as its second argument.');
        if (typeof a[0] == "string") {
            if (a[0] !== "literal")
                throw new Error('For the "in" operator, a string array should be wrapped in a "literal" operator to disambiguate from expressions.');
            if (!Array.isArray(a[1]))
                throw new Error('The "in" operator was provided a literal value which was not an array as second argument.');
            a = a[1]
        }
        let _ = getValueType(s);
        for (let tt = 0; tt < a.length - 1; tt += 1)
            _ = _ & getValueType(a[tt]);
        assertOfType(["match", ...i], _, ValueTypes.STRING | ValueTypes.NUMBER | ValueTypes.BOOLEAN, "input"),
        _ = (ValueTypes.STRING | ValueTypes.NUMBER | ValueTypes.BOOLEAN) & _;
        const $ = computeOperatorFunctionName("in", o)
          , _e = [];
        for (let tt = 0; tt < a.length; tt += 1)
            _e.push(`  if (inputValue == ${expressionToGlsl(o, a[tt], _)}) { return true; }`);
        return o.functions[$] = `bool ${$}(float inputValue) {
${_e.join(`
`)}
  return false;
}`,
        `${$}(${expressionToGlsl(o, s, _)})`
    }
};
function parseStyle(o, i) {
    const s = `
    attribute vec2 ${Attributes.TEXTURE_COORD};
    uniform mat4 ${Uniforms.TILE_TRANSFORM};
    uniform float ${Uniforms.TEXTURE_PIXEL_WIDTH};
    uniform float ${Uniforms.TEXTURE_PIXEL_HEIGHT};
    uniform float ${Uniforms.TEXTURE_RESOLUTION};
    uniform float ${Uniforms.TEXTURE_ORIGIN_X};
    uniform float ${Uniforms.TEXTURE_ORIGIN_Y};
    uniform float ${Uniforms.DEPTH};

    varying vec2 v_textureCoord;
    varying vec2 v_mapCoord;

    void main() {
      v_textureCoord = ${Attributes.TEXTURE_COORD};
      v_mapCoord = vec2(
        ${Uniforms.TEXTURE_ORIGIN_X} + ${Uniforms.TEXTURE_RESOLUTION} * ${Uniforms.TEXTURE_PIXEL_WIDTH} * v_textureCoord[0],
        ${Uniforms.TEXTURE_ORIGIN_Y} - ${Uniforms.TEXTURE_RESOLUTION} * ${Uniforms.TEXTURE_PIXEL_HEIGHT} * v_textureCoord[1]
      );
      gl_Position = ${Uniforms.TILE_TRANSFORM} * vec4(${Attributes.TEXTURE_COORD}, ${Uniforms.DEPTH}, 1.0);
    }
  `
      , a = {
        inFragmentShader: !0,
        variables: [],
        attributes: [],
        stringLiteralsMap: {},
        functions: {},
        bandCount: i,
        style: o
    }
      , _ = [];
    if (o.color !== void 0) {
        const et = expressionToGlsl(a, o.color, ValueTypes.COLOR);
        _.push(`color = ${et};`)
    }
    if (o.contrast !== void 0) {
        const et = expressionToGlsl(a, o.contrast, ValueTypes.NUMBER);
        _.push(`color.rgb = clamp((${et} + 1.0) * color.rgb - (${et} / 2.0), vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`)
    }
    if (o.exposure !== void 0) {
        const et = expressionToGlsl(a, o.exposure, ValueTypes.NUMBER);
        _.push(`color.rgb = clamp((${et} + 1.0) * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`)
    }
    if (o.saturation !== void 0) {
        const et = expressionToGlsl(a, o.saturation, ValueTypes.NUMBER);
        _.push(`
      float saturation = ${et} + 1.0;
      float sr = (1.0 - saturation) * 0.2126;
      float sg = (1.0 - saturation) * 0.7152;
      float sb = (1.0 - saturation) * 0.0722;
      mat3 saturationMatrix = mat3(
        sr + saturation, sr, sr,
        sg, sg + saturation, sg,
        sb, sb, sb + saturation
      );
      color.rgb = clamp(saturationMatrix * color.rgb, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));
    `)
    }
    if (o.gamma !== void 0) {
        const et = expressionToGlsl(a, o.gamma, ValueTypes.NUMBER);
        _.push(`color.rgb = pow(color.rgb, vec3(1.0 / ${et}));`)
    }
    if (o.brightness !== void 0) {
        const et = expressionToGlsl(a, o.brightness, ValueTypes.NUMBER);
        _.push(`color.rgb = clamp(color.rgb + ${et}, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));`)
    }
    const $ = {}
      , _e = a.variables.length;
    if (_e > 1 && !o.variables)
        throw new Error(`Missing variables in style (expected ${a.variables})`);
    for (let et = 0; et < _e; ++et) {
        const j = a.variables[et];
        if (!(j.name in o.variables))
            throw new Error(`Missing '${j.name}' in style variables`);
        const it = uniformNameForVariable(j.name);
        $[it] = function() {
            let st = o.variables[j.name];
            return typeof st == "string" && (st = getStringNumberEquivalent(a, st)),
            st !== void 0 ? st : -9999999
        }
    }
    const tt = Object.keys($).map(function(et) {
        return `uniform float ${et};`
    })
      , nt = Math.ceil(i / 4);
    tt.push(`uniform sampler2D ${Uniforms.TILE_TEXTURE_ARRAY}[${nt}];`),
    a.paletteTextures && tt.push(`uniform sampler2D ${PALETTE_TEXTURE_ARRAY}[${a.paletteTextures.length}];`);
    const rt = Object.keys(a.functions).map(function(et) {
        return a.functions[et]
    })
      , ot = `
    #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
    #else
    precision mediump float;
    #endif

    varying vec2 v_textureCoord;
    varying vec2 v_mapCoord;
    uniform vec4 ${Uniforms.RENDER_EXTENT};
    uniform float ${Uniforms.TRANSITION_ALPHA};
    uniform float ${Uniforms.TEXTURE_PIXEL_WIDTH};
    uniform float ${Uniforms.TEXTURE_PIXEL_HEIGHT};
    uniform float ${Uniforms.RESOLUTION};
    uniform float ${Uniforms.ZOOM};

    ${tt.join(`
`)}

    ${rt.join(`
`)}

    void main() {
      if (
        v_mapCoord[0] < ${Uniforms.RENDER_EXTENT}[0] ||
        v_mapCoord[1] < ${Uniforms.RENDER_EXTENT}[1] ||
        v_mapCoord[0] > ${Uniforms.RENDER_EXTENT}[2] ||
        v_mapCoord[1] > ${Uniforms.RENDER_EXTENT}[3]
      ) {
        discard;
      }

      vec4 color = texture2D(${Uniforms.TILE_TEXTURE_ARRAY}[0],  v_textureCoord);

      ${_.join(`
`)}

      gl_FragColor = color;
      gl_FragColor.rgb *= gl_FragColor.a;
      gl_FragColor *= ${Uniforms.TRANSITION_ALPHA};
    }`;
    return {
        vertexShader: s,
        fragmentShader: ot,
        uniforms: $,
        paletteTextures: a.paletteTextures
    }
}
class WebGLTileLayer extends BaseTileLayer$1 {
    constructor(i) {
        i = i ? Object.assign({}, i) : {};
        const s = i.style || {};
        delete i.style;
        const a = i.cacheSize;
        delete i.cacheSize,
        super(i),
        this.sources_ = i.sources,
        this.renderedSource_ = null,
        this.renderedResolution_ = NaN,
        this.style_ = s,
        this.cacheSize_ = a,
        this.styleVariables_ = this.style_.variables || {},
        this.addChangeListener(LayerProperty.SOURCE, this.handleSourceUpdate_)
    }
    getSources(i, s) {
        const a = this.getSource();
        return this.sources_ ? typeof this.sources_ == "function" ? this.sources_(i, s) : this.sources_ : a ? [a] : []
    }
    getRenderSource() {
        return this.renderedSource_ || this.getSource()
    }
    getSourceState() {
        const i = this.getRenderSource();
        return i ? i.getState() : "undefined"
    }
    handleSourceUpdate_() {
        this.hasRenderer() && this.getRenderer().clearCache(),
        this.getSource() && this.setStyle(this.style_)
    }
    getSourceBandCount_() {
        const i = Number.MAX_SAFE_INTEGER
          , s = this.getSources([-i, -i, i, i], i);
        return s && s.length && "bandCount"in s[0] ? s[0].bandCount : 4
    }
    createRenderer() {
        const i = parseStyle(this.style_, this.getSourceBandCount_());
        return new WebGLTileLayerRenderer$1(this,{
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader,
            uniforms: i.uniforms,
            cacheSize: this.cacheSize_,
            paletteTextures: i.paletteTextures
        })
    }
    renderSources(i, s) {
        const a = this.getRenderer();
        let _;
        for (let $ = 0, _e = s.length; $ < _e; ++$)
            this.renderedSource_ = s[$],
            a.prepareFrame(i) && (_ = a.renderFrame(i));
        return _
    }
    render(i, s) {
        this.rendered = !0;
        const a = i.viewState
          , _ = this.getSources(i.extent, a.resolution);
        let $ = !0;
        for (let tt = 0, nt = _.length; tt < nt; ++tt) {
            const rt = _[tt]
              , ot = rt.getState();
            if (ot == "loading") {
                const et = () => {
                    rt.getState() == "ready" && (rt.removeEventListener("change", et),
                    this.changed())
                }
                ;
                rt.addEventListener("change", et)
            }
            $ = $ && ot == "ready"
        }
        const _e = this.renderSources(i, _);
        if (this.getRenderer().renderComplete && $)
            return this.renderedResolution_ = a.resolution,
            _e;
        if (this.renderedResolution_ > .5 * a.resolution) {
            const tt = this.getSources(i.extent, this.renderedResolution_).filter(nt => !_.includes(nt));
            if (tt.length > 0)
                return this.renderSources(i, tt)
        }
        return _e
    }
    setStyle(i) {
        this.styleVariables_ = i.variables || {},
        this.style_ = i;
        const s = parseStyle(this.style_, this.getSourceBandCount_());
        this.getRenderer().reset({
            vertexShader: s.vertexShader,
            fragmentShader: s.fragmentShader,
            uniforms: s.uniforms
        }),
        this.changed()
    }
    updateStyleVariables(i) {
        Object.assign(this.styleVariables_, i),
        this.changed()
    }
}
WebGLTileLayer.prototype.dispose;
const WebGLTileLayer$1 = WebGLTileLayer;
class CanvasTileLayerRenderer extends CanvasLayerRenderer$1 {
    constructor(i) {
        super(i),
        this.extentChanged = !0,
        this.renderedExtent_ = null,
        this.renderedPixelRatio,
        this.renderedProjection = null,
        this.renderedRevision,
        this.renderedTiles = [],
        this.newTiles_ = !1,
        this.tmpExtent = createEmpty(),
        this.tmpTileRange_ = new TileRange$1(0,0,0,0)
    }
    isDrawableTile(i) {
        const s = this.getLayer()
          , a = i.getState()
          , _ = s.getUseInterimTilesOnError();
        return a == TileState.LOADED || a == TileState.EMPTY || a == TileState.ERROR && !_
    }
    getTile(i, s, a, _) {
        const $ = _.pixelRatio
          , _e = _.viewState.projection
          , tt = this.getLayer();
        let rt = tt.getSource().getTile(i, s, a, $, _e);
        return rt.getState() == TileState.ERROR && tt.getUseInterimTilesOnError() && tt.getPreload() > 0 && (this.newTiles_ = !0),
        this.isDrawableTile(rt) || (rt = rt.getInterimTile()),
        rt
    }
    getData(i) {
        const s = this.frameState;
        if (!s)
            return null;
        const a = this.getLayer()
          , _ = apply(s.pixelToCoordinateTransform, i.slice())
          , $ = a.getExtent();
        if ($ && !containsCoordinate($, _))
            return null;
        const _e = s.pixelRatio
          , tt = s.viewState.projection
          , nt = s.viewState
          , rt = a.getRenderSource()
          , ot = rt.getTileGridForProjection(nt.projection)
          , et = rt.getTilePixelRatio(s.pixelRatio);
        for (let j = ot.getZForResolution(nt.resolution); j >= ot.getMinZoom(); --j) {
            const it = ot.getTileCoordForCoordAndZ(_, j)
              , st = rt.getTile(j, it[1], it[2], _e, tt);
            if (!(st instanceof ImageTile$1 || st instanceof ReprojTile$1) || st instanceof ReprojTile$1 && st.getState() === TileState.EMPTY)
                return null;
            if (st.getState() !== TileState.LOADED)
                continue;
            const at = ot.getOrigin(j)
              , lt = toSize(ot.getTileSize(j))
              , ct = ot.getResolution(j)
              , ut = Math.floor(et * ((_[0] - at[0]) / ct - it[1] * lt[0]))
              , dt = Math.floor(et * ((at[1] - _[1]) / ct - it[2] * lt[1]))
              , ft = Math.round(et * rt.getGutterForProjection(nt.projection));
            return this.getImageData(st.getImage(), ut + ft, dt + ft)
        }
        return null
    }
    loadedTileCallback(i, s, a) {
        return this.isDrawableTile(a) ? super.loadedTileCallback(i, s, a) : !1
    }
    prepareFrame(i) {
        return !!this.getLayer().getSource()
    }
    renderFrame(i, s) {
        const a = i.layerStatesArray[i.layerIndex]
          , _ = i.viewState
          , $ = _.projection
          , _e = _.resolution
          , tt = _.center
          , nt = _.rotation
          , rt = i.pixelRatio
          , ot = this.getLayer()
          , et = ot.getSource()
          , j = et.getRevision()
          , it = et.getTileGridForProjection($)
          , st = it.getZForResolution(_e, et.zDirection)
          , at = it.getResolution(st);
        let lt = i.extent;
        const ct = i.viewState.resolution
          , ut = et.getTilePixelRatio(rt)
          , dt = Math.round(getWidth(lt) / ct * rt)
          , ft = Math.round(getHeight(lt) / ct * rt)
          , ht = a.extent && fromUserExtent(a.extent);
        ht && (lt = getIntersection(lt, fromUserExtent(a.extent)));
        const pt = at * dt / 2 / ut
          , gt = at * ft / 2 / ut
          , _t = [tt[0] - pt, tt[1] - gt, tt[0] + pt, tt[1] + gt]
          , mt = it.getTileRangeForExtentAndZ(lt, st)
          , yt = {};
        yt[st] = {};
        const bt = this.createLoadedTileFinder(et, $, yt)
          , vt = this.tmpExtent
          , wt = this.tmpTileRange_;
        this.newTiles_ = !1;
        const Tt = nt ? getRotatedViewport(_.center, ct, nt, i.size) : void 0;
        for (let tn = mt.minX; tn <= mt.maxX; ++tn)
            for (let Vt = mt.minY; Vt <= mt.maxY; ++Vt) {
                if (nt && !it.tileCoordIntersectsViewport([st, tn, Vt], Tt))
                    continue;
                const Nt = this.getTile(st, tn, Vt, i);
                if (this.isDrawableTile(Nt)) {
                    const jt = getUid(this);
                    if (Nt.getState() == TileState.LOADED) {
                        yt[st][Nt.tileCoord.toString()] = Nt;
                        let Gt = Nt.inTransition(jt);
                        Gt && a.opacity !== 1 && (Nt.endTransition(jt),
                        Gt = !1),
                        !this.newTiles_ && (Gt || !this.renderedTiles.includes(Nt)) && (this.newTiles_ = !0)
                    }
                    if (Nt.getAlpha(jt, i.time) === 1)
                        continue
                }
                const Yt = it.getTileCoordChildTileRange(Nt.tileCoord, wt, vt);
                let Xt = !1;
                Yt && (Xt = bt(st + 1, Yt)),
                Xt || it.forEachTileCoordParentTileRange(Nt.tileCoord, bt, wt, vt)
            }
        const $t = at / _e * rt / ut;
        compose(this.pixelTransform, i.size[0] / 2, i.size[1] / 2, 1 / rt, 1 / rt, nt, -dt / 2, -ft / 2);
        const Et = toString$1(this.pixelTransform);
        this.useContainer(s, Et, this.getBackground(i));
        const Pt = this.context
          , Rt = Pt.canvas;
        makeInverse(this.inversePixelTransform, this.pixelTransform),
        compose(this.tempTransform, dt / 2, ft / 2, $t, $t, 0, -dt / 2, -ft / 2),
        Rt.width != dt || Rt.height != ft ? (Rt.width = dt,
        Rt.height = ft) : this.containerReused || Pt.clearRect(0, 0, dt, ft),
        ht && this.clipUnrotated(Pt, i, ht),
        et.getInterpolate() || (Pt.imageSmoothingEnabled = !1),
        this.preRender(Pt, i),
        this.renderedTiles.length = 0;
        let At = Object.keys(yt).map(Number);
        At.sort(ascending);
        let Mt, Ut, Lt;
        a.opacity === 1 && (!this.containerReused || et.getOpaque(i.viewState.projection)) ? At = At.reverse() : (Mt = [],
        Ut = []);
        for (let tn = At.length - 1; tn >= 0; --tn) {
            const Vt = At[tn]
              , Nt = et.getTilePixelSize(Vt, rt, $)
              , Xt = it.getResolution(Vt) / at
              , jt = Nt[0] * Xt * $t
              , Gt = Nt[1] * Xt * $t
              , Kt = it.getTileCoordForCoordAndZ(getTopLeft(_t), Vt)
              , qt = it.getTileCoordExtent(Kt)
              , rn = apply(this.tempTransform, [ut * (qt[0] - _t[0]) / at, ut * (_t[3] - qt[3]) / at])
              , on = ut * et.getGutterForProjection($)
              , _n = yt[Vt];
            for (const mn in _n) {
                const Sn = _n[mn]
                  , bn = Sn.tileCoord
                  , In = Kt[1] - bn[1]
                  , Nn = Math.round(rn[0] - (In - 1) * jt)
                  , cn = Kt[2] - bn[2]
                  , $n = Math.round(rn[1] - (cn - 1) * Gt)
                  , gn = Math.round(rn[0] - In * jt)
                  , dn = Math.round(rn[1] - cn * Gt)
                  , Dn = Nn - gn
                  , kn = $n - dn
                  , An = st === Vt
                  , Fn = An && Sn.getAlpha(getUid(this), i.time) !== 1;
                let On = !1;
                if (!Fn)
                    if (Mt) {
                        Lt = [gn, dn, gn + Dn, dn, gn + Dn, dn + kn, gn, dn + kn];
                        for (let jn = 0, Vn = Mt.length; jn < Vn; ++jn)
                            if (st !== Vt && Vt < Ut[jn]) {
                                const Mn = Mt[jn];
                                intersects$1([gn, dn, gn + Dn, dn + kn], [Mn[0], Mn[3], Mn[4], Mn[7]]) && (On || (Pt.save(),
                                On = !0),
                                Pt.beginPath(),
                                Pt.moveTo(Lt[0], Lt[1]),
                                Pt.lineTo(Lt[2], Lt[3]),
                                Pt.lineTo(Lt[4], Lt[5]),
                                Pt.lineTo(Lt[6], Lt[7]),
                                Pt.moveTo(Mn[6], Mn[7]),
                                Pt.lineTo(Mn[4], Mn[5]),
                                Pt.lineTo(Mn[2], Mn[3]),
                                Pt.lineTo(Mn[0], Mn[1]),
                                Pt.clip())
                            }
                        Mt.push(Lt),
                        Ut.push(Vt)
                    } else
                        Pt.clearRect(gn, dn, Dn, kn);
                this.drawTileImage(Sn, i, gn, dn, Dn, kn, on, An),
                Mt && !Fn ? (On && Pt.restore(),
                this.renderedTiles.unshift(Sn)) : this.renderedTiles.push(Sn),
                this.updateUsedTiles(i.usedTiles, et, Sn)
            }
        }
        return this.renderedRevision = j,
        this.renderedResolution = at,
        this.extentChanged = !this.renderedExtent_ || !equals$1(this.renderedExtent_, _t),
        this.renderedExtent_ = _t,
        this.renderedPixelRatio = rt,
        this.renderedProjection = $,
        this.manageTilePyramid(i, et, it, rt, $, lt, st, ot.getPreload()),
        this.scheduleExpireCache(i, et),
        this.postRender(Pt, i),
        a.extent && Pt.restore(),
        Pt.imageSmoothingEnabled = !0,
        Et !== Rt.style.transform && (Rt.style.transform = Et),
        this.container
    }
    drawTileImage(i, s, a, _, $, _e, tt, nt) {
        const rt = this.getTileImage(i);
        if (!rt)
            return;
        const ot = getUid(this)
          , et = s.layerStatesArray[s.layerIndex]
          , j = et.opacity * (nt ? i.getAlpha(ot, s.time) : 1)
          , it = j !== this.context.globalAlpha;
        it && (this.context.save(),
        this.context.globalAlpha = j),
        this.context.drawImage(rt, tt, tt, rt.width - 2 * tt, rt.height - 2 * tt, a, _, $, _e),
        it && this.context.restore(),
        j !== et.opacity ? s.animate = !0 : nt && i.endTransition(ot)
    }
    getImage() {
        const i = this.context;
        return i ? i.canvas : null
    }
    getTileImage(i) {
        return i.getImage()
    }
    scheduleExpireCache(i, s) {
        if (s.canExpireCache()) {
            const a = (function(_, $, _e) {
                const tt = getUid(_);
                tt in _e.usedTiles && _.expireCache(_e.viewState.projection, _e.usedTiles[tt])
            }
            ).bind(null, s);
            i.postRenderFunctions.push(a)
        }
    }
    updateUsedTiles(i, s, a) {
        const _ = getUid(s);
        _ in i || (i[_] = {}),
        i[_][a.getKey()] = !0
    }
    manageTilePyramid(i, s, a, _, $, _e, tt, nt, rt) {
        const ot = getUid(s);
        ot in i.wantedTiles || (i.wantedTiles[ot] = {});
        const et = i.wantedTiles[ot]
          , j = i.tileQueue
          , it = a.getMinZoom()
          , st = i.viewState.rotation
          , at = st ? getRotatedViewport(i.viewState.center, i.viewState.resolution, st, i.size) : void 0;
        let lt = 0, ct, ut, dt, ft, ht, pt;
        for (pt = it; pt <= tt; ++pt)
            for (ut = a.getTileRangeForExtentAndZ(_e, pt, ut),
            dt = a.getResolution(pt),
            ft = ut.minX; ft <= ut.maxX; ++ft)
                for (ht = ut.minY; ht <= ut.maxY; ++ht)
                    st && !a.tileCoordIntersectsViewport([pt, ft, ht], at) || (tt - pt <= nt ? (++lt,
                    ct = s.getTile(pt, ft, ht, _, $),
                    ct.getState() == TileState.IDLE && (et[ct.getKey()] = !0,
                    j.isKeyQueued(ct.getKey()) || j.enqueue([ct, ot, a.getTileCoordCenter(ct.tileCoord), dt])),
                    rt !== void 0 && rt(ct)) : s.useTile(pt, ft, ht, $));
        s.updateCacheSize(lt, $)
    }
}
const CanvasTileLayerRenderer$1 = CanvasTileLayerRenderer;
class TileLayer extends BaseTileLayer$1 {
    constructor(i) {
        super(i)
    }
    createRenderer() {
        return new CanvasTileLayerRenderer$1(this)
    }
}
const TileLayer$1 = TileLayer
  , TileEventType = {
    TILELOADSTART: "tileloadstart",
    TILELOADEND: "tileloadend",
    TILELOADERROR: "tileloaderror"
}
  , tmpTileCoord = [0, 0, 0]
  , DECIMALS$1 = 5;
class TileGrid {
    constructor(i) {
        this.minZoom = i.minZoom !== void 0 ? i.minZoom : 0,
        this.resolutions_ = i.resolutions,
        assert(isSorted(this.resolutions_, function(_, $) {
            return $ - _
        }, !0), "`resolutions` must be sorted in descending order");
        let s;
        if (!i.origins) {
            for (let _ = 0, $ = this.resolutions_.length - 1; _ < $; ++_)
                if (!s)
                    s = this.resolutions_[_] / this.resolutions_[_ + 1];
                else if (this.resolutions_[_] / this.resolutions_[_ + 1] !== s) {
                    s = void 0;
                    break
                }
        }
        this.zoomFactor_ = s,
        this.maxZoom = this.resolutions_.length - 1,
        this.origin_ = i.origin !== void 0 ? i.origin : null,
        this.origins_ = null,
        i.origins !== void 0 && (this.origins_ = i.origins,
        assert(this.origins_.length == this.resolutions_.length, "Number of `origins` and `resolutions` must be equal"));
        const a = i.extent;
        a !== void 0 && !this.origin_ && !this.origins_ && (this.origin_ = getTopLeft(a)),
        assert(!this.origin_ && this.origins_ || this.origin_ && !this.origins_, "Either `origin` or `origins` must be configured, never both"),
        this.tileSizes_ = null,
        i.tileSizes !== void 0 && (this.tileSizes_ = i.tileSizes,
        assert(this.tileSizes_.length == this.resolutions_.length, "Number of `tileSizes` and `resolutions` must be equal")),
        this.tileSize_ = i.tileSize !== void 0 ? i.tileSize : this.tileSizes_ ? null : DEFAULT_TILE_SIZE,
        assert(!this.tileSize_ && this.tileSizes_ || this.tileSize_ && !this.tileSizes_, "Either `tileSize` or `tileSizes` must be configured, never both"),
        this.extent_ = a !== void 0 ? a : null,
        this.fullTileRanges_ = null,
        this.tmpSize_ = [0, 0],
        this.tmpExtent_ = [0, 0, 0, 0],
        i.sizes !== void 0 ? this.fullTileRanges_ = i.sizes.map(function(_, $) {
            const _e = new TileRange$1(Math.min(0, _[0]),Math.max(_[0] - 1, -1),Math.min(0, _[1]),Math.max(_[1] - 1, -1));
            if (a) {
                const tt = this.getTileRangeForExtentAndZ(a, $);
                _e.minX = Math.max(tt.minX, _e.minX),
                _e.maxX = Math.min(tt.maxX, _e.maxX),
                _e.minY = Math.max(tt.minY, _e.minY),
                _e.maxY = Math.min(tt.maxY, _e.maxY)
            }
            return _e
        }, this) : a && this.calculateTileRanges_(a)
    }
    forEachTileCoord(i, s, a) {
        const _ = this.getTileRangeForExtentAndZ(i, s);
        for (let $ = _.minX, _e = _.maxX; $ <= _e; ++$)
            for (let tt = _.minY, nt = _.maxY; tt <= nt; ++tt)
                a([s, $, tt])
    }
    forEachTileCoordParentTileRange(i, s, a, _) {
        let $, _e, tt, nt = null, rt = i[0] - 1;
        for (this.zoomFactor_ === 2 ? (_e = i[1],
        tt = i[2]) : nt = this.getTileCoordExtent(i, _); rt >= this.minZoom; ) {
            if (this.zoomFactor_ === 2 ? (_e = Math.floor(_e / 2),
            tt = Math.floor(tt / 2),
            $ = createOrUpdate(_e, _e, tt, tt, a)) : $ = this.getTileRangeForExtentAndZ(nt, rt, a),
            s(rt, $))
                return !0;
            --rt
        }
        return !1
    }
    getExtent() {
        return this.extent_
    }
    getMaxZoom() {
        return this.maxZoom
    }
    getMinZoom() {
        return this.minZoom
    }
    getOrigin(i) {
        return this.origin_ ? this.origin_ : this.origins_[i]
    }
    getResolution(i) {
        return this.resolutions_[i]
    }
    getResolutions() {
        return this.resolutions_
    }
    getTileCoordChildTileRange(i, s, a) {
        if (i[0] < this.maxZoom) {
            if (this.zoomFactor_ === 2) {
                const $ = i[1] * 2
                  , _e = i[2] * 2;
                return createOrUpdate($, $ + 1, _e, _e + 1, s)
            }
            const _ = this.getTileCoordExtent(i, a || this.tmpExtent_);
            return this.getTileRangeForExtentAndZ(_, i[0] + 1, s)
        }
        return null
    }
    getTileRangeForTileCoordAndZ(i, s, a) {
        if (s > this.maxZoom || s < this.minZoom)
            return null;
        const _ = i[0]
          , $ = i[1]
          , _e = i[2];
        if (s === _)
            return createOrUpdate($, _e, $, _e, a);
        if (this.zoomFactor_) {
            const nt = Math.pow(this.zoomFactor_, s - _)
              , rt = Math.floor($ * nt)
              , ot = Math.floor(_e * nt);
            if (s < _)
                return createOrUpdate(rt, rt, ot, ot, a);
            const et = Math.floor(nt * ($ + 1)) - 1
              , j = Math.floor(nt * (_e + 1)) - 1;
            return createOrUpdate(rt, et, ot, j, a)
        }
        const tt = this.getTileCoordExtent(i, this.tmpExtent_);
        return this.getTileRangeForExtentAndZ(tt, s, a)
    }
    getTileRangeForExtentAndZ(i, s, a) {
        this.getTileCoordForXYAndZ_(i[0], i[3], s, !1, tmpTileCoord);
        const _ = tmpTileCoord[1]
          , $ = tmpTileCoord[2];
        this.getTileCoordForXYAndZ_(i[2], i[1], s, !0, tmpTileCoord);
        const _e = tmpTileCoord[1]
          , tt = tmpTileCoord[2];
        return createOrUpdate(_, _e, $, tt, a)
    }
    getTileCoordCenter(i) {
        const s = this.getOrigin(i[0])
          , a = this.getResolution(i[0])
          , _ = toSize(this.getTileSize(i[0]), this.tmpSize_);
        return [s[0] + (i[1] + .5) * _[0] * a, s[1] - (i[2] + .5) * _[1] * a]
    }
    getTileCoordExtent(i, s) {
        const a = this.getOrigin(i[0])
          , _ = this.getResolution(i[0])
          , $ = toSize(this.getTileSize(i[0]), this.tmpSize_)
          , _e = a[0] + i[1] * $[0] * _
          , tt = a[1] - (i[2] + 1) * $[1] * _
          , nt = _e + $[0] * _
          , rt = tt + $[1] * _;
        return createOrUpdate$2(_e, tt, nt, rt, s)
    }
    getTileCoordForCoordAndResolution(i, s, a) {
        return this.getTileCoordForXYAndResolution_(i[0], i[1], s, !1, a)
    }
    getTileCoordForXYAndResolution_(i, s, a, _, $) {
        const _e = this.getZForResolution(a)
          , tt = a / this.getResolution(_e)
          , nt = this.getOrigin(_e)
          , rt = toSize(this.getTileSize(_e), this.tmpSize_);
        let ot = tt * (i - nt[0]) / a / rt[0]
          , et = tt * (nt[1] - s) / a / rt[1];
        return _ ? (ot = ceil(ot, DECIMALS$1) - 1,
        et = ceil(et, DECIMALS$1) - 1) : (ot = floor(ot, DECIMALS$1),
        et = floor(et, DECIMALS$1)),
        createOrUpdate$1(_e, ot, et, $)
    }
    getTileCoordForXYAndZ_(i, s, a, _, $) {
        const _e = this.getOrigin(a)
          , tt = this.getResolution(a)
          , nt = toSize(this.getTileSize(a), this.tmpSize_);
        let rt = (i - _e[0]) / tt / nt[0]
          , ot = (_e[1] - s) / tt / nt[1];
        return _ ? (rt = ceil(rt, DECIMALS$1) - 1,
        ot = ceil(ot, DECIMALS$1) - 1) : (rt = floor(rt, DECIMALS$1),
        ot = floor(ot, DECIMALS$1)),
        createOrUpdate$1(a, rt, ot, $)
    }
    getTileCoordForCoordAndZ(i, s, a) {
        return this.getTileCoordForXYAndZ_(i[0], i[1], s, !1, a)
    }
    getTileCoordResolution(i) {
        return this.resolutions_[i[0]]
    }
    getTileSize(i) {
        return this.tileSize_ ? this.tileSize_ : this.tileSizes_[i]
    }
    getFullTileRange(i) {
        return this.fullTileRanges_ ? this.fullTileRanges_[i] : this.extent_ ? this.getTileRangeForExtentAndZ(this.extent_, i) : null
    }
    getZForResolution(i, s) {
        const a = linearFindNearest(this.resolutions_, i, s || 0);
        return clamp(a, this.minZoom, this.maxZoom)
    }
    tileCoordIntersectsViewport(i, s) {
        return intersectsLinearRing(s, 0, s.length, 2, this.getTileCoordExtent(i))
    }
    calculateTileRanges_(i) {
        const s = this.resolutions_.length
          , a = new Array(s);
        for (let _ = this.minZoom; _ < s; ++_)
            a[_] = this.getTileRangeForExtentAndZ(i, _);
        this.fullTileRanges_ = a
    }
}
const TileGrid$1 = TileGrid;
function getForProjection(o) {
    let i = o.getDefaultTileGrid();
    return i || (i = createForProjection(o),
    o.setDefaultTileGrid(i)),
    i
}
function wrapX(o, i, s) {
    const a = i[0]
      , _ = o.getTileCoordCenter(i)
      , $ = extentFromProjection(s);
    if (!containsCoordinate($, _)) {
        const _e = getWidth($)
          , tt = Math.ceil(($[0] - _[0]) / _e);
        return _[0] += _e * tt,
        o.getTileCoordForCoordAndZ(_, a)
    }
    return i
}
function createForExtent(o, i, s, a) {
    a = a !== void 0 ? a : "top-left";
    const _ = resolutionsFromExtent(o, i, s);
    return new TileGrid$1({
        extent: o,
        origin: getCorner(o, a),
        resolutions: _,
        tileSize: s
    })
}
function createXYZ(o) {
    const i = o || {}
      , s = i.extent || get$1("EPSG:3857").getExtent()
      , a = {
        extent: s,
        minZoom: i.minZoom,
        tileSize: i.tileSize,
        resolutions: resolutionsFromExtent(s, i.maxZoom, i.tileSize, i.maxResolution)
    };
    return new TileGrid$1(a)
}
function resolutionsFromExtent(o, i, s, a) {
    i = i !== void 0 ? i : DEFAULT_MAX_ZOOM,
    s = toSize(s !== void 0 ? s : DEFAULT_TILE_SIZE);
    const _ = getHeight(o)
      , $ = getWidth(o);
    a = a > 0 ? a : Math.max($ / s[0], _ / s[1]);
    const _e = i + 1
      , tt = new Array(_e);
    for (let nt = 0; nt < _e; ++nt)
        tt[nt] = a / Math.pow(2, nt);
    return tt
}
function createForProjection(o, i, s, a) {
    const _ = extentFromProjection(o);
    return createForExtent(_, i, s, a)
}
function extentFromProjection(o) {
    o = get$1(o);
    let i = o.getExtent();
    if (!i) {
        const s = 180 * METERS_PER_UNIT$1.degrees / o.getMetersPerUnit();
        i = createOrUpdate$2(-s, -s, s, s)
    }
    return i
}
class TileSource extends Source$1 {
    constructor(i) {
        super({
            attributions: i.attributions,
            attributionsCollapsible: i.attributionsCollapsible,
            projection: i.projection,
            state: i.state,
            wrapX: i.wrapX,
            interpolate: i.interpolate
        }),
        this.on,
        this.once,
        this.un,
        this.opaque_ = i.opaque !== void 0 ? i.opaque : !1,
        this.tilePixelRatio_ = i.tilePixelRatio !== void 0 ? i.tilePixelRatio : 1,
        this.tileGrid = i.tileGrid !== void 0 ? i.tileGrid : null;
        const s = [256, 256];
        this.tileGrid && toSize(this.tileGrid.getTileSize(this.tileGrid.getMinZoom()), s),
        this.tileCache = new TileCache$1(i.cacheSize || 0),
        this.tmpSize = [0, 0],
        this.key_ = i.key || "",
        this.tileOptions = {
            transition: i.transition,
            interpolate: i.interpolate
        },
        this.zDirection = i.zDirection ? i.zDirection : 0
    }
    canExpireCache() {
        return this.tileCache.canExpireCache()
    }
    expireCache(i, s) {
        const a = this.getTileCacheForProjection(i);
        a && a.expireCache(s)
    }
    forEachLoadedTile(i, s, a, _) {
        const $ = this.getTileCacheForProjection(i);
        if (!$)
            return !1;
        let _e = !0, tt, nt, rt;
        for (let ot = a.minX; ot <= a.maxX; ++ot)
            for (let et = a.minY; et <= a.maxY; ++et)
                nt = getKeyZXY(s, ot, et),
                rt = !1,
                $.containsKey(nt) && (tt = $.get(nt),
                rt = tt.getState() === TileState.LOADED,
                rt && (rt = _(tt) !== !1)),
                rt || (_e = !1);
        return _e
    }
    getGutterForProjection(i) {
        return 0
    }
    getKey() {
        return this.key_
    }
    setKey(i) {
        this.key_ !== i && (this.key_ = i,
        this.changed())
    }
    getOpaque(i) {
        return this.opaque_
    }
    getResolutions(i) {
        const s = i ? this.getTileGridForProjection(i) : this.tileGrid;
        return s ? s.getResolutions() : null
    }
    getTile(i, s, a, _, $) {
        return abstract()
    }
    getTileGrid() {
        return this.tileGrid
    }
    getTileGridForProjection(i) {
        return this.tileGrid ? this.tileGrid : getForProjection(i)
    }
    getTileCacheForProjection(i) {
        const s = this.getProjection();
        return assert(s === null || equivalent(s, i), "A VectorTile source can only be rendered if it has a projection compatible with the view projection."),
        this.tileCache
    }
    getTilePixelRatio(i) {
        return this.tilePixelRatio_
    }
    getTilePixelSize(i, s, a) {
        const _ = this.getTileGridForProjection(a)
          , $ = this.getTilePixelRatio(s)
          , _e = toSize(_.getTileSize(i), this.tmpSize);
        return $ == 1 ? _e : scale(_e, $, this.tmpSize)
    }
    getTileCoordForTileUrlFunction(i, s) {
        s = s !== void 0 ? s : this.getProjection();
        const a = this.getTileGridForProjection(s);
        return this.getWrapX() && s.isGlobal() && (i = wrapX(a, i, s)),
        withinExtentAndZ(i, a) ? i : null
    }
    clear() {
        this.tileCache.clear()
    }
    refresh() {
        this.clear(),
        super.refresh()
    }
    updateCacheSize(i, s) {
        const a = this.getTileCacheForProjection(s);
        i > a.highWaterMark && (a.highWaterMark = i)
    }
    useTile(i, s, a, _) {}
}
class TileSourceEvent extends Event$1 {
    constructor(i, s) {
        super(i),
        this.tile = s
    }
}
const TileSource$1 = TileSource;
function createFromTemplate(o, i) {
    const s = /\{z\}/g
      , a = /\{x\}/g
      , _ = /\{y\}/g
      , $ = /\{-y\}/g;
    return function(_e, tt, nt) {
        if (_e)
            return o.replace(s, _e[0].toString()).replace(a, _e[1].toString()).replace(_, _e[2].toString()).replace($, function() {
                const rt = _e[0]
                  , ot = i.getFullTileRange(rt);
                return assert(ot, "The {-y} placeholder requires a tile grid with extent"),
                (ot.getHeight() - _e[2] - 1).toString()
            })
    }
}
function createFromTemplates(o, i) {
    const s = o.length
      , a = new Array(s);
    for (let _ = 0; _ < s; ++_)
        a[_] = createFromTemplate(o[_], i);
    return createFromTileUrlFunctions(a)
}
function createFromTileUrlFunctions(o) {
    return o.length === 1 ? o[0] : function(i, s, a) {
        if (!i)
            return;
        const _ = hash(i)
          , $ = modulo(_, o.length);
        return o[$](i, s, a)
    }
}
function expandUrl(o) {
    const i = [];
    let s = /\{([a-z])-([a-z])\}/.exec(o);
    if (s) {
        const a = s[1].charCodeAt(0)
          , _ = s[2].charCodeAt(0);
        let $;
        for ($ = a; $ <= _; ++$)
            i.push(o.replace(s[0], String.fromCharCode($)));
        return i
    }
    if (s = /\{(\d+)-(\d+)\}/.exec(o),
    s) {
        const a = parseInt(s[2], 10);
        for (let _ = parseInt(s[1], 10); _ <= a; _++)
            i.push(o.replace(s[0], _.toString()));
        return i
    }
    return i.push(o),
    i
}
class UrlTile extends TileSource$1 {
    constructor(i) {
        super({
            attributions: i.attributions,
            cacheSize: i.cacheSize,
            opaque: i.opaque,
            projection: i.projection,
            state: i.state,
            tileGrid: i.tileGrid,
            tilePixelRatio: i.tilePixelRatio,
            wrapX: i.wrapX,
            transition: i.transition,
            interpolate: i.interpolate,
            key: i.key,
            attributionsCollapsible: i.attributionsCollapsible,
            zDirection: i.zDirection
        }),
        this.generateTileUrlFunction_ = this.tileUrlFunction === UrlTile.prototype.tileUrlFunction,
        this.tileLoadFunction = i.tileLoadFunction,
        i.tileUrlFunction && (this.tileUrlFunction = i.tileUrlFunction),
        this.urls = null,
        i.urls ? this.setUrls(i.urls) : i.url && this.setUrl(i.url),
        this.tileLoadingKeys_ = {}
    }
    getTileLoadFunction() {
        return this.tileLoadFunction
    }
    getTileUrlFunction() {
        return Object.getPrototypeOf(this).tileUrlFunction === this.tileUrlFunction ? this.tileUrlFunction.bind(this) : this.tileUrlFunction
    }
    getUrls() {
        return this.urls
    }
    handleTileChange(i) {
        const s = i.target
          , a = getUid(s)
          , _ = s.getState();
        let $;
        _ == TileState.LOADING ? (this.tileLoadingKeys_[a] = !0,
        $ = TileEventType.TILELOADSTART) : a in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[a],
        $ = _ == TileState.ERROR ? TileEventType.TILELOADERROR : _ == TileState.LOADED ? TileEventType.TILELOADEND : void 0),
        $ != null && this.dispatchEvent(new TileSourceEvent($,s))
    }
    setTileLoadFunction(i) {
        this.tileCache.clear(),
        this.tileLoadFunction = i,
        this.changed()
    }
    setTileUrlFunction(i, s) {
        this.tileUrlFunction = i,
        this.tileCache.pruneExceptNewestZ(),
        typeof s < "u" ? this.setKey(s) : this.changed()
    }
    setUrl(i) {
        const s = expandUrl(i);
        this.urls = s,
        this.setUrls(s)
    }
    setUrls(i) {
        this.urls = i;
        const s = i.join(`
`);
        this.generateTileUrlFunction_ ? this.setTileUrlFunction(createFromTemplates(i, this.tileGrid), s) : this.setKey(s)
    }
    tileUrlFunction(i, s, a) {}
    useTile(i, s, a) {
        const _ = getKeyZXY(i, s, a);
        this.tileCache.containsKey(_) && this.tileCache.get(_)
    }
}
const UrlTile$1 = UrlTile;
class TileImage extends UrlTile$1 {
    constructor(i) {
        super({
            attributions: i.attributions,
            cacheSize: i.cacheSize,
            opaque: i.opaque,
            projection: i.projection,
            state: i.state,
            tileGrid: i.tileGrid,
            tileLoadFunction: i.tileLoadFunction ? i.tileLoadFunction : defaultTileLoadFunction,
            tilePixelRatio: i.tilePixelRatio,
            tileUrlFunction: i.tileUrlFunction,
            url: i.url,
            urls: i.urls,
            wrapX: i.wrapX,
            transition: i.transition,
            interpolate: i.interpolate !== void 0 ? i.interpolate : !0,
            key: i.key,
            attributionsCollapsible: i.attributionsCollapsible,
            zDirection: i.zDirection
        }),
        this.crossOrigin = i.crossOrigin !== void 0 ? i.crossOrigin : null,
        this.tileClass = i.tileClass !== void 0 ? i.tileClass : ImageTile$1,
        this.tileCacheForProjection = {},
        this.tileGridForProjection = {},
        this.reprojectionErrorThreshold_ = i.reprojectionErrorThreshold,
        this.renderReprojectionEdges_ = !1
    }
    canExpireCache() {
        if (this.tileCache.canExpireCache())
            return !0;
        for (const i in this.tileCacheForProjection)
            if (this.tileCacheForProjection[i].canExpireCache())
                return !0;
        return !1
    }
    expireCache(i, s) {
        const a = this.getTileCacheForProjection(i);
        this.tileCache.expireCache(this.tileCache == a ? s : {});
        for (const _ in this.tileCacheForProjection) {
            const $ = this.tileCacheForProjection[_];
            $.expireCache($ == a ? s : {})
        }
    }
    getGutterForProjection(i) {
        return this.getProjection() && i && !equivalent(this.getProjection(), i) ? 0 : this.getGutter()
    }
    getGutter() {
        return 0
    }
    getKey() {
        let i = super.getKey();
        return this.getInterpolate() || (i += ":disable-interpolation"),
        i
    }
    getOpaque(i) {
        return this.getProjection() && i && !equivalent(this.getProjection(), i) ? !1 : super.getOpaque(i)
    }
    getTileGridForProjection(i) {
        const s = this.getProjection();
        if (this.tileGrid && (!s || equivalent(s, i)))
            return this.tileGrid;
        const a = getUid(i);
        return a in this.tileGridForProjection || (this.tileGridForProjection[a] = getForProjection(i)),
        this.tileGridForProjection[a]
    }
    getTileCacheForProjection(i) {
        const s = this.getProjection();
        if (!s || equivalent(s, i))
            return this.tileCache;
        const a = getUid(i);
        return a in this.tileCacheForProjection || (this.tileCacheForProjection[a] = new TileCache$1(this.tileCache.highWaterMark)),
        this.tileCacheForProjection[a]
    }
    createTile_(i, s, a, _, $, _e) {
        const tt = [i, s, a]
          , nt = this.getTileCoordForTileUrlFunction(tt, $)
          , rt = nt ? this.tileUrlFunction(nt, _, $) : void 0
          , ot = new this.tileClass(tt,rt !== void 0 ? TileState.IDLE : TileState.EMPTY,rt !== void 0 ? rt : "",this.crossOrigin,this.tileLoadFunction,this.tileOptions);
        return ot.key = _e,
        ot.addEventListener(EventType.CHANGE, this.handleTileChange.bind(this)),
        ot
    }
    getTile(i, s, a, _, $) {
        const _e = this.getProjection();
        if (!_e || !$ || equivalent(_e, $))
            return this.getTileInternal(i, s, a, _, _e || $);
        const tt = this.getTileCacheForProjection($)
          , nt = [i, s, a];
        let rt;
        const ot = getKey(nt);
        tt.containsKey(ot) && (rt = tt.get(ot));
        const et = this.getKey();
        if (rt && rt.key == et)
            return rt;
        const j = this.getTileGridForProjection(_e)
          , it = this.getTileGridForProjection($)
          , st = this.getTileCoordForTileUrlFunction(nt, $)
          , at = new ReprojTile$1(_e,j,$,it,nt,st,this.getTilePixelRatio(_),this.getGutter(), (lt, ct, ut, dt) => this.getTileInternal(lt, ct, ut, dt, _e),this.reprojectionErrorThreshold_,this.renderReprojectionEdges_,this.getInterpolate());
        return at.key = et,
        rt ? (at.interimTile = rt,
        at.refreshInterimChain(),
        tt.replace(ot, at)) : tt.set(ot, at),
        at
    }
    getTileInternal(i, s, a, _, $) {
        let _e = null;
        const tt = getKeyZXY(i, s, a)
          , nt = this.getKey();
        if (!this.tileCache.containsKey(tt))
            _e = this.createTile_(i, s, a, _, $, nt),
            this.tileCache.set(tt, _e);
        else if (_e = this.tileCache.get(tt),
        _e.key != nt) {
            const rt = _e;
            _e = this.createTile_(i, s, a, _, $, nt),
            rt.getState() == TileState.IDLE ? _e.interimTile = rt.interimTile : _e.interimTile = rt,
            _e.refreshInterimChain(),
            this.tileCache.replace(tt, _e)
        }
        return _e
    }
    setRenderReprojectionEdges(i) {
        if (this.renderReprojectionEdges_ != i) {
            this.renderReprojectionEdges_ = i;
            for (const s in this.tileCacheForProjection)
                this.tileCacheForProjection[s].clear();
            this.changed()
        }
    }
    setTileGridForProjection(i, s) {
        const a = get$1(i);
        if (a) {
            const _ = getUid(a);
            _ in this.tileGridForProjection || (this.tileGridForProjection[_] = s)
        }
    }
    clear() {
        super.clear();
        for (const i in this.tileCacheForProjection)
            this.tileCacheForProjection[i].clear()
    }
}
function defaultTileLoadFunction(o, i) {
    o.getImage().src = i
}
const TileImage$1 = TileImage;
class XYZ extends TileImage$1 {
    constructor(i) {
        i = i || {};
        const s = i.projection !== void 0 ? i.projection : "EPSG:3857"
          , a = i.tileGrid !== void 0 ? i.tileGrid : createXYZ({
            extent: extentFromProjection(s),
            maxResolution: i.maxResolution,
            maxZoom: i.maxZoom,
            minZoom: i.minZoom,
            tileSize: i.tileSize
        });
        super({
            attributions: i.attributions,
            cacheSize: i.cacheSize,
            crossOrigin: i.crossOrigin,
            interpolate: i.interpolate,
            opaque: i.opaque,
            projection: s,
            reprojectionErrorThreshold: i.reprojectionErrorThreshold,
            tileGrid: a,
            tileLoadFunction: i.tileLoadFunction,
            tilePixelRatio: i.tilePixelRatio,
            tileUrlFunction: i.tileUrlFunction,
            url: i.url,
            urls: i.urls,
            wrapX: i.wrapX !== void 0 ? i.wrapX : !0,
            transition: i.transition,
            attributionsCollapsible: i.attributionsCollapsible,
            zDirection: i.zDirection
        }),
        this.gutter_ = i.gutter !== void 0 ? i.gutter : 0
    }
    getGutter() {
        return this.gutter_
    }
}
const XYZ$1 = XYZ
  , DECIMALS = 4;
function appendParams(o, i) {
    const s = [];
    Object.keys(i).forEach(function(_) {
        i[_] !== null && i[_] !== void 0 && s.push(_ + "=" + encodeURIComponent(i[_]))
    });
    const a = s.join("&");
    return o = o.replace(/[?&]$/, ""),
    o += o.includes("?") ? "&" : "?",
    o + a
}
const DEFAULT_VERSION = "1.3.0";
function getRequestUrl$1(o, i, s, a, _) {
    _.WIDTH = s[0],
    _.HEIGHT = s[1];
    const $ = a.getAxisOrientation();
    let _e;
    const tt = compareVersions(_.VERSION, "1.3") >= 0;
    return _[tt ? "CRS" : "SRS"] = a.getCode(),
    tt && $.substr(0, 2) == "ne" ? _e = [i[1], i[0], i[3], i[2]] : _e = i,
    _.BBOX = _e.join(","),
    appendParams(o, _)
}
function getImageSrc(o, i, s, a, _, $, _e) {
    $ = Object.assign({
        REQUEST: "GetMap"
    }, $);
    const tt = i / s
      , nt = [round(getWidth(o) / tt, DECIMALS), round(getHeight(o) / tt, DECIMALS)];
    if (s != 1)
        switch (_e) {
        case "geoserver":
            const ot = 90 * s + .5 | 0;
            "FORMAT_OPTIONS"in $ ? $.FORMAT_OPTIONS += ";dpi:" + ot : $.FORMAT_OPTIONS = "dpi:" + ot;
            break;
        case "mapserver":
            $.MAP_RESOLUTION = 90 * s;
            break;
        case "carmentaserver":
        case "qgis":
            $.DPI = 90 * s;
            break;
        default:
            throw new Error("Unknown `serverType` configured")
        }
    return getRequestUrl$1(_, o, nt, a, $)
}
function getRequestParams(o, i) {
    return Object.assign({
        REQUEST: i,
        SERVICE: "WMS",
        VERSION: DEFAULT_VERSION,
        FORMAT: "image/png",
        STYLES: "",
        TRANSPARENT: !0
    }, o)
}
class TileWMS extends TileImage$1 {
    constructor(i) {
        i = i || {};
        const s = Object.assign({}, i.params)
          , a = "TRANSPARENT"in s ? s.TRANSPARENT : !0;
        super({
            attributions: i.attributions,
            attributionsCollapsible: i.attributionsCollapsible,
            cacheSize: i.cacheSize,
            crossOrigin: i.crossOrigin,
            interpolate: i.interpolate,
            opaque: !a,
            projection: i.projection,
            reprojectionErrorThreshold: i.reprojectionErrorThreshold,
            tileClass: i.tileClass,
            tileGrid: i.tileGrid,
            tileLoadFunction: i.tileLoadFunction,
            url: i.url,
            urls: i.urls,
            wrapX: i.wrapX !== void 0 ? i.wrapX : !0,
            transition: i.transition,
            zDirection: i.zDirection
        }),
        this.gutter_ = i.gutter !== void 0 ? i.gutter : 0,
        this.params_ = s,
        this.v13_ = !0,
        this.serverType_ = i.serverType,
        this.hidpi_ = i.hidpi !== void 0 ? i.hidpi : !0,
        this.tmpExtent_ = createEmpty(),
        this.updateV13_(),
        this.setKey(this.getKeyForParams_())
    }
    getFeatureInfoUrl(i, s, a, _) {
        const $ = get$1(a)
          , _e = this.getProjection() || $;
        let tt = this.getTileGrid();
        tt || (tt = this.getTileGridForProjection(_e));
        const nt = transform(i, $, _e)
          , rt = calculateSourceResolution(_e, $, i, s)
          , ot = tt.getZForResolution(rt, this.zDirection)
          , et = tt.getResolution(ot)
          , j = tt.getTileCoordForCoordAndZ(nt, ot);
        if (tt.getResolutions().length <= j[0])
            return;
        let it = tt.getTileCoordExtent(j, this.tmpExtent_);
        const st = this.gutter_;
        st !== 0 && (it = buffer$1(it, et * st, it));
        const at = {
            QUERY_LAYERS: this.params_.LAYERS
        };
        Object.assign(at, getRequestParams(this.params_, "GetFeatureInfo"), _);
        const lt = Math.floor((nt[0] - it[0]) / et)
          , ct = Math.floor((it[3] - nt[1]) / et);
        return at[this.v13_ ? "I" : "X"] = lt,
        at[this.v13_ ? "J" : "Y"] = ct,
        this.getRequestUrl_(j, it, 1, _e || $, at)
    }
    getLegendUrl(i, s) {
        if (this.urls[0] === void 0)
            return;
        const a = {
            SERVICE: "WMS",
            VERSION: DEFAULT_VERSION,
            REQUEST: "GetLegendGraphic",
            FORMAT: "image/png"
        };
        if (s === void 0 || s.LAYER === void 0) {
            const _ = this.params_.LAYERS;
            if (!(!Array.isArray(_) || _.length === 1))
                return;
            a.LAYER = _
        }
        if (i !== void 0) {
            const _ = this.getProjection() ? this.getProjection().getMetersPerUnit() : 1
              , $ = 28e-5;
            a.SCALE = i * _ / $
        }
        return Object.assign(a, s),
        appendParams(this.urls[0], a)
    }
    getGutter() {
        return this.gutter_
    }
    getParams() {
        return this.params_
    }
    getRequestUrl_(i, s, a, _, $) {
        const _e = this.urls;
        if (!_e)
            return;
        let tt;
        if (_e.length == 1)
            tt = _e[0];
        else {
            const nt = modulo(hash(i), _e.length);
            tt = _e[nt]
        }
        return getImageSrc(s, (this.tileGrid || this.getTileGridForProjection(_)).getResolution(i[0]), a, _, tt, $, this.serverType_)
    }
    getTilePixelRatio(i) {
        return !this.hidpi_ || this.serverType_ === void 0 ? 1 : i
    }
    getKeyForParams_() {
        let i = 0;
        const s = [];
        for (const a in this.params_)
            s[i++] = a + "-" + this.params_[a];
        return s.join("/")
    }
    updateParams(i) {
        Object.assign(this.params_, i),
        this.updateV13_(),
        this.setKey(this.getKeyForParams_())
    }
    updateV13_() {
        const i = this.params_.VERSION || DEFAULT_VERSION;
        this.v13_ = compareVersions(i, "1.3") >= 0
    }
    tileUrlFunction(i, s, a) {
        let _ = this.getTileGrid();
        if (_ || (_ = this.getTileGridForProjection(a)),
        _.getResolutions().length <= i[0])
            return;
        s != 1 && (!this.hidpi_ || this.serverType_ === void 0) && (s = 1);
        const $ = _.getResolution(i[0]);
        let _e = _.getTileCoordExtent(i, this.tmpExtent_);
        const tt = this.gutter_;
        tt !== 0 && (_e = buffer$1(_e, $ * tt, _e));
        const nt = Object.assign({}, getRequestParams(this.params_, "GetMap"));
        return this.getRequestUrl_(i, _e, s, a, nt)
    }
}
const TileWMS$1 = TileWMS;
class DataTileSource extends TileSource$1 {
    constructor(i) {
        const s = i.projection === void 0 ? "EPSG:3857" : i.projection;
        let a = i.tileGrid;
        a === void 0 && s && (a = createXYZ({
            extent: extentFromProjection(s),
            maxResolution: i.maxResolution,
            maxZoom: i.maxZoom,
            minZoom: i.minZoom,
            tileSize: i.tileSize
        })),
        super({
            cacheSize: .1,
            attributions: i.attributions,
            attributionsCollapsible: i.attributionsCollapsible,
            projection: s,
            tileGrid: a,
            opaque: i.opaque,
            state: i.state,
            wrapX: i.wrapX,
            transition: i.transition,
            interpolate: i.interpolate
        }),
        this.gutter_ = i.gutter !== void 0 ? i.gutter : 0,
        this.tileSize_ = i.tileSize ? toSize(i.tileSize) : null,
        this.tileSizes_ = null,
        this.tileLoadingKeys_ = {},
        this.loader_ = i.loader,
        this.handleTileChange_ = this.handleTileChange_.bind(this),
        this.bandCount = i.bandCount === void 0 ? 4 : i.bandCount,
        this.tileGridForProjection_ = {},
        this.tileCacheForProjection_ = {}
    }
    setTileSizes(i) {
        this.tileSizes_ = i
    }
    getTileSize(i) {
        if (this.tileSizes_)
            return this.tileSizes_[i];
        if (this.tileSize_)
            return this.tileSize_;
        const s = this.getTileGrid();
        return s ? toSize(s.getTileSize(i)) : [256, 256]
    }
    getGutterForProjection(i) {
        const s = this.getProjection();
        return !s || equivalent(s, i) ? this.gutter_ : 0
    }
    setLoader(i) {
        this.loader_ = i
    }
    getReprojTile_(i, s, a, _, $) {
        const _e = this.getTileCacheForProjection(_)
          , tt = getKeyZXY(i, s, a);
        if (_e.containsKey(tt)) {
            const lt = _e.get(tt);
            if (lt && lt.key == this.getKey())
                return lt
        }
        const nt = this.getTileGrid()
          , rt = Math.max.apply(null, nt.getResolutions().map( (lt, ct) => {
            const ut = toSize(nt.getTileSize(ct))
              , dt = this.getTileSize(ct);
            return Math.max(dt[0] / ut[0], dt[1] / ut[1])
        }
        ))
          , ot = this.getTileGridForProjection($)
          , et = this.getTileGridForProjection(_)
          , j = [i, s, a]
          , it = this.getTileCoordForTileUrlFunction(j, _)
          , st = Object.assign({
            sourceProj: $,
            sourceTileGrid: ot,
            targetProj: _,
            targetTileGrid: et,
            tileCoord: j,
            wrappedTileCoord: it,
            pixelRatio: rt,
            gutter: this.getGutterForProjection($),
            getTileFunction: (lt, ct, ut, dt) => this.getTile(lt, ct, ut, dt, $)
        }, this.tileOptions)
          , at = new ReprojDataTile$1(st);
        return at.key = this.getKey(),
        at
    }
    getTile(i, s, a, _, $) {
        const _e = this.getProjection();
        if (_e && $ && !equivalent(_e, $))
            return this.getReprojTile_(i, s, a, $, _e);
        const tt = this.getTileSize(i)
          , nt = getKeyZXY(i, s, a);
        if (this.tileCache.containsKey(nt))
            return this.tileCache.get(nt);
        const rt = this.loader_;
        function ot() {
            return toPromise(function() {
                return rt(i, s, a)
            })
        }
        const et = Object.assign({
            tileCoord: [i, s, a],
            loader: ot,
            size: tt
        }, this.tileOptions)
          , j = new DataTile$2(et);
        return j.key = this.getKey(),
        j.addEventListener(EventType.CHANGE, this.handleTileChange_),
        this.tileCache.set(nt, j),
        j
    }
    handleTileChange_(i) {
        const s = i.target
          , a = getUid(s)
          , _ = s.getState();
        let $;
        _ == TileState.LOADING ? (this.tileLoadingKeys_[a] = !0,
        $ = TileEventType.TILELOADSTART) : a in this.tileLoadingKeys_ && (delete this.tileLoadingKeys_[a],
        $ = _ == TileState.ERROR ? TileEventType.TILELOADERROR : _ == TileState.LOADED ? TileEventType.TILELOADEND : void 0),
        $ && this.dispatchEvent(new TileSourceEvent($,s))
    }
    getTileGridForProjection(i) {
        const s = this.getProjection();
        if (this.tileGrid && (!s || equivalent(s, i)))
            return this.tileGrid;
        const a = getUid(i);
        return a in this.tileGridForProjection_ || (this.tileGridForProjection_[a] = getForProjection(i)),
        this.tileGridForProjection_[a]
    }
    setTileGridForProjection(i, s) {
        const a = get$1(i);
        if (a) {
            const _ = getUid(a);
            _ in this.tileGridForProjection_ || (this.tileGridForProjection_[_] = s)
        }
    }
    getTileCacheForProjection(i) {
        const s = this.getProjection();
        if (!s || equivalent(s, i))
            return this.tileCache;
        const a = getUid(i);
        return a in this.tileCacheForProjection_ || (this.tileCacheForProjection_[a] = new TileCache$1(.1)),
        this.tileCacheForProjection_[a]
    }
    expireCache(i, s) {
        const a = this.getTileCacheForProjection(i);
        this.tileCache.expireCache(this.tileCache == a ? s : {});
        for (const _ in this.tileCacheForProjection_) {
            const $ = this.tileCacheForProjection_[_];
            $.expireCache($ == a ? s : {})
        }
    }
    clear() {
        super.clear();
        for (const i in this.tileCacheForProjection_)
            this.tileCacheForProjection_[i].clear()
    }
}
const DataTile = DataTileSource;
function uncurryThis(o) {
    return (i, ...s) => ReflectApply(o, i, s)
}
function uncurryThisGetter(o, i) {
    return uncurryThis(ReflectGetOwnPropertyDescriptor(o, i).get)
}
const {apply: ReflectApply, construct: ReflectConstruct, defineProperty: ReflectDefineProperty, get: ReflectGet, getOwnPropertyDescriptor: ReflectGetOwnPropertyDescriptor, getPrototypeOf: ReflectGetPrototypeOf, has: ReflectHas, ownKeys: ReflectOwnKeys, set: ReflectSet, setPrototypeOf: ReflectSetPrototypeOf} = Reflect
  , {iterator: SymbolIterator, species: SymbolSpecies, toStringTag: SymbolToStringTag, for: SymbolFor} = Symbol
  , NativeObject = Object
  , {create: ObjectCreate, defineProperty: ObjectDefineProperty, freeze: ObjectFreeze, is: ObjectIs} = NativeObject
  , NativeArray = Array
  , ArrayPrototype = NativeArray.prototype
  , NativeArrayPrototypeSymbolIterator = ArrayPrototype[SymbolIterator]
  , ArrayPrototypeSymbolIterator = uncurryThis(NativeArrayPrototypeSymbolIterator)
  , NativeArrayBuffer = ArrayBuffer
  , ArrayBufferPrototype = NativeArrayBuffer.prototype;
uncurryThisGetter(ArrayBufferPrototype, "byteLength");
const NativeSharedArrayBuffer = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : null;
NativeSharedArrayBuffer && uncurryThisGetter(NativeSharedArrayBuffer.prototype, "byteLength");
const TypedArray = ReflectGetPrototypeOf(Uint8Array);
TypedArray.from;
const TypedArrayPrototype = TypedArray.prototype;
TypedArrayPrototype[SymbolIterator];
uncurryThis(TypedArrayPrototype.keys);
uncurryThis(TypedArrayPrototype.values);
uncurryThis(TypedArrayPrototype.entries);
uncurryThis(TypedArrayPrototype.set);
uncurryThis(TypedArrayPrototype.reverse);
uncurryThis(TypedArrayPrototype.fill);
uncurryThis(TypedArrayPrototype.copyWithin);
uncurryThis(TypedArrayPrototype.sort);
uncurryThis(TypedArrayPrototype.slice);
uncurryThis(TypedArrayPrototype.subarray);
uncurryThisGetter(TypedArrayPrototype, "buffer");
uncurryThisGetter(TypedArrayPrototype, "byteOffset");
uncurryThisGetter(TypedArrayPrototype, "length");
uncurryThisGetter(TypedArrayPrototype, SymbolToStringTag);
const NativeUint16Array = Uint16Array
  , NativeUint32Array = Uint32Array
  , NativeFloat32Array = Float32Array
  , ArrayIteratorPrototype = ReflectGetPrototypeOf([][SymbolIterator]())
  , ArrayIteratorPrototypeNext = uncurryThis(ArrayIteratorPrototype.next)
  , GeneratorPrototypeNext = uncurryThis(function*() {}().next)
  , IteratorPrototype = ReflectGetPrototypeOf(ArrayIteratorPrototype)
  , DataViewPrototype = DataView.prototype
  , DataViewPrototypeGetUint16 = uncurryThis(DataViewPrototype.getUint16)
  , NativeWeakMap = WeakMap
  , WeakMapPrototype = NativeWeakMap.prototype
  , WeakMapPrototypeGet = uncurryThis(WeakMapPrototype.get)
  , WeakMapPrototypeSet = uncurryThis(WeakMapPrototype.set)
  , arrayIterators = new NativeWeakMap
  , SafeIteratorPrototype = ObjectCreate(null, {
    next: {
        value: function o() {
            const i = WeakMapPrototypeGet(arrayIterators, this);
            return ArrayIteratorPrototypeNext(i)
        }
    },
    [SymbolIterator]: {
        value: function o() {
            return this
        }
    }
});
function safeIfNeeded(o) {
    if (o[SymbolIterator] === NativeArrayPrototypeSymbolIterator && ArrayIteratorPrototype.next === ArrayIteratorPrototypeNext)
        return o;
    const i = ObjectCreate(SafeIteratorPrototype);
    return WeakMapPrototypeSet(arrayIterators, i, ArrayPrototypeSymbolIterator(o)),
    i
}
const generators = new NativeWeakMap
  , DummyArrayIteratorPrototype = ObjectCreate(IteratorPrototype, {
    next: {
        value: function o() {
            const i = WeakMapPrototypeGet(generators, this);
            return GeneratorPrototypeNext(i)
        },
        writable: !0,
        configurable: !0
    }
});
for (const o of ReflectOwnKeys(ArrayIteratorPrototype))
    o !== "next" && ObjectDefineProperty(DummyArrayIteratorPrototype, o, ReflectGetOwnPropertyDescriptor(ArrayIteratorPrototype, o));
const mantissaBitLength = 10
  , mantissaMask = 1023
  , buffer = new NativeArrayBuffer(4)
  , floatView = new NativeFloat32Array(buffer)
  , uint32View = new NativeUint32Array(buffer)
  , mantissaTable = new NativeUint32Array(2048);
for (let o = 1; o < 1024; ++o) {
    let i = o << 13
      , s = 0;
    for (; !(i & 8388608); )
        i <<= 1,
        s -= 8388608;
    i &= -8388609,
    s += 947912704,
    mantissaTable[o] = i | s
}
for (let o = 1024; o < 2048; ++o)
    mantissaTable[o] = 939524096 + (o - 1024 << 13);
const exponentTable = new NativeUint32Array(64);
for (let o = 1; o < 31; ++o)
    exponentTable[o] = o << 23;
exponentTable[31] = 1199570944;
exponentTable[32] = 2147483648;
for (let o = 33; o < 63; ++o)
    exponentTable[o] = 2147483648 + (o - 32 << 23);
exponentTable[63] = 3347054592;
const offsetTable = new NativeUint16Array(64);
for (let o = 1; o < 64; ++o)
    o !== 32 && (offsetTable[o] = 1024);
function convertToNumber(o) {
    const i = o >> mantissaBitLength;
    return uint32View[0] = mantissaTable[offsetTable[i] + (o & mantissaMask)] + exponentTable[i],
    floatView[0]
}
function getFloat16(o, i, ...s) {
    return convertToNumber(DataViewPrototypeGetUint16(o, i, ...safeIfNeeded(s)))
}
var getAttribute$2 = {
    exports: {}
};
function getAttribute(o, i, s) {
    const a = s && s.debug || !1;
    a && console.log("[xml-utils] getting " + i + " in " + o);
    const _ = typeof o == "object" ? o.outer : o
      , $ = _.slice(0, _.indexOf(">") + 1)
      , _e = ['"', "'"];
    for (let tt = 0; tt < _e.length; tt++) {
        const nt = _e[tt]
          , rt = i + "\\=" + nt + "([^" + nt + "]*)" + nt;
        a && console.log("[xml-utils] pattern:", rt);
        const et = new RegExp(rt).exec($);
        if (a && console.log("[xml-utils] match:", et),
        et)
            return et[1]
    }
}
getAttribute$2.exports = getAttribute;
getAttribute$2.exports.default = getAttribute;
var getAttributeExports = getAttribute$2.exports;
const getAttribute$1 = getDefaultExportFromCjs(getAttributeExports);
var findTagsByName$2 = {
    exports: {}
}
  , findTagByName$2 = {
    exports: {}
}
  , indexOfMatch$2 = {
    exports: {}
};
function indexOfMatch$1(o, i, s) {
    const _ = new RegExp(i).exec(o.slice(s));
    return _ ? s + _.index : -1
}
indexOfMatch$2.exports = indexOfMatch$1;
indexOfMatch$2.exports.default = indexOfMatch$1;
var indexOfMatchExports = indexOfMatch$2.exports
  , indexOfMatchEnd$2 = {
    exports: {}
};
function indexOfMatchEnd$1(o, i, s) {
    const _ = new RegExp(i).exec(o.slice(s));
    return _ ? s + _.index + _[0].length - 1 : -1
}
indexOfMatchEnd$2.exports = indexOfMatchEnd$1;
indexOfMatchEnd$2.exports.default = indexOfMatchEnd$1;
var indexOfMatchEndExports = indexOfMatchEnd$2.exports
  , countSubstring$2 = {
    exports: {}
};
function countSubstring$1(o, i) {
    const s = new RegExp(i,"g")
      , a = o.match(s);
    return a ? a.length : 0
}
countSubstring$2.exports = countSubstring$1;
countSubstring$2.exports.default = countSubstring$1;
var countSubstringExports = countSubstring$2.exports;
const indexOfMatch = indexOfMatchExports
  , indexOfMatchEnd = indexOfMatchEndExports
  , countSubstring = countSubstringExports;
function findTagByName$1(o, i, s) {
    const a = s && s.debug || !1
      , _ = !(s && typeof s.nested === !1)
      , $ = s && s.startIndex || 0;
    a && console.log("[xml-utils] starting findTagByName with", i, " and ", s);
    const _e = indexOfMatch(o, `<${i}[ 
>/]`, $);
    if (a && console.log("[xml-utils] start:", _e),
    _e === -1)
        return;
    const tt = o.slice(_e + i.length);
    let nt = indexOfMatchEnd(tt, "^[^<]*[ /]>", 0);
    const rt = nt !== -1 && tt[nt - 1] === "/";
    if (a && console.log("[xml-utils] selfClosing:", rt),
    rt === !1)
        if (_) {
            let it = 0
              , st = 1
              , at = 0;
            for (; (nt = indexOfMatchEnd(tt, "[ /]" + i + ">", it)) !== -1; ) {
                const lt = tt.substring(it, nt + 1);
                if (st += countSubstring(lt, "<" + i + `[ 
	>]`),
                at += countSubstring(lt, "</" + i + ">"),
                at >= st)
                    break;
                it = nt
            }
        } else
            nt = indexOfMatchEnd(tt, "[ /]" + i + ">", 0);
    const ot = _e + i.length + nt + 1;
    if (a && console.log("[xml-utils] end:", ot),
    ot === -1)
        return;
    const et = o.slice(_e, ot);
    let j;
    return rt ? j = null : j = et.slice(et.indexOf(">") + 1, et.lastIndexOf("<")),
    {
        inner: j,
        outer: et,
        start: _e,
        end: ot
    }
}
findTagByName$2.exports = findTagByName$1;
findTagByName$2.exports.default = findTagByName$1;
var findTagByNameExports = findTagByName$2.exports;
const findTagByName = findTagByNameExports;
function findTagsByName(o, i, s) {
    const a = []
      , _ = s && s.debug || !1
      , $ = s && typeof s.nested == "boolean" ? s.nested : !0;
    let _e = s && s.startIndex || 0, tt;
    for (; tt = findTagByName(o, i, {
        debug: _,
        startIndex: _e
    }); )
        $ ? _e = tt.start + 1 + i.length : _e = tt.end,
        a.push(tt);
    return _ && console.log("findTagsByName found", a.length, "tags"),
    a
}
findTagsByName$2.exports = findTagsByName;
findTagsByName$2.exports.default = findTagsByName;
var findTagsByNameExports = findTagsByName$2.exports;
const findTagsByName$1 = getDefaultExportFromCjs(findTagsByNameExports)
  , fieldTagNames = {
    315: "Artist",
    258: "BitsPerSample",
    265: "CellLength",
    264: "CellWidth",
    320: "ColorMap",
    259: "Compression",
    33432: "Copyright",
    306: "DateTime",
    338: "ExtraSamples",
    266: "FillOrder",
    289: "FreeByteCounts",
    288: "FreeOffsets",
    291: "GrayResponseCurve",
    290: "GrayResponseUnit",
    316: "HostComputer",
    270: "ImageDescription",
    257: "ImageLength",
    256: "ImageWidth",
    271: "Make",
    281: "MaxSampleValue",
    280: "MinSampleValue",
    272: "Model",
    254: "NewSubfileType",
    274: "Orientation",
    262: "PhotometricInterpretation",
    284: "PlanarConfiguration",
    296: "ResolutionUnit",
    278: "RowsPerStrip",
    277: "SamplesPerPixel",
    305: "Software",
    279: "StripByteCounts",
    273: "StripOffsets",
    255: "SubfileType",
    263: "Threshholding",
    282: "XResolution",
    283: "YResolution",
    326: "BadFaxLines",
    327: "CleanFaxData",
    343: "ClipPath",
    328: "ConsecutiveBadFaxLines",
    433: "Decode",
    434: "DefaultImageColor",
    269: "DocumentName",
    336: "DotRange",
    321: "HalftoneHints",
    346: "Indexed",
    347: "JPEGTables",
    285: "PageName",
    297: "PageNumber",
    317: "Predictor",
    319: "PrimaryChromaticities",
    532: "ReferenceBlackWhite",
    339: "SampleFormat",
    340: "SMinSampleValue",
    341: "SMaxSampleValue",
    559: "StripRowCounts",
    330: "SubIFDs",
    292: "T4Options",
    293: "T6Options",
    325: "TileByteCounts",
    323: "TileLength",
    324: "TileOffsets",
    322: "TileWidth",
    301: "TransferFunction",
    318: "WhitePoint",
    344: "XClipPathUnits",
    286: "XPosition",
    529: "YCbCrCoefficients",
    531: "YCbCrPositioning",
    530: "YCbCrSubSampling",
    345: "YClipPathUnits",
    287: "YPosition",
    37378: "ApertureValue",
    40961: "ColorSpace",
    36868: "DateTimeDigitized",
    36867: "DateTimeOriginal",
    34665: "Exif IFD",
    36864: "ExifVersion",
    33434: "ExposureTime",
    41728: "FileSource",
    37385: "Flash",
    40960: "FlashpixVersion",
    33437: "FNumber",
    42016: "ImageUniqueID",
    37384: "LightSource",
    37500: "MakerNote",
    37377: "ShutterSpeedValue",
    37510: "UserComment",
    33723: "IPTC",
    34675: "ICC Profile",
    700: "XMP",
    42112: "GDAL_METADATA",
    42113: "GDAL_NODATA",
    34377: "Photoshop",
    33550: "ModelPixelScale",
    33922: "ModelTiepoint",
    34264: "ModelTransformation",
    34735: "GeoKeyDirectory",
    34736: "GeoDoubleParams",
    34737: "GeoAsciiParams",
    50674: "LercParameters"
}
  , fieldTags = {};
for (const o in fieldTagNames)
    fieldTagNames.hasOwnProperty(o) && (fieldTags[fieldTagNames[o]] = parseInt(o, 10));
const arrayFields = [fieldTags.BitsPerSample, fieldTags.ExtraSamples, fieldTags.SampleFormat, fieldTags.StripByteCounts, fieldTags.StripOffsets, fieldTags.StripRowCounts, fieldTags.TileByteCounts, fieldTags.TileOffsets, fieldTags.SubIFDs]
  , fieldTypeNames = {
    1: "BYTE",
    2: "ASCII",
    3: "SHORT",
    4: "LONG",
    5: "RATIONAL",
    6: "SBYTE",
    7: "UNDEFINED",
    8: "SSHORT",
    9: "SLONG",
    10: "SRATIONAL",
    11: "FLOAT",
    12: "DOUBLE",
    13: "IFD",
    16: "LONG8",
    17: "SLONG8",
    18: "IFD8"
}
  , fieldTypes = {};
for (const o in fieldTypeNames)
    fieldTypeNames.hasOwnProperty(o) && (fieldTypes[fieldTypeNames[o]] = parseInt(o, 10));
const photometricInterpretations = {
    WhiteIsZero: 0,
    BlackIsZero: 1,
    RGB: 2,
    Palette: 3,
    TransparencyMask: 4,
    CMYK: 5,
    YCbCr: 6,
    CIELab: 8,
    ICCLab: 9
}
  , ExtraSamplesValues = {
    Unspecified: 0,
    Assocalpha: 1,
    Unassalpha: 2
}
  , LercParameters = {
    Version: 0,
    AddCompression: 1
}
  , LercAddCompression = {
    None: 0,
    Deflate: 1
}
  , geoKeyNames = {
    1024: "GTModelTypeGeoKey",
    1025: "GTRasterTypeGeoKey",
    1026: "GTCitationGeoKey",
    2048: "GeographicTypeGeoKey",
    2049: "GeogCitationGeoKey",
    2050: "GeogGeodeticDatumGeoKey",
    2051: "GeogPrimeMeridianGeoKey",
    2052: "GeogLinearUnitsGeoKey",
    2053: "GeogLinearUnitSizeGeoKey",
    2054: "GeogAngularUnitsGeoKey",
    2055: "GeogAngularUnitSizeGeoKey",
    2056: "GeogEllipsoidGeoKey",
    2057: "GeogSemiMajorAxisGeoKey",
    2058: "GeogSemiMinorAxisGeoKey",
    2059: "GeogInvFlatteningGeoKey",
    2060: "GeogAzimuthUnitsGeoKey",
    2061: "GeogPrimeMeridianLongGeoKey",
    2062: "GeogTOWGS84GeoKey",
    3072: "ProjectedCSTypeGeoKey",
    3073: "PCSCitationGeoKey",
    3074: "ProjectionGeoKey",
    3075: "ProjCoordTransGeoKey",
    3076: "ProjLinearUnitsGeoKey",
    3077: "ProjLinearUnitSizeGeoKey",
    3078: "ProjStdParallel1GeoKey",
    3079: "ProjStdParallel2GeoKey",
    3080: "ProjNatOriginLongGeoKey",
    3081: "ProjNatOriginLatGeoKey",
    3082: "ProjFalseEastingGeoKey",
    3083: "ProjFalseNorthingGeoKey",
    3084: "ProjFalseOriginLongGeoKey",
    3085: "ProjFalseOriginLatGeoKey",
    3086: "ProjFalseOriginEastingGeoKey",
    3087: "ProjFalseOriginNorthingGeoKey",
    3088: "ProjCenterLongGeoKey",
    3089: "ProjCenterLatGeoKey",
    3090: "ProjCenterEastingGeoKey",
    3091: "ProjCenterNorthingGeoKey",
    3092: "ProjScaleAtNatOriginGeoKey",
    3093: "ProjScaleAtCenterGeoKey",
    3094: "ProjAzimuthAngleGeoKey",
    3095: "ProjStraightVertPoleLongGeoKey",
    3096: "ProjRectifiedGridAngleGeoKey",
    4096: "VerticalCSTypeGeoKey",
    4097: "VerticalCitationGeoKey",
    4098: "VerticalDatumGeoKey",
    4099: "VerticalUnitsGeoKey"
};
function fromWhiteIsZero(o, i) {
    const {width: s, height: a} = o
      , _ = new Uint8Array(s * a * 3);
    let $;
    for (let _e = 0, tt = 0; _e < o.length; ++_e,
    tt += 3)
        $ = 256 - o[_e] / i * 256,
        _[tt] = $,
        _[tt + 1] = $,
        _[tt + 2] = $;
    return _
}
function fromBlackIsZero(o, i) {
    const {width: s, height: a} = o
      , _ = new Uint8Array(s * a * 3);
    let $;
    for (let _e = 0, tt = 0; _e < o.length; ++_e,
    tt += 3)
        $ = o[_e] / i * 256,
        _[tt] = $,
        _[tt + 1] = $,
        _[tt + 2] = $;
    return _
}
function fromPalette(o, i) {
    const {width: s, height: a} = o
      , _ = new Uint8Array(s * a * 3)
      , $ = i.length / 3
      , _e = i.length / 3 * 2;
    for (let tt = 0, nt = 0; tt < o.length; ++tt,
    nt += 3) {
        const rt = o[tt];
        _[nt] = i[rt] / 65536 * 256,
        _[nt + 1] = i[rt + $] / 65536 * 256,
        _[nt + 2] = i[rt + _e] / 65536 * 256
    }
    return _
}
function fromCMYK(o) {
    const {width: i, height: s} = o
      , a = new Uint8Array(i * s * 3);
    for (let _ = 0, $ = 0; _ < o.length; _ += 4,
    $ += 3) {
        const _e = o[_]
          , tt = o[_ + 1]
          , nt = o[_ + 2]
          , rt = o[_ + 3];
        a[$] = 255 * ((255 - _e) / 256) * ((255 - rt) / 256),
        a[$ + 1] = 255 * ((255 - tt) / 256) * ((255 - rt) / 256),
        a[$ + 2] = 255 * ((255 - nt) / 256) * ((255 - rt) / 256)
    }
    return a
}
function fromYCbCr(o) {
    const {width: i, height: s} = o
      , a = new Uint8ClampedArray(i * s * 3);
    for (let _ = 0, $ = 0; _ < o.length; _ += 3,
    $ += 3) {
        const _e = o[_]
          , tt = o[_ + 1]
          , nt = o[_ + 2];
        a[$] = _e + 1.402 * (nt - 128),
        a[$ + 1] = _e - .34414 * (tt - 128) - .71414 * (nt - 128),
        a[$ + 2] = _e + 1.772 * (tt - 128)
    }
    return a
}
const Xn = .95047
  , Yn = 1
  , Zn = 1.08883;
function fromCIELab(o) {
    const {width: i, height: s} = o
      , a = new Uint8Array(i * s * 3);
    for (let _ = 0, $ = 0; _ < o.length; _ += 3,
    $ += 3) {
        const _e = o[_ + 0]
          , tt = o[_ + 1] << 24 >> 24
          , nt = o[_ + 2] << 24 >> 24;
        let rt = (_e + 16) / 116, ot = tt / 500 + rt, et = rt - nt / 200, j, it, st;
        ot = Xn * (ot * ot * ot > .008856 ? ot * ot * ot : (ot - 16 / 116) / 7.787),
        rt = Yn * (rt * rt * rt > .008856 ? rt * rt * rt : (rt - 16 / 116) / 7.787),
        et = Zn * (et * et * et > .008856 ? et * et * et : (et - 16 / 116) / 7.787),
        j = ot * 3.2406 + rt * -1.5372 + et * -.4986,
        it = ot * -.9689 + rt * 1.8758 + et * .0415,
        st = ot * .0557 + rt * -.204 + et * 1.057,
        j = j > .0031308 ? 1.055 * j ** (1 / 2.4) - .055 : 12.92 * j,
        it = it > .0031308 ? 1.055 * it ** (1 / 2.4) - .055 : 12.92 * it,
        st = st > .0031308 ? 1.055 * st ** (1 / 2.4) - .055 : 12.92 * st,
        a[$] = Math.max(0, Math.min(1, j)) * 255,
        a[$ + 1] = Math.max(0, Math.min(1, it)) * 255,
        a[$ + 2] = Math.max(0, Math.min(1, st)) * 255
    }
    return a
}
const scriptRel = "modulepreload"
  , assetsURL = function(o) {
    return "/" + o
}
  , seen = {}
  , __vitePreload = function o(i, s, a) {
    if (!s || s.length === 0)
        return i();
    const _ = document.getElementsByTagName("link");
    return Promise.all(s.map($ => {
        if ($ = assetsURL($),
        $ in seen)
            return;
        seen[$] = !0;
        const _e = $.endsWith(".css")
          , tt = _e ? '[rel="stylesheet"]' : "";
        if (!!a)
            for (let ot = _.length - 1; ot >= 0; ot--) {
                const et = _[ot];
                if (et.href === $ && (!_e || et.rel === "stylesheet"))
                    return
            }
        else if (document.querySelector(`link[href="${$}"]${tt}`))
            return;
        const rt = document.createElement("link");
        if (rt.rel = _e ? "stylesheet" : scriptRel,
        _e || (rt.as = "script",
        rt.crossOrigin = ""),
        rt.href = $,
        document.head.appendChild(rt),
        _e)
            return new Promise( (ot, et) => {
                rt.addEventListener("load", ot),
                rt.addEventListener("error", () => et(new Error(`Unable to preload CSS for ${$}`)))
            }
            )
    }
    )).then( () => i()).catch($ => {
        const _e = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (_e.payload = $,
        window.dispatchEvent(_e),
        !_e.defaultPrevented)
            throw $
    }
    )
}
  , registry = new Map;
function addDecoder(o, i) {
    Array.isArray(o) || (o = [o]),
    o.forEach(s => registry.set(s, i))
}
async function getDecoder(o) {
    const i = registry.get(o.Compression);
    if (!i)
        throw new Error(`Unknown compression method identifier: ${o.Compression}`);
    const s = await i();
    return new s(o)
}
addDecoder([void 0, 1], () => __vitePreload( () => import("./raw-7a0fe838.js"), ["assets/raw-7a0fe838.js", "assets/basedecoder-3573ccae.js"]).then(o => o.default));
addDecoder(5, () => __vitePreload( () => import("./lzw-901d9363.js"), ["assets/lzw-901d9363.js", "assets/basedecoder-3573ccae.js"]).then(o => o.default));
addDecoder(6, () => {
    throw new Error("old style JPEG compression is not supported.")
}
);
addDecoder(7, () => __vitePreload( () => import("./jpeg-2f15dd85.js"), ["assets/jpeg-2f15dd85.js", "assets/basedecoder-3573ccae.js"]).then(o => o.default));
addDecoder([8, 32946], () => __vitePreload( () => import("./deflate-29fb883b.js"), ["assets/deflate-29fb883b.js", "assets/pako.esm-bae9e474.js", "assets/basedecoder-3573ccae.js"]).then(o => o.default));
addDecoder(32773, () => __vitePreload( () => import("./packbits-90020365.js"), ["assets/packbits-90020365.js", "assets/basedecoder-3573ccae.js"]).then(o => o.default));
addDecoder(34887, () => __vitePreload( () => import("./lerc-59ddb701.js"), ["assets/lerc-59ddb701.js", "assets/pako.esm-bae9e474.js", "assets/basedecoder-3573ccae.js"]).then(o => o.default));
addDecoder(50001, () => __vitePreload( () => import("./webimage-aa764004.js"), ["assets/webimage-aa764004.js", "assets/basedecoder-3573ccae.js"]).then(o => o.default));
function copyNewSize(o, i, s, a=1) {
    return new (Object.getPrototypeOf(o)).constructor(i * s * a)
}
function resampleNearest(o, i, s, a, _) {
    const $ = i / a
      , _e = s / _;
    return o.map(tt => {
        const nt = copyNewSize(tt, a, _);
        for (let rt = 0; rt < _; ++rt) {
            const ot = Math.min(Math.round(_e * rt), s - 1);
            for (let et = 0; et < a; ++et) {
                const j = Math.min(Math.round($ * et), i - 1)
                  , it = tt[ot * i + j];
                nt[rt * a + et] = it
            }
        }
        return nt
    }
    )
}
function lerp(o, i, s) {
    return (1 - s) * o + s * i
}
function resampleBilinear(o, i, s, a, _) {
    const $ = i / a
      , _e = s / _;
    return o.map(tt => {
        const nt = copyNewSize(tt, a, _);
        for (let rt = 0; rt < _; ++rt) {
            const ot = _e * rt
              , et = Math.floor(ot)
              , j = Math.min(Math.ceil(ot), s - 1);
            for (let it = 0; it < a; ++it) {
                const st = $ * it
                  , at = st % 1
                  , lt = Math.floor(st)
                  , ct = Math.min(Math.ceil(st), i - 1)
                  , ut = tt[et * i + lt]
                  , dt = tt[et * i + ct]
                  , ft = tt[j * i + lt]
                  , ht = tt[j * i + ct]
                  , pt = lerp(lerp(ut, dt, at), lerp(ft, ht, at), ot % 1);
                nt[rt * a + it] = pt
            }
        }
        return nt
    }
    )
}
function resample(o, i, s, a, _, $="nearest") {
    switch ($.toLowerCase()) {
    case "nearest":
        return resampleNearest(o, i, s, a, _);
    case "bilinear":
    case "linear":
        return resampleBilinear(o, i, s, a, _);
    default:
        throw new Error(`Unsupported resampling method: '${$}'`)
    }
}
function resampleNearestInterleaved(o, i, s, a, _, $) {
    const _e = i / a
      , tt = s / _
      , nt = copyNewSize(o, a, _, $);
    for (let rt = 0; rt < _; ++rt) {
        const ot = Math.min(Math.round(tt * rt), s - 1);
        for (let et = 0; et < a; ++et) {
            const j = Math.min(Math.round(_e * et), i - 1);
            for (let it = 0; it < $; ++it) {
                const st = o[ot * i * $ + j * $ + it];
                nt[rt * a * $ + et * $ + it] = st
            }
        }
    }
    return nt
}
function resampleBilinearInterleaved(o, i, s, a, _, $) {
    const _e = i / a
      , tt = s / _
      , nt = copyNewSize(o, a, _, $);
    for (let rt = 0; rt < _; ++rt) {
        const ot = tt * rt
          , et = Math.floor(ot)
          , j = Math.min(Math.ceil(ot), s - 1);
        for (let it = 0; it < a; ++it) {
            const st = _e * it
              , at = st % 1
              , lt = Math.floor(st)
              , ct = Math.min(Math.ceil(st), i - 1);
            for (let ut = 0; ut < $; ++ut) {
                const dt = o[et * i * $ + lt * $ + ut]
                  , ft = o[et * i * $ + ct * $ + ut]
                  , ht = o[j * i * $ + lt * $ + ut]
                  , pt = o[j * i * $ + ct * $ + ut]
                  , gt = lerp(lerp(dt, ft, at), lerp(ht, pt, at), ot % 1);
                nt[rt * a * $ + it * $ + ut] = gt
            }
        }
    }
    return nt
}
function resampleInterleaved(o, i, s, a, _, $, _e="nearest") {
    switch (_e.toLowerCase()) {
    case "nearest":
        return resampleNearestInterleaved(o, i, s, a, _, $);
    case "bilinear":
    case "linear":
        return resampleBilinearInterleaved(o, i, s, a, _, $);
    default:
        throw new Error(`Unsupported resampling method: '${_e}'`)
    }
}
function sum(o, i, s) {
    let a = 0;
    for (let _ = i; _ < s; ++_)
        a += o[_];
    return a
}
function arrayForType(o, i, s) {
    switch (o) {
    case 1:
        if (i <= 8)
            return new Uint8Array(s);
        if (i <= 16)
            return new Uint16Array(s);
        if (i <= 32)
            return new Uint32Array(s);
        break;
    case 2:
        if (i === 8)
            return new Int8Array(s);
        if (i === 16)
            return new Int16Array(s);
        if (i === 32)
            return new Int32Array(s);
        break;
    case 3:
        switch (i) {
        case 16:
        case 32:
            return new Float32Array(s);
        case 64:
            return new Float64Array(s)
        }
        break
    }
    throw Error("Unsupported data format/bitsPerSample")
}
function needsNormalization(o, i) {
    return (o === 1 || o === 2) && i <= 32 && i % 8 === 0 ? !1 : !(o === 3 && (i === 16 || i === 32 || i === 64))
}
function normalizeArray(o, i, s, a, _, $, _e) {
    const tt = new DataView(o)
      , nt = s === 2 ? _e * $ : _e * $ * a
      , rt = s === 2 ? 1 : a
      , ot = arrayForType(i, _, nt)
      , et = parseInt("1".repeat(_), 2);
    if (i === 1) {
        let j;
        s === 1 ? j = a * _ : j = _;
        let it = $ * j;
        it & 7 && (it = it + 7 & -8);
        for (let st = 0; st < _e; ++st) {
            const at = st * it;
            for (let lt = 0; lt < $; ++lt) {
                const ct = at + lt * rt * _;
                for (let ut = 0; ut < rt; ++ut) {
                    const dt = ct + ut * _
                      , ft = (st * $ + lt) * rt + ut
                      , ht = Math.floor(dt / 8)
                      , pt = dt % 8;
                    if (pt + _ <= 8)
                        ot[ft] = tt.getUint8(ht) >> 8 - _ - pt & et;
                    else if (pt + _ <= 16)
                        ot[ft] = tt.getUint16(ht) >> 16 - _ - pt & et;
                    else if (pt + _ <= 24) {
                        const gt = tt.getUint16(ht) << 8 | tt.getUint8(ht + 2);
                        ot[ft] = gt >> 24 - _ - pt & et
                    } else
                        ot[ft] = tt.getUint32(ht) >> 32 - _ - pt & et
                }
            }
        }
    }
    return ot.buffer
}
class GeoTIFFImage {
    constructor(i, s, a, _, $, _e) {
        this.fileDirectory = i,
        this.geoKeys = s,
        this.dataView = a,
        this.littleEndian = _,
        this.tiles = $ ? {} : null,
        this.isTiled = !i.StripOffsets;
        const tt = i.PlanarConfiguration;
        if (this.planarConfiguration = typeof tt > "u" ? 1 : tt,
        this.planarConfiguration !== 1 && this.planarConfiguration !== 2)
            throw new Error("Invalid planar configuration.");
        this.source = _e
    }
    getFileDirectory() {
        return this.fileDirectory
    }
    getGeoKeys() {
        return this.geoKeys
    }
    getWidth() {
        return this.fileDirectory.ImageWidth
    }
    getHeight() {
        return this.fileDirectory.ImageLength
    }
    getSamplesPerPixel() {
        return typeof this.fileDirectory.SamplesPerPixel < "u" ? this.fileDirectory.SamplesPerPixel : 1
    }
    getTileWidth() {
        return this.isTiled ? this.fileDirectory.TileWidth : this.getWidth()
    }
    getTileHeight() {
        return this.isTiled ? this.fileDirectory.TileLength : typeof this.fileDirectory.RowsPerStrip < "u" ? Math.min(this.fileDirectory.RowsPerStrip, this.getHeight()) : this.getHeight()
    }
    getBlockWidth() {
        return this.getTileWidth()
    }
    getBlockHeight(i) {
        return this.isTiled || (i + 1) * this.getTileHeight() <= this.getHeight() ? this.getTileHeight() : this.getHeight() - i * this.getTileHeight()
    }
    getBytesPerPixel() {
        let i = 0;
        for (let s = 0; s < this.fileDirectory.BitsPerSample.length; ++s)
            i += this.getSampleByteSize(s);
        return i
    }
    getSampleByteSize(i) {
        if (i >= this.fileDirectory.BitsPerSample.length)
            throw new RangeError(`Sample index ${i} is out of range.`);
        return Math.ceil(this.fileDirectory.BitsPerSample[i] / 8)
    }
    getReaderForSample(i) {
        const s = this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[i] : 1
          , a = this.fileDirectory.BitsPerSample[i];
        switch (s) {
        case 1:
            if (a <= 8)
                return DataView.prototype.getUint8;
            if (a <= 16)
                return DataView.prototype.getUint16;
            if (a <= 32)
                return DataView.prototype.getUint32;
            break;
        case 2:
            if (a <= 8)
                return DataView.prototype.getInt8;
            if (a <= 16)
                return DataView.prototype.getInt16;
            if (a <= 32)
                return DataView.prototype.getInt32;
            break;
        case 3:
            switch (a) {
            case 16:
                return function(_, $) {
                    return getFloat16(this, _, $)
                }
                ;
            case 32:
                return DataView.prototype.getFloat32;
            case 64:
                return DataView.prototype.getFloat64
            }
            break
        }
        throw Error("Unsupported data format/bitsPerSample")
    }
    getSampleFormat(i=0) {
        return this.fileDirectory.SampleFormat ? this.fileDirectory.SampleFormat[i] : 1
    }
    getBitsPerSample(i=0) {
        return this.fileDirectory.BitsPerSample[i]
    }
    getArrayForSample(i, s) {
        const a = this.getSampleFormat(i)
          , _ = this.getBitsPerSample(i);
        return arrayForType(a, _, s)
    }
    async getTileOrStrip(i, s, a, _, $) {
        const _e = Math.ceil(this.getWidth() / this.getTileWidth())
          , tt = Math.ceil(this.getHeight() / this.getTileHeight());
        let nt;
        const {tiles: rt} = this;
        this.planarConfiguration === 1 ? nt = s * _e + i : this.planarConfiguration === 2 && (nt = a * _e * tt + s * _e + i);
        let ot, et;
        this.isTiled ? (ot = this.fileDirectory.TileOffsets[nt],
        et = this.fileDirectory.TileByteCounts[nt]) : (ot = this.fileDirectory.StripOffsets[nt],
        et = this.fileDirectory.StripByteCounts[nt]);
        const j = (await this.source.fetch([{
            offset: ot,
            length: et
        }], $))[0];
        let it;
        return rt === null || !rt[nt] ? (it = (async () => {
            let st = await _.decode(this.fileDirectory, j);
            const at = this.getSampleFormat()
              , lt = this.getBitsPerSample();
            return needsNormalization(at, lt) && (st = normalizeArray(st, at, this.planarConfiguration, this.getSamplesPerPixel(), lt, this.getTileWidth(), this.getBlockHeight(s))),
            st
        }
        )(),
        rt !== null && (rt[nt] = it)) : it = rt[nt],
        {
            x: i,
            y: s,
            sample: a,
            data: await it
        }
    }
    async _readRaster(i, s, a, _, $, _e, tt, nt, rt) {
        const ot = this.getTileWidth()
          , et = this.getTileHeight()
          , j = this.getWidth()
          , it = this.getHeight()
          , st = Math.max(Math.floor(i[0] / ot), 0)
          , at = Math.min(Math.ceil(i[2] / ot), Math.ceil(j / ot))
          , lt = Math.max(Math.floor(i[1] / et), 0)
          , ct = Math.min(Math.ceil(i[3] / et), Math.ceil(it / et))
          , ut = i[2] - i[0];
        let dt = this.getBytesPerPixel();
        const ft = []
          , ht = [];
        for (let _t = 0; _t < s.length; ++_t)
            this.planarConfiguration === 1 ? ft.push(sum(this.fileDirectory.BitsPerSample, 0, s[_t]) / 8) : ft.push(0),
            ht.push(this.getReaderForSample(s[_t]));
        const pt = []
          , {littleEndian: gt} = this;
        for (let _t = lt; _t < ct; ++_t)
            for (let mt = st; mt < at; ++mt)
                for (let yt = 0; yt < s.length; ++yt) {
                    const bt = yt
                      , vt = s[yt];
                    this.planarConfiguration === 2 && (dt = this.getSampleByteSize(yt));
                    const wt = this.getTileOrStrip(mt, _t, vt, $, rt).then(Tt => {
                        const $t = Tt.data
                          , Et = new DataView($t)
                          , Pt = this.getBlockHeight(Tt.y)
                          , Rt = Tt.y * et
                          , At = Tt.x * ot
                          , Mt = Rt + Pt
                          , Ut = (Tt.x + 1) * ot
                          , Lt = ht[bt]
                          , tn = Math.min(Pt, Pt - (Mt - i[3]), it - Rt)
                          , Vt = Math.min(ot, ot - (Ut - i[2]), j - At);
                        for (let Nt = Math.max(0, i[1] - Rt); Nt < tn; ++Nt)
                            for (let Yt = Math.max(0, i[0] - At); Yt < Vt; ++Yt) {
                                const Xt = (Nt * ot + Yt) * dt
                                  , jt = Lt.call(Et, Xt + ft[bt], gt);
                                let Gt;
                                _ ? (Gt = (Nt + Rt - i[1]) * ut * s.length + (Yt + At - i[0]) * s.length + bt,
                                a[Gt] = jt) : (Gt = (Nt + Rt - i[1]) * ut + Yt + At - i[0],
                                a[bt][Gt] = jt)
                            }
                    }
                    );
                    pt.push(wt)
                }
        if (await Promise.all(pt),
        _e && i[2] - i[0] !== _e || tt && i[3] - i[1] !== tt) {
            let _t;
            return _ ? _t = resampleInterleaved(a, i[2] - i[0], i[3] - i[1], _e, tt, s.length, nt) : _t = resample(a, i[2] - i[0], i[3] - i[1], _e, tt, nt),
            _t.width = _e,
            _t.height = tt,
            _t
        }
        return a.width = _e || i[2] - i[0],
        a.height = tt || i[3] - i[1],
        a
    }
    async readRasters({window: i, samples: s=[], interleave: a, pool: _=null, width: $, height: _e, resampleMethod: tt, fillValue: nt, signal: rt}={}) {
        const ot = i || [0, 0, this.getWidth(), this.getHeight()];
        if (ot[0] > ot[2] || ot[1] > ot[3])
            throw new Error("Invalid subsets");
        const et = ot[2] - ot[0]
          , j = ot[3] - ot[1]
          , it = et * j
          , st = this.getSamplesPerPixel();
        if (!s || !s.length)
            for (let ut = 0; ut < st; ++ut)
                s.push(ut);
        else
            for (let ut = 0; ut < s.length; ++ut)
                if (s[ut] >= st)
                    return Promise.reject(new RangeError(`Invalid sample index '${s[ut]}'.`));
        let at;
        if (a) {
            const ut = this.fileDirectory.SampleFormat ? Math.max.apply(null, this.fileDirectory.SampleFormat) : 1
              , dt = Math.max.apply(null, this.fileDirectory.BitsPerSample);
            at = arrayForType(ut, dt, it * s.length),
            nt && at.fill(nt)
        } else {
            at = [];
            for (let ut = 0; ut < s.length; ++ut) {
                const dt = this.getArrayForSample(s[ut], it);
                Array.isArray(nt) && ut < nt.length ? dt.fill(nt[ut]) : nt && !Array.isArray(nt) && dt.fill(nt),
                at.push(dt)
            }
        }
        const lt = _ || await getDecoder(this.fileDirectory);
        return await this._readRaster(ot, s, at, a, lt, $, _e, tt, rt)
    }
    async readRGB({window: i, interleave: s=!0, pool: a=null, width: _, height: $, resampleMethod: _e, enableAlpha: tt=!1, signal: nt}={}) {
        const rt = i || [0, 0, this.getWidth(), this.getHeight()];
        if (rt[0] > rt[2] || rt[1] > rt[3])
            throw new Error("Invalid subsets");
        const ot = this.fileDirectory.PhotometricInterpretation;
        if (ot === photometricInterpretations.RGB) {
            let ct = [0, 1, 2];
            if (this.fileDirectory.ExtraSamples !== ExtraSamplesValues.Unspecified && tt) {
                ct = [];
                for (let ut = 0; ut < this.fileDirectory.BitsPerSample.length; ut += 1)
                    ct.push(ut)
            }
            return this.readRasters({
                window: i,
                interleave: s,
                samples: ct,
                pool: a,
                width: _,
                height: $,
                resampleMethod: _e,
                signal: nt
            })
        }
        let et;
        switch (ot) {
        case photometricInterpretations.WhiteIsZero:
        case photometricInterpretations.BlackIsZero:
        case photometricInterpretations.Palette:
            et = [0];
            break;
        case photometricInterpretations.CMYK:
            et = [0, 1, 2, 3];
            break;
        case photometricInterpretations.YCbCr:
        case photometricInterpretations.CIELab:
            et = [0, 1, 2];
            break;
        default:
            throw new Error("Invalid or unsupported photometric interpretation.")
        }
        const j = {
            window: rt,
            interleave: !0,
            samples: et,
            pool: a,
            width: _,
            height: $,
            resampleMethod: _e,
            signal: nt
        }
          , {fileDirectory: it} = this
          , st = await this.readRasters(j)
          , at = 2 ** this.fileDirectory.BitsPerSample[0];
        let lt;
        switch (ot) {
        case photometricInterpretations.WhiteIsZero:
            lt = fromWhiteIsZero(st, at);
            break;
        case photometricInterpretations.BlackIsZero:
            lt = fromBlackIsZero(st, at);
            break;
        case photometricInterpretations.Palette:
            lt = fromPalette(st, it.ColorMap);
            break;
        case photometricInterpretations.CMYK:
            lt = fromCMYK(st);
            break;
        case photometricInterpretations.YCbCr:
            lt = fromYCbCr(st);
            break;
        case photometricInterpretations.CIELab:
            lt = fromCIELab(st);
            break;
        default:
            throw new Error("Unsupported photometric interpretation.")
        }
        if (!s) {
            const ct = new Uint8Array(lt.length / 3)
              , ut = new Uint8Array(lt.length / 3)
              , dt = new Uint8Array(lt.length / 3);
            for (let ft = 0, ht = 0; ft < lt.length; ft += 3,
            ++ht)
                ct[ht] = lt[ft],
                ut[ht] = lt[ft + 1],
                dt[ht] = lt[ft + 2];
            lt = [ct, ut, dt]
        }
        return lt.width = st.width,
        lt.height = st.height,
        lt
    }
    getTiePoints() {
        if (!this.fileDirectory.ModelTiepoint)
            return [];
        const i = [];
        for (let s = 0; s < this.fileDirectory.ModelTiepoint.length; s += 6)
            i.push({
                i: this.fileDirectory.ModelTiepoint[s],
                j: this.fileDirectory.ModelTiepoint[s + 1],
                k: this.fileDirectory.ModelTiepoint[s + 2],
                x: this.fileDirectory.ModelTiepoint[s + 3],
                y: this.fileDirectory.ModelTiepoint[s + 4],
                z: this.fileDirectory.ModelTiepoint[s + 5]
            });
        return i
    }
    getGDALMetadata(i=null) {
        const s = {};
        if (!this.fileDirectory.GDAL_METADATA)
            return null;
        const a = this.fileDirectory.GDAL_METADATA;
        let _ = findTagsByName$1(a, "Item");
        i === null ? _ = _.filter($ => getAttribute$1($, "sample") === void 0) : _ = _.filter($ => Number(getAttribute$1($, "sample")) === i);
        for (let $ = 0; $ < _.length; ++$) {
            const _e = _[$];
            s[getAttribute$1(_e, "name")] = _e.inner
        }
        return s
    }
    getGDALNoData() {
        if (!this.fileDirectory.GDAL_NODATA)
            return null;
        const i = this.fileDirectory.GDAL_NODATA;
        return Number(i.substring(0, i.length - 1))
    }
    getOrigin() {
        const i = this.fileDirectory.ModelTiepoint
          , s = this.fileDirectory.ModelTransformation;
        if (i && i.length === 6)
            return [i[3], i[4], i[5]];
        if (s)
            return [s[3], s[7], s[11]];
        throw new Error("The image does not have an affine transformation.")
    }
    getResolution(i=null) {
        const s = this.fileDirectory.ModelPixelScale
          , a = this.fileDirectory.ModelTransformation;
        if (s)
            return [s[0], -s[1], s[2]];
        if (a)
            return [a[0], a[5], a[10]];
        if (i) {
            const [_,$,_e] = i.getResolution();
            return [_ * i.getWidth() / this.getWidth(), $ * i.getHeight() / this.getHeight(), _e * i.getWidth() / this.getWidth()]
        }
        throw new Error("The image does not have an affine transformation.")
    }
    pixelIsArea() {
        return this.geoKeys.GTRasterTypeGeoKey === 1
    }
    getBoundingBox() {
        const i = this.getOrigin()
          , s = this.getResolution()
          , a = i[0]
          , _ = i[1]
          , $ = a + s[0] * this.getWidth()
          , _e = _ + s[1] * this.getHeight();
        return [Math.min(a, $), Math.min(_, _e), Math.max(a, $), Math.max(_, _e)]
    }
}
const GeoTIFFImage$1 = GeoTIFFImage;
class DataView64 {
    constructor(i) {
        this._dataView = new DataView(i)
    }
    get buffer() {
        return this._dataView.buffer
    }
    getUint64(i, s) {
        const a = this.getUint32(i, s)
          , _ = this.getUint32(i + 4, s);
        let $;
        if (s) {
            if ($ = a + 2 ** 32 * _,
            !Number.isSafeInteger($))
                throw new Error(`${$} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
            return $
        }
        if ($ = 2 ** 32 * a + _,
        !Number.isSafeInteger($))
            throw new Error(`${$} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
        return $
    }
    getInt64(i, s) {
        let a = 0;
        const _ = (this._dataView.getUint8(i + (s ? 7 : 0)) & 128) > 0;
        let $ = !0;
        for (let _e = 0; _e < 8; _e++) {
            let tt = this._dataView.getUint8(i + (s ? _e : 7 - _e));
            _ && ($ ? tt !== 0 && (tt = ~(tt - 1) & 255,
            $ = !1) : tt = ~tt & 255),
            a += tt * 256 ** _e
        }
        return _ && (a = -a),
        a
    }
    getUint8(i, s) {
        return this._dataView.getUint8(i, s)
    }
    getInt8(i, s) {
        return this._dataView.getInt8(i, s)
    }
    getUint16(i, s) {
        return this._dataView.getUint16(i, s)
    }
    getInt16(i, s) {
        return this._dataView.getInt16(i, s)
    }
    getUint32(i, s) {
        return this._dataView.getUint32(i, s)
    }
    getInt32(i, s) {
        return this._dataView.getInt32(i, s)
    }
    getFloat16(i, s) {
        return getFloat16(this._dataView, i, s)
    }
    getFloat32(i, s) {
        return this._dataView.getFloat32(i, s)
    }
    getFloat64(i, s) {
        return this._dataView.getFloat64(i, s)
    }
}
class DataSlice {
    constructor(i, s, a, _) {
        this._dataView = new DataView(i),
        this._sliceOffset = s,
        this._littleEndian = a,
        this._bigTiff = _
    }
    get sliceOffset() {
        return this._sliceOffset
    }
    get sliceTop() {
        return this._sliceOffset + this.buffer.byteLength
    }
    get littleEndian() {
        return this._littleEndian
    }
    get bigTiff() {
        return this._bigTiff
    }
    get buffer() {
        return this._dataView.buffer
    }
    covers(i, s) {
        return this.sliceOffset <= i && this.sliceTop >= i + s
    }
    readUint8(i) {
        return this._dataView.getUint8(i - this._sliceOffset, this._littleEndian)
    }
    readInt8(i) {
        return this._dataView.getInt8(i - this._sliceOffset, this._littleEndian)
    }
    readUint16(i) {
        return this._dataView.getUint16(i - this._sliceOffset, this._littleEndian)
    }
    readInt16(i) {
        return this._dataView.getInt16(i - this._sliceOffset, this._littleEndian)
    }
    readUint32(i) {
        return this._dataView.getUint32(i - this._sliceOffset, this._littleEndian)
    }
    readInt32(i) {
        return this._dataView.getInt32(i - this._sliceOffset, this._littleEndian)
    }
    readFloat32(i) {
        return this._dataView.getFloat32(i - this._sliceOffset, this._littleEndian)
    }
    readFloat64(i) {
        return this._dataView.getFloat64(i - this._sliceOffset, this._littleEndian)
    }
    readUint64(i) {
        const s = this.readUint32(i)
          , a = this.readUint32(i + 4);
        let _;
        if (this._littleEndian) {
            if (_ = s + 2 ** 32 * a,
            !Number.isSafeInteger(_))
                throw new Error(`${_} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
            return _
        }
        if (_ = 2 ** 32 * s + a,
        !Number.isSafeInteger(_))
            throw new Error(`${_} exceeds MAX_SAFE_INTEGER. Precision may be lost. Please report if you get this message to https://github.com/geotiffjs/geotiff.js/issues`);
        return _
    }
    readInt64(i) {
        let s = 0;
        const a = (this._dataView.getUint8(i + (this._littleEndian ? 7 : 0)) & 128) > 0;
        let _ = !0;
        for (let $ = 0; $ < 8; $++) {
            let _e = this._dataView.getUint8(i + (this._littleEndian ? $ : 7 - $));
            a && (_ ? _e !== 0 && (_e = ~(_e - 1) & 255,
            _ = !1) : _e = ~_e & 255),
            s += _e * 256 ** $
        }
        return a && (s = -s),
        s
    }
    readOffset(i) {
        return this._bigTiff ? this.readUint64(i) : this.readUint32(i)
    }
}
const defaultPoolSize = typeof navigator < "u" && navigator.hardwareConcurrency || 2;
class Pool {
    constructor(i=defaultPoolSize, s) {
        this.workers = null,
        this._awaitingDecoder = null,
        this.size = i,
        this.messageId = 0,
        i && (this._awaitingDecoder = s ? Promise.resolve(s) : new Promise(a => {
            __vitePreload( () => import("./decoder-5ce692e3.js"), []).then(_ => {
                a(_.create)
            }
            )
        }
        ),
        this._awaitingDecoder.then(a => {
            this._awaitingDecoder = null,
            this.workers = [];
            for (let _ = 0; _ < i; _++)
                this.workers.push({
                    worker: a(),
                    idle: !0
                })
        }
        ))
    }
    async decode(i, s) {
        return this._awaitingDecoder && await this._awaitingDecoder,
        this.size === 0 ? getDecoder(i).then(a => a.decode(i, s)) : new Promise(a => {
            const _ = this.workers.find(tt => tt.idle) || this.workers[Math.floor(Math.random() * this.size)];
            _.idle = !1;
            const $ = this.messageId++
              , _e = tt => {
                tt.data.id === $ && (_.idle = !0,
                a(tt.data.decoded),
                _.worker.removeEventListener("message", _e))
            }
            ;
            _.worker.addEventListener("message", _e),
            _.worker.postMessage({
                fileDirectory: i,
                buffer: s,
                id: $
            }, [s])
        }
        )
    }
    destroy() {
        this.workers && (this.workers.forEach(i => {
            i.worker.terminate()
        }
        ),
        this.workers = null)
    }
}
const Pool$1 = Pool
  , CRLFCRLF = `\r
\r
`;
function itemsToObject(o) {
    if (typeof Object.fromEntries < "u")
        return Object.fromEntries(o);
    const i = {};
    for (const [s,a] of o)
        i[s.toLowerCase()] = a;
    return i
}
function parseHeaders(o) {
    const i = o.split(`\r
`).map(s => {
        const a = s.split(":").map(_ => _.trim());
        return a[0] = a[0].toLowerCase(),
        a
    }
    );
    return itemsToObject(i)
}
function parseContentType(o) {
    const [i,...s] = o.split(";").map(_ => _.trim())
      , a = s.map(_ => _.split("="));
    return {
        type: i,
        params: itemsToObject(a)
    }
}
function parseContentRange(o) {
    let i, s, a;
    return o && ([,i,s,a] = o.match(/bytes (\d+)-(\d+)\/(\d+)/),
    i = parseInt(i, 10),
    s = parseInt(s, 10),
    a = parseInt(a, 10)),
    {
        start: i,
        end: s,
        total: a
    }
}
function parseByteRanges(o, i) {
    let s = null;
    const a = new TextDecoder("ascii")
      , _ = []
      , $ = `--${i}`
      , _e = `${$}--`;
    for (let tt = 0; tt < 10; ++tt)
        a.decode(new Uint8Array(o,tt,$.length)) === $ && (s = tt);
    if (s === null)
        throw new Error("Could not find initial boundary");
    for (; s < o.byteLength; ) {
        const tt = a.decode(new Uint8Array(o,s,Math.min($.length + 1024, o.byteLength - s)));
        if (tt.length === 0 || tt.startsWith(_e))
            break;
        if (!tt.startsWith($))
            throw new Error("Part does not start with boundary");
        const nt = tt.substr($.length + 2);
        if (nt.length === 0)
            break;
        const rt = nt.indexOf(CRLFCRLF)
          , ot = parseHeaders(nt.substr(0, rt))
          , {start: et, end: j, total: it} = parseContentRange(ot["content-range"])
          , st = s + $.length + rt + CRLFCRLF.length
          , at = parseInt(j, 10) + 1 - parseInt(et, 10);
        _.push({
            headers: ot,
            data: o.slice(st, st + at),
            offset: et,
            length: at,
            fileSize: it
        }),
        s = st + at + 4
    }
    return _
}
class BaseSource {
    async fetch(i, s=void 0) {
        return Promise.all(i.map(a => this.fetchSlice(a, s)))
    }
    async fetchSlice(i) {
        throw new Error(`fetching of slice ${i} not possible, not implemented`)
    }
    get fileSize() {
        return null
    }
    async close() {}
}
class QuickLRU extends Map {
    constructor(i={}) {
        if (super(),
        !(i.maxSize && i.maxSize > 0))
            throw new TypeError("`maxSize` must be a number greater than 0");
        if (typeof i.maxAge == "number" && i.maxAge === 0)
            throw new TypeError("`maxAge` must be a number greater than 0");
        this.maxSize = i.maxSize,
        this.maxAge = i.maxAge || Number.POSITIVE_INFINITY,
        this.onEviction = i.onEviction,
        this.cache = new Map,
        this.oldCache = new Map,
        this._size = 0
    }
    _emitEvictions(i) {
        if (typeof this.onEviction == "function")
            for (const [s,a] of i)
                this.onEviction(s, a.value)
    }
    _deleteIfExpired(i, s) {
        return typeof s.expiry == "number" && s.expiry <= Date.now() ? (typeof this.onEviction == "function" && this.onEviction(i, s.value),
        this.delete(i)) : !1
    }
    _getOrDeleteIfExpired(i, s) {
        if (this._deleteIfExpired(i, s) === !1)
            return s.value
    }
    _getItemValue(i, s) {
        return s.expiry ? this._getOrDeleteIfExpired(i, s) : s.value
    }
    _peek(i, s) {
        const a = s.get(i);
        return this._getItemValue(i, a)
    }
    _set(i, s) {
        this.cache.set(i, s),
        this._size++,
        this._size >= this.maxSize && (this._size = 0,
        this._emitEvictions(this.oldCache),
        this.oldCache = this.cache,
        this.cache = new Map)
    }
    _moveToRecent(i, s) {
        this.oldCache.delete(i),
        this._set(i, s)
    }
    *_entriesAscending() {
        for (const i of this.oldCache) {
            const [s,a] = i;
            this.cache.has(s) || this._deleteIfExpired(s, a) === !1 && (yield i)
        }
        for (const i of this.cache) {
            const [s,a] = i;
            this._deleteIfExpired(s, a) === !1 && (yield i)
        }
    }
    get(i) {
        if (this.cache.has(i)) {
            const s = this.cache.get(i);
            return this._getItemValue(i, s)
        }
        if (this.oldCache.has(i)) {
            const s = this.oldCache.get(i);
            if (this._deleteIfExpired(i, s) === !1)
                return this._moveToRecent(i, s),
                s.value
        }
    }
    set(i, s, {maxAge: a=this.maxAge}={}) {
        const _ = typeof a == "number" && a !== Number.POSITIVE_INFINITY ? Date.now() + a : void 0;
        this.cache.has(i) ? this.cache.set(i, {
            value: s,
            expiry: _
        }) : this._set(i, {
            value: s,
            expiry: _
        })
    }
    has(i) {
        return this.cache.has(i) ? !this._deleteIfExpired(i, this.cache.get(i)) : this.oldCache.has(i) ? !this._deleteIfExpired(i, this.oldCache.get(i)) : !1
    }
    peek(i) {
        if (this.cache.has(i))
            return this._peek(i, this.cache);
        if (this.oldCache.has(i))
            return this._peek(i, this.oldCache)
    }
    delete(i) {
        const s = this.cache.delete(i);
        return s && this._size--,
        this.oldCache.delete(i) || s
    }
    clear() {
        this.cache.clear(),
        this.oldCache.clear(),
        this._size = 0
    }
    resize(i) {
        if (!(i && i > 0))
            throw new TypeError("`maxSize` must be a number greater than 0");
        const s = [...this._entriesAscending()]
          , a = s.length - i;
        a < 0 ? (this.cache = new Map(s),
        this.oldCache = new Map,
        this._size = s.length) : (a > 0 && this._emitEvictions(s.slice(0, a)),
        this.oldCache = new Map(s.slice(a)),
        this.cache = new Map,
        this._size = 0),
        this.maxSize = i
    }
    *keys() {
        for (const [i] of this)
            yield i
    }
    *values() {
        for (const [,i] of this)
            yield i
    }
    *[Symbol.iterator]() {
        for (const i of this.cache) {
            const [s,a] = i;
            this._deleteIfExpired(s, a) === !1 && (yield[s, a.value])
        }
        for (const i of this.oldCache) {
            const [s,a] = i;
            this.cache.has(s) || this._deleteIfExpired(s, a) === !1 && (yield[s, a.value])
        }
    }
    *entriesDescending() {
        let i = [...this.cache];
        for (let s = i.length - 1; s >= 0; --s) {
            const a = i[s]
              , [_,$] = a;
            this._deleteIfExpired(_, $) === !1 && (yield[_, $.value])
        }
        i = [...this.oldCache];
        for (let s = i.length - 1; s >= 0; --s) {
            const a = i[s]
              , [_,$] = a;
            this.cache.has(_) || this._deleteIfExpired(_, $) === !1 && (yield[_, $.value])
        }
    }
    *entriesAscending() {
        for (const [i,s] of this._entriesAscending())
            yield[i, s.value]
    }
    get size() {
        if (!this._size)
            return this.oldCache.size;
        let i = 0;
        for (const s of this.oldCache.keys())
            this.cache.has(s) || i++;
        return Math.min(this._size + i, this.maxSize)
    }
    entries() {
        return this.entriesAscending()
    }
    forEach(i, s=this) {
        for (const [a,_] of this.entriesAscending())
            i.call(s, _, a, this)
    }
    get[Symbol.toStringTag]() {
        return JSON.stringify([...this.entriesAscending()])
    }
}
async function wait(o) {
    return new Promise(i => setTimeout(i, o))
}
function zip(o, i) {
    const s = Array.isArray(o) ? o : Array.from(o)
      , a = Array.isArray(i) ? i : Array.from(i);
    return s.map( (_, $) => [_, a[$]])
}
class AbortError extends Error {
    constructor(i) {
        super(i),
        Error.captureStackTrace && Error.captureStackTrace(this, AbortError),
        this.name = "AbortError"
    }
}
class CustomAggregateError extends Error {
    constructor(i, s) {
        super(s),
        this.errors = i,
        this.message = s,
        this.name = "AggregateError"
    }
}
const AggregateError = CustomAggregateError;
class Block {
    constructor(i, s, a=null) {
        this.offset = i,
        this.length = s,
        this.data = a
    }
    get top() {
        return this.offset + this.length
    }
}
class BlockGroup {
    constructor(i, s, a) {
        this.offset = i,
        this.length = s,
        this.blockIds = a
    }
}
class BlockedSource extends BaseSource {
    constructor(i, {blockSize: s=65536, cacheSize: a=100}={}) {
        super(),
        this.source = i,
        this.blockSize = s,
        this.blockCache = new QuickLRU({
            maxSize: a,
            onEviction: (_, $) => {
                this.evictedBlocks.set(_, $)
            }
        }),
        this.evictedBlocks = new Map,
        this.blockRequests = new Map,
        this.blockIdsToFetch = new Set,
        this.abortedBlockIds = new Set
    }
    get fileSize() {
        return this.source.fileSize
    }
    async fetch(i, s) {
        const a = []
          , _ = []
          , $ = [];
        this.evictedBlocks.clear();
        for (const {offset: j, length: it} of i) {
            let st = j + it;
            const {fileSize: at} = this;
            at !== null && (st = Math.min(st, at));
            const lt = Math.floor(j / this.blockSize) * this.blockSize;
            for (let ct = lt; ct < st; ct += this.blockSize) {
                const ut = Math.floor(ct / this.blockSize);
                !this.blockCache.has(ut) && !this.blockRequests.has(ut) && (this.blockIdsToFetch.add(ut),
                _.push(ut)),
                this.blockRequests.has(ut) && a.push(this.blockRequests.get(ut)),
                $.push(ut)
            }
        }
        await wait(),
        this.fetchBlocks(s);
        const _e = [];
        for (const j of _)
            this.blockRequests.has(j) && _e.push(this.blockRequests.get(j));
        await Promise.allSettled(a),
        await Promise.allSettled(_e);
        const tt = []
          , nt = $.filter(j => this.abortedBlockIds.has(j) || !this.blockCache.has(j));
        if (nt.forEach(j => this.blockIdsToFetch.add(j)),
        nt.length > 0 && s && !s.aborted) {
            this.fetchBlocks(null);
            for (const j of nt) {
                const it = this.blockRequests.get(j);
                if (!it)
                    throw new Error(`Block ${j} is not in the block requests`);
                tt.push(it)
            }
            await Promise.allSettled(tt)
        }
        if (s && s.aborted)
            throw new AbortError("Request was aborted");
        const rt = $.map(j => this.blockCache.get(j) || this.evictedBlocks.get(j))
          , ot = rt.filter(j => !j);
        if (ot.length)
            throw new AggregateError(ot,"Request failed");
        const et = new Map(zip($, rt));
        return this.readSliceData(i, et)
    }
    fetchBlocks(i) {
        if (this.blockIdsToFetch.size > 0) {
            const s = this.groupBlocks(this.blockIdsToFetch)
              , a = this.source.fetch(s, i);
            for (let _ = 0; _ < s.length; ++_) {
                const $ = s[_];
                for (const _e of $.blockIds)
                    this.blockRequests.set(_e, (async () => {
                        try {
                            const tt = (await a)[_]
                              , nt = _e * this.blockSize
                              , rt = nt - tt.offset
                              , ot = Math.min(rt + this.blockSize, tt.data.byteLength)
                              , et = tt.data.slice(rt, ot)
                              , j = new Block(nt,et.byteLength,et,_e);
                            this.blockCache.set(_e, j),
                            this.abortedBlockIds.delete(_e)
                        } catch (tt) {
                            if (tt.name === "AbortError")
                                tt.signal = i,
                                this.blockCache.delete(_e),
                                this.abortedBlockIds.add(_e);
                            else
                                throw tt
                        } finally {
                            this.blockRequests.delete(_e)
                        }
                    }
                    )())
            }
            this.blockIdsToFetch.clear()
        }
    }
    groupBlocks(i) {
        const s = Array.from(i).sort( (_e, tt) => _e - tt);
        if (s.length === 0)
            return [];
        let a = []
          , _ = null;
        const $ = [];
        for (const _e of s)
            _ === null || _ + 1 === _e ? (a.push(_e),
            _ = _e) : ($.push(new BlockGroup(a[0] * this.blockSize,a.length * this.blockSize,a)),
            a = [_e],
            _ = _e);
        return $.push(new BlockGroup(a[0] * this.blockSize,a.length * this.blockSize,a)),
        $
    }
    readSliceData(i, s) {
        return i.map(a => {
            let _ = a.offset + a.length;
            this.fileSize !== null && (_ = Math.min(this.fileSize, _));
            const $ = Math.floor(a.offset / this.blockSize)
              , _e = Math.floor(_ / this.blockSize)
              , tt = new ArrayBuffer(a.length)
              , nt = new Uint8Array(tt);
            for (let rt = $; rt <= _e; ++rt) {
                const ot = s.get(rt)
                  , et = ot.offset - a.offset
                  , j = ot.top - _;
                let it = 0, st = 0, at;
                et < 0 ? it = -et : et > 0 && (st = et),
                j < 0 ? at = ot.length - it : at = _ - ot.offset - it;
                const lt = new Uint8Array(ot.data,it,at);
                nt.set(lt, st)
            }
            return tt
        }
        )
    }
}
class BaseResponse {
    get ok() {
        return this.status >= 200 && this.status <= 299
    }
    get status() {
        throw new Error("not implemented")
    }
    getHeader(i) {
        throw new Error("not implemented")
    }
    async getData() {
        throw new Error("not implemented")
    }
}
class BaseClient {
    constructor(i) {
        this.url = i
    }
    async request({headers: i, credentials: s, signal: a}={}) {
        throw new Error("request is not implemented")
    }
}
class FetchResponse extends BaseResponse {
    constructor(i) {
        super(),
        this.response = i
    }
    get status() {
        return this.response.status
    }
    getHeader(i) {
        return this.response.headers.get(i)
    }
    async getData() {
        return this.response.arrayBuffer ? await this.response.arrayBuffer() : (await this.response.buffer()).buffer
    }
}
class FetchClient extends BaseClient {
    constructor(i, s) {
        super(i),
        this.credentials = s
    }
    async request({headers: i, credentials: s, signal: a}={}) {
        const _ = await fetch(this.url, {
            headers: i,
            credentials: s,
            signal: a
        });
        return new FetchResponse(_)
    }
}
class XHRResponse extends BaseResponse {
    constructor(i, s) {
        super(),
        this.xhr = i,
        this.data = s
    }
    get status() {
        return this.xhr.status
    }
    getHeader(i) {
        return this.xhr.getResponseHeader(i)
    }
    async getData() {
        return this.data
    }
}
class XHRClient extends BaseClient {
    constructRequest(i, s) {
        return new Promise( (a, _) => {
            const $ = new XMLHttpRequest;
            $.open("GET", this.url),
            $.responseType = "arraybuffer";
            for (const [_e,tt] of Object.entries(i))
                $.setRequestHeader(_e, tt);
            $.onload = () => {
                const _e = $.response;
                a(new XHRResponse($,_e))
            }
            ,
            $.onerror = _,
            $.onabort = () => _(new AbortError("Request aborted")),
            $.send(),
            s && (s.aborted && $.abort(),
            s.addEventListener("abort", () => $.abort()))
        }
        )
    }
    async request({headers: i, signal: s}={}) {
        return await this.constructRequest(i, s)
    }
}
const fs = {};
class HttpResponse extends BaseResponse {
    constructor(i, s) {
        super(),
        this.response = i,
        this.dataPromise = s
    }
    get status() {
        return this.response.statusCode
    }
    getHeader(i) {
        return this.response.headers[i]
    }
    async getData() {
        return await this.dataPromise
    }
}
class HttpClient extends BaseClient {
    constructor(i) {
        super(i),
        this.parsedUrl = fs.parse(this.url),
        this.httpApi = (this.parsedUrl.protocol === "http:",
        fs)
    }
    constructRequest(i, s) {
        return new Promise( (a, _) => {
            const $ = this.httpApi.get({
                ...this.parsedUrl,
                headers: i
            }, _e => {
                const tt = new Promise(nt => {
                    const rt = [];
                    _e.on("data", ot => {
                        rt.push(ot)
                    }
                    ),
                    _e.on("end", () => {
                        const ot = Buffer.concat(rt).buffer;
                        nt(ot)
                    }
                    ),
                    _e.on("error", _)
                }
                );
                a(new HttpResponse(_e,tt))
            }
            );
            $.on("error", _),
            s && (s.aborted && $.destroy(new AbortError("Request aborted")),
            s.addEventListener("abort", () => $.destroy(new AbortError("Request aborted"))))
        }
        )
    }
    async request({headers: i, signal: s}={}) {
        return await this.constructRequest(i, s)
    }
}
class RemoteSource extends BaseSource {
    constructor(i, s, a, _) {
        super(),
        this.client = i,
        this.headers = s,
        this.maxRanges = a,
        this.allowFullFile = _,
        this._fileSize = null
    }
    async fetch(i, s) {
        return this.maxRanges >= i.length ? this.fetchSlices(i, s) : (this.maxRanges > 0 && i.length > 1,
        Promise.all(i.map(a => this.fetchSlice(a, s))))
    }
    async fetchSlices(i, s) {
        const a = await this.client.request({
            headers: {
                ...this.headers,
                Range: `bytes=${i.map( ({offset: _, length: $}) => `${_}-${_ + $}`).join(",")}`
            },
            signal: s
        });
        if (a.ok)
            if (a.status === 206) {
                const {type: _, params: $} = parseContentType(a.getHeader("content-type"));
                if (_ === "multipart/byteranges") {
                    const et = parseByteRanges(await a.getData(), $.boundary);
                    return this._fileSize = et[0].fileSize || null,
                    et
                }
                const _e = await a.getData()
                  , {start: tt, end: nt, total: rt} = parseContentRange(a.getHeader("content-range"));
                this._fileSize = rt || null;
                const ot = [{
                    data: _e,
                    offset: tt,
                    length: nt - tt
                }];
                if (i.length > 1) {
                    const et = await Promise.all(i.slice(1).map(j => this.fetchSlice(j, s)));
                    return ot.concat(et)
                }
                return ot
            } else {
                if (!this.allowFullFile)
                    throw new Error("Server responded with full file");
                const _ = await a.getData();
                return this._fileSize = _.byteLength,
                [{
                    data: _,
                    offset: 0,
                    length: _.byteLength
                }]
            }
        else
            throw new Error("Error fetching data.")
    }
    async fetchSlice(i, s) {
        const {offset: a, length: _} = i
          , $ = await this.client.request({
            headers: {
                ...this.headers,
                Range: `bytes=${a}-${a + _}`
            },
            signal: s
        });
        if ($.ok)
            if ($.status === 206) {
                const _e = await $.getData()
                  , {total: tt} = parseContentRange($.getHeader("content-range"));
                return this._fileSize = tt || null,
                {
                    data: _e,
                    offset: a,
                    length: _
                }
            } else {
                if (!this.allowFullFile)
                    throw new Error("Server responded with full file");
                const _e = await $.getData();
                return this._fileSize = _e.byteLength,
                {
                    data: _e,
                    offset: 0,
                    length: _e.byteLength
                }
            }
        else
            throw new Error("Error fetching data.")
    }
    get fileSize() {
        return this._fileSize
    }
}
function maybeWrapInBlockedSource(o, {blockSize: i, cacheSize: s}) {
    return i === null ? o : new BlockedSource(o,{
        blockSize: i,
        cacheSize: s
    })
}
function makeFetchSource(o, {headers: i={}, credentials: s, maxRanges: a=0, allowFullFile: _=!1, ...$}={}) {
    const _e = new FetchClient(o,s)
      , tt = new RemoteSource(_e,i,a,_);
    return maybeWrapInBlockedSource(tt, $)
}
function makeXHRSource(o, {headers: i={}, maxRanges: s=0, allowFullFile: a=!1, ..._}={}) {
    const $ = new XHRClient(o)
      , _e = new RemoteSource($,i,s,a);
    return maybeWrapInBlockedSource(_e, _)
}
function makeHttpSource(o, {headers: i={}, maxRanges: s=0, allowFullFile: a=!1, ..._}={}) {
    const $ = new HttpClient(o)
      , _e = new RemoteSource($,i,s,a);
    return maybeWrapInBlockedSource(_e, _)
}
function makeRemoteSource(o, {forceXHR: i=!1, ...s}={}) {
    return typeof fetch == "function" && !i ? makeFetchSource(o, s) : typeof XMLHttpRequest < "u" ? makeXHRSource(o, s) : makeHttpSource(o, s)
}
class FileReaderSource extends BaseSource {
    constructor(i) {
        super(),
        this.file = i
    }
    async fetchSlice(i, s) {
        return new Promise( (a, _) => {
            const $ = this.file.slice(i.offset, i.offset + i.length)
              , _e = new FileReader;
            _e.onload = tt => a(tt.target.result),
            _e.onerror = _,
            _e.onabort = _,
            _e.readAsArrayBuffer($),
            s && s.addEventListener("abort", () => _e.abort())
        }
        )
    }
}
function makeFileReaderSource(o) {
    return new FileReaderSource(o)
}
function getFieldTypeLength(o) {
    switch (o) {
    case fieldTypes.BYTE:
    case fieldTypes.ASCII:
    case fieldTypes.SBYTE:
    case fieldTypes.UNDEFINED:
        return 1;
    case fieldTypes.SHORT:
    case fieldTypes.SSHORT:
        return 2;
    case fieldTypes.LONG:
    case fieldTypes.SLONG:
    case fieldTypes.FLOAT:
    case fieldTypes.IFD:
        return 4;
    case fieldTypes.RATIONAL:
    case fieldTypes.SRATIONAL:
    case fieldTypes.DOUBLE:
    case fieldTypes.LONG8:
    case fieldTypes.SLONG8:
    case fieldTypes.IFD8:
        return 8;
    default:
        throw new RangeError(`Invalid field type: ${o}`)
    }
}
function parseGeoKeyDirectory(o) {
    const i = o.GeoKeyDirectory;
    if (!i)
        return null;
    const s = {};
    for (let a = 4; a <= i[3] * 4; a += 4) {
        const _ = geoKeyNames[i[a]]
          , $ = i[a + 1] ? fieldTagNames[i[a + 1]] : null
          , _e = i[a + 2]
          , tt = i[a + 3];
        let nt = null;
        if (!$)
            nt = tt;
        else {
            if (nt = o[$],
            typeof nt > "u" || nt === null)
                throw new Error(`Could not get value of geoKey '${_}'.`);
            typeof nt == "string" ? nt = nt.substring(tt, tt + _e - 1) : nt.subarray && (nt = nt.subarray(tt, tt + _e),
            _e === 1 && (nt = nt[0]))
        }
        s[_] = nt
    }
    return s
}
function getValues(o, i, s, a) {
    let _ = null
      , $ = null;
    const _e = getFieldTypeLength(i);
    switch (i) {
    case fieldTypes.BYTE:
    case fieldTypes.ASCII:
    case fieldTypes.UNDEFINED:
        _ = new Uint8Array(s),
        $ = o.readUint8;
        break;
    case fieldTypes.SBYTE:
        _ = new Int8Array(s),
        $ = o.readInt8;
        break;
    case fieldTypes.SHORT:
        _ = new Uint16Array(s),
        $ = o.readUint16;
        break;
    case fieldTypes.SSHORT:
        _ = new Int16Array(s),
        $ = o.readInt16;
        break;
    case fieldTypes.LONG:
    case fieldTypes.IFD:
        _ = new Uint32Array(s),
        $ = o.readUint32;
        break;
    case fieldTypes.SLONG:
        _ = new Int32Array(s),
        $ = o.readInt32;
        break;
    case fieldTypes.LONG8:
    case fieldTypes.IFD8:
        _ = new Array(s),
        $ = o.readUint64;
        break;
    case fieldTypes.SLONG8:
        _ = new Array(s),
        $ = o.readInt64;
        break;
    case fieldTypes.RATIONAL:
        _ = new Uint32Array(s * 2),
        $ = o.readUint32;
        break;
    case fieldTypes.SRATIONAL:
        _ = new Int32Array(s * 2),
        $ = o.readInt32;
        break;
    case fieldTypes.FLOAT:
        _ = new Float32Array(s),
        $ = o.readFloat32;
        break;
    case fieldTypes.DOUBLE:
        _ = new Float64Array(s),
        $ = o.readFloat64;
        break;
    default:
        throw new RangeError(`Invalid field type: ${i}`)
    }
    if (i === fieldTypes.RATIONAL || i === fieldTypes.SRATIONAL)
        for (let tt = 0; tt < s; tt += 2)
            _[tt] = $.call(o, a + tt * _e),
            _[tt + 1] = $.call(o, a + (tt * _e + 4));
    else
        for (let tt = 0; tt < s; ++tt)
            _[tt] = $.call(o, a + tt * _e);
    return i === fieldTypes.ASCII ? new TextDecoder("utf-8").decode(_) : _
}
class ImageFileDirectory {
    constructor(i, s, a) {
        this.fileDirectory = i,
        this.geoKeyDirectory = s,
        this.nextIFDByteOffset = a
    }
}
class GeoTIFFImageIndexError extends Error {
    constructor(i) {
        super(`No image at index ${i}`),
        this.index = i
    }
}
class GeoTIFFBase {
    async readRasters(i={}) {
        const {window: s, width: a, height: _} = i;
        let {resX: $, resY: _e, bbox: tt} = i;
        const nt = await this.getImage();
        let rt = nt;
        const ot = await this.getImageCount()
          , et = nt.getBoundingBox();
        if (s && tt)
            throw new Error('Both "bbox" and "window" passed.');
        if (a || _) {
            if (s) {
                const [st,at] = nt.getOrigin()
                  , [lt,ct] = nt.getResolution();
                tt = [st + s[0] * lt, at + s[1] * ct, st + s[2] * lt, at + s[3] * ct]
            }
            const it = tt || et;
            if (a) {
                if ($)
                    throw new Error("Both width and resX passed");
                $ = (it[2] - it[0]) / a
            }
            if (_) {
                if (_e)
                    throw new Error("Both width and resY passed");
                _e = (it[3] - it[1]) / _
            }
        }
        if ($ || _e) {
            const it = [];
            for (let st = 0; st < ot; ++st) {
                const at = await this.getImage(st)
                  , {SubfileType: lt, NewSubfileType: ct} = at.fileDirectory;
                (st === 0 || lt === 2 || ct & 1) && it.push(at)
            }
            it.sort( (st, at) => st.getWidth() - at.getWidth());
            for (let st = 0; st < it.length; ++st) {
                const at = it[st]
                  , lt = (et[2] - et[0]) / at.getWidth()
                  , ct = (et[3] - et[1]) / at.getHeight();
                if (rt = at,
                $ && $ > lt || _e && _e > ct)
                    break
            }
        }
        let j = s;
        if (tt) {
            const [it,st] = nt.getOrigin()
              , [at,lt] = rt.getResolution(nt);
            j = [Math.round((tt[0] - it) / at), Math.round((tt[1] - st) / lt), Math.round((tt[2] - it) / at), Math.round((tt[3] - st) / lt)],
            j = [Math.min(j[0], j[2]), Math.min(j[1], j[3]), Math.max(j[0], j[2]), Math.max(j[1], j[3])]
        }
        return rt.readRasters({
            ...i,
            window: j
        })
    }
}
let GeoTIFF$1 = class Cr extends GeoTIFFBase {
    constructor(i, s, a, _, $={}) {
        super(),
        this.source = i,
        this.littleEndian = s,
        this.bigTiff = a,
        this.firstIFDOffset = _,
        this.cache = $.cache || !1,
        this.ifdRequests = [],
        this.ghostValues = null
    }
    async getSlice(i, s) {
        const a = this.bigTiff ? 4048 : 1024;
        return new DataSlice((await this.source.fetch([{
            offset: i,
            length: typeof s < "u" ? s : a
        }]))[0],i,this.littleEndian,this.bigTiff)
    }
    async parseFileDirectoryAt(i) {
        const s = this.bigTiff ? 20 : 12
          , a = this.bigTiff ? 8 : 2;
        let _ = await this.getSlice(i);
        const $ = this.bigTiff ? _.readUint64(i) : _.readUint16(i)
          , _e = $ * s + (this.bigTiff ? 16 : 6);
        _.covers(i, _e) || (_ = await this.getSlice(i, _e));
        const tt = {};
        let nt = i + (this.bigTiff ? 8 : 2);
        for (let et = 0; et < $; nt += s,
        ++et) {
            const j = _.readUint16(nt)
              , it = _.readUint16(nt + 2)
              , st = this.bigTiff ? _.readUint64(nt + 4) : _.readUint32(nt + 4);
            let at, lt;
            const ct = getFieldTypeLength(it)
              , ut = nt + (this.bigTiff ? 12 : 8);
            if (ct * st <= (this.bigTiff ? 8 : 4))
                at = getValues(_, it, st, ut);
            else {
                const dt = _.readOffset(ut)
                  , ft = getFieldTypeLength(it) * st;
                if (_.covers(dt, ft))
                    at = getValues(_, it, st, dt);
                else {
                    const ht = await this.getSlice(dt, ft);
                    at = getValues(ht, it, st, dt)
                }
            }
            st === 1 && arrayFields.indexOf(j) === -1 && !(it === fieldTypes.RATIONAL || it === fieldTypes.SRATIONAL) ? lt = at[0] : lt = at,
            tt[fieldTagNames[j]] = lt
        }
        const rt = parseGeoKeyDirectory(tt)
          , ot = _.readOffset(i + a + s * $);
        return new ImageFileDirectory(tt,rt,ot)
    }
    async requestIFD(i) {
        if (this.ifdRequests[i])
            return this.ifdRequests[i];
        if (i === 0)
            return this.ifdRequests[i] = this.parseFileDirectoryAt(this.firstIFDOffset),
            this.ifdRequests[i];
        if (!this.ifdRequests[i - 1])
            try {
                this.ifdRequests[i - 1] = this.requestIFD(i - 1)
            } catch (s) {
                throw s instanceof GeoTIFFImageIndexError ? new GeoTIFFImageIndexError(i) : s
            }
        return this.ifdRequests[i] = (async () => {
            const s = await this.ifdRequests[i - 1];
            if (s.nextIFDByteOffset === 0)
                throw new GeoTIFFImageIndexError(i);
            return this.parseFileDirectoryAt(s.nextIFDByteOffset)
        }
        )(),
        this.ifdRequests[i]
    }
    async getImage(i=0) {
        const s = await this.requestIFD(i);
        return new GeoTIFFImage$1(s.fileDirectory,s.geoKeyDirectory,this.dataView,this.littleEndian,this.cache,this.source)
    }
    async getImageCount() {
        let i = 0
          , s = !0;
        for (; s; )
            try {
                await this.requestIFD(i),
                ++i
            } catch (a) {
                if (a instanceof GeoTIFFImageIndexError)
                    s = !1;
                else
                    throw a
            }
        return i
    }
    async getGhostValues() {
        const i = this.bigTiff ? 16 : 8;
        if (this.ghostValues)
            return this.ghostValues;
        const s = "GDAL_STRUCTURAL_METADATA_SIZE="
          , a = s.length + 100;
        let _ = await this.getSlice(i, a);
        if (s === getValues(_, fieldTypes.ASCII, s.length, i)) {
            const _e = getValues(_, fieldTypes.ASCII, a, i).split(`
`)[0]
              , tt = Number(_e.split("=")[1].split(" ")[0]) + _e.length;
            tt > a && (_ = await this.getSlice(i, tt));
            const nt = getValues(_, fieldTypes.ASCII, tt, i);
            this.ghostValues = {},
            nt.split(`
`).filter(rt => rt.length > 0).map(rt => rt.split("=")).forEach( ([rt,ot]) => {
                this.ghostValues[rt] = ot
            }
            )
        }
        return this.ghostValues
    }
    static async fromSource(i, s, a) {
        const _ = (await i.fetch([{
            offset: 0,
            length: 1024
        }], a))[0]
          , $ = new DataView64(_)
          , _e = $.getUint16(0, 0);
        let tt;
        if (_e === 18761)
            tt = !0;
        else if (_e === 19789)
            tt = !1;
        else
            throw new TypeError("Invalid byte order value.");
        const nt = $.getUint16(2, tt);
        let rt;
        if (nt === 42)
            rt = !1;
        else if (nt === 43) {
            if (rt = !0,
            $.getUint16(4, tt) !== 8)
                throw new Error("Unsupported offset byte-size.")
        } else
            throw new TypeError("Invalid magic number.");
        const ot = rt ? $.getUint64(8, tt) : $.getUint32(4, tt);
        return new Cr(i,tt,rt,ot,s)
    }
    close() {
        return typeof this.source.close == "function" ? this.source.close() : !1
    }
}
;
class MultiGeoTIFF extends GeoTIFFBase {
    constructor(i, s) {
        super(),
        this.mainFile = i,
        this.overviewFiles = s,
        this.imageFiles = [i].concat(s),
        this.fileDirectoriesPerFile = null,
        this.fileDirectoriesPerFileParsing = null,
        this.imageCount = null
    }
    async parseFileDirectoriesPerFile() {
        const i = [this.mainFile.parseFileDirectoryAt(this.mainFile.firstIFDOffset)].concat(this.overviewFiles.map(s => s.parseFileDirectoryAt(s.firstIFDOffset)));
        return this.fileDirectoriesPerFile = await Promise.all(i),
        this.fileDirectoriesPerFile
    }
    async getImage(i=0) {
        await this.getImageCount(),
        await this.parseFileDirectoriesPerFile();
        let s = 0
          , a = 0;
        for (let _ = 0; _ < this.imageFiles.length; _++) {
            const $ = this.imageFiles[_];
            for (let _e = 0; _e < this.imageCounts[_]; _e++) {
                if (i === s) {
                    const tt = await $.requestIFD(a);
                    return new GeoTIFFImage$1(tt.fileDirectory,tt.geoKeyDirectory,$.dataView,$.littleEndian,$.cache,$.source)
                }
                s++,
                a++
            }
            a = 0
        }
        throw new RangeError("Invalid image index")
    }
    async getImageCount() {
        if (this.imageCount !== null)
            return this.imageCount;
        const i = [this.mainFile.getImageCount()].concat(this.overviewFiles.map(s => s.getImageCount()));
        return this.imageCounts = await Promise.all(i),
        this.imageCount = this.imageCounts.reduce( (s, a) => s + a, 0),
        this.imageCount
    }
}
async function fromUrl(o, i={}, s) {
    return GeoTIFF$1.fromSource(makeRemoteSource(o, i), s)
}
async function fromBlob(o, i) {
    return GeoTIFF$1.fromSource(makeFileReaderSource(o), i)
}
async function fromUrls(o, i=[], s={}, a) {
    const _ = await GeoTIFF$1.fromSource(makeRemoteSource(o, s), a)
      , $ = await Promise.all(i.map(_e => GeoTIFF$1.fromSource(makeRemoteSource(_e, s))));
    return new MultiGeoTIFF(_,$)
}
function isMask(o) {
    return ((o.fileDirectory.NewSubfileType || 0) & 4) === 4
}
function readRGB(o, i) {
    if (!o)
        return !1;
    if (o === !0)
        return !0;
    if (i.getSamplesPerPixel() !== 3)
        return !1;
    const s = i.fileDirectory.PhotometricInterpretation
      , a = photometricInterpretations;
    return s === a.CMYK || s === a.YCbCr || s === a.CIELab || s === a.ICCLab
}
const STATISTICS_MAXIMUM = "STATISTICS_MAXIMUM"
  , STATISTICS_MINIMUM = "STATISTICS_MINIMUM"
  , defaultTileSize = 256;
let workerPool;
function getWorkerPool() {
    return workerPool || (workerPool = new Pool$1),
    workerPool
}
function getBoundingBox(o) {
    try {
        return o.getBoundingBox()
    } catch {
        return [0, 0, o.getWidth(), o.getHeight()]
    }
}
function getOrigin(o) {
    try {
        return o.getOrigin().slice(0, 2)
    } catch {
        return [0, o.getHeight()]
    }
}
function getResolutions(o, i) {
    try {
        return o.getResolution(i)
    } catch {
        return [i.getWidth() / o.getWidth(), i.getHeight() / o.getHeight()]
    }
}
function getProjection(o) {
    const i = o.geoKeys;
    if (!i)
        return null;
    if (i.ProjectedCSTypeGeoKey && i.ProjectedCSTypeGeoKey !== 32767) {
        const s = "EPSG:" + i.ProjectedCSTypeGeoKey;
        let a = get$1(s);
        if (!a) {
            const _ = fromCode(i.ProjLinearUnitsGeoKey);
            _ && (a = new Projection$1({
                code: s,
                units: _
            }))
        }
        return a
    }
    if (i.GeographicTypeGeoKey && i.GeographicTypeGeoKey !== 32767) {
        const s = "EPSG:" + i.GeographicTypeGeoKey;
        let a = get$1(s);
        if (!a) {
            const _ = fromCode(i.GeogAngularUnitsGeoKey);
            _ && (a = new Projection$1({
                code: s,
                units: _
            }))
        }
        return a
    }
    return null
}
function getImagesForTIFF(o) {
    return o.getImageCount().then(function(i) {
        const s = new Array(i);
        for (let a = 0; a < i; ++a)
            s[a] = o.getImage(a);
        return Promise.all(s)
    })
}
function getImagesForSource(o, i) {
    let s;
    return o.blob ? s = fromBlob(o.blob) : o.overviews ? s = fromUrls(o.url, o.overviews, i) : s = fromUrl(o.url, i),
    s.then(getImagesForTIFF)
}
function assertEqual(o, i, s, a, _) {
    if (Array.isArray(o)) {
        const $ = o.length;
        if (!Array.isArray(i) || $ != i.length) {
            const _e = new Error(a);
            throw _(_e),
            _e
        }
        for (let _e = 0; _e < $; ++_e)
            assertEqual(o[_e], i[_e], s, a, _);
        return
    }
    if (i = i,
    Math.abs(o - i) > s * o)
        throw new Error(a)
}
function getMinForDataType(o) {
    return o instanceof Int8Array ? -128 : o instanceof Int16Array ? -32768 : o instanceof Int32Array ? -2147483648 : o instanceof Float32Array ? 12e-39 : 0
}
function getMaxForDataType(o) {
    return o instanceof Int8Array ? 127 : o instanceof Uint8Array || o instanceof Uint8ClampedArray ? 255 : o instanceof Int16Array ? 32767 : o instanceof Uint16Array ? 65535 : o instanceof Int32Array ? 2147483647 : o instanceof Uint32Array ? 4294967295 : o instanceof Float32Array ? 34e37 : 255
}
class GeoTIFFSource extends DataTile {
    constructor(i) {
        super({
            state: "loading",
            tileGrid: null,
            projection: i.projection || null,
            opaque: i.opaque,
            transition: i.transition,
            interpolate: i.interpolate !== !1,
            wrapX: i.wrapX
        }),
        this.sourceInfo_ = i.sources;
        const s = this.sourceInfo_.length;
        this.sourceOptions_ = i.sourceOptions,
        this.sourceImagery_ = new Array(s),
        this.sourceMasks_ = new Array(s),
        this.resolutionFactors_ = new Array(s),
        this.samplesPerPixel_,
        this.nodataValues_,
        this.metadata_,
        this.normalize_ = i.normalize !== !1,
        this.addAlpha_ = !1,
        this.error_ = null,
        this.convertToRGB_ = i.convertToRGB || !1,
        this.setKey(this.sourceInfo_.map($ => $.url).join(","));
        const a = this
          , _ = new Array(s);
        for (let $ = 0; $ < s; ++$)
            _[$] = getImagesForSource(this.sourceInfo_[$], this.sourceOptions_);
        Promise.all(_).then(function($) {
            a.configure_($)
        }).catch(function($) {
            error($),
            a.error_ = $,
            a.setState("error")
        })
    }
    getError() {
        return this.error_
    }
    determineProjection(i) {
        const s = i[0];
        for (let a = s.length - 1; a >= 0; --a) {
            const _ = s[a]
              , $ = getProjection(_);
            if ($) {
                this.projection = $;
                break
            }
        }
    }
    configure_(i) {
        let s, a, _, $, _e;
        const tt = new Array(i.length)
          , nt = new Array(i.length)
          , rt = new Array(i.length);
        let ot = 0;
        const et = i.length;
        for (let at = 0; at < et; ++at) {
            const lt = []
              , ct = [];
            i[at].forEach(_t => {
                isMask(_t) ? ct.push(_t) : lt.push(_t)
            }
            );
            const ut = lt.length;
            if (ct.length > 0 && ct.length !== ut)
                throw new Error(`Expected one mask per image found ${ct.length} masks and ${ut} images`);
            let dt, ft;
            const ht = new Array(ut)
              , pt = new Array(ut)
              , gt = new Array(ut);
            nt[at] = new Array(ut),
            rt[at] = new Array(ut);
            for (let _t = 0; _t < ut; ++_t) {
                const mt = lt[_t]
                  , yt = mt.getGDALNoData();
                rt[at][_t] = mt.getGDALMetadata(0),
                nt[at][_t] = yt;
                const bt = this.sourceInfo_[at].bands;
                tt[at] = bt ? bt.length : mt.getSamplesPerPixel();
                const vt = ut - (_t + 1);
                dt || (dt = getBoundingBox(mt)),
                ft || (ft = getOrigin(mt));
                const wt = getResolutions(mt, lt[0]);
                gt[vt] = wt[0];
                const Tt = [mt.getTileWidth(), mt.getTileHeight()];
                Tt[0] !== Tt[1] && Tt[1] < defaultTileSize && (Tt[0] = defaultTileSize,
                Tt[1] = defaultTileSize),
                ht[vt] = Tt;
                const $t = wt[0] / Math.abs(wt[1]);
                pt[vt] = [Tt[0], Tt[1] / $t]
            }
            if (s ? getIntersection(s, dt, s) : s = dt,
            !a)
                a = ft;
            else {
                const _t = `Origin mismatch for source ${at}, got [${ft}] but expected [${a}]`;
                assertEqual(a, ft, 0, _t, this.viewRejector)
            }
            if (!_e)
                _e = gt,
                this.resolutionFactors_[at] = 1;
            else {
                _e.length - ot > gt.length && (ot = _e.length - gt.length);
                const _t = _e[_e.length - 1] / gt[gt.length - 1];
                this.resolutionFactors_[at] = _t;
                const mt = gt.map(bt => bt *= _t)
                  , yt = `Resolution mismatch for source ${at}, got [${mt}] but expected [${_e}]`;
                assertEqual(_e.slice(ot, _e.length), mt, .02, yt, this.viewRejector)
            }
            _ ? assertEqual(_.slice(ot, _.length), pt, .01, `Tile size mismatch for source ${at}`, this.viewRejector) : _ = pt,
            $ ? assertEqual($.slice(ot, $.length), ht, 0, `Tile size mismatch for source ${at}`, this.viewRejector) : $ = ht,
            this.sourceImagery_[at] = lt.reverse(),
            this.sourceMasks_[at] = ct.reverse()
        }
        for (let at = 0, lt = this.sourceImagery_.length; at < lt; ++at) {
            const ct = this.sourceImagery_[at];
            for (; ct.length < _e.length; )
                ct.unshift(void 0)
        }
        this.getProjection() || this.determineProjection(i),
        this.samplesPerPixel_ = tt,
        this.nodataValues_ = nt,
        this.metadata_ = rt;
        e: for (let at = 0; at < et; ++at) {
            if (this.sourceInfo_[at].nodata !== void 0) {
                this.addAlpha_ = !0;
                break
            }
            if (this.sourceMasks_[at].length) {
                this.addAlpha_ = !0;
                break
            }
            const lt = nt[at]
              , ct = this.sourceInfo_[at].bands;
            if (ct) {
                for (let ut = 0; ut < ct.length; ++ut)
                    if (lt[ct[ut] - 1] !== null) {
                        this.addAlpha_ = !0;
                        break e
                    }
                continue
            }
            for (let ut = 0; ut < lt.length; ++ut)
                if (lt[ut] !== null) {
                    this.addAlpha_ = !0;
                    break e
                }
        }
        let j = this.addAlpha_ ? 1 : 0;
        for (let at = 0; at < et; ++at)
            j += tt[at];
        this.bandCount = j;
        const it = new TileGrid$1({
            extent: s,
            minZoom: ot,
            origin: a,
            resolutions: _e,
            tileSizes: _
        });
        this.tileGrid = it,
        this.setTileSizes($),
        this.setLoader(this.loadTile_.bind(this)),
        this.setState("ready");
        const st = 1;
        _e.length === 2 ? _e = [_e[0], _e[1], _e[1] / 2] : _e.length === 1 && (_e = [_e[0] * 2, _e[0], _e[0] / 2]),
        this.viewResolver({
            showFullExtent: !0,
            projection: this.projection,
            resolutions: _e,
            center: toUserCoordinate(getCenter(s), this.projection),
            extent: toUserExtent(s, this.projection),
            zoom: st
        })
    }
    loadTile_(i, s, a) {
        const _ = this.getTileSize(i)
          , $ = this.sourceImagery_.length
          , _e = new Array($ * 2)
          , tt = this.nodataValues_
          , nt = this.sourceInfo_
          , rt = getWorkerPool();
        for (let ot = 0; ot < $; ++ot) {
            const et = nt[ot]
              , j = this.resolutionFactors_[ot]
              , it = [Math.round(s * (_[0] * j)), Math.round(a * (_[1] * j)), Math.round((s + 1) * (_[0] * j)), Math.round((a + 1) * (_[1] * j))]
              , st = this.sourceImagery_[ot][i];
            let at;
            et.bands && (at = et.bands.map(function(ft) {
                return ft - 1
            }));
            let lt;
            "nodata"in et && et.nodata !== null ? lt = et.nodata : at ? lt = at.map(function(ft) {
                return tt[ot][ft]
            }) : lt = tt[ot];
            const ct = {
                window: it,
                width: _[0],
                height: _[1],
                samples: at,
                fillValue: lt,
                pool: rt,
                interleave: !1
            };
            readRGB(this.convertToRGB_, st) ? _e[ot] = st.readRGB(ct) : _e[ot] = st.readRasters(ct);
            const ut = $ + ot
              , dt = this.sourceMasks_[ot][i];
            if (!dt) {
                _e[ut] = Promise.resolve(null);
                continue
            }
            _e[ut] = dt.readRasters({
                window: it,
                width: _[0],
                height: _[1],
                samples: [0],
                pool: rt,
                interleave: !1
            })
        }
        return Promise.all(_e).then(this.composeTile_.bind(this, _)).catch(function(ot) {
            throw error(ot),
            ot
        })
    }
    composeTile_(i, s) {
        const a = this.metadata_
          , _ = this.sourceInfo_
          , $ = this.sourceImagery_.length
          , _e = this.bandCount
          , tt = this.samplesPerPixel_
          , nt = this.nodataValues_
          , rt = this.normalize_
          , ot = this.addAlpha_
          , et = i[0] * i[1]
          , j = et * _e;
        let it;
        rt ? it = new Uint8Array(j) : it = new Float32Array(j);
        let st = 0;
        for (let at = 0; at < et; ++at) {
            let lt = ot;
            for (let ct = 0; ct < $; ++ct) {
                const ut = _[ct];
                let dt = ut.min, ft = ut.max, ht, pt;
                if (rt) {
                    const gt = a[ct][0];
                    dt === void 0 && (gt && STATISTICS_MINIMUM in gt ? dt = parseFloat(gt[STATISTICS_MINIMUM]) : dt = getMinForDataType(s[ct][0])),
                    ft === void 0 && (gt && STATISTICS_MAXIMUM in gt ? ft = parseFloat(gt[STATISTICS_MAXIMUM]) : ft = getMaxForDataType(s[ct][0])),
                    ht = 255 / (ft - dt),
                    pt = -dt * ht
                }
                for (let gt = 0; gt < tt[ct]; ++gt) {
                    const _t = s[ct][gt][at];
                    let mt;
                    if (rt ? mt = clamp(ht * _t + pt, 0, 255) : mt = _t,
                    !ot)
                        it[st] = mt;
                    else {
                        let yt = ut.nodata;
                        if (yt === void 0) {
                            let vt;
                            ut.bands ? vt = ut.bands[gt] - 1 : vt = gt,
                            yt = nt[ct][vt]
                        }
                        const bt = isNaN(yt);
                        (!bt && _t !== yt || bt && !isNaN(_t)) && (lt = !1,
                        it[st] = mt)
                    }
                    st++
                }
                if (!lt) {
                    const gt = $ + ct
                      , _t = s[gt];
                    _t && !_t[0][at] && (lt = !0)
                }
            }
            ot && (lt || (it[st] = 255),
            st++)
        }
        return it
    }
}
GeoTIFFSource.prototype.getView;
const GeoTIFF = GeoTIFFSource;
function getRequestUrl(o, i, s, a, _, $) {
    const _e = _.getCode().split(/:(?=\d+$)/).pop()
      , tt = s / a
      , nt = [round(getWidth(i) / tt, DECIMALS), round(getHeight(i) / tt, DECIMALS)];
    $.SIZE = nt[0] + "," + nt[1],
    $.BBOX = i.join(","),
    $.BBOXSR = _e,
    $.IMAGESR = _e,
    $.DPI = Math.round($.DPI ? $.DPI * a : 90 * a);
    const rt = o.replace(/MapServer\/?$/, "MapServer/export").replace(/ImageServer\/?$/, "ImageServer/exportImage");
    if (rt == o)
        throw new Error("`options.featureTypes` should be an Array");
    return appendParams(rt, $)
}
class TileArcGISRest extends TileImage$1 {
    constructor(i) {
        i = i || {},
        super({
            attributions: i.attributions,
            cacheSize: i.cacheSize,
            crossOrigin: i.crossOrigin,
            interpolate: i.interpolate,
            projection: i.projection,
            reprojectionErrorThreshold: i.reprojectionErrorThreshold,
            tileGrid: i.tileGrid,
            tileLoadFunction: i.tileLoadFunction,
            url: i.url,
            urls: i.urls,
            wrapX: i.wrapX !== void 0 ? i.wrapX : !0,
            transition: i.transition,
            zDirection: i.zDirection
        }),
        this.params_ = i.params || {},
        this.hidpi_ = i.hidpi !== void 0 ? i.hidpi : !0,
        this.tmpExtent_ = createEmpty(),
        this.setKey(this.getKeyForParams_())
    }
    getKeyForParams_() {
        let i = 0;
        const s = [];
        for (const a in this.params_)
            s[i++] = a + "-" + this.params_[a];
        return s.join("/")
    }
    getParams() {
        return this.params_
    }
    getRequestUrl_(i, s, a, _, $, _e) {
        const tt = this.urls;
        if (!tt)
            return;
        let nt;
        if (tt.length == 1)
            nt = tt[0];
        else {
            const rt = modulo(hash(i), tt.length);
            nt = tt[rt]
        }
        return getRequestUrl(nt, a, (this.tileGrid || this.getTileGridForProjection($)).getResolution(i[0]), _, $, _e)
    }
    getTilePixelRatio(i) {
        return this.hidpi_ ? i : 1
    }
    updateParams(i) {
        Object.assign(this.params_, i),
        this.setKey(this.getKeyForParams_())
    }
    tileUrlFunction(i, s, a) {
        let _ = this.getTileGrid();
        if (_ || (_ = this.getTileGridForProjection(a)),
        _.getResolutions().length <= i[0])
            return;
        s != 1 && !this.hidpi_ && (s = 1);
        const $ = _.getTileCoordExtent(i, this.tmpExtent_);
        let _e = toSize(_.getTileSize(i[0]), this.tmpSize);
        s != 1 && (_e = scale(_e, s, this.tmpSize));
        const tt = {
            F: "image",
            FORMAT: "PNG32",
            TRANSPARENT: !0
        };
        return Object.assign(tt, this.params_),
        this.getRequestUrl_(i, _e, $, s, a, tt)
    }
}
const TileArcGISRest$1 = TileArcGISRest;
function captureMapCanvasWithoutFeatures(o, i) {
    Object.keys(i).forEach($ => {
        i[$].layer.setVisible(!1)
    }
    ),
    o.renderSync();
    const s = o.getViewport().querySelector("canvas")
      , a = document.createElement("canvas");
    return a.width = s.width,
    a.height = s.height,
    a.getContext("2d").drawImage(s, 0, 0),
    Object.keys(i).forEach($ => {
        i[$].layer.setVisible(!0)
    }
    ),
    a
}
function toGeoJSONFeature(o) {
    const i = new GeoJSON$1
      , s = o.getGeometry();
    return {
        id: o.getId(),
        type: "Feature",
        geometry: s ? i.writeGeometryObject(s) : {
            type: "Point",
            coordinates: []
        },
        properties: o.getProperties()
    }
}
function toOpenLayersLayer(o) {
    return o.type === "zxy" ? new TileLayer$1({
        extent: o.extents,
        source: new XYZ$1({
            url: o.url,
            tileSize: o.tileSize,
            minZoom: o.minZoom,
            maxZoom: o.maxZoom,
            crossOrigin: "anonymous"
        })
    }) : o.type === "tiled wms" ? new TileLayer$1({
        extent: o.extents,
        source: new TileWMS$1({
            url: o.url,
            params: {
                LAYERS: o.wmsLayer,
                TILED: !0
            },
            crossOrigin: "anonymous"
        })
    }) : o.type === "arcgis map server" ? new TileLayer$1({
        extent: o.extents,
        source: new TileArcGISRest$1({
            url: o.url,
            crossOrigin: "anonymous"
        })
    }) : o.type === "cog" ? new WebGLTileLayer$1({
        extent: o.extents,
        source: new GeoTIFF({
            convertToRGB: !0,
            wrapX: !0,
            sources: [{
                url: o.url,
                nodata: 0
            }]
        })
    }) : null
}
var geoJSONFeatureType = (o => (o.Polygon = "Polygon",
o.LineString = "LineString",
o))(geoJSONFeatureType || {});
function mapLocationsToLngLat(o) {
    switch (o) {
    case mapLocations.City:
        return [-.118092, 51.509865, 16];
    case mapLocations.Port:
        return [1.3306033, 51.1271764, 16];
    case mapLocations.Fields:
        return [1.1298438, 51.1527109, 15];
    case mapLocations.Trees:
        return [-4.6006068, 55.822426, 16];
    case mapLocations.FishFarm:
        return [-2.7127099, 53.6400423, 17];
    case mapLocations.Quarry:
        return [-2.8025518, 51.3001841, 16];
    case mapLocations.HousingEstates:
        return [-2.5388533, 53.5061574, 16];
    case mapLocations.AgriFarmTiff:
        return [-86.57694478791015, 39.269353479530025, 17];
    default:
        return [-2.7127099, 53.6400423, 16]
    }
}
const saveAsGeoJSON = (o, i) => {
    const s = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(o))
      , a = document.createElement("a");
    a.setAttribute("href", s),
    a.setAttribute("download", i + ".json"),
    document.body.appendChild(a),
    a.click(),
    a.remove()
}
  , DRAWING_LAYER_NAME = "segment_requests"
  , OlMap = React.forwardRef( ({style: o, mapClicked: i, originalDrawingMode: s}, a) => {
    const _ = reactExports.useRef(null)
      , $ = reactExports.useRef(null)
      , [_e,tt,nt] = mapLocationsToLngLat(mapLocations.Fields)
      , rt = reactExports.useMemo( () => new VectorSource$1({
        wrapX: !1
    }), [])
      , ot = reactExports.useMemo( () => new VectorLayer$1({
        source: rt,
        style: drawingStyle
    }), [rt])
      , [et] = reactExports.useState(_e)
      , [j] = reactExports.useState(tt)
      , [it] = reactExports.useState(nt)
      , [st,at] = reactExports.useState({})
      , lt = reactExports.useRef([])
      , [,ct] = reactExports.useReducer(jt => jt + 1, 0)
      , ut = reactExports.useRef(!1)
      , dt = reactExports.useRef({
        pointController: new Draw$1({
            type: "Point",
            style: drawingStyle,
            source: rt,
            condition: jt => noModifierKeys(jt) && primaryAction(jt) && !ut.current
        }),
        boundingBoxController: new Draw$1({
            type: "Circle",
            style: drawingStyle,
            source: rt,
            geometryFunction: createBox(),
            condition: jt => noModifierKeys(jt) && primaryAction(jt) && !ut.current
        })
    });
    s === SegmentRequestType.BoundingBox ? (dt.current.boundingBoxController.setActive(!0),
    dt.current.pointController.setActive(!1)) : s === SegmentRequestType.Point && (dt.current.pointController.setActive(!0),
    dt.current.boundingBoxController.setActive(!1)),
    reactExports.useEffect( () => {
        if (_.current == null || $.current)
            return;
        at(Gt => (Gt[DRAWING_LAYER_NAME] = {
            source: rt,
            layer: ot
        },
        Gt));
        const jt = fromLonLat([et, j]);
        $.current = new Map$2({
            target: _.current,
            layers: [ot],
            view: new View$1({
                center: [jt[0], jt[1]],
                zoom: it,
                projection: "EPSG:3857"
            })
        }),
        $.current.on("click", Gt => {
            var Kt;
            if (ut.current) {
                Gt.preventDefault();
                const qt = rt.getFeaturesAtCoordinate(Gt.coordinate);
                (Kt = $.current) == null || Kt.forEachFeatureAtPixel(Gt.pixel, rn => {
                    const on = rn;
                    on != null && rt.removeFeature(on)
                }
                , {
                    hitTolerance: 10,
                    layerFilter: rn => rn === ot
                }),
                qt && qt.forEach(rn => {
                    rt.removeFeature(rn)
                }
                )
            } else {
                if (i == null)
                    return;
                const qt = Gt.coordinate;
                i([qt[0], qt[1]])
            }
        }
        ),
        $.current.addInteraction(dt.current.boundingBoxController),
        $.current.addInteraction(dt.current.pointController)
    }
    , [et, j, ot, it, rt, i]);
    function ft(jt) {
        const Gt = $.current.getCoordinateFromPixel(jt);
        return [Gt[0], Gt[1]]
    }
    function ht(jt) {
        const Gt = $.current.getPixelFromCoordinate(jt);
        return [Gt[0], Gt[1]]
    }
    function pt(jt) {
        const Gt = {
            type: "FeatureCollection",
            features: []
        }
          , Kt = new VectorSource$1({
            features: new GeoJSON$1().readFeatures(Gt)
        })
          , qt = new VectorLayer$1({
            source: Kt,
            style: getFeatureStyle
        });
        $.current.addLayer(qt),
        at(rn => (rn[jt] = {
            source: Kt,
            layer: qt
        },
        rn))
    }
    function gt(jt, Gt, Kt) {
        const qt = st[Gt]
          , rn = Kt.map(_n => {
            const mn = ft(_n);
            return [mn[0], mn[1]]
        }
        )
          , on = new Feature$1({
            geometry: new Polygon$1([rn])
        });
        return on.setId(jt),
        qt.source.addFeature(on),
        toGeoJSONFeature(on)
    }
    function _t(jt, Gt, Kt) {
        const qt = st[Gt]
          , rn = Kt.map(_n => {
            const mn = ft(_n);
            return [mn[0], mn[1]]
        }
        )
          , on = new Feature$1({
            geometry: new LineString$1(rn)
        });
        return on.setId(jt),
        qt.source.addFeature(on),
        toGeoJSONFeature(on)
    }
    function mt(jt, Gt) {
        const Kt = st[Gt]
          , qt = Kt.source.getFeatureById(jt);
        qt != null && Kt.source.removeFeature(qt)
    }
    function yt(jt) {
        const Gt = st[jt];
        return Gt == null ? void 0 : {
            type: "FeatureCollection",
            features: Gt.source.getFeatures().map(rn => toGeoJSONFeature(rn))
        }
    }
    function bt(jt, Gt, Kt) {
        var rn;
        const qt = fromLonLat([jt, Gt], "EPSG:3857");
        (rn = $.current) == null || rn.setView(new View$1({
            zoom: Kt,
            center: qt
        }))
    }
    function vt(jt) {
        var rn;
        const Gt = new View$1({
            center: [(jt[0] + jt[2]) / 2, (jt[1] + jt[3]) / 2]
        });
        (rn = $.current) == null || rn.setView(Gt);
        const Kt = Gt.getResolutionForExtent(jt)
          , qt = Gt.getZoomForResolution(Kt);
        qt != null && Gt.setZoom(qt - 1)
    }
    function wt(jt) {
        if (jt.type == SegmentRequestType.BoundingBox)
            return;
        const Gt = new Feature$1({
            geometry: new Point$1(jt.coordinate)
        });
        st[DRAWING_LAYER_NAME].source.addFeature(Gt)
    }
    function Tt() {
        return st[DRAWING_LAYER_NAME].source.getFeatures().map(qt => qt.getGeometry().getType() == "Point" ? $t(qt) : Et(qt))
    }
    function $t(jt) {
        const Kt = jt.getGeometry().getCoordinates();
        return {
            type: SegmentRequestType.Point,
            coordinate: [Kt[0], Kt[1]]
        }
    }
    function Et(jt) {
        const Gt = jt.getGeometry().getExtent()
          , Kt = [Gt[0], Gt[1]]
          , qt = [Gt[2], Gt[3]];
        return {
            type: SegmentRequestType.BoundingBox,
            topLeft: Kt,
            bottomRight: qt
        }
    }
    function Pt() {
        st[DRAWING_LAYER_NAME].source.clear()
    }
    function Rt() {
        return captureMapCanvasWithoutFeatures($.current, st)
    }
    function At() {
        const jt = $.current.getSize();
        return [jt.at(0), jt.at(1)]
    }
    function Mt() {
        return $.current.getView().getProjection().getCode()
    }
    function Ut(jt) {
        switch (jt) {
        case SegmentRequestType.Point:
            dt.current.boundingBoxController.setActive(!1),
            dt.current.pointController.setActive(!0);
            break;
        case SegmentRequestType.BoundingBox:
            dt.current.boundingBoxController.setActive(!0),
            dt.current.pointController.setActive(!1);
            break
        }
    }
    function Lt(jt, Gt) {
        const qt = st[Gt].source.getFeatureById(jt);
        qt != null && qt.setStyle(getHighlightStyle(qt))
    }
    function tn(jt, Gt) {
        const qt = st[Gt].source.getFeatureById(jt);
        qt != null && qt.setStyle(getFeatureStyle(qt))
    }
    function Vt(jt, Gt) {
        const qt = st[Gt].source.getFeatureById(jt);
        if (qt == null)
            return;
        const on = qt.getGeometry().getExtent()
          , _n = getCenter(on);
        $.current.getView().animate({
            center: _n,
            duration: 300
        })
    }
    function Nt(jt) {
        var rn;
        const qt = new GeoJSON$1().readFeature(jt).clone();
        return (rn = qt.getGeometry()) == null || rn.transform(Mt(), "EPSG:4326"),
        toGeoJSONFeature(qt)
    }
    function Yt(jt) {
        ut.current = jt,
        ct()
    }
    function Xt(jt) {
        if ($.current == null)
            return;
        const Gt = structuredClone(jt).reverse();
        $.current.getLayers().clear(),
        lt.current = Gt.map(Kt => {
            var rn;
            const qt = toOpenLayersLayer(Kt);
            if (qt != null)
                return qt.setVisible(Kt.visible),
                (rn = $.current) == null || rn.addLayer(qt),
                {
                    name: Kt.name,
                    layer: qt
                }
        }
        ).filter(Kt => Kt != null),
        Object.keys(st).forEach(Kt => {
            var rn;
            const qt = st[Kt];
            (rn = $.current) == null || rn.addLayer(qt.layer)
        }
        )
    }
    return React.useImperativeHandle(a, () => ({
        pixelToCoordinate: ft,
        coordinateToPixel: ht,
        addPolygon: gt,
        addLine: _t,
        flyMapTo: bt,
        zoomToExtents: vt,
        getMapCanvas: Rt,
        getMapContainerWidthAndHeight: At,
        addFeatureLayer: pt,
        tryGetFeatureLayer: yt,
        deleteFeatureById: mt,
        addSegmentRequest: wt,
        getSegmentRequests: Tt,
        clearSegmentRequests: Pt,
        getProjection: Mt,
        setDrawingMode: Ut,
        highlightFeature: Lt,
        unhighlightFeature: tn,
        panToFeature: Vt,
        projectToLngLat: Nt,
        toggleDrawingDeletion: Yt,
        addMapTileLayers: Xt
    })),
    jsxRuntimeExports.jsx("div", {
        ref: _,
        style: o,
        className: `map ${ut.current ? "delete-cursor" : ""}`
    })
}
)
  , PolygonNodesIcon = ({width: o, height: i, fill: s}) => jsxRuntimeExports.jsx("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: o,
    height: i,
    fill: s,
    viewBox: "0 0 24 24",
    children: jsxRuntimeExports.jsx("path", {
        d: "M20 14.185v-2.369A2.997 2.997 0 0 0 22 9c0-1.654-1.346-3-3-3a2.99 2.99 0 0 0-2.116.876L12.969 5.31c.01-.103.031-.204.031-.31 0-1.654-1.346-3-3-3S7 3.346 7 5c0 .762.295 1.451.765 1.981L6.091 9.212A2.977 2.977 0 0 0 5 9c-1.654 0-3 1.346-3 3s1.346 3 3 3c.159 0 .313-.023.465-.047L7.4 17.532c-.248.436-.4.932-.4 1.468 0 1.654 1.346 3 3 3a2.994 2.994 0 0 0 2.863-2.153l3.962-.792A2.987 2.987 0 0 0 19 20c1.654 0 3-1.346 3-3a2.995 2.995 0 0 0-2-2.815zM19 8a1.001 1.001 0 1 1-1 1c0-.551.448-1 1-1zm-9-4a1.001 1.001 0 1 1-1 1c0-.551.448-1 1-1zm-6 8a1.001 1.001 0 1 1 1 1c-.552 0-1-.449-1-1zm6 8a1 1 0 1 1 0-2 1 1 0 0 1 0 2zm2.761-2.172A3.005 3.005 0 0 0 10 16c-.386 0-.752.079-1.091.213l-1.674-2.231C7.705 13.451 8 12.762 8 12c0-.536-.152-1.032-.399-1.467l1.935-2.58c.152.024.305.047.464.047a2.99 2.99 0 0 0 2.116-.876l3.915 1.566c-.01.103-.031.204-.031.31 0 1.302.839 2.401 2 2.815v2.369a2.996 2.996 0 0 0-2 2.815c0 .061.015.117.018.177l-3.257.652zM19 18a1 1 0 1 1 0-2 1 1 0 0 1 0 2z"
    })
});
var propTypes = {
    exports: {}
}
  , ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
  , ReactPropTypesSecret_1 = ReactPropTypesSecret$1
  , ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
    function o(a, _, $, _e, tt, nt) {
        if (nt !== ReactPropTypesSecret) {
            var rt = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
            throw rt.name = "Invariant Violation",
            rt
        }
    }
    o.isRequired = o;
    function i() {
        return o
    }
    var s = {
        array: o,
        bigint: o,
        bool: o,
        func: o,
        number: o,
        object: o,
        string: o,
        symbol: o,
        any: o,
        arrayOf: i,
        element: o,
        elementType: o,
        instanceOf: i,
        node: o,
        objectOf: i,
        oneOf: i,
        oneOfType: i,
        shape: i,
        exact: i,
        checkPropTypes: emptyFunctionWithReset,
        resetWarningCache: emptyFunction
    };
    return s.PropTypes = s,
    s
};
propTypes.exports = factoryWithThrowingShims();
var propTypesExports = propTypes.exports;
const PropTypes = getDefaultExportFromCjs(propTypesExports);
var defaultAttributes = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
}
  , __defProp$8 = Object.defineProperty
  , __defProps$3 = Object.defineProperties
  , __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$8 = Object.getOwnPropertySymbols
  , __hasOwnProp$8 = Object.prototype.hasOwnProperty
  , __propIsEnum$8 = Object.prototype.propertyIsEnumerable
  , __defNormalProp$8 = (o, i, s) => i in o ? __defProp$8(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$8 = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$8.call(i, s) && __defNormalProp$8(o, s, i[s]);
    if (__getOwnPropSymbols$8)
        for (var s of __getOwnPropSymbols$8(i))
            __propIsEnum$8.call(i, s) && __defNormalProp$8(o, s, i[s]);
    return o
}
  , __spreadProps$3 = (o, i) => __defProps$3(o, __getOwnPropDescs$3(i))
  , __objRest$2 = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$8.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$8)
        for (var a of __getOwnPropSymbols$8(o))
            i.indexOf(a) < 0 && __propIsEnum$8.call(o, a) && (s[a] = o[a]);
    return s
}
  , createReactComponent = (o, i, s) => {
    const a = reactExports.forwardRef( (_, $) => {
        var _e = _
          , {color: tt="currentColor", size: nt=24, stroke: rt=2, children: ot} = _e
          , et = __objRest$2(_e, ["color", "size", "stroke", "children"]);
        return reactExports.createElement("svg", __spreadValues$8(__spreadProps$3(__spreadValues$8({
            ref: $
        }, defaultAttributes), {
            width: nt,
            height: nt,
            stroke: tt,
            strokeWidth: rt,
            className: `tabler-icon tabler-icon-${o}`
        }), et), [...s.map( ([j,it]) => reactExports.createElement(j, it)), ...ot || []])
    }
    );
    return a.propTypes = {
        color: PropTypes.string,
        size: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
        stroke: PropTypes.oneOfType([PropTypes.string, PropTypes.number])
    },
    a.displayName = `${i}`,
    a
}
  , IconArrowRight = createReactComponent("arrow-right", "IconArrowRight", [["path", {
    d: "M5 12l14 0",
    key: "svg-0"
}], ["path", {
    d: "M13 18l6 -6",
    key: "svg-1"
}], ["path", {
    d: "M13 6l6 6",
    key: "svg-2"
}]])
  , IconGripVertical = createReactComponent("grip-vertical", "IconGripVertical", [["path", {
    d: "M9 5m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0",
    key: "svg-0"
}], ["path", {
    d: "M9 12m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0",
    key: "svg-1"
}], ["path", {
    d: "M9 19m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0",
    key: "svg-2"
}], ["path", {
    d: "M15 5m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0",
    key: "svg-3"
}], ["path", {
    d: "M15 12m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0",
    key: "svg-4"
}], ["path", {
    d: "M15 19m-1 0a1 1 0 1 0 2 0a1 1 0 1 0 -2 0",
    key: "svg-5"
}]])
  , IconSettings = createReactComponent("settings", "IconSettings", [["path", {
    d: "M10.325 4.317c.426 -1.756 2.924 -1.756 3.35 0a1.724 1.724 0 0 0 2.573 1.066c1.543 -.94 3.31 .826 2.37 2.37a1.724 1.724 0 0 0 1.065 2.572c1.756 .426 1.756 2.924 0 3.35a1.724 1.724 0 0 0 -1.066 2.573c.94 1.543 -.826 3.31 -2.37 2.37a1.724 1.724 0 0 0 -2.572 1.065c-.426 1.756 -2.924 1.756 -3.35 0a1.724 1.724 0 0 0 -2.573 -1.066c-1.543 .94 -3.31 -.826 -2.37 -2.37a1.724 1.724 0 0 0 -1.065 -2.572c-1.756 -.426 -1.756 -2.924 0 -3.35a1.724 1.724 0 0 0 1.066 -2.573c-.94 -1.543 .826 -3.31 2.37 -2.37c1 .608 2.296 .07 2.572 -1.065z",
    key: "svg-0"
}], ["path", {
    d: "M9 12a3 3 0 1 0 6 0a3 3 0 0 0 -6 0",
    key: "svg-1"
}]])
  , IconStack2 = createReactComponent("stack-2", "IconStack2", [["path", {
    d: "M12 4l-8 4l8 4l8 -4l-8 -4",
    key: "svg-0"
}], ["path", {
    d: "M4 12l8 4l8 -4",
    key: "svg-1"
}], ["path", {
    d: "M4 16l8 4l8 -4",
    key: "svg-2"
}]])
  , IconTrashFilled = createReactComponent("trash-filled", "IconTrashFilled", [["path", {
    d: "M20 6a1 1 0 0 1 .117 1.993l-.117 .007h-.081l-.919 11a3 3 0 0 1 -2.824 2.995l-.176 .005h-8c-1.598 0 -2.904 -1.249 -2.992 -2.75l-.005 -.167l-.923 -11.083h-.08a1 1 0 0 1 -.117 -1.993l.117 -.007h16z",
    fill: "currentColor",
    key: "svg-0",
    strokeWidth: "0"
}], ["path", {
    d: "M14 2a2 2 0 0 1 2 2a1 1 0 0 1 -1.993 .117l-.007 -.117h-4l-.007 .117a1 1 0 0 1 -1.993 -.117a2 2 0 0 1 1.85 -1.995l.15 -.005h4z",
    fill: "currentColor",
    key: "svg-1",
    strokeWidth: "0"
}]])
  , IconTrash = createReactComponent("trash", "IconTrash", [["path", {
    d: "M4 7l16 0",
    key: "svg-0"
}], ["path", {
    d: "M10 11l0 6",
    key: "svg-1"
}], ["path", {
    d: "M14 11l0 6",
    key: "svg-2"
}], ["path", {
    d: "M5 7l1 12a2 2 0 0 0 2 2h8a2 2 0 0 0 2 -2l1 -12",
    key: "svg-3"
}], ["path", {
    d: "M9 7v-3a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v3",
    key: "svg-4"
}]])
  , IconZoomInArea = createReactComponent("zoom-in-area", "IconZoomInArea", [["path", {
    d: "M15 13v4",
    key: "svg-0"
}], ["path", {
    d: "M13 15h4",
    key: "svg-1"
}], ["path", {
    d: "M15 15m-5 0a5 5 0 1 0 10 0a5 5 0 1 0 -10 0",
    key: "svg-2"
}], ["path", {
    d: "M22 22l-3 -3",
    key: "svg-3"
}], ["path", {
    d: "M6 18h-1a2 2 0 0 1 -2 -2v-1",
    key: "svg-4"
}], ["path", {
    d: "M3 11v-1",
    key: "svg-5"
}], ["path", {
    d: "M3 6v-1a2 2 0 0 1 2 -2h1",
    key: "svg-6"
}], ["path", {
    d: "M10 3h1",
    key: "svg-7"
}], ["path", {
    d: "M15 3h1a2 2 0 0 1 2 2v1",
    key: "svg-8"
}]]);
const FeaturesListItem = o => jsxRuntimeExports.jsx(Box, {
    py: 5,
    px: 20,
    sx: i => ({
        backgroundColor: i.colorScheme === "dark" ? i.colors.dark[6] : i.colors.gray[0],
        textAlign: "start",
        padding: i.spacing.xl,
        borderRadius: i.radius.md,
        cursor: "pointer",
        "&:hover": {
            backgroundColor: i.colorScheme === "dark" ? i.colors.dark[5] : i.colors.gray[1]
        }
    }),
    onMouseEnter: () => o.onMouseEnter(o.feature),
    onMouseLeave: () => o.onMouseLeave(o.feature),
    onClick: () => o.onClick(o.feature),
    children: jsxRuntimeExports.jsxs(Group, {
        position: "apart",
        noWrap: !0,
        children: [jsxRuntimeExports.jsx(Text$2, {
            sx: {
                textOverflow: "ellipsis",
                overflow: "hidden"
            },
            children: o.feature.id ?? ""
        }), jsxRuntimeExports.jsx(ActionIcon, {
            onClick: () => o.onDeleteFeature(o.feature),
            children: jsxRuntimeExports.jsx(IconTrash, {
                color: "red",
                size: "1.125rem"
            })
        })]
    })
})
  , FeatureToolbar = o => {
    const [i,s] = reactExports.useState(!0)
      , [a,_] = reactExports.useState(!1);
    return jsxRuntimeExports.jsx(Paper, {
        h: "100%",
        w: 300,
        shadow: "md",
        sx: () => ({
            position: "absolute",
            display: "flex",
            alignItems: "start",
            justifyContent: "center",
            borderRadius: "0.1rem",
            top: "0",
            right: "0"
        }),
        children: jsxRuntimeExports.jsxs(Flex, {
            h: "100%",
            w: "100%",
            gap: "md",
            justify: "flex-start",
            align: "stretch",
            wrap: "nowrap",
            direction: "column",
            px: 20,
            py: 5,
            children: [jsxRuntimeExports.jsxs(Stack, {
                w: "100%",
                mah: "20%",
                spacing: "sm",
                children: [jsxRuntimeExports.jsx(Box, {
                    mah: 80,
                    sx: $ => ({
                        overflow: "hidden",
                        height: "auto",
                        color: $.colors.teal[7],
                        display: "flex",
                        flexDirection: "column",
                        justifyContent: "center",
                        margin: "auto"
                    }),
                    children: jsxRuntimeExports.jsx(PolygonNodesIcon, {
                        fill: "currentColor",
                        width: "100%",
                        height: "100%"
                    })
                }), jsxRuntimeExports.jsxs(Stack, {
                    spacing: 0,
                    children: [jsxRuntimeExports.jsx(Title, {
                        order: 3,
                        align: "center",
                        color: "cyan.7",
                        children: "GeoSegment Demo"
                    }), jsxRuntimeExports.jsx(Title, {
                        order: 6,
                        align: "center",
                        color: "cyan.7",
                        children: "AI Powered"
                    }), jsxRuntimeExports.jsx(Divider, {
                        my: "xl"
                    })]
                })]
            }), jsxRuntimeExports.jsxs(Stack, {
                mah: "30%",
                spacing: "sm",
                children: [jsxRuntimeExports.jsx(ScrollArea, {
                    children: jsxRuntimeExports.jsxs(Stack, {
                        children: [jsxRuntimeExports.jsx(Input.Wrapper, {
                            id: "segmenting-using-control",
                            label: "Segment Using",
                            children: jsxRuntimeExports.jsx(SegmentedControl, {
                                id: "segmenting-using-control",
                                title: "Segment Using",
                                fullWidth: !0,
                                orientation: "vertical",
                                styles: {
                                    control: {
                                        zIndex: 0
                                    },
                                    indicator: {
                                        zIndex: 0
                                    }
                                },
                                data: [{
                                    label: "Point",
                                    value: SegmentRequestType.Point.toString()
                                }, {
                                    label: "Box",
                                    value: SegmentRequestType.BoundingBox.toString()
                                }],
                                onChange: $ => {
                                    $ && o.onSegmentModeChange(parseInt($))
                                }
                            })
                        }), jsxRuntimeExports.jsx(Select, {
                            label: "Segment Into",
                            data: [{
                                label: "Polygon",
                                value: geoJSONFeatureType.Polygon
                            }, {
                                label: "LineString",
                                value: geoJSONFeatureType.LineString
                            }],
                            onChange: $ => $ && o.onSegmentTypeChange($),
                            defaultValue: geoJSONFeatureType.Polygon
                        }), jsxRuntimeExports.jsxs(Button.Group, {
                            orientation: "vertical",
                            children: [jsxRuntimeExports.jsx(Button, {
                                onClick: () => _($ => (o.onToggleDeleteMode(!$),
                                !$)),
                                variant: a ? "filled" : "default",
                                fw: "normal",
                                children: "Delete Points / Boxes..."
                            }), jsxRuntimeExports.jsx(Button, {
                                onClick: o.onClear,
                                variant: "default",
                                fw: "normal",
                                children: "Delete All Points / Boxes"
                            })]
                        })]
                    })
                }), jsxRuntimeExports.jsxs(Popover, {
                    withinPortal: !0,
                    width: 200,
                    position: "left",
                    withArrow: !0,
                    shadow: "md",
                    opened: i,
                    zIndex: 1,
                    children: [jsxRuntimeExports.jsx(Popover.Target, {
                        children: jsxRuntimeExports.jsx(Button, {
                            onClick: () => {
                                o.onDone(),
                                s(!1)
                            }
                            ,
                            variant: "gradient",
                            gradient: {
                                from: "#0ca678",
                                to: "green",
                                deg: 100
                            },
                            children: "Generate Segment Features"
                        })
                    }), jsxRuntimeExports.jsxs(Popover.Dropdown, {
                        children: [jsxRuntimeExports.jsx(Text$2, {
                            size: "sm",
                            children: "Click on the map to add markers, then click me to convert them into segmented features! (lots of features can take a few seconds to generate)."
                        }), jsxRuntimeExports.jsx(Text$2, {
                            fw: 700,
                            mt: 5,
                            children: "Generating segments snapshots the current viewable map. So make sure the tiles, and your segment points/boxes, are in view!"
                        }), jsxRuntimeExports.jsx(Text$2, {
                            mt: 5,
                            children: "This example uses the free Google Maps aerial mapping as a base layer. But you can add your own custom mapping via the 'Layers' button."
                        })]
                    })]
                }), jsxRuntimeExports.jsx(Divider, {
                    my: 0
                })]
            }), jsxRuntimeExports.jsxs(Stack, {
                sx: () => ({
                    flexGrow: 1,
                    display: "flex",
                    flexDirection: "column",
                    gap: "sm",
                    overflow: "hidden"
                }),
                children: [jsxRuntimeExports.jsx(Text$2, {
                    span: !0,
                    fw: 525,
                    children: "Segmented Feature List"
                }), jsxRuntimeExports.jsx(ScrollArea, {
                    sx: () => ({
                        flexGrow: 1
                    }),
                    children: jsxRuntimeExports.jsx(Stack, {
                        spacing: "xs",
                        sx: () => ({
                            flexGrow: 1
                        }),
                        children: o.features.map( ($, _e) => jsxRuntimeExports.jsx(FeaturesListItem, {
                            onMouseEnter: o.onHoverEnterOverFeature,
                            onMouseLeave: o.onHoverLeaveOverFeature,
                            feature: $,
                            onDeleteFeature: o.onDeleteFeature,
                            onClick: o.onFeatureClick
                        }, `${$.id ?? ""}-${_e}`))
                    })
                }), jsxRuntimeExports.jsx(Divider, {})]
            }), jsxRuntimeExports.jsxs(Stack, {
                spacing: "xs",
                children: [jsxRuntimeExports.jsx(Text$2, {
                    span: !0,
                    fw: 525,
                    children: "Export Options"
                }), jsxRuntimeExports.jsx(Button, {
                    onClick: o.onExportAsGeoJSON,
                    children: "Save as GeoJSON"
                }), jsxRuntimeExports.jsx(Divider, {
                    my: "0"
                })]
            }), jsxRuntimeExports.jsx(Stack, {
                my: 10,
                children: jsxRuntimeExports.jsx(Button, {
                    onClick: o.onLogout,
                    variant: "outline",
                    children: "Log Out"
                })
            })]
        })
    })
}
;
var fastDeepEqual = function o(i, s) {
    if (i === s)
        return !0;
    if (i && s && typeof i == "object" && typeof s == "object") {
        if (i.constructor !== s.constructor)
            return !1;
        var a, _, $;
        if (Array.isArray(i)) {
            if (a = i.length,
            a != s.length)
                return !1;
            for (_ = a; _-- !== 0; )
                if (!o(i[_], s[_]))
                    return !1;
            return !0
        }
        if (i.constructor === RegExp)
            return i.source === s.source && i.flags === s.flags;
        if (i.valueOf !== Object.prototype.valueOf)
            return i.valueOf() === s.valueOf();
        if (i.toString !== Object.prototype.toString)
            return i.toString() === s.toString();
        if ($ = Object.keys(i),
        a = $.length,
        a !== Object.keys(s).length)
            return !1;
        for (_ = a; _-- !== 0; )
            if (!Object.prototype.hasOwnProperty.call(s, $[_]))
                return !1;
        for (_ = a; _-- !== 0; ) {
            var _e = $[_];
            if (!o(i[_e], s[_e]))
                return !1
        }
        return !0
    }
    return i !== i && s !== s
};
const isEqual = getDefaultExportFromCjs(fastDeepEqual);
function filterErrors(o) {
    return o === null || typeof o != "object" ? {} : Object.keys(o).reduce( (i, s) => {
        const a = o[s];
        return a != null && a !== !1 && (i[s] = a),
        i
    }
    , {})
}
var __defProp$7 = Object.defineProperty
  , __getOwnPropSymbols$7 = Object.getOwnPropertySymbols
  , __hasOwnProp$7 = Object.prototype.hasOwnProperty
  , __propIsEnum$7 = Object.prototype.propertyIsEnumerable
  , __defNormalProp$7 = (o, i, s) => i in o ? __defProp$7(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$7 = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$7.call(i, s) && __defNormalProp$7(o, s, i[s]);
    if (__getOwnPropSymbols$7)
        for (var s of __getOwnPropSymbols$7(i))
            __propIsEnum$7.call(i, s) && __defNormalProp$7(o, s, i[s]);
    return o
}
;
function clearListState(o, i) {
    if (i === null || typeof i != "object")
        return {};
    const s = __spreadValues$7({}, i);
    return Object.keys(i).forEach(a => {
        a.includes(`${String(o)}.`) && delete s[a]
    }
    ),
    s
}
const FORM_INDEX = "__MANTINE_FORM_INDEX__";
function shouldValidateOnChange(o, i) {
    return i ? typeof i == "boolean" ? i : Array.isArray(i) ? i.includes(o.replace(/[.][0-9]/g, `.${FORM_INDEX}`)) : !1 : !1
}
function set(o, i, s) {
    typeof s.value == "object" && (s.value = klona(s.value)),
    !s.enumerable || s.get || s.set || !s.configurable || !s.writable || i === "__proto__" ? Object.defineProperty(o, i, s) : o[i] = s.value
}
function klona(o) {
    if (typeof o != "object")
        return o;
    var i = 0, s, a, _, $ = Object.prototype.toString.call(o);
    if ($ === "[object Object]" ? _ = Object.create(o.__proto__ || null) : $ === "[object Array]" ? _ = Array(o.length) : $ === "[object Set]" ? (_ = new Set,
    o.forEach(function(_e) {
        _.add(klona(_e))
    })) : $ === "[object Map]" ? (_ = new Map,
    o.forEach(function(_e, tt) {
        _.set(klona(tt), klona(_e))
    })) : $ === "[object Date]" ? _ = new Date(+o) : $ === "[object RegExp]" ? _ = new RegExp(o.source,o.flags) : $ === "[object DataView]" ? _ = new o.constructor(klona(o.buffer)) : $ === "[object ArrayBuffer]" ? _ = o.slice(0) : $.slice(-6) === "Array]" && (_ = new o.constructor(o)),
    _) {
        for (a = Object.getOwnPropertySymbols(o); i < a.length; i++)
            set(_, a[i], Object.getOwnPropertyDescriptor(o, a[i]));
        for (i = 0,
        a = Object.getOwnPropertyNames(o); i < a.length; i++)
            Object.hasOwnProperty.call(_, s = a[i]) && _[s] === o[s] || set(_, s, Object.getOwnPropertyDescriptor(o, s))
    }
    return _ || o
}
function getSplittedPath(o) {
    return typeof o != "string" ? [] : o.split(".")
}
function setPath(o, i, s) {
    const a = getSplittedPath(o);
    if (a.length === 0)
        return s;
    const _ = klona(s);
    if (a.length === 1)
        return _[a[0]] = i,
        _;
    let $ = _[a[0]];
    for (let _e = 1; _e < a.length - 1; _e += 1) {
        if ($ === void 0)
            return _;
        $ = $[a[_e]]
    }
    return $[a[a.length - 1]] = i,
    _
}
function getPath(o, i) {
    const s = getSplittedPath(o);
    if (s.length === 0 || typeof i != "object" || i === null)
        return;
    let a = i[s[0]];
    for (let _ = 1; _ < s.length && a !== void 0; _ += 1)
        a = a[s[_]];
    return a
}
function getValidationResults(o) {
    const i = filterErrors(o);
    return {
        hasErrors: Object.keys(i).length > 0,
        errors: i
    }
}
function validateRulesRecord(o, i, s="", a={}) {
    return typeof o != "object" || o === null ? a : Object.keys(o).reduce( (_, $) => {
        const _e = o[$]
          , tt = `${s === "" ? "" : `${s}.`}${$}`
          , nt = getPath(tt, i);
        let rt = !1;
        return typeof _e == "function" && (_[tt] = _e(nt, i, tt)),
        typeof _e == "object" && Array.isArray(nt) && (rt = !0,
        nt.forEach( (ot, et) => validateRulesRecord(_e, i, `${tt}.${et}`, _))),
        typeof _e == "object" && typeof nt == "object" && nt !== null && (rt || validateRulesRecord(_e, i, tt, _)),
        _
    }
    , a)
}
function validateValues(o, i) {
    return getValidationResults(typeof o == "function" ? o(i) : validateRulesRecord(o, i))
}
function validateFieldValue(o, i, s) {
    if (typeof o != "string")
        return {
            hasError: !1,
            error: null
        };
    const a = validateValues(i, s)
      , _ = Object.keys(a.errors).find($ => o.split(".").every( (_e, tt) => _e === $.split(".")[tt]));
    return {
        hasError: !!_,
        error: _ ? a.errors[_] : null
    }
}
function reorderPath(o, {from: i, to: s}, a) {
    const _ = getPath(o, a);
    if (!Array.isArray(_))
        return a;
    const $ = [..._]
      , _e = _[i];
    return $.splice(i, 1),
    $.splice(s, 0, _e),
    setPath(o, $, a)
}
var __defProp$6 = Object.defineProperty
  , __getOwnPropSymbols$6 = Object.getOwnPropertySymbols
  , __hasOwnProp$6 = Object.prototype.hasOwnProperty
  , __propIsEnum$6 = Object.prototype.propertyIsEnumerable
  , __defNormalProp$6 = (o, i, s) => i in o ? __defProp$6(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$6 = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$6.call(i, s) && __defNormalProp$6(o, s, i[s]);
    if (__getOwnPropSymbols$6)
        for (var s of __getOwnPropSymbols$6(i))
            __propIsEnum$6.call(i, s) && __defNormalProp$6(o, s, i[s]);
    return o
}
;
function reorderErrors(o, {from: i, to: s}, a) {
    const _ = `${o}.${i}`
      , $ = `${o}.${s}`
      , _e = __spreadValues$6({}, a);
    return Object.keys(a).every(tt => {
        let nt, rt;
        if (tt.startsWith(_) && (nt = tt,
        rt = tt.replace(_, $)),
        tt.startsWith($) && (nt = tt.replace($, _),
        rt = tt),
        nt && rt) {
            const ot = _e[nt]
              , et = _e[rt];
            return et === void 0 ? delete _e[nt] : _e[nt] = et,
            ot === void 0 ? delete _e[rt] : _e[rt] = ot,
            !1
        }
        return !0
    }
    ),
    _e
}
function removePath(o, i, s) {
    const a = getPath(o, s);
    return Array.isArray(a) ? setPath(o, a.filter( (_, $) => $ !== i), s) : s
}
var __defProp$5 = Object.defineProperty
  , __getOwnPropSymbols$5 = Object.getOwnPropertySymbols
  , __hasOwnProp$5 = Object.prototype.hasOwnProperty
  , __propIsEnum$5 = Object.prototype.propertyIsEnumerable
  , __defNormalProp$5 = (o, i, s) => i in o ? __defProp$5(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$5 = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$5.call(i, s) && __defNormalProp$5(o, s, i[s]);
    if (__getOwnPropSymbols$5)
        for (var s of __getOwnPropSymbols$5(i))
            __propIsEnum$5.call(i, s) && __defNormalProp$5(o, s, i[s]);
    return o
}
;
function getIndexFromKeyAfterPath(o, i) {
    const s = o.substring(i.length + 1).split(".")[0];
    return parseInt(s, 10)
}
function changeErrorIndices(o, i, s, a) {
    if (i === void 0)
        return s;
    const _ = `${String(o)}`;
    let $ = s;
    a === -1 && ($ = clearListState(`${_}.${i}`, $));
    const _e = __spreadValues$5({}, $)
      , tt = new Set;
    return Object.entries($).filter( ([nt]) => {
        if (!nt.startsWith(`${_}.`))
            return !1;
        const rt = getIndexFromKeyAfterPath(nt, _);
        return Number.isNaN(rt) ? !1 : rt >= i
    }
    ).forEach( ([nt,rt]) => {
        const ot = getIndexFromKeyAfterPath(nt, _)
          , et = nt.replace(`${_}.${ot}`, `${_}.${ot + a}`);
        _e[et] = rt,
        tt.add(et),
        tt.has(nt) || delete _e[nt]
    }
    ),
    _e
}
function insertPath(o, i, s, a) {
    const _ = getPath(o, a);
    if (!Array.isArray(_))
        return a;
    const $ = [..._];
    return $.splice(typeof s == "number" ? s : $.length, 0, i),
    setPath(o, $, a)
}
function getStatus(o, i) {
    const s = Object.keys(o);
    if (typeof i == "string") {
        const a = s.filter(_ => _.startsWith(`${i}.`));
        return o[i] || a.some(_ => o[_]) || !1
    }
    return s.some(a => o[a])
}
function getInputOnChange(o) {
    return i => {
        if (!i)
            o(i);
        else if (typeof i == "function")
            o(i);
        else if (typeof i == "object" && "nativeEvent"in i) {
            const {currentTarget: s} = i;
            s instanceof HTMLInputElement ? s.type === "checkbox" ? o(s.checked) : o(s.value) : (s instanceof HTMLTextAreaElement || s instanceof HTMLSelectElement) && o(s.value)
        } else
            o(i)
    }
}
var __defProp$4 = Object.defineProperty
  , __defProps$2 = Object.defineProperties
  , __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$4 = Object.getOwnPropertySymbols
  , __hasOwnProp$4 = Object.prototype.hasOwnProperty
  , __propIsEnum$4 = Object.prototype.propertyIsEnumerable
  , __defNormalProp$4 = (o, i, s) => i in o ? __defProp$4(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$4 = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$4.call(i, s) && __defNormalProp$4(o, s, i[s]);
    if (__getOwnPropSymbols$4)
        for (var s of __getOwnPropSymbols$4(i))
            __propIsEnum$4.call(i, s) && __defNormalProp$4(o, s, i[s]);
    return o
}
  , __spreadProps$2 = (o, i) => __defProps$2(o, __getOwnPropDescs$2(i));
function useForm({initialValues: o={}, initialErrors: i={}, initialDirty: s={}, initialTouched: a={}, clearInputErrorOnChange: _=!0, validateInputOnChange: $=!1, validateInputOnBlur: _e=!1, transformValues: tt=rt => rt, validate: nt}={}) {
    const [rt,ot] = reactExports.useState(a)
      , [et,j] = reactExports.useState(s)
      , [it,st] = reactExports.useState(o)
      , [at,lt] = reactExports.useState(filterErrors(i))
      , ct = reactExports.useRef(o)
      , ut = Nt => {
        ct.current = Nt
    }
      , dt = reactExports.useCallback( () => ot({}), [])
      , ft = Nt => {
        const Yt = Nt ? __spreadValues$4(__spreadValues$4({}, it), Nt) : it;
        ut(Yt),
        j({})
    }
      , ht = reactExports.useCallback(Nt => lt(Yt => filterErrors(typeof Nt == "function" ? Nt(Yt) : Nt)), [])
      , pt = reactExports.useCallback( () => lt({}), [])
      , gt = reactExports.useCallback( () => {
        st(o),
        pt(),
        ut(o),
        j({}),
        dt()
    }
    , [])
      , _t = reactExports.useCallback( (Nt, Yt) => ht(Xt => __spreadProps$2(__spreadValues$4({}, Xt), {
        [Nt]: Yt
    })), [])
      , mt = reactExports.useCallback(Nt => ht(Yt => {
        if (typeof Nt != "string")
            return Yt;
        const Xt = __spreadValues$4({}, Yt);
        return delete Xt[Nt],
        Xt
    }
    ), [])
      , yt = reactExports.useCallback(Nt => j(Yt => {
        if (typeof Nt != "string")
            return Yt;
        const Xt = clearListState(Nt, Yt);
        return delete Xt[Nt],
        Xt
    }
    ), [])
      , bt = reactExports.useCallback( (Nt, Yt) => {
        const Xt = shouldValidateOnChange(Nt, $);
        yt(Nt),
        ot(jt => __spreadProps$2(__spreadValues$4({}, jt), {
            [Nt]: !0
        })),
        st(jt => {
            const Gt = setPath(Nt, Yt, jt);
            if (Xt) {
                const Kt = validateFieldValue(Nt, nt, Gt);
                Kt.hasError ? _t(Nt, Kt.error) : mt(Nt)
            }
            return Gt
        }
        ),
        !Xt && _ && _t(Nt, null)
    }
    , [])
      , vt = reactExports.useCallback(Nt => {
        st(Yt => {
            const Xt = typeof Nt == "function" ? Nt(Yt) : Nt;
            return __spreadValues$4(__spreadValues$4({}, Yt), Xt)
        }
        ),
        _ && pt()
    }
    , [])
      , wt = reactExports.useCallback( (Nt, Yt) => {
        yt(Nt),
        st(Xt => reorderPath(Nt, Yt, Xt)),
        lt(Xt => reorderErrors(Nt, Yt, Xt))
    }
    , [])
      , Tt = reactExports.useCallback( (Nt, Yt) => {
        yt(Nt),
        st(Xt => removePath(Nt, Yt, Xt)),
        lt(Xt => changeErrorIndices(Nt, Yt, Xt, -1))
    }
    , [])
      , $t = reactExports.useCallback( (Nt, Yt, Xt) => {
        yt(Nt),
        st(jt => insertPath(Nt, Yt, Xt, jt)),
        lt(jt => changeErrorIndices(Nt, Xt, jt, 1))
    }
    , [])
      , Et = reactExports.useCallback( () => {
        const Nt = validateValues(nt, it);
        return lt(Nt.errors),
        Nt
    }
    , [it, nt])
      , Pt = reactExports.useCallback(Nt => {
        const Yt = validateFieldValue(Nt, nt, it);
        return Yt.hasError ? _t(Nt, Yt.error) : mt(Nt),
        Yt
    }
    , [it, nt])
      , Rt = (Nt, {type: Yt="input", withError: Xt=!0, withFocus: jt=!0}={}) => {
        const Kt = {
            onChange: getInputOnChange(qt => bt(Nt, qt))
        };
        return Xt && (Kt.error = at[Nt]),
        Yt === "checkbox" ? Kt.checked = getPath(Nt, it) : Kt.value = getPath(Nt, it),
        jt && (Kt.onFocus = () => ot(qt => __spreadProps$2(__spreadValues$4({}, qt), {
            [Nt]: !0
        })),
        Kt.onBlur = () => {
            if (shouldValidateOnChange(Nt, _e)) {
                const qt = validateFieldValue(Nt, nt, it);
                qt.hasError ? _t(Nt, qt.error) : mt(Nt)
            }
        }
        ),
        Kt
    }
      , At = (Nt, Yt) => Xt => {
        Xt == null || Xt.preventDefault();
        const jt = Et();
        jt.hasErrors ? Yt == null || Yt(jt.errors, it, Xt) : Nt == null || Nt(tt(it), Xt)
    }
      , Mt = Nt => tt(Nt || it)
      , Ut = reactExports.useCallback(Nt => {
        Nt.preventDefault(),
        gt()
    }
    , [])
      , Lt = Nt => {
        if (Nt) {
            const Xt = getPath(Nt, et);
            if (typeof Xt == "boolean")
                return Xt;
            const jt = getPath(Nt, it)
              , Gt = getPath(Nt, ct.current);
            return !isEqual(jt, Gt)
        }
        return Object.keys(et).length > 0 ? getStatus(et) : !isEqual(it, ct.current)
    }
      , tn = reactExports.useCallback(Nt => getStatus(rt, Nt), [rt])
      , Vt = reactExports.useCallback(Nt => Nt ? !validateFieldValue(Nt, nt, it).hasError : !validateValues(nt, it).hasErrors, [it, nt]);
    return {
        values: it,
        errors: at,
        setValues: vt,
        setErrors: ht,
        setFieldValue: bt,
        setFieldError: _t,
        clearFieldError: mt,
        clearErrors: pt,
        reset: gt,
        validate: Et,
        validateField: Pt,
        reorderListItem: wt,
        removeListItem: Tt,
        insertListItem: $t,
        getInputProps: Rt,
        onSubmit: At,
        onReset: Ut,
        isDirty: Lt,
        isTouched: tn,
        setTouched: ot,
        setDirty: j,
        resetTouched: dt,
        resetDirty: ft,
        isValid: Vt,
        getTransformedValues: Mt
    }
}
function parseTileMapXml(o, i) {
    const a = new DOMParser().parseFromString(o, "text/xml")
      , _ = a.querySelector("Title")
      , $ = a.querySelector("BoundingBox")
      , _e = a.querySelectorAll("TileSets TileSet")
      , tt = a.querySelector("TileFormat");
    if (!_ || !$ || _e.length === 0)
        throw new Error("Invalid XML structure");
    const nt = _.textContent || "";
    let rt;
    if ($) {
        const at = parseFloat($.getAttribute("minx") || "0")
          , lt = parseFloat($.getAttribute("miny") || "0")
          , ct = parseFloat($.getAttribute("maxx") || "0")
          , ut = parseFloat($.getAttribute("maxy") || "0");
        at !== 0 && lt !== 0 && ct !== 0 && ut !== 0 && (rt = transformExtent([at, lt, ct, ut], "EPSG:4326", "EPSG:3857"))
    }
    const ot = tt ? [parseInt(tt.getAttribute("width") || "0", 10), parseInt(tt.getAttribute("height") || "0", 10)] : void 0
      , et = parseInt(_e[0].getAttribute("order") || "0", 10)
      , j = parseInt(_e[_e.length - 1].getAttribute("order") || "0", 10)
      , it = i.split("/");
    it[it.length - 1] = "{z}/{x}/{-y}.png";
    const st = it.join("/");
    return {
        name: nt,
        extents: rt,
        type: "zxy",
        url: st,
        tileSize: ot,
        minZoom: et,
        maxZoom: j,
        visible: !0
    }
}
async function extractCOGInfo(o) {
    const a = (await (await fromUrl(o)).getImage()).getBoundingBox()
      , _ = o.split("/")
      , $ = _[_.length - 1]
      , _e = $.lastIndexOf(".");
    return {
        name: _e === -1 ? $ : $.substring(0, _e),
        extents: a,
        type: "cog",
        url: o,
        visible: !0
    }
}
const ZXYLayerForm = ({layer: o, edittedLayer: i}) => {
    const s = structuredClone(o)
      , [a,_] = reactExports.useState(void 0);
    function $(j) {
        return {
            name: j.name,
            url: j.url,
            extents: j.extents == null ? [void 0, void 0, void 0, void 0] : j.extents,
            tileSize: j.tileSize == null ? [void 0, void 0] : j.tileSize,
            minZoom: j.minZoom,
            maxZoom: j.maxZoom
        }
    }
    const _e = useForm({
        initialValues: $(s),
        validate: {
            name: j => j.trim().length > 0 ? null : "Name is required",
            url: j => j.trim().length > 0 ? null : "URL is required",
            extents: j => tt(j) || nt(j) ? null : "You must fill all extent values (minX, minY, maxX, maxY) with numbers",
            tileSize: j => tt(j) || nt(j) ? null : "You must fill all tile size values (width, height) with numbers",
            minZoom: j => j == null || !isNaN(j) ? null : "Min Zoom must be a number",
            maxZoom: j => j == null || !isNaN(j) ? null : "Max Zoom must be a number"
        }
    });
    function tt(j) {
        return j.every(it => it != null && !isNaN(it))
    }
    function nt(j) {
        return j.every(it => it == null)
    }
    function rt() {
        const j = tt(_e.values.extents) ? _e.values.extents : void 0
          , it = tt(_e.values.tileSize) ? _e.values.tileSize : void 0;
        return {
            ..._e.values,
            type: "zxy",
            extents: j,
            tileSize: it,
            visible: s.visible
        }
    }
    function ot(j, it) {
        it == null || it == "" ? _e.getInputProps(j).onChange(void 0) : _e.getInputProps(j).onChange(it)
    }
    async function et(j) {
        const it = await fetch(j);
        if (!it.ok)
            throw new Error(`Failed to fetch XML: ${it.statusText}`);
        const st = await it.text()
          , at = parseTileMapXml(st, j);
        _e.setValues($(at))
    }
    return jsxRuntimeExports.jsxs(Stack, {
        spacing: "xl",
        children: [jsxRuntimeExports.jsx(TextInput, {
            size: "md",
            onChange: j => _(j.currentTarget.value),
            rightSection: jsxRuntimeExports.jsx(ActionIcon, {
                size: 32,
                variant: "filled",
                color: "primary",
                onClick: () => {
                    a != null && et(a).catch(j => {
                        console.log(j)
                    }
                    )
                }
                ,
                children: jsxRuntimeExports.jsx(IconArrowRight, {
                    size: "1.1rem",
                    stroke: 1.5
                })
            }),
            label: "Import from tilemapresource.xml...",
            placeholder: "https://example/public/golf-course-geotiff-tiles/tiles/tilemapresource.xml",
            rightSectionWidth: 42
        }), jsxRuntimeExports.jsxs("form", {
            onSubmit: _e.onSubmit( () => {
                const j = rt();
                i(j)
            }
            ),
            children: [jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [jsxRuntimeExports.jsx(TextInput, {
                    styles: () => ({
                        label: {
                            fontWeight: "bold"
                        }
                    }),
                    withAsterisk: !0,
                    label: "Layer Name",
                    ..._e.getInputProps("name")
                }), jsxRuntimeExports.jsx(TextInput, {
                    styles: () => ({
                        label: {
                            fontWeight: "bold"
                        }
                    }),
                    withAsterisk: !0,
                    label: "URL Template",
                    placeholder: "https://url/to/tiles/{z}/{x}/{-y}.png",
                    error: _e.errors.url && "URL is required",
                    ..._e.getInputProps("url")
                }), jsxRuntimeExports.jsxs(Input.Wrapper, {
                    label: "Layer Extents",
                    styles: () => ({
                        label: {
                            fontWeight: "bold"
                        }
                    }),
                    error: _e.getInputProps("extents").error,
                    children: [jsxRuntimeExports.jsx(NumberInput, {
                        label: "Min X",
                        sx: {
                            flex: 1
                        },
                        ..._e.getInputProps("extents.0"),
                        onChange: j => {
                            ot("extents.0", j)
                        }
                    }), jsxRuntimeExports.jsx(NumberInput, {
                        label: "Min Y",
                        sx: {
                            flex: 1
                        },
                        ..._e.getInputProps("extents.1"),
                        onChange: j => {
                            ot("extents.1", j)
                        }
                    }), jsxRuntimeExports.jsx(NumberInput, {
                        label: "Max X",
                        sx: {
                            flex: 1
                        },
                        ..._e.getInputProps("extents.2"),
                        onChange: j => {
                            ot("extents.2", j)
                        }
                    }), jsxRuntimeExports.jsx(NumberInput, {
                        label: "Max Y",
                        sx: {
                            flex: 1
                        },
                        ..._e.getInputProps("extents.3"),
                        onChange: j => {
                            ot("extents.3", j)
                        }
                    })]
                }), jsxRuntimeExports.jsxs(Input.Wrapper, {
                    label: "Tile Size",
                    styles: () => ({
                        label: {
                            fontWeight: "bold"
                        }
                    }),
                    error: _e.getInputProps("tileSize").error,
                    children: [jsxRuntimeExports.jsx(NumberInput, {
                        label: "Tile Width (px)",
                        sx: {
                            flex: 1
                        },
                        ..._e.getInputProps("tileSize.0"),
                        onChange: j => {
                            ot("tileSize.0", j)
                        }
                    }), jsxRuntimeExports.jsx(NumberInput, {
                        label: "Tile height (px)",
                        sx: {
                            flex: 1
                        },
                        ..._e.getInputProps("tileSize.1"),
                        onChange: j => {
                            ot("tileSize.1", j)
                        }
                    })]
                }), jsxRuntimeExports.jsxs(Input.Wrapper, {
                    label: "Zoom Settings",
                    styles: () => ({
                        label: {
                            fontWeight: "bold"
                        }
                    }),
                    children: [jsxRuntimeExports.jsx(NumberInput, {
                        label: "Min Zoom",
                        sx: {
                            flex: 1
                        },
                        ..._e.getInputProps("minZoom"),
                        onChange: j => {
                            ot("minZoom", j)
                        }
                    }), jsxRuntimeExports.jsx(NumberInput, {
                        label: "max Zoom",
                        sx: {
                            flex: 1
                        },
                        ..._e.getInputProps("maxZoom"),
                        onChange: j => {
                            ot("maxZoom", j)
                        }
                    })]
                })]
            }), jsxRuntimeExports.jsx(Group, {
                position: "right",
                mt: "md",
                children: jsxRuntimeExports.jsx(Button, {
                    type: "submit",
                    children: "Save"
                })
            })]
        })]
    })
}
  , TiledWMSLayerForm = ({layer: o, edittedLayer: i}) => {
    const s = structuredClone(o);
    function a(rt) {
        return {
            name: rt.name,
            url: rt.url,
            wmsLayer: rt.wmsLayer,
            extents: rt.extents == null ? [void 0, void 0, void 0, void 0] : rt.extents
        }
    }
    const _ = useForm({
        initialValues: a(s),
        validate: {
            name: rt => rt.trim().length > 0 ? null : "Name is required",
            url: rt => rt.trim().length > 0 ? null : "URL is required",
            extents: rt => $(rt) || _e(rt) ? null : "You must fill all extent values (minX, minY, maxX, maxY) with numbers",
            wmsLayer: rt => rt.trim().length > 0 ? null : "WMS Layer is required"
        }
    });
    function $(rt) {
        return rt.every(ot => ot != null && !isNaN(ot))
    }
    function _e(rt) {
        return rt.every(ot => ot == null)
    }
    function tt() {
        const rt = $(_.values.extents) ? _.values.extents : void 0;
        return {
            name: _.values.name,
            url: _.values.url,
            type: "tiled wms",
            wmsLayer: _.values.wmsLayer,
            extents: rt,
            visible: !0
        }
    }
    function nt(rt, ot) {
        ot == null || ot == "" ? _.getInputProps(rt).onChange(void 0) : _.getInputProps(rt).onChange(ot)
    }
    return jsxRuntimeExports.jsxs("form", {
        onSubmit: _.onSubmit( () => {
            i(tt())
        }
        ),
        children: [jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [jsxRuntimeExports.jsx(TextInput, {
                styles: () => ({
                    label: {
                        fontWeight: "bold"
                    }
                }),
                withAsterisk: !0,
                label: "Layer Name",
                ..._.getInputProps("name")
            }), jsxRuntimeExports.jsx(TextInput, {
                styles: () => ({
                    label: {
                        fontWeight: "bold"
                    }
                }),
                withAsterisk: !0,
                label: "URL Template",
                placeholder: "https://url/to/tiles/{z}/{x}/{-y}.png",
                error: _.errors.url && "URL is required",
                ..._.getInputProps("url")
            }), jsxRuntimeExports.jsxs(Input.Wrapper, {
                label: "Layer Extents",
                styles: () => ({
                    label: {
                        fontWeight: "bold"
                    }
                }),
                error: _.getInputProps("extents").error,
                children: [jsxRuntimeExports.jsx(NumberInput, {
                    label: "Min X",
                    sx: {
                        flex: 1
                    },
                    ..._.getInputProps("extents.0"),
                    onChange: rt => {
                        nt("extents.0", rt)
                    }
                }), jsxRuntimeExports.jsx(NumberInput, {
                    label: "Min Y",
                    sx: {
                        flex: 1
                    },
                    ..._.getInputProps("extents.1"),
                    onChange: rt => {
                        nt("extents.1", rt)
                    }
                }), jsxRuntimeExports.jsx(NumberInput, {
                    label: "Max X",
                    sx: {
                        flex: 1
                    },
                    ..._.getInputProps("extents.2"),
                    onChange: rt => {
                        nt("extents.2", rt)
                    }
                }), jsxRuntimeExports.jsx(NumberInput, {
                    label: "Max Y",
                    sx: {
                        flex: 1
                    },
                    ..._.getInputProps("extents.3"),
                    onChange: rt => {
                        nt("extents.3", rt)
                    }
                })]
            }), jsxRuntimeExports.jsx(TextInput, {
                styles: () => ({
                    label: {
                        fontWeight: "bold"
                    }
                }),
                withAsterisk: !0,
                label: "WMS Layer",
                placeholder: "topp:states",
                ..._.getInputProps("wmsLayer")
            })]
        }), jsxRuntimeExports.jsx(Group, {
            position: "right",
            mt: "md",
            children: jsxRuntimeExports.jsx(Button, {
                type: "submit",
                children: "Save"
            })
        })]
    })
}
  , ArcGISMapServiceForm = ({layer: o, edittedLayer: i}) => {
    const s = structuredClone(o);
    function a(rt) {
        return {
            name: rt.name,
            url: rt.url,
            extents: rt.extents == null ? [void 0, void 0, void 0, void 0] : rt.extents
        }
    }
    const _ = useForm({
        initialValues: a(s),
        validate: {
            name: rt => rt.trim().length > 0 ? null : "Name is required",
            url: rt => rt.trim().length > 0 ? null : "URL is required",
            extents: rt => $(rt) || _e(rt) ? null : "You must fill all extent values (minX, minY, maxX, maxY) with numbers"
        }
    });
    function $(rt) {
        return rt.every(ot => ot != null && !isNaN(ot))
    }
    function _e(rt) {
        return rt.every(ot => ot == null)
    }
    function tt() {
        const rt = $(_.values.extents) ? _.values.extents : void 0;
        return {
            name: _.values.name,
            url: _.values.url,
            type: "arcgis map server",
            extents: rt,
            visible: !0
        }
    }
    function nt(rt, ot) {
        ot == null || ot == "" ? _.getInputProps(rt).onChange(void 0) : _.getInputProps(rt).onChange(ot)
    }
    return jsxRuntimeExports.jsxs("form", {
        onSubmit: _.onSubmit( () => {
            i(tt())
        }
        ),
        children: [jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
            children: [jsxRuntimeExports.jsx(TextInput, {
                styles: () => ({
                    label: {
                        fontWeight: "bold"
                    }
                }),
                withAsterisk: !0,
                label: "Layer Name",
                ..._.getInputProps("name")
            }), jsxRuntimeExports.jsx(TextInput, {
                styles: () => ({
                    label: {
                        fontWeight: "bold"
                    }
                }),
                withAsterisk: !0,
                label: "URL Template",
                placeholder: "https://services.arcgisonline.com/arcgis/rest/services/World_Imagery/MapServer",
                error: _.errors.url && "URL is required",
                ..._.getInputProps("url")
            }), jsxRuntimeExports.jsxs(Input.Wrapper, {
                label: "Layer Extents",
                styles: () => ({
                    label: {
                        fontWeight: "bold"
                    }
                }),
                error: _.getInputProps("extents").error,
                children: [jsxRuntimeExports.jsx(NumberInput, {
                    label: "Min X",
                    sx: {
                        flex: 1
                    },
                    ..._.getInputProps("extents.0"),
                    onChange: rt => {
                        nt("extents.0", rt)
                    }
                }), jsxRuntimeExports.jsx(NumberInput, {
                    label: "Min Y",
                    sx: {
                        flex: 1
                    },
                    ..._.getInputProps("extents.1"),
                    onChange: rt => {
                        nt("extents.1", rt)
                    }
                }), jsxRuntimeExports.jsx(NumberInput, {
                    label: "Max X",
                    sx: {
                        flex: 1
                    },
                    ..._.getInputProps("extents.2"),
                    onChange: rt => {
                        nt("extents.2", rt)
                    }
                }), jsxRuntimeExports.jsx(NumberInput, {
                    label: "Max Y",
                    sx: {
                        flex: 1
                    },
                    ..._.getInputProps("extents.3"),
                    onChange: rt => {
                        nt("extents.3", rt)
                    }
                })]
            })]
        }), jsxRuntimeExports.jsx(Group, {
            position: "right",
            mt: "md",
            children: jsxRuntimeExports.jsx(Button, {
                type: "submit",
                children: "Save"
            })
        })]
    })
}
  , COGLayerForm = ({layer: o, edittedLayer: i}) => {
    const s = structuredClone(o)
      , [a,_] = reactExports.useState(void 0);
    function $(j) {
        return {
            name: j.name,
            url: j.url,
            extents: j.extents == null ? [void 0, void 0, void 0, void 0] : j.extents
        }
    }
    const _e = useForm({
        initialValues: $(s),
        validate: {
            name: j => j.trim().length > 0 ? null : "Name is required",
            url: j => j.trim().length > 0 ? null : "URL is required",
            extents: j => tt(j) || nt(j) ? null : "You must fill all extent values (minX, minY, maxX, maxY) with numbers"
        }
    });
    function tt(j) {
        return j.every(it => it != null && !isNaN(it))
    }
    function nt(j) {
        return j.every(it => it == null)
    }
    function rt() {
        const j = tt(_e.values.extents) ? _e.values.extents : void 0;
        return {
            ..._e.values,
            type: "cog",
            extents: j,
            visible: s.visible
        }
    }
    function ot(j, it) {
        it == null || it == "" ? _e.getInputProps(j).onChange(void 0) : _e.getInputProps(j).onChange(it)
    }
    async function et(j) {
        const it = await extractCOGInfo(j);
        _e.setValues($(it))
    }
    return jsxRuntimeExports.jsxs(Stack, {
        spacing: "xl",
        children: [jsxRuntimeExports.jsx(TextInput, {
            size: "md",
            onChange: j => _(j.currentTarget.value),
            rightSection: jsxRuntimeExports.jsx(ActionIcon, {
                size: 32,
                variant: "filled",
                color: "primary",
                onClick: () => {
                    a != null && et(a).catch(j => {
                        console.log(j)
                    }
                    )
                }
                ,
                children: jsxRuntimeExports.jsx(IconArrowRight, {
                    size: "1.1rem",
                    stroke: 1.5
                })
            }),
            label: "Import from url...",
            placeholder: "https://example/public/mycog.tif",
            rightSectionWidth: 42
        }), jsxRuntimeExports.jsxs("form", {
            onSubmit: _e.onSubmit( () => {
                const j = rt();
                i(j)
            }
            ),
            children: [jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                children: [jsxRuntimeExports.jsx(TextInput, {
                    styles: () => ({
                        label: {
                            fontWeight: "bold"
                        }
                    }),
                    withAsterisk: !0,
                    label: "Layer Name",
                    ..._e.getInputProps("name")
                }), jsxRuntimeExports.jsx(TextInput, {
                    styles: () => ({
                        label: {
                            fontWeight: "bold"
                        }
                    }),
                    withAsterisk: !0,
                    label: "URL Template",
                    placeholder: "https://example/public/mycog.tif",
                    error: _e.errors.url && "URL is required",
                    ..._e.getInputProps("url")
                }), jsxRuntimeExports.jsxs(Input.Wrapper, {
                    label: "Layer Extents",
                    styles: () => ({
                        label: {
                            fontWeight: "bold"
                        }
                    }),
                    error: _e.getInputProps("extents").error,
                    children: [jsxRuntimeExports.jsx(NumberInput, {
                        label: "Min X",
                        sx: {
                            flex: 1
                        },
                        ..._e.getInputProps("extents.0"),
                        onChange: j => {
                            ot("extents.0", j)
                        }
                    }), jsxRuntimeExports.jsx(NumberInput, {
                        label: "Min Y",
                        sx: {
                            flex: 1
                        },
                        ..._e.getInputProps("extents.1"),
                        onChange: j => {
                            ot("extents.1", j)
                        }
                    }), jsxRuntimeExports.jsx(NumberInput, {
                        label: "Max X",
                        sx: {
                            flex: 1
                        },
                        ..._e.getInputProps("extents.2"),
                        onChange: j => {
                            ot("extents.2", j)
                        }
                    }), jsxRuntimeExports.jsx(NumberInput, {
                        label: "Max Y",
                        sx: {
                            flex: 1
                        },
                        ..._e.getInputProps("extents.3"),
                        onChange: j => {
                            ot("extents.3", j)
                        }
                    })]
                })]
            }), jsxRuntimeExports.jsx(Group, {
                position: "right",
                mt: "md",
                children: jsxRuntimeExports.jsx(Button, {
                    type: "submit",
                    children: "Save"
                })
            })]
        })]
    })
}
  , MapTileLayerEditor = o => {
    const [i,s] = reactExports.useState(structuredClone(o.layer));
    function a(_) {
        _ == null || _ == i.type || (_ == "zxy" ? s($ => ({
            ...$,
            type: "zxy"
        })) : _ == "tiled wms" ? s($ => ({
            ...$,
            type: "tiled wms",
            wmsLayer: ""
        })) : _ == "arcgis map server" ? s($ => ({
            ...$,
            type: "arcgis map server"
        })) : _ == "cog" && s($ => ({
            ...$,
            type: "cog"
        })))
    }
    return jsxRuntimeExports.jsxs(Stack, {
        spacing: "lg",
        mih: 200,
        children: [jsxRuntimeExports.jsx(Select, {
            data: [{
                label: "ZXY",
                value: "zxy"
            }, {
                label: "Tiled WMS",
                value: "tiled wms"
            }, {
                label: "ArcGIS Map Server",
                value: "arcgis map server"
            }],
            label: "Map tile layer type",
            dropdownPosition: "bottom",
            mb: 5,
            value: i.type,
            onChange: a
        }), i.type == "zxy" && jsxRuntimeExports.jsx(ZXYLayerForm, {
            layer: i,
            edittedLayer: _ => o.onSave(_, o.layerNumber)
        }), i.type == "tiled wms" && jsxRuntimeExports.jsx(TiledWMSLayerForm, {
            layer: i,
            edittedLayer: _ => o.onSave(_, o.layerNumber)
        }), i.type == "arcgis map server" && jsxRuntimeExports.jsx(ArcGISMapServiceForm, {
            layer: i,
            edittedLayer: _ => o.onSave(_, o.layerNumber)
        }), i.type == "cog" && jsxRuntimeExports.jsx(COGLayerForm, {
            layer: i,
            edittedLayer: _ => o.onSave(_, o.layerNumber)
        })]
    })
}
  , MapLayerManager = o => {
    const [i,s] = reactExports.useState(structuredClone(o.layers))
      , [a,_] = reactExports.useState()
      , [,$] = useDisclosure(!1)
      , [_e,tt] = reactExports.useState(null);
    function nt(st, at) {
        st.dataTransfer.setData("text/plain", ""),
        tt(at)
    }
    function rt(st) {
        st.preventDefault()
    }
    function ot(st, at) {
        if (st.preventDefault(),
        _e) {
            const lt = [...i];
            lt.splice(i.indexOf(_e), 1),
            lt.splice(at, 0, _e),
            s(lt),
            tt(null)
        }
    }
    function et() {
        s(st => {
            const at = {
                name: `Layer ${generateUniqueString()}`,
                type: "zxy",
                url: "",
                extents: void 0,
                tileSize: void 0,
                visible: !0
            };
            return _(at),
            [at, ...st]
        }
        )
    }
    function j(st) {
        s(at => at.filter( (ct, ut) => ut != st))
    }
    function it(st, at) {
        s(lt => (lt[at] = st,
        [...lt]))
    }
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [jsxRuntimeExports.jsx(Modal, {
            size: "xl",
            opened: a != null,
            onClose: () => {
                $.close(),
                _(null)
            }
            ,
            children: a != null && jsxRuntimeExports.jsx(MapTileLayerEditor, {
                layer: a,
                layerNumber: i.indexOf(a),
                onSave: (st, at) => {
                    it(st, at),
                    $.close(),
                    _(null)
                }
            })
        }), jsxRuntimeExports.jsxs(Stack, {
            spacing: "md",
            children: [jsxRuntimeExports.jsx(Text$2, {
                fw: "bold",
                fz: "sm",
                children: "For the demo, all layers must be in the Web Mercator projection (EPSG:3857). And added layers do not save when refreshing the page."
            }), jsxRuntimeExports.jsxs(Table, {
                striped: !0,
                highlightOnHover: !0,
                withBorder: !0,
                children: [jsxRuntimeExports.jsx("thead", {
                    children: jsxRuntimeExports.jsxs("tr", {
                        children: [jsxRuntimeExports.jsx("th", {}), jsxRuntimeExports.jsx("th", {
                            children: "Layer Name"
                        }), jsxRuntimeExports.jsx("th", {
                            children: "Layer Type"
                        }), jsxRuntimeExports.jsx("th", {
                            children: "Options"
                        }), jsxRuntimeExports.jsx("th", {
                            children: "Visible"
                        })]
                    })
                }), jsxRuntimeExports.jsx("tbody", {
                    children: i.map( (st, at) => jsxRuntimeExports.jsxs("tr", {
                        draggable: !0,
                        onDragStart: lt => nt(lt, st),
                        onDragOver: rt,
                        onDrop: lt => ot(lt, at),
                        children: [jsxRuntimeExports.jsx("td", {
                            children: jsxRuntimeExports.jsx(Center, {
                                style: {
                                    cursor: "grab"
                                },
                                children: jsxRuntimeExports.jsx(IconGripVertical, {
                                    size: 18
                                })
                            })
                        }), jsxRuntimeExports.jsx("td", {
                            children: st.name
                        }), jsxRuntimeExports.jsx("td", {
                            children: st.type
                        }), jsxRuntimeExports.jsx("td", {
                            children: jsxRuntimeExports.jsxs(Group, {
                                spacing: 4,
                                children: [jsxRuntimeExports.jsx(ActionIcon, {
                                    variant: "outline",
                                    color: "green",
                                    onClick: () => {
                                        _(st)
                                    }
                                    ,
                                    children: jsxRuntimeExports.jsx(IconSettings, {
                                        size: "1rem"
                                    })
                                }), jsxRuntimeExports.jsx(ActionIcon, {
                                    variant: "outline",
                                    color: "red",
                                    onClick: () => j(at),
                                    children: jsxRuntimeExports.jsx(IconTrashFilled, {
                                        size: "1rem"
                                    })
                                }), jsxRuntimeExports.jsx(ActionIcon, {
                                    variant: "outline",
                                    color: "blue",
                                    disabled: st.extents == null,
                                    onClick: () => {
                                        o.onSave(i),
                                        o.onZoomToLayer(st),
                                        $.close()
                                    }
                                    ,
                                    children: jsxRuntimeExports.jsx(IconZoomInArea, {
                                        size: "1rem"
                                    })
                                })]
                            })
                        }), jsxRuntimeExports.jsx("td", {
                            children: jsxRuntimeExports.jsx(Switch, {
                                onLabel: "ON",
                                offLabel: "OFF",
                                checked: st.visible,
                                onChange: lt => {
                                    st.visible = lt.currentTarget.checked,
                                    s([...i])
                                }
                            })
                        })]
                    }, st.name))
                })]
            })]
        }), jsxRuntimeExports.jsxs(Flex, {
            align: "center",
            justify: "space-between",
            mt: 15,
            children: [jsxRuntimeExports.jsx(Button, {
                variant: "filled",
                color: "green",
                onClick: et,
                children: "Add Layer"
            }), jsxRuntimeExports.jsx(Button, {
                onClick: () => {
                    o.onSave(i),
                    $.close()
                }
                ,
                children: "Save Changes"
            })]
        })]
    })
}
  , demoTilesRepository = () => ({
    getCurrentUsersTiles: async () => [{
        name: "GeoTIFF Example 1",
        type: "zxy",
        url: "https://geosegmenttiles.b-cdn.net/public/geotiff-example-1/tiles/{z}/{x}/{-y}.png",
        tileSize: [256, 256],
        minZoom: 15,
        maxZoom: 21,
        extents: [-9638059050104e-6, 4760069496319e-6, -9637343766351e-6, 476058634371e-5],
        visible: !0
    }, {
        name: "Google Maps - Satellite",
        type: "zxy",
        url: "https://www.google.com/maps/vt?lyrs=s@189&gl=cn&x={x}&y={y}&z={z}",
        visible: !0
    }]
})
  , tilesRepo = demoTilesRepository()
  , UserTileLayersContext = reactExports.createContext({
    tileLayers: [],
    updateLayers: () => {}
})
  , UserTileLayersContextProvider = ({children: o}) => {
    const [i,s] = reactExports.useState([]);
    function a(_) {
        s(_)
    }
    return reactExports.useEffect( () => {
        (async () => {
            const $ = await tilesRepo.getCurrentUsersTiles();
            s($)
        }
        )().catch($ => {
            console.error($)
        }
        )
    }
    , []),
    jsxRuntimeExports.jsx(UserTileLayersContext.Provider, {
        value: {
            tileLayers: i,
            updateLayers: a
        },
        children: o
    })
}
  , GENERATED_FEATURES_LAYER_NAME = "predicted-features";
function DemoPage({onLogout: o}) {
    const i = reactExports.useRef(null)
      , [s,{open: a, close: _}] = useDisclosure(!1)
      , [$,_e] = reactExports.useState(geoJSONFeatureType.Polygon)
      , tt = reactExports.useContext(SegmentAnythingModelContext)
      , {tileLayers: nt, updateLayers: rt} = reactExports.useContext(UserTileLayersContext)
      , [ot,et] = reactExports.useState(SegmentRequestType.Point)
      , [j,it] = reactExports.useState({
        type: "FeatureCollection",
        features: []
    })
      , [st,at] = useDisclosure(!1)
      , lt = () => {
        var ft;
        (ft = i.current) == null || ft.clearSegmentRequests()
    }
      , ct = ft => {
        ft.id != null && (i.current.deleteFeatureById(ft.id.toString(), GENERATED_FEATURES_LAYER_NAME),
        it(ht => {
            const pt = ht.features.filter(gt => gt.id !== ft.id);
            return {
                ...ht,
                features: pt
            }
        }
        ))
    }
      , ut = (ft, ht, pt) => {
        i.current.flyMapTo(ft, ht, pt)
    }
      , dt = () => {
        async function ft() {
            if (i.current != null) {
                a();
                try {
                    const pt = i.current.getSegmentRequests().map(vt => {
                        if (vt.type === SegmentRequestType.Point) {
                            const wt = i.current.coordinateToPixel(vt.coordinate);
                            return {
                                type: InferenceType.SinglePoint,
                                point: {
                                    x: wt[0],
                                    y: wt[1]
                                }
                            }
                        } else {
                            const wt = i.current.coordinateToPixel(vt.topLeft)
                              , Tt = i.current.coordinateToPixel(vt.bottomRight);
                            return {
                                type: InferenceType.BoundingBox,
                                topLeft: {
                                    x: wt[0],
                                    y: wt[1]
                                },
                                bottomRight: {
                                    x: Tt[0],
                                    y: Tt[1]
                                }
                            }
                        }
                    }
                    )
                      , gt = i.current.getMapCanvas()
                      , [_t,mt] = i.current.getMapContainerWidthAndHeight()
                      , yt = await tt.model.getInferenceMasks(gt, _t, mt, pt);
                    i.current.tryGetFeatureLayer(GENERATED_FEATURES_LAYER_NAME) != null || i.current.addFeatureLayer(GENERATED_FEATURES_LAYER_NAME),
                    yt.forEach(vt => {
                        const wt = `Feature-${generateUniqueString()}`
                          , Tt = vt.map(Et => [Et[0], Et[1]]);
                        let $t;
                        $ === geoJSONFeatureType.Polygon ? $t = i.current.addPolygon(wt, GENERATED_FEATURES_LAYER_NAME, Tt) : $t = i.current.addLine(wt, GENERATED_FEATURES_LAYER_NAME, Tt),
                        it(Et => ({
                            ...Et,
                            features: [...Et.features, $t]
                        }))
                    }
                    )
                } catch (ht) {
                    console.log(ht)
                } finally {
                    lt(),
                    _()
                }
            }
        }
        ft().catch(ht => console.log(ht))
    }
    ;
    return reactExports.useEffect( () => {
        var ft;
        (ft = i.current) == null || ft.setDrawingMode(ot)
    }
    , [ot]),
    reactExports.useEffect( () => {
        var ft;
        (ft = i.current) == null || ft.addMapTileLayers(nt)
    }
    , [nt]),
    jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
        children: jsxRuntimeExports.jsxs("div", {
            style: {
                display: "flex",
                flexDirection: "row",
                position: "relative"
            },
            children: [jsxRuntimeExports.jsx(Box, {
                pos: "relative",
                w: "100%",
                h: "100%",
                children: jsxRuntimeExports.jsx(LoadingOverlay, {
                    visible: s,
                    overlayBlur: 2
                })
            }), jsxRuntimeExports.jsx(Modal, {
                size: "xl",
                opened: st,
                onClose: at.close,
                children: jsxRuntimeExports.jsx(MapLayerManager, {
                    layers: nt,
                    onSave: ft => {
                        rt(ft),
                        at.close()
                    }
                    ,
                    onZoomToLayer: ft => {
                        var ht;
                        ft.extents != null && ((ht = i.current) == null || ht.zoomToExtents(ft.extents))
                    }
                })
            }), jsxRuntimeExports.jsx(OlMap, {
                style: {
                    position: "absolute",
                    width: "100%",
                    height: "100%"
                },
                ref: i,
                originalDrawingMode: ot
            }), jsxRuntimeExports.jsxs(Group, {
                m: 10,
                pos: "absolute",
                children: [jsxRuntimeExports.jsx(SegmentedControl, {
                    data: Object.keys(mapLocations).map(ft => ({
                        label: mapLocations[ft],
                        value: ft
                    })),
                    onChange: ft => {
                        const [ht,pt,gt] = mapLocationsToLngLat(mapLocations[ft]);
                        ut(ht, pt, gt)
                    }
                }), jsxRuntimeExports.jsx(Button, {
                    leftIcon: jsxRuntimeExports.jsx(IconStack2, {
                        size: "1rem"
                    }),
                    variant: "default",
                    onClick: at.open,
                    children: "Layers"
                })]
            }), jsxRuntimeExports.jsx(FeatureToolbar, {
                features: j.features,
                onDeleteFeature: ct,
                onExportAsGeoJSON: () => {
                    const ft = {
                        ...j,
                        features: j.features.map(ht => i.current.projectToLngLat(ht))
                    };
                    saveAsGeoJSON(ft, "segmented-features-as-geojson")
                }
                ,
                onSegmentTypeChange: ft => _e(geoJSONFeatureType[ft]),
                onClear: lt,
                onToggleDeleteMode: ft => {
                    var ht;
                    (ht = i.current) == null || ht.toggleDrawingDeletion(ft)
                }
                ,
                onHoverEnterOverFeature: ft => {
                    var ht;
                    ft.id != null && ((ht = i.current) == null || ht.highlightFeature(ft.id.toString(), GENERATED_FEATURES_LAYER_NAME))
                }
                ,
                onHoverLeaveOverFeature: ft => {
                    var ht;
                    ft.id != null && ((ht = i.current) == null || ht.unhighlightFeature(ft.id.toString(), GENERATED_FEATURES_LAYER_NAME))
                }
                ,
                onFeatureClick: ft => {
                    var ht;
                    ft.id != null && ((ht = i.current) == null || ht.panToFeature(ft.id.toString(), GENERATED_FEATURES_LAYER_NAME))
                }
                ,
                onDone: () => {
                    dt()
                }
                ,
                onLogout: o,
                onSegmentModeChange: ft => {
                    et(ft)
                }
            })]
        })
    })
}
function _setPrototypeOf(o, i) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(a, _) {
        return a.__proto__ = _,
        a
    }
    ,
    _setPrototypeOf(o, i)
}
function _inheritsLoose(o, i) {
    o.prototype = Object.create(i.prototype),
    o.prototype.constructor = o,
    _setPrototypeOf(o, i)
}
const config = {
    disabled: !1
}
  , TransitionGroupContext = React.createContext(null);
var UNMOUNTED = "unmounted"
  , EXITED = "exited"
  , ENTERING = "entering"
  , ENTERED = "entered"
  , EXITING = "exiting"
  , Transition = function(o) {
    _inheritsLoose(i, o);
    function i(a, _) {
        var $;
        $ = o.call(this, a, _) || this;
        var _e = _, tt = _e && !_e.isMounting ? a.enter : a.appear, nt;
        return $.appearStatus = null,
        a.in ? tt ? (nt = EXITED,
        $.appearStatus = ENTERING) : nt = ENTERED : a.unmountOnExit || a.mountOnEnter ? nt = UNMOUNTED : nt = EXITED,
        $.state = {
            status: nt
        },
        $.nextCallback = null,
        $
    }
    i.getDerivedStateFromProps = function(_, $) {
        var _e = _.in;
        return _e && $.status === UNMOUNTED ? {
            status: EXITED
        } : null
    }
    ;
    var s = i.prototype;
    return s.componentDidMount = function() {
        this.updateStatus(!0, this.appearStatus)
    }
    ,
    s.componentDidUpdate = function(_) {
        var $ = null;
        if (_ !== this.props) {
            var _e = this.state.status;
            this.props.in ? _e !== ENTERING && _e !== ENTERED && ($ = ENTERING) : (_e === ENTERING || _e === ENTERED) && ($ = EXITING)
        }
        this.updateStatus(!1, $)
    }
    ,
    s.componentWillUnmount = function() {
        this.cancelNextCallback()
    }
    ,
    s.getTimeouts = function() {
        var _ = this.props.timeout, $, _e, tt;
        return $ = _e = tt = _,
        _ != null && typeof _ != "number" && ($ = _.exit,
        _e = _.enter,
        tt = _.appear !== void 0 ? _.appear : _e),
        {
            exit: $,
            enter: _e,
            appear: tt
        }
    }
    ,
    s.updateStatus = function(_, $) {
        _ === void 0 && (_ = !1),
        $ !== null ? (this.cancelNextCallback(),
        $ === ENTERING ? this.performEnter(_) : this.performExit()) : this.props.unmountOnExit && this.state.status === EXITED && this.setState({
            status: UNMOUNTED
        })
    }
    ,
    s.performEnter = function(_) {
        var $ = this
          , _e = this.props.enter
          , tt = this.context ? this.context.isMounting : _
          , nt = this.props.nodeRef ? [tt] : [ReactDOM.findDOMNode(this), tt]
          , rt = nt[0]
          , ot = nt[1]
          , et = this.getTimeouts()
          , j = tt ? et.appear : et.enter;
        if (!_ && !_e || config.disabled) {
            this.safeSetState({
                status: ENTERED
            }, function() {
                $.props.onEntered(rt)
            });
            return
        }
        this.props.onEnter(rt, ot),
        this.safeSetState({
            status: ENTERING
        }, function() {
            $.props.onEntering(rt, ot),
            $.onTransitionEnd(j, function() {
                $.safeSetState({
                    status: ENTERED
                }, function() {
                    $.props.onEntered(rt, ot)
                })
            })
        })
    }
    ,
    s.performExit = function() {
        var _ = this
          , $ = this.props.exit
          , _e = this.getTimeouts()
          , tt = this.props.nodeRef ? void 0 : ReactDOM.findDOMNode(this);
        if (!$ || config.disabled) {
            this.safeSetState({
                status: EXITED
            }, function() {
                _.props.onExited(tt)
            });
            return
        }
        this.props.onExit(tt),
        this.safeSetState({
            status: EXITING
        }, function() {
            _.props.onExiting(tt),
            _.onTransitionEnd(_e.exit, function() {
                _.safeSetState({
                    status: EXITED
                }, function() {
                    _.props.onExited(tt)
                })
            })
        })
    }
    ,
    s.cancelNextCallback = function() {
        this.nextCallback !== null && (this.nextCallback.cancel(),
        this.nextCallback = null)
    }
    ,
    s.safeSetState = function(_, $) {
        $ = this.setNextCallback($),
        this.setState(_, $)
    }
    ,
    s.setNextCallback = function(_) {
        var $ = this
          , _e = !0;
        return this.nextCallback = function(tt) {
            _e && (_e = !1,
            $.nextCallback = null,
            _(tt))
        }
        ,
        this.nextCallback.cancel = function() {
            _e = !1
        }
        ,
        this.nextCallback
    }
    ,
    s.onTransitionEnd = function(_, $) {
        this.setNextCallback($);
        var _e = this.props.nodeRef ? this.props.nodeRef.current : ReactDOM.findDOMNode(this)
          , tt = _ == null && !this.props.addEndListener;
        if (!_e || tt) {
            setTimeout(this.nextCallback, 0);
            return
        }
        if (this.props.addEndListener) {
            var nt = this.props.nodeRef ? [this.nextCallback] : [_e, this.nextCallback]
              , rt = nt[0]
              , ot = nt[1];
            this.props.addEndListener(rt, ot)
        }
        _ != null && setTimeout(this.nextCallback, _)
    }
    ,
    s.render = function() {
        var _ = this.state.status;
        if (_ === UNMOUNTED)
            return null;
        var $ = this.props
          , _e = $.children;
        $.in,
        $.mountOnEnter,
        $.unmountOnExit,
        $.appear,
        $.enter,
        $.exit,
        $.timeout,
        $.addEndListener,
        $.onEnter,
        $.onEntering,
        $.onEntered,
        $.onExit,
        $.onExiting,
        $.onExited,
        $.nodeRef;
        var tt = _objectWithoutPropertiesLoose($, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
        return React.createElement(TransitionGroupContext.Provider, {
            value: null
        }, typeof _e == "function" ? _e(_, tt) : React.cloneElement(React.Children.only(_e), tt))
    }
    ,
    i
}(React.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = {};
function noop() {}
Transition.defaultProps = {
    in: !1,
    mountOnEnter: !1,
    unmountOnExit: !1,
    appear: !1,
    enter: !0,
    exit: !0,
    onEnter: noop,
    onEntering: noop,
    onEntered: noop,
    onExit: noop,
    onExiting: noop,
    onExited: noop
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
const Transition$1 = Transition;
function _assertThisInitialized(o) {
    if (o === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return o
}
function getChildMapping(o, i) {
    var s = function($) {
        return i && reactExports.isValidElement($) ? i($) : $
    }
      , a = Object.create(null);
    return o && reactExports.Children.map(o, function(_) {
        return _
    }).forEach(function(_) {
        a[_.key] = s(_)
    }),
    a
}
function mergeChildMappings(o, i) {
    o = o || {},
    i = i || {};
    function s(ot) {
        return ot in i ? i[ot] : o[ot]
    }
    var a = Object.create(null)
      , _ = [];
    for (var $ in o)
        $ in i ? _.length && (a[$] = _,
        _ = []) : _.push($);
    var _e, tt = {};
    for (var nt in i) {
        if (a[nt])
            for (_e = 0; _e < a[nt].length; _e++) {
                var rt = a[nt][_e];
                tt[a[nt][_e]] = s(rt)
            }
        tt[nt] = s(nt)
    }
    for (_e = 0; _e < _.length; _e++)
        tt[_[_e]] = s(_[_e]);
    return tt
}
function getProp(o, i, s) {
    return s[i] != null ? s[i] : o.props[i]
}
function getInitialChildMapping(o, i) {
    return getChildMapping(o.children, function(s) {
        return reactExports.cloneElement(s, {
            onExited: i.bind(null, s),
            in: !0,
            appear: getProp(s, "appear", o),
            enter: getProp(s, "enter", o),
            exit: getProp(s, "exit", o)
        })
    })
}
function getNextChildMapping(o, i, s) {
    var a = getChildMapping(o.children)
      , _ = mergeChildMappings(i, a);
    return Object.keys(_).forEach(function($) {
        var _e = _[$];
        if (reactExports.isValidElement(_e)) {
            var tt = $ in i
              , nt = $ in a
              , rt = i[$]
              , ot = reactExports.isValidElement(rt) && !rt.props.in;
            nt && (!tt || ot) ? _[$] = reactExports.cloneElement(_e, {
                onExited: s.bind(null, _e),
                in: !0,
                exit: getProp(_e, "exit", o),
                enter: getProp(_e, "enter", o)
            }) : !nt && tt && !ot ? _[$] = reactExports.cloneElement(_e, {
                in: !1
            }) : nt && tt && reactExports.isValidElement(rt) && (_[$] = reactExports.cloneElement(_e, {
                onExited: s.bind(null, _e),
                in: rt.props.in,
                exit: getProp(_e, "exit", o),
                enter: getProp(_e, "enter", o)
            }))
        }
    }),
    _
}
var values = Object.values || function(o) {
    return Object.keys(o).map(function(i) {
        return o[i]
    })
}
  , defaultProps = {
    component: "div",
    childFactory: function o(i) {
        return i
    }
}
  , TransitionGroup = function(o) {
    _inheritsLoose(i, o);
    function i(a, _) {
        var $;
        $ = o.call(this, a, _) || this;
        var _e = $.handleExited.bind(_assertThisInitialized($));
        return $.state = {
            contextValue: {
                isMounting: !0
            },
            handleExited: _e,
            firstRender: !0
        },
        $
    }
    var s = i.prototype;
    return s.componentDidMount = function() {
        this.mounted = !0,
        this.setState({
            contextValue: {
                isMounting: !1
            }
        })
    }
    ,
    s.componentWillUnmount = function() {
        this.mounted = !1
    }
    ,
    i.getDerivedStateFromProps = function(_, $) {
        var _e = $.children
          , tt = $.handleExited
          , nt = $.firstRender;
        return {
            children: nt ? getInitialChildMapping(_, tt) : getNextChildMapping(_, _e, tt),
            firstRender: !1
        }
    }
    ,
    s.handleExited = function(_, $) {
        var _e = getChildMapping(this.props.children);
        _.key in _e || (_.props.onExited && _.props.onExited($),
        this.mounted && this.setState(function(tt) {
            var nt = _extends({}, tt.children);
            return delete nt[_.key],
            {
                children: nt
            }
        }))
    }
    ,
    s.render = function() {
        var _ = this.props
          , $ = _.component
          , _e = _.childFactory
          , tt = _objectWithoutPropertiesLoose(_, ["component", "childFactory"])
          , nt = this.state.contextValue
          , rt = values(this.state.children).map(_e);
        return delete tt.appear,
        delete tt.enter,
        delete tt.exit,
        $ === null ? React.createElement(TransitionGroupContext.Provider, {
            value: nt
        }, rt) : React.createElement(TransitionGroupContext.Provider, {
            value: nt
        }, React.createElement($, tt, rt))
    }
    ,
    i
}(React.Component);
TransitionGroup.propTypes = {};
TransitionGroup.defaultProps = defaultProps;
const TransitionGroup$1 = TransitionGroup
  , [useNotificationsEvents,createEvent] = createUseExternalEvents("mantine-notifications")
  , showNotification = createEvent("show")
  , hideNotification = createEvent("hide")
  , cleanNotifications = createEvent("clean")
  , cleanNotificationsQueue = createEvent("cleanQueue")
  , updateNotification = createEvent("update")
  , notifications = {
    show: showNotification,
    hide: hideNotification,
    clean: cleanNotifications,
    cleanQueue: cleanNotificationsQueue,
    update: updateNotification
};
function getPositionStyles([o,i], s) {
    const a = {};
    return o === "top" && (a.top = s),
    o === "bottom" && (a.bottom = s),
    i === "left" && (a.left = s),
    i === "right" && (a.right = s),
    i === "center" && (a.left = "50%",
    a.transform = "translateX(-50%)"),
    a
}
var __defProp$3 = Object.defineProperty
  , __getOwnPropSymbols$3 = Object.getOwnPropertySymbols
  , __hasOwnProp$3 = Object.prototype.hasOwnProperty
  , __propIsEnum$3 = Object.prototype.propertyIsEnumerable
  , __defNormalProp$3 = (o, i, s) => i in o ? __defProp$3(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$3 = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$3.call(i, s) && __defNormalProp$3(o, s, i[s]);
    if (__getOwnPropSymbols$3)
        for (var s of __getOwnPropSymbols$3(i))
            __propIsEnum$3.call(i, s) && __defNormalProp$3(o, s, i[s]);
    return o
}
;
const transforms = {
    left: "translateX(-100%)",
    right: "translateX(100%)",
    "top-center": "translateY(-100%)",
    "bottom-center": "translateY(100%)"
}
  , noTransform = {
    left: "translateX(0)",
    right: "translateX(0)",
    "top-center": "translateY(0)",
    "bottom-center": "translateY(0)"
};
function getNotificationStateStyles({state: o, maxHeight: i, positioning: s, transitionDuration: a}) {
    const [_,$] = s
      , _e = $ === "center" ? `${_}-center` : $
      , tt = {
        opacity: 0,
        maxHeight: i,
        transform: transforms[_e],
        transitionDuration: `${a}ms, ${a}ms, ${a}ms`,
        transitionTimingFunction: "cubic-bezier(.51,.3,0,1.21), cubic-bezier(.51,.3,0,1.21), linear",
        transitionProperty: "opacity, transform, max-height"
    }
      , nt = {
        opacity: 1,
        transform: noTransform[_e]
    }
      , rt = {
        opacity: 0,
        maxHeight: 0,
        transform: transforms[_e]
    }
      , ot = {
        entering: nt,
        entered: nt,
        exiting: rt,
        exited: rt
    };
    return __spreadValues$3(__spreadValues$3({}, tt), ot[o])
}
function getAutoClose(o, i) {
    return typeof i == "number" ? i : i === !1 || o === !1 ? !1 : o
}
var __defProp$2 = Object.defineProperty
  , __defProps$1 = Object.defineProperties
  , __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$2 = Object.getOwnPropertySymbols
  , __hasOwnProp$2 = Object.prototype.hasOwnProperty
  , __propIsEnum$2 = Object.prototype.propertyIsEnumerable
  , __defNormalProp$2 = (o, i, s) => i in o ? __defProp$2(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$2 = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$2.call(i, s) && __defNormalProp$2(o, s, i[s]);
    if (__getOwnPropSymbols$2)
        for (var s of __getOwnPropSymbols$2(i))
            __propIsEnum$2.call(i, s) && __defNormalProp$2(o, s, i[s]);
    return o
}
  , __spreadProps$1 = (o, i) => __defProps$1(o, __getOwnPropDescs$1(i))
  , __objRest$1 = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp$2.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols$2)
        for (var a of __getOwnPropSymbols$2(o))
            i.indexOf(a) < 0 && __propIsEnum$2.call(o, a) && (s[a] = o[a]);
    return s
}
;
function NotificationContainer(o) {
    var i = o
      , {notification: s, autoClose: a, onHide: _, innerRef: $} = i
      , _e = __objRest$1(i, ["notification", "autoClose", "onHide", "innerRef"]);
    const tt = s
      , {autoClose: nt, message: rt} = tt
      , ot = __objRest$1(tt, ["autoClose", "message"])
      , et = getAutoClose(a, nt)
      , j = reactExports.useRef()
      , it = () => {
        _(s.id),
        window.clearTimeout(j.current)
    }
      , st = () => {
        clearTimeout(j.current)
    }
      , at = () => {
        typeof et == "number" && (j.current = window.setTimeout(it, et))
    }
    ;
    return reactExports.useEffect( () => {
        typeof s.onOpen == "function" && s.onOpen(s)
    }
    , []),
    reactExports.useEffect( () => (at(),
    st), [a, s.autoClose]),
    React.createElement(Notification, __spreadProps$1(__spreadValues$2(__spreadValues$2({}, ot), _e), {
        onClose: it,
        onMouseEnter: st,
        onMouseLeave: at,
        ref: $
    }), rt)
}
NotificationContainer.displayName = "@mantine/notifications/NotificationContainer";
var useStyles = createStyles( (o, {zIndex: i}) => ({
    notifications: {
        width: `calc(100% - ${o.spacing.md} * 2)`,
        boxSizing: "border-box",
        position: "fixed",
        zIndex: i
    },
    notification: {
        "&:not(:first-of-type)": {
            marginTop: o.spacing.sm
        }
    }
}));
const useStyles$1 = useStyles;
var __defProp$1 = Object.defineProperty
  , __defProps = Object.defineProperties
  , __getOwnPropDescs = Object.getOwnPropertyDescriptors
  , __getOwnPropSymbols$1 = Object.getOwnPropertySymbols
  , __hasOwnProp$1 = Object.prototype.hasOwnProperty
  , __propIsEnum$1 = Object.prototype.propertyIsEnumerable
  , __defNormalProp$1 = (o, i, s) => i in o ? __defProp$1(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues$1 = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp$1.call(i, s) && __defNormalProp$1(o, s, i[s]);
    if (__getOwnPropSymbols$1)
        for (var s of __getOwnPropSymbols$1(i))
            __propIsEnum$1.call(i, s) && __defNormalProp$1(o, s, i[s]);
    return o
}
  , __spreadProps = (o, i) => __defProps(o, __getOwnPropDescs(i));
function useNotificationsState({limit: o}) {
    const {state: i, queue: s, update: a, cleanQueue: _} = useQueue({
        initialValues: [],
        limit: o
    });
    return {
        notifications: i,
        queue: s,
        showNotification: rt => {
            const ot = rt.id || randomId();
            return a(et => rt.id && et.some(j => j.id === rt.id) ? et : [...et, __spreadProps(__spreadValues$1({}, rt), {
                id: ot
            })]),
            ot
        }
        ,
        updateNotification: rt => a(ot => {
            const et = ot.findIndex(it => it.id === rt.id);
            if (et === -1)
                return ot;
            const j = [...ot];
            return j[et] = rt,
            j
        }
        ),
        hideNotification: rt => a(ot => ot.filter(et => et.id === rt ? (typeof et.onClose == "function" && et.onClose(et),
        !1) : !0)),
        cleanQueue: _,
        clean: () => a( () => [])
    }
}
var __defProp = Object.defineProperty
  , __getOwnPropSymbols = Object.getOwnPropertySymbols
  , __hasOwnProp = Object.prototype.hasOwnProperty
  , __propIsEnum = Object.prototype.propertyIsEnumerable
  , __defNormalProp = (o, i, s) => i in o ? __defProp(o, i, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: s
}) : o[i] = s
  , __spreadValues = (o, i) => {
    for (var s in i || (i = {}))
        __hasOwnProp.call(i, s) && __defNormalProp(o, s, i[s]);
    if (__getOwnPropSymbols)
        for (var s of __getOwnPropSymbols(i))
            __propIsEnum.call(i, s) && __defNormalProp(o, s, i[s]);
    return o
}
  , __objRest = (o, i) => {
    var s = {};
    for (var a in o)
        __hasOwnProp.call(o, a) && i.indexOf(a) < 0 && (s[a] = o[a]);
    if (o != null && __getOwnPropSymbols)
        for (var a of __getOwnPropSymbols(o))
            i.indexOf(a) < 0 && __propIsEnum.call(o, a) && (s[a] = o[a]);
    return s
}
;
const POSITIONS = ["top-left", "top-right", "top-center", "bottom-left", "bottom-right", "bottom-center"]
  , Notifications = o => {
    var i = o
      , {className: s, position: a="bottom-right", autoClose: _=4e3, transitionDuration: $=250, containerWidth: _e=rem(440), notificationMaxHeight: tt=rem(200), limit: nt=5, zIndex: rt=getDefaultZIndex("overlay"), style: ot, children: et, target: j} = i
      , it = __objRest(i, ["className", "position", "autoClose", "transitionDuration", "containerWidth", "notificationMaxHeight", "limit", "zIndex", "style", "children", "target"]);
    const st = useForceUpdate()
      , at = reactExports.useRef({})
      , lt = reactExports.useRef(0)
      , {notifications: ct, showNotification: ut, updateNotification: dt, hideNotification: ft, clean: ht, cleanQueue: pt} = useNotificationsState({
        limit: nt
    })
      , {classes: gt, cx: _t, theme: mt} = useStyles$1({
        zIndex: rt
    })
      , yt = useReducedMotion()
      , vt = (mt.respectReducedMotion ? yt : !1) ? 1 : $
      , wt = (POSITIONS.includes(a) ? a : "bottom-right").split("-");
    useDidUpdate( () => {
        ct.length > lt.current && setTimeout( () => st(), 0),
        lt.current = ct.length
    }
    , [ct]),
    useNotificationsEvents({
        show: ut,
        hide: ft,
        update: dt,
        clean: ht,
        cleanQueue: pt
    });
    const Tt = ct.map($t => React.createElement(Transition$1, {
        key: $t.id,
        timeout: vt,
        onEnter: () => at.current[$t.id].offsetHeight,
        nodeRef: {
            current: at.current[$t.id]
        }
    }, Et => React.createElement(NotificationContainer, {
        innerRef: Pt => {
            at.current[$t.id] = Pt
        }
        ,
        notification: $t,
        onHide: ft,
        className: gt.notification,
        autoClose: _,
        sx: [__spreadValues({}, getNotificationStateStyles({
            state: Et,
            positioning: wt,
            transitionDuration: vt,
            maxHeight: tt
        })), ...Array.isArray($t.sx) ? $t.sx : [$t.sx]]
    })));
    return React.createElement(Portal, {
        target: j
    }, React.createElement(Box, __spreadValues({
        className: _t(gt.notifications, s),
        style: ot,
        sx: __spreadValues({
            maxWidth: _e
        }, getPositionStyles(wt, mt.spacing.md))
    }, it), React.createElement(TransitionGroup$1, null, Tt)))
}
;
Notifications.displayName = "@mantine/notifications/Notifications";
Notifications.show = notifications.show;
Notifications.hide = notifications.hide;
Notifications.update = notifications.update;
Notifications.clean = notifications.clean;
Notifications.cleanQueue = notifications.cleanQueue;
function LoginPage() {
    const o = useNavigate()
      , i = useForm({
        initialValues: {
            email: "",
            password: "",
            accepted_terms_and_conditions: !1
        },
        validate: {
            email: _ => _.includes("@") ? null : "Invalid email",
            password: _ => _.length > 0 ? null : "Password cannot be empty",
            accepted_terms_and_conditions: _ => _ ? null : "You must accept the terms and conditions to continue"
        }
    });
    function s(_) {
        firebaseLogin(_.email, _.password).then( () => {
            o("/")
        }
        ).catch($ => {
            switch ($.code) {
            case "auth/invalid-email":
                i.setFieldError("email", "Invalid email");
                break;
            case "auth/user-disabled":
                i.setFieldError("email", "User disabled");
                break;
            case "auth/user-not-found":
            case "auth/wrong-password":
                i.setFieldError("email", "User not found or wrong password");
                break
            }
        }
        )
    }
    function a(_) {
        firebaseSendResetPasswordRequest(_).then( () => {
            notifications.show({
                title: "Password Reset Request Sent",
                message: "If the account exists, you will receive an email with instructions to reset your password."
            })
        }
        ).catch($ => {
            switch ($.code) {
            case "auth/invalid-email":
                i.setFieldError("email", "Invalid email");
                break;
            case "auth/user-disabled":
                i.setFieldError("email", "User disabled");
                break;
            case "auth/user-not-found":
            case "auth/wrong-password":
                i.setFieldError("email", "User not found or wrong password");
                break
            }
        }
        )
    }
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
        children: jsxRuntimeExports.jsx(Center, {
            pos: "relative",
            sx: _ => ({
                background: _.fn.linearGradient(45, "#83a4d4", "#b6fbff")
            }),
            children: jsxRuntimeExports.jsx(Container, {
                w: 500,
                children: jsxRuntimeExports.jsxs(Paper, {
                    withBorder: !0,
                    shadow: "md",
                    p: 30,
                    mt: 30,
                    radius: "md",
                    children: [jsxRuntimeExports.jsx(Center, {
                        mb: "xl",
                        children: jsxRuntimeExports.jsxs(Group, {
                            spacing: "sm",
                            children: [jsxRuntimeExports.jsx(ThemeIcon, {
                                variant: "gradient",
                                gradient: {
                                    from: "teal.7",
                                    to: "cyan.7",
                                    deg: 105
                                },
                                children: jsxRuntimeExports.jsx(PolygonNodesIcon, {
                                    width: 20,
                                    height: 20,
                                    fill: "currentColor"
                                })
                            }), jsxRuntimeExports.jsx(Title, {
                                order: 2,
                                align: "center",
                                color: "dark.4",
                                children: "GeoSegment Demo"
                            })]
                        })
                    }), jsxRuntimeExports.jsxs("form", {
                        onSubmit: i.onSubmit(_ => s(_)),
                        children: [jsxRuntimeExports.jsx(TextInput, {
                            label: "Email",
                            placeholder: "you@emailprovider.com",
                            required: !0,
                            ...i.getInputProps("email")
                        }), jsxRuntimeExports.jsx(PasswordInput, {
                            label: "Password",
                            placeholder: "Your password",
                            required: !0,
                            mt: "md",
                            ...i.getInputProps("password")
                        }), jsxRuntimeExports.jsx(Anchor, {
                            fz: "sm",
                            onClick: () => {
                                i.validateField("email").hasError || a(i.values.email)
                            }
                            ,
                            children: "Forgot Password"
                        }), jsxRuntimeExports.jsx(Checkbox, {
                            my: "md",
                            label: jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                                children: ["I accept the", " ", jsxRuntimeExports.jsx(Anchor, {
                                    href: "https://firebasestorage.googleapis.com/v0/b/geosegment-299df.appspot.com/o/public%2Fgeosegment_demo_terms_and_conditions.txt?alt=media&token=fcb7dbc4-16dd-4d3a-aaa1-8159293bcd3d",
                                    target: "_blank",
                                    children: "terms and conditions"
                                }), " ", "of the demo"]
                            }),
                            ...i.getInputProps("accepted_terms_and_conditions")
                        }), jsxRuntimeExports.jsx(Center, {
                            my: "md",
                            children: jsxRuntimeExports.jsx(Button, {
                                type: "submit",
                                mx: "auto",
                                fullWidth: !0,
                                children: "Sign in"
                            })
                        })]
                    }), jsxRuntimeExports.jsx(Center, {
                        children: jsxRuntimeExports.jsx(Anchor, {
                            href: "/signup",
                            fw: "600",
                            children: "Sign up for a demo account"
                        })
                    })]
                })
            })
        })
    })
}
function SignUpPage() {
    const o = useNavigate()
      , i = useForm({
        initialValues: {
            email: "",
            password: "",
            accepted_terms_and_conditions: !1
        },
        validate: {
            email: a => a.includes("@") ? null : "Invalid email",
            password: a => a.length > 4 ? null : "Password must be greater than 4 characters",
            accepted_terms_and_conditions: a => a ? null : "You must accept the terms and conditions to continue"
        }
    });
    function s(a) {
        firebaseCreateUserWithEmailAndPassword(a.email, a.password).then( () => {
            o("/")
        }
        ).catch(_ => {
            switch (_.code) {
            case "auth/email-already-in-use":
            case "auth/invalid-email":
                i.setFieldError("email", "User disabled");
                break;
            case "auth/operation-not-allowed":
                i.setFieldError("email", "Unexpected error - operation not allowed");
                break;
            case "auth/weak-password":
                i.setFieldError("password", "Password is too weak");
                break
            }
        }
        )
    }
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
        children: jsxRuntimeExports.jsx(Center, {
            pos: "relative",
            sx: a => ({
                background: a.fn.linearGradient(45, "#83a4d4", "#b6fbff")
            }),
            children: jsxRuntimeExports.jsx(Container, {
                w: 500,
                children: jsxRuntimeExports.jsx(Paper, {
                    withBorder: !0,
                    shadow: "md",
                    p: 30,
                    mt: 30,
                    radius: "md",
                    children: jsxRuntimeExports.jsxs("form", {
                        onSubmit: i.onSubmit(a => s(a)),
                        children: [jsxRuntimeExports.jsx(Center, {
                            mb: "xl",
                            children: jsxRuntimeExports.jsxs(Group, {
                                spacing: "sm",
                                children: [jsxRuntimeExports.jsx(ThemeIcon, {
                                    variant: "gradient",
                                    gradient: {
                                        from: "teal.7",
                                        to: "cyan.7",
                                        deg: 105
                                    },
                                    children: jsxRuntimeExports.jsx(PolygonNodesIcon, {
                                        width: 20,
                                        height: 20,
                                        fill: "currentColor"
                                    })
                                }), jsxRuntimeExports.jsx(Title, {
                                    order: 2,
                                    align: "center",
                                    color: "dark.4",
                                    children: "GeoSegment Demo"
                                })]
                            })
                        }), jsxRuntimeExports.jsx(TextInput, {
                            label: "Email",
                            placeholder: "you@emailprovider.com",
                            required: !0,
                            ...i.getInputProps("email")
                        }), jsxRuntimeExports.jsx(PasswordInput, {
                            label: "Password",
                            placeholder: "Your password",
                            required: !0,
                            mt: "md",
                            ...i.getInputProps("password")
                        }), jsxRuntimeExports.jsx(Checkbox, {
                            my: "md",
                            label: jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
                                children: ["I accept the", " ", jsxRuntimeExports.jsx(Anchor, {
                                    href: "https://firebasestorage.googleapis.com/v0/b/geosegment-299df.appspot.com/o/public%2Fgeosegment_demo_terms_and_conditions.txt?alt=media&token=fcb7dbc4-16dd-4d3a-aaa1-8159293bcd3d",
                                    target: "_blank",
                                    children: "terms and conditions"
                                }), " ", "of the demo"]
                            }),
                            ...i.getInputProps("accepted_terms_and_conditions")
                        }), jsxRuntimeExports.jsx(Center, {
                            mt: "md",
                            children: jsxRuntimeExports.jsx(Button, {
                                type: "submit",
                                mx: "auto",
                                fullWidth: !0,
                                children: "Sign Up"
                            })
                        })]
                    })
                })
            })
        })
    })
}
const router = createBrowserRouter([{
    path: "/",
    element: jsxRuntimeExports.jsx(ProtectedRoute, {
        children: jsxRuntimeExports.jsx(UserTileLayersContextProvider, {
            children: jsxRuntimeExports.jsx(DemoPage, {
                onLogout: () => {
                    firebaseLogout().catch(o => console.log(o))
                }
            })
        })
    })
}, {
    path: "/login",
    element: jsxRuntimeExports.jsx(LoginPage, {})
}, {
    path: "/signup",
    element: jsxRuntimeExports.jsx(SignUpPage, {})
}]);
client.createRoot(document.getElementById("root")).render(jsxRuntimeExports.jsxs(MantineProvider, {
    withGlobalStyles: !0,
    withNormalizeCSS: !0,
    children: [jsxRuntimeExports.jsx(Notifications, {}), jsxRuntimeExports.jsx(AuthProvider, {
        children: jsxRuntimeExports.jsx(SegmentAnythingContextProvider, {
            children: jsxRuntimeExports.jsx(React.StrictMode, {
                children: jsxRuntimeExports.jsx(RouterProvider, {
                    router
                })
            })
        })
    })]
}));
export {LercParameters as L, LercAddCompression as a, getDefaultExportFromCjs as g};
